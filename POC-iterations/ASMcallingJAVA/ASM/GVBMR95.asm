         TITLE 'GVBMR95  - BATCH EVENT EXTRACT PROGRAM'
**********************************************************************
*
* (C) COPYRIGHT IBM CORPORATION 2003, 2022.
*     Copyright Contributors to the GenevaERS Project.
* SPDX-License-Identifier: Apache-2.0
*
**********************************************************************
*
*  Licensed under the Apache License, Version 2.0 (the "License");
*  you may not use this file except in compliance with the License.
*  You may obtain a copy of the License at
*
*     http://www.apache.org/licenses/LICENSE-2.0
*
*  Unless required by applicable law or agreed to in writing, software
*  distributed under the License is distributed on an "AS IS" BASIS,
*  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
*  or implied.
*  See the License for the specific language governing permissions
*  and limitations under the License.
*
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*                                                                     *
* IMPORTANT: This shows how GVBJGO95 is called by GVBMR95 only.       *
*            See lines 763 through 793.
*                                                                     *
* THIS IS NOT A MAINTAINED OR VERSIONED COPY OF GVBMR95               *
*                                                                     *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*                                                                     *
*  GVBMR95 - SELECTS EVENT DATA FOR PROCESSING BASED ON               *
*            CRITERIA DERIVED FROM THE ORIGINAL VIEW DEFINITION       *
*            PARAMETERS WHICH WERE TRANSLATED INTO AN EXTRACTION      *
*            LOGIC TABLE.                                             *
*                                                                     *
*          - MULTIPLE VIEW REQUESTS MAY BE APPLIED AGAINST THE        *
*            SAME EVENT RECORD ("DRIVER FILE").                       *
*                                                                     *
*  FUNCTION CODES:                                                    *
*                                                                     *
*                                                                     *
*  RETURN CODES:                                                      *
*                                                                     *
*            0  - SUCCESSFUL                                          *
*            8  - ERROR                                               *
*                                                                     *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*                                                                     *
*  REGISTER USAGE:                                                    *
*                                                                     *
*        R15 - TEMPORARY WORK REGISTER                                *
*            - LOOK-UP   KEY    LENGTH                                *
*            - RETURN    CODE                                         *
*                                                                     *
*        R14 - TEMPORARY WORK REGISTER                                *
*            - INTERNAL  SUBROUTINE  RETURN ADDRESS (3RD LEVEL)       *
*            - RETURN    ADDR                                         *
*                                                                     *
*        R13 - REGISTER  SAVE AREA  ADDRESS (THREAD WORK AREA)        *
*                                                                     *
*        R12 - PROGRAM   BASE REGISTER                                *
*        R11 - WORK REGISTER                                          *
*                                                                     *
*        R10 - INTERNAL  SUBROUTINE  RETURN ADDRESS (1ST LEVEL)       *
*        R9  - INTERNAL  SUBROUTINE  RETURN ADDRESS (2ND LEVEL)       *
*                                                                     *
*        R8  - CURRENT   EXTRACT  COLUMN    ADDRESS                   *
*            - CURRENT   LOGIC TABLE ROW    ADDRESS                   *
*                                                                     *
*        R7  - EXTRACT   RECORD  ADDRESS                              *
*            - LOGIC     TABLE LOOP  COUNTER                          *
*                                                                     *
*        R6  - CURRENT   EVENT       RECORD ADDRESS (DRIVER FILE)     *
*        R5  - CURRENT   REFERENCE   RECORD ADDRESS (TABLE LOOK-UPS)  *
*            - CODE SEG  LOGIC TABLE ROW    ADDRESS                   *
*                                                                     *
*        R4  - WORK      REGISTER                                     *
*            - BINARY    SEARCH  TOP        INDEX                     *
*            - PREVIOUS  RECORD  BUFFER     ADDRESS                   *
*            - CURRENT   CODE    BUFFER     POSITION                  *
*                                                                     *
*        R3  - Previous record pointer (reload from PREVRECA if used) *
*            - BINARY    SEARCH  BOT        INDEX                     *
*            - CURRENT   RECORD  BUFFER     LENGTH                    *
*            - CURRENT   CODE    SEGMENT    STARTING  ADDRESS         *
*                                                                     *
*        R2  - GENERATED CODE    BASE       REGISTER                  *
*            - DCB       ADDRESS                                      *
*                                                                     *
*        R1  - PARAMETER LIST ADDRESS                                 *
*            - TEMPORARY WORK REGISTER                                *
*                                                                     *
*        R0  - TEMPORARY WORK REGISTER                                *
*                                                                     *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
                        EJECT
GVBMR95  CSECT
         macro
&aghlab  agh  &reg,&harea
         AIF  ('&aghlab' EQ '').noaghlab
&aghlab  ds    0h
.noaghlab lgh  r0,&harea
          agr  &reg,r0
         mend
*
         Copy  GVBASSRT
         Copy  GVBMR95C
         Copy  EXECDATA
         Copy  GVBMR95W
         Copy  GVBX95PA
         Copy  GVBMR95L
         Copy  GVB0200B
         Copy  GVB1000B
*
         Push  PRINT
         Print OFF,NOGEN,NOPRINT
         Copy  ASMMSP
LEAVE    OpSyn ASM_LEAVE
         ASMMREL ON
         IEABRCX DEFINE
         Pop   PRINT
*
         Copy  GVBUTEQU
         Copy  DL96EQU
         Copy  GVBLOGIT
         Copy  GVBRPTIT
         Copy  GVBPHEAD
         Copy  GVBMRZPE        ZIIP function equates
*
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*                                                                     *
*        PROGRAM INTERRUPT EXIT DATA AREA (0C7)                       *
*                                                                     *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*
         PRINT NOGEN
         IHAEPIE
         PRINT GEN
*
MSGLIST  GVBMSG DSECT
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*                                                                     *
*        TRACE HEX DUMP LINE FORMAT                                   *
*                                                                     *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*
DUMPLINE DSECT
*
         DS    CL39            PREFIX
DUMPOFF  DS    CL08            OFFSET
         DS    CL02
DUMPHEX1 DS    CL08            4 - 8 HEX DIGIT SECTIONS
DUMPSPC1 DS    CL01
DUMPHEX2 DS    CL08
DUMPSPC2 DS    CL01
DUMPHEX3 DS    CL08
DUMPSPC3 DS    CL01
DUMPHEX4 DS    CL08
DUMPSPC4 DS    CL04
DUMPHEX5 DS    CL08            4 - 8 HEX DIGIT SECTIONS
DUMPSPC5 DS    CL01
DUMPHEX6 DS    CL08            4 - 8 HEX DIGIT SECTIONS
DUMPSPC6 DS    CL01
DUMPHEX7 DS    CL08            4 - 8 HEX DIGIT SECTIONS
DUMPSPC7 DS    CL01
DUMPHEX8 DS    CL08            4 - 8 HEX DIGIT SECTIONS
DUMPSPC8 DS    CL04
DUMPAST1 DS    CL01
DUMPCHAR DS    CL32
DUMPAST2 DS    CL01
                        EJECT
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*                                                                     *
*        Floating point register equates                              *
*                                                                     *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*
gvbmr95  csect
fp0      equ 0,,,,fpr
fp1      equ 1,,,,fpr
fp2      equ 2,,,,fpr
fp3      equ 3,,,,fpr
fp4      equ 4,,,,fpr
fp5      equ 5,,,,fpr
fp6      equ 6,,,,fpr
fp7      equ 7,,,,fpr
fp8      equ 8,,,,fpr
fp9      equ 9,,,,fpr
fp10     equ 10,,,,fpr
fp11     equ 11,,,,fpr
fp12     equ 12,,,,fpr
fp13     equ 13,,,,fpr
fp14     equ 14,,,,fpr
fp15     equ 15,,,,fpr
*
*  Note: z/OS standard linkage defines the first 8 FPR as volatile so
*        they are used without saving
*   Also GPR R14 is often used to hold an accumulator address and in
*   MR96, checks are made to elide any LAY that might reload R14.
*   With DFP, the accumulator, now an extended DFP number, has to be
*   loaded into FPRs to operate on it - these loads will also be
*   removed if the LAY of R14 is removed.
*   This REQUIRES that the accumulator addressed by R14 is always
*   into the same FP registers - in this case the pair FP0/FP2
*
*   FP8/10 is loaded with a floating point zero - the exponent is
*   unpredictable
*   FP9/11 will be loaded with the quantum value for 3 or 8 decimal
*   places during GVBMR96 processing - these registers must be left
*   as is as some machine code models need this value as does DL96
*
                        SPACE 3
*
ACCUMLEN EQU   L'COLDATA
*
*CYYMMDD EQU   03                 "CCYYMMDD"    CONTENT CODE
*CYYDDD  EQU   11                 "CCYYDDD"     CONTENT CODE
*
tempry   dsect
*        sole use of this dsect is to create a symbol table entry
*        that gives us the length of the jump instruction being used
*        in the machine code generation.
mc_jump  jlnop *
*        and now use the dsect to create the displacement length
*        (assumes displacement at the end of the instruction and
*         a two byte buffer at start (opcode + other bits)
mc_disp_l equ  *-mc_jump-2
*
gvbmr95  csect
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*                                                                     *
*        REGISTER EQUATES:                                            *
*                                                                     *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*
         YREGS
                       EJECT
*
                        EJECT
*
*
GVBMR95  CSECT
*
GVBMR95  RMODE 31
GVBMR95  amode 31
*        This routine operates in amode 64, but if the entry point is
*        A64, then any IDENTIFY macros assign A64.   While this is ok
*        for any internal use, some of the IDENTIFY entries are for
*        external users so need A31 for now so the AMODE at entry is
*        set to A31, and we then switch as soon as possible into A64
*
         sam64                 and switch in to a64 now
         SYSSTATE ARCHLVL=2,amode64=YES
         j     code
MR95EYE GVBEYE GVBMR95
         print nogen
*
***********************************************************************
*  SAVE  CALLER'S REGISTER CONTENTS                                   *
*  ACQUIRE   MAIN TASK'S   THREAD   WORK  AREA                        *
*  CHAIN REGISTER SAVE     AREAS  & SAVE  BASE   ADDRESSES            *
***********************************************************************
*
*  This is an AR mode program so we MUST use the stack
*  This code is directly from MVS Assembler Services Guide SA22-7605
*
*  Note AMODE31 at entry
*
static   loctr          set up static loctr first
code     loctr          followed by the code Loctr
         bakr  R14,0              Save status
         sac   0                  make sure we are in primary mode
         larl  r12,gvbmr95        set up 1st base (clean as in A64)
         llgtr r15,r15            and clean
         llgtr r14,r14            and clean
         llgtr r13,r13            and clean
         llgtr r11,r11            and clean
         llgtr r10,r10            and clean
         llgtr r9,r9            and clean
         llgtr r8,r8            and clean
         llgtr r7,r7            and clean
         llgtr r6,r6            and clean
         llgtr r5,r5            and clean
         llgtr r4,r4            and clean
         llgtr r3,r3            and clean
         llgtr r2,r2            and clean
         llgtr r1,r1            and clean
         llgtr r0,r0            and clean
         using (gvbmr95,code),r12

         STORAGE OBTAIN,          get some storage for workarea        +
               LENGTH=THRDLEN+l'maineyeb,  Thread and eyecatcher       +
               COND=NO,           Unconditional                        +
               CHECKZERO=YES      ask system to tell us if it's cleared
         if    (cgij,r15,ne,x'14')  X'14' signals the storage is clean
           lgr R6,R1              ZERO WORK  AREA
           LHI R7,THRDLEN+l'maineyeb
           XR  R14,R14
           XR  R15,R15
           MVCL R6,R14
         endif
*
         MVC   0(l'maineyeb,R1),MAINEYEB   COPY EYEBALL
         lgr   r13,r1             copy address (STORAGE is documented  +
                to return a 64-bit pointer)
         aghi  r13,l'maineyeb     and miss the eyecatcher
*
         using (thrdarea,thrdend),r13 Tell assembler to map the area
         using genenv,env_area
         using genparm,parm_area
         using genfile,file_area
         USING MSGLIST,MSG_AREA
         using savf4sa,thrdarea   and map the save area
         mvc   savf4said,=c'F6SA'   and tell others of the stack usage
         ST    R13,THRDMAIN       SAVE MAIN TASK  WORK   AREA  ADDR
         ST    R13,GP_THRD_WA     Save thread WA address
*
         lamy  R0,R10,SAVEsrb     ZERO ar0-ar10
         lamy  R14,r15,SAVEsrb    and ar14-ar15 using an               +

*
         zap   switches,p000      set main counter to zero
*
         Larl  R14,MDLWTO         INITIALIZE  WTO PARAMETER AREA
         MVC   WTOPARM(WTOPARML),0(R14)
*
         MVI   SPACES+0,C' '      INITIALIZE  CONSTANT
         MVC   SPACES+1(L'SPACES-1),SPACES+0
***********************************************************************
*  Call GVBURALI to obtain the alias name, if any                     *
*                                                                     *
*  GVBURALI will search for any alias name for GVBMR95 (hard coded in *
*  the routine)                                                       *
*  The module name is returned in r0/r1 with r15 set to 0 for an      *
*  alias, set to 4 otherwise                                          *
*                                                                     *
***********************************************************************
         llgf  r15,=v(gvburali)          get address
         bassm r14,r15                   and call it

         stm   r0,r1,namepgm             save returned name
         if cij,r15,eq,0                 did it find anything?
           oi  alias,l'alias             set alias on (len=flag)
         else
           ni  alias,x'ff'-l'alias       make sure it is off
         endif
*
* Exclude execution of "GVBMR95"
         if clc,namepgm,eq,=cl8'GVBMR95'
*      'GVB00140 - Program must be executed with GVBMR95E or GVBMR95R'
         GVBMSG WTO,MSGNO=EXEC_PGM_ERR,SUBNO=1,                        +
               SUB1=(PGMNAME,L'PGMNAME),                               +
               MSGBUFFER=(PRNTBUFF,L'PRNTBUFF),                        +
               MF=(E,MSG_AREA)
         LHI   r15,12
*
         j    ERROREND
         endif

***********************************************************************
*  Allocate LOG file and open it                                      *
***********************************************************************
         STORAGE OBTAIN,          get some storage for DCB             +
               LENGTH=logfilel+l'logfeyeb,                             +
               LOC=BELOW,         must be below for the DCB            +
               COND=NO            Unconditional
*        STORAGE returns a valid 64-bit address
         lgr   r2,r1                     copy for later
         aghi  R2,l'logfeyeb
         MVC   0(l'logfeyeb,R1),logfeyeb COPY   EYEBALL
         ST    R2,Logfdcba        SAVE   DCB  ADDRESS
*
         larl  R14,Logfile               COPY MODEL   DCB
         using ihadcb,r2
         MVC   ihadcb(logfilel),0(R14)
         LA    R0,Logfdcbe-Logfile(,R2) SET  DCBE    ADDRESS IN  DCB
         sty   R0,DCBDCBE
         lhi   r1,namepgml-namepgm       Default pgm name lenght
         sth   r1,namepgml
*
         if clc,namepgm,eq,=cl8'GVBMR95R'  R for reference
           mvc dcbddnam,=cl8'REFRLOG' set the report ddname
           mvc rpt_dd95l,=cl8'REFRLOG'
         else
           mvc dcbddnam,=cl8'EXTRLOG' set the report ddname
           mvc rpt_dd95l,=cl8'EXTRLOG'
         endif
*
         MVC   WKREENT(8),OPENPARM       OPEN  log file
         sam31
         sysstate amode64=NO
         OPEN  ((R2),(OUTPUT)),MODE=31,MF=(E,WKREENT)
         sysstate amode64=YES
         sam64
         TM    48(R2),X'10'              SUCCESSFULLY OPENED  ???
         BRO   Init_call_MR96            YES - BYPASS ABEND
         drop  r2
*
         GVBMSG WTO,MSGNO=OPEN_LOG_FAIL,SUBNO=2,                       +
               SUB1=(PGMNAME,L'PGMNAME),                               +
               SUB2=(rpt_dd95l,8),                                     +
               MSGBUFFER=(PRNTBUFF,L'PRNTBUFF),                        +
               MF=(E,MSG_AREA)
         LHI   r15,12
*
         j    ERROREND

***********************************************************************
*  CALL "GVBMR96" INITIALIZATION ROUTINE                              *
***********************************************************************
Init_call_MR96 ds 0h
         llgf  R15,GVBMR96        LOAD "GVBMR96"   ADDRESS
         bassm R14,R15            CALL "GVBMR96" - INITIALIZATION
*
*        Following code will set r14 to the message number to be
*        issued
*
         if    (ltgr,r14,r15,z)    check the return code
*
*      check to see if we're apf authorized so we can get cpu stats
*
           mvi localauth,c'N'   assume not
           sam31
           sysstate amode64=NO
           testauth fctn=1      test for apf authorisation
           sysstate amode64=YES
           sam64
           if (cij,r15,eq,0)    0 => auth 4 => not auth
               mvi localauth,c'A'
           endif
*
* Can we use zIIP?
*
           mvc  workazip,ziipaddr   Address of zIIP module
           if (ltgf,r15,workazip,nz)  zIIP function available?
             oill r15,x'0001'       set amode 64 in link address
             st   r15,workazip      save back with 64 bit on
             la   r1,zIIP_init      zIIP init function
             bassm r14,r15          Call zIIP init
           else
             LLGT  R14,EXECDADR     LOAD PARAMETER DATA  ADDRESS
             USING EXECDATA,R14
             if (CLI,EXECZIIP,EQ,C'Y')
               GVBMSG LOG,MSGNO=ZIIP_FEATURE_NOT_AVAILABLE,SUBNO=1,    +
               SUB1=(PGMNAME,L'PGMNAME),                               +
               GENENV=GENENV,                                          +
               MSGBUFFER=(PRNTBUFF,L'PRNTBUFF),                        +
               MF=(E,MSG_AREA)
               LA  R15,8
               B   ERROREND        Bye now
             endif
             DROP R14 EXECADR
           endif

           larl r15,gvbmr95s        get address of main code
           oill r15,x'0001'         set amode 64 in link address
           bassm r14,r15            use bassm to set
*                and off we go - we need to use this set up here
*                otherwise BAKR in GVBMR95S builds a incorrect
*                return address and the ending PR comes back in A24

*          allow any return code from the linked to program to
*          propogate
           st    r15,overall_return_code   save return code
         else ,
           J   ERROREND             END
         endif

         sysstate amode64=NO
         sam31
*
         using   ihadcb,r2
         ly    r2,tracdcba

         if      (cij,r2,ne,0),and,        not zero?                   +
               (tm,dcboflgs,dcbofopn,o)    and dcb is open
           MVC WKREENT(8),OPENPARM
           CLOSE ((R2)),MODE=31,MF=(E,WKREENT)
         endif
         l     R2,CTRLDCBA        CLOSE CONTROL REPORT FILE
         if      (cij,r2,ne,0),and,        not zero?                   +
               (tm,dcboflgs,dcbofopn,o)    and dcb is open
           MVC WKREENT(8),OPENPARM
           CLOSE ((R2)),MODE=31,MF=(E,WKREENT)
         endif
         ly    R2,SNAPDCBA        CLOSE SNAPDCB
         if      (cij,r2,ne,0),and,        not zero?                   +
               (tm,dcboflgs,dcbofopn,o)    and dcb is open
           MVC WKREENT(8),OPENPARM
           CLOSE ((R2)),MODE=31,MF=(E,WKREENT)
         endif
         drop  r2
*
***********************************************************************
*  RETURN                                                             *
***********************************************************************
         lae   r1,0(0,r13)        copy address
         aghi  r1,-l'maineyeb       move back
         lgf   r2,overall_return_code     get return code from area
*
         if TM,WORKFLAG1,MSG811DONE,NZ  single threaded and pipes ?
           if Cij,R2,lt,4
             la  r2,4            set warning for this condition
           endif
         endif
*
         STORAGE RELEASE,ADDR=(R1),LENGTH=THRDLEN+l'maineyeb           +
                                  return the storage
         lgr   R15,R2             SET  RETURN CODE
*
         pr    ,                  and return restoring any amode
*
         sysstate amode64=YES
         ENTRY GVBFUNTB
         ENTRY GVBFUNCT
         ENTRY GVBmaj_t
         ENTRY GVBmaj_c
         ENTRY MR95TRAC
         ENTRY WRTXLEIN
         ENTRY LKPXLEIN
         ENTRY MR95NV
         ENTRY MR95EN
*
code     loctr ,
gvbmr95s ds    0h
         bakr  r14,0              Save state
***********************************************************************
*  EXECUTE "PASS-2" OF THE CODE GENERATION PROCESS                    *
***********************************************************************
         if TM,WORKFLAG1,MSGLVL_DEBUG,o  Check the message level
           logit msg=tracp2b
         endif
         LARL  R15,PASS2          PASS  TWO THROUGH LOGIC TABLE
         BASR  R14,R15
         if TM,WORKFLAG1,MSGLVL_DEBUG,o  Check the message level
           logit msg=tracp2d
         endif
***********************************************************************
*  "SNAP" THE LOGIC TABLE AND GENERATED CODE (IF REQUESTED)           *
***********************************************************************
         llgt  R14,EXECDADR       LOAD PARAMETER DATA  ADDRESS
         USING EXECDATA,R14
         if CLI,EXECSNAP,eq,C'Y'  SNAP TABLES ???
           DROP R14
*
           STORAGE OBTAIN,        get some storage for DCB             +
               LENGTH=snapdcb_l,                                       +
               LOC=BELOW,         must be below for the DCB            +
               COND=NO            Unconditional
*          STORAGE returns a valid 64-bit address
           lgr r2,r1                     copy for later
           STy R2,snapdcba        SAVE   DCB  ADDRESS

           using ihadcb,r2
           mvc ihadcb(SNAPDCB_L),snapdcb
           tm  alias,l'alias
           if    (o)                       alias set
             if clc,namepgm,eq,=cl8'GVBMR95R'    R for reference
               mvc  dcbddnam,=CL8'REFRDUMP'      def EXTRDUMP
             endif
           endif
*
           sam31
           sysstate amode64=NO
           MVC WKREENT(8),OPENPARM
           OPEN ((R2),(OUTPUT)),MODE=31,MF=(E,WKREENT)
*
           llgt R8,LTBEGIN        LOAD LOGIC    TABLE ADDRESS
           aghi r8,-8             include the eyecatcher
*
           llgt R15,LTENROWA      SNAP LOGIC    TABLE
           agh R15,0(,R15)
           bctr r15,0
           SNAP DCB=(r2),PDATA=(REGS),ID=020,STORAGE=((R8),(R15))
*
           llgt R9,CODEBEG        LOAD GENERATED CODE ADDRESS
           aghi r9,-8             include the eyecatcher
           llgt R15,CODEEND       SNAP GENERATED CODE
           bctr r15,0
           SNAP DCB=(r2),ID=030,STORAGE=((R9),(R15))
*
           llgt r8,GPEXTRA        get the initvar area
           using initvar,r8
           llgt R9,litpoolb       LOAD literal pool start
           aghi r9,-8             include the eyecatcher
           llgt R15,litpoolc      and the end
           aghi r15,l'nvprolog-1
           SNAP DCB=(r2),ID=030,STORAGE=((R9),(R15))
           drop r8
           sam64
           sysstate amode64=YES
         endif
                        EJECT
***********************************************************************
*  SAVE EXTRACTION BEGINNING DATE/TIME                                *
***********************************************************************
         XC    begtime,begtime    GET  BEGINNING  TIME
         lay   R2,begtime
         lay   R3,timelist
         TIME  STCK,(R2),LINKAGE=SYSTEM,DATETYPE=YYYYMMDD,             +
               MF=(E,(R3))
*
         sam31
         sysstate amode64=NO
         STCKCONV STCKVAL=begtime,CONVVAL=workarea,TIMETYPE=DEC,       +
               DATETYPE=YYYYDDD,MF=(E,stckconveform)
         sam64
         sysstate amode64=YES
         MVC   begdate,workarea+8
*
                        SPACE 3
***********************************************************************
*  SET-UP ENTRY POINT FOR PARALLEL SUB-TASKS                          *
***********************************************************************
         LARL  R1,SUBTASK
         IDENTIFY EP=MR95THRD,ENTRY=(1)
         IF LTR,R15,r15,nz
           MVC   ERRDATA,SPACES
           CVD   R15,DBLWORK
           OI    DBLWORK+L'DBLWORK-1,X'0F'
           UNPK  errdata(8),DBLWORK
           XC    MSGS2PTR,MSGS2PTR  No additional parms
           lghi  R14,IDENTIFY_FAIL IDENTIFY UNSUCCESSFUL
           J     errmsg#           ISSUE ERROR MESSAGE
         endif
                        EJECT
***********************************************************************
*  CREATE GENEVA ENCLAVE IF APF AUTHORIZED                            *
*  FOR GATHERING CPU STATS (and zIIP, if available)                   *
***********************************************************************
         if (cli,localauth,eq,c'A') APF authorized?
*
           MODESET MODE=SUP        The following only need SUP state
*
*
           IWM4ECRE TYPE=DEPENDENT,ETOKEN=ENCLTOKN
           if cij,R15,ne,0         not ok
             st r15,return_code      then save R15
             st r0,reason_code            and r0
             basr r15,0              get the current address
             sr r15,r12            and make it an offset
             st r15,error_address  and save
           else
*
*     now set up parmlist and registers for encassoc sysevent call
*     This associates the enclave with the address space
*     This call removes the need for the address space to be nonswap
*
             la r1,encassoc_parm           and point at parmlist
             xc encassoc_parm,encassoc_parm clear parm list
             mvi encassoc_function_code,encassoc_join Join function
             lhi r0,x'ffff8000'            set up asid field in r0
             lam r0,r1,encltokn            load token into Ar0/1
             xr r9,r9             clear r9
             ipk ,                save current key in r2
             spka 0(r9)            and flip to key 0

             sam31
             sysstate amode64=NO
             sysevent ENCASSOC,ENTRY=BRANCH,TYPE=ENCASSOC_JOIN,        +
               ASID=(0)
             spka 0(r2)           restore the saved key
             if cij,r15,eq,0
*                                        Join current task to enclave
               IWMEJOIN ETOKEN=ENCLTOKN
               if Cij,R15,le,4    0 or 4 is ok
*
                 if (ltgf,r15,workazip,nz) zIIP function available?
                   la r1,zIIP_oct   zIIP offload control function
                   bassm r14,r15    Call zIIP function

                   if Cij,R15,gt,4  anything greater than 4 is bad
                     st r15,return_code then save R15
                     st r0,reason_code    and r0
                     basr r15,0      get the current address
                     sr r15,r12    and make it an offset
                     st r12,error_address and save
                   endif
                 endif
               else
                 st r15,return_code then save R15
                 st r0,reason_code        and r0
                 basr r15,0          get the current address
                 sr r15,r12        and make it an offset
                 st r12,error_address and save
               endif
             else
               st r15,return_code    then save R15
               st r0,reason_code          and r0
               basr r15,0            get the current address
               sr r15,r12          and make it an offset
               st r12,error_address and save
             endif
             sam64
             sysstate amode64=YES
           endif
*
           MODESET MODE=PROB
           if oc,return_code,return_code,nz  test the return code
             unpk dblwork(9),return_code(5)  Unpack the hex - with an  +
                  extra char on both that we will ignore
             tr   dblwork(8),hexconv   and make it all printable
             unpk dblwork2(9),reason_code(5)  Unpack the hex
             tr   dblwork2(8),hexconv   and make it all printable
             unpk dblwork3(9),error_address(5)  Unpack the hex
             tr   dblwork3(8),hexconv   and make it all printable

             GVBMSG LOg,MSGNO=ENCLAVE_CREATE_FAIL,SUBNO=4,             +
               GENENV=GENENV,                                          +
               SUB1=(PGMNAME,L'PGMNAME),                               +
               SUB2=(DBLWORK,L'DBLWORK),                               +
               SUB3=(DBLWORK2,L'DBLWORK2),                             +
               SUB4=(DBLWORK3,L'DBLWORK3),                             +
               MSGBUFFER=(PRNTBUFF,L'PRNTBUFF),                        +
               MF=(E,MSG_AREA)
*
*            bras r9,errformat
*            ly r9,msg_bufl       get the message length
*            sth r9,prntlen
*
*            WTO TEXT=PRNTLEN,MF=(E,WTOPARM)
*            ahi   r9,4
*            sth   r9,prntlen
*            logit msg=prntlen
*
             LA  r15,16
             B   ERROREND        End now
           endif
*
         endif
***********************************************************************
*  DISPLAY "THREADS STARTED" MESSAGE                                  *
***********************************************************************
*        logit msg=tracthb
*
         LH    R0,THRDCNT         INDICATE HOW   MANY THREADS STARTED
         L     R14,EXECDADR       LOAD PARAMETER DATA ADDRESS
         USING EXECDATA,R14
         if CLI,EXECSNGL,eq,C'1',or,    FIRST THREAD   ONLY MODE  ???  +
               CLI,EXECSNGL,eq,C'A'     or ONE   THREAD   MODE ???
           LHI R0,1               YES - CHANGE  COUNT TO  1
           STH R0,THRDCNT
         endif
         DROP  R14
         CVD   R0,DBLWORK
         OI    DBLWORK+L'DBLWORK-1,X'0F'
         UNPK  errdata(3),DBLWORK

         GVBMSG WTO,MSGNO=NUM_THREADS,SUBNO=2,GENENV=GENENV,           +
               SUB1=(PGMNAME,L'PGMNAME),                               +
               SUB2=(errdata,3),                                       +
               MSGBUFFER=(PRNTBUFF,L'PRNTBUFF),                        +
               MF=(E,MSG_AREA)

         GVBMSG LOG,MSGNO=NUM_THREADS,SUBNO=2,GENENV=GENENV,           +
               SUB1=(PGMNAME,L'PGMNAME),                               +
               SUB2=(errdata,3),                                       +
               MSGBUFFER=(PRNTBUFF,L'PRNTBUFF),                        +
               MF=(E,MSG_AREA)
*
***********************************************************************
         sam31
         sysstate amode64=NO
         LH    R2,THRDCNT         LOAD NUMBER OF PARALLEL  THREADS
         GETMAIN R,LV=18*8+8+96
         STG   R13,18*8(,R1)      Save original R13
         LLGTR R13,R1
*
*
         LOAD  EPLOC=LINKNAME,ERRET=G0010
         LLGTR R15,R0
         OILH  R15,M31
         J     G0011
G0010    EQU   *
         WTO 'GVBGO95 NOT LOADED'
         dc    h'0'
static   loctr
LINKNAME DC    CL8'GVBJGO95'
M31      equ   X'8000'
code     loctr
G0011    EQU   *
*
         STH   R2,18*8+8+8(,R13)  PAOPT
         LA    R1,18*8+8(,R13)
         BASSM R14,R15
*
*
         LG    R13,18*8(,R13)     Restore original R13
         sysstate amode64=YES
         sam64
***********************************************************************
*
                        EJECT
***********************************************************************
*  EXECUTE USING FIRST "THREAD WORK AREA" IF IN "SINGLE THREAD" MODE  *
***********************************************************************
         LH    R2,THRDCNT         LOAD NUMBER OF PARALLEL  THREADS
         llgt  R3,THRDFRST        LOAD FIRST  THREAD WORK  AREA ADDRESS
*
         llgt  R14,EXECDADR       LOAD  PARAMETER DATA  ADDRESS
         USING EXECDATA,R14
         basr    r9,0             create a local base
         using (*,done),r9        and tell the assembler
         if CLI,EXECSNGL,eq,c'1',or,    FIRST THREAD ONLY MODE ???     +
               CLI,EXECSNGL,eq,C'A'     ONE   THREAD MODE ???
           DROP R14               YES - BYPASS SUBTASKS
*
           lgr R1,R3              POINT  TO CORRECT THREAD WORK AREA
           BRASl R10,PICKEVNT     SELECT NEXT EVENT FILE   FROM QUEUE
           USING LOGICTBL,R8
           cgijnh R8,0,done       ANY    LEFT ???                      +
                                  NO  -  DONE
*
mainthrd   using (thrdarea,thrdend),r13
mainsa     using savf4sa,mainthrd.savearea
workthrd   using (thrdarea,thrdend),r3
worksa     using savf4sa,workthrd.savearea
           stg  R13,worksa.SAVF4SAprev
           stg  R3,mainsa.SAVF4SAnext
           mvc workthrd.localziip,mainthrd.localziip copy ziip status
           mvc workthrd.localauth,mainthrd.localauth copy auth status
           mvc workthrd.workazip,mainthrd.workazip copy ziip status
           ly   r0,mainthrd.snapdcba
           sty  r0,workthrd.snapdcba
*
           llgtr r13,r3          switch  to  first thread work area    +
                                    with a clean 64 bit r13
           ST  R8,THRDES          SAVE   "ES" SET  ADDRESS
           J   MAIN               CONTINUE  WITH  MAINLINE
         else
*********************************************************************
*   This section is using the EVENTS service to handle the multiple
*   ECBs.
*   The system creates a table with an entry for each subtask
*   (EVENTS entries), and then as we create the subtasks we add their
*    ECB into the list (EVENTS table=(4),ecb=(7) )
*
*   Then we can wait on the list (EVENTS table=(4),WAIT=YES) and when
*   any ECB is posted, the system will return with R1 pointing at the
*   posted ECB
*
*   We also add in one more ECB that is used by the ESTAE to stop
*   other tasks during ESTAE processing
*
*********************************************************************
*          set up EVENTS list to hold the ECBs
           la  r4,1(,r2)          add 1 to number of slots - this is   +
                                  the extra slot for the ESTAE ECB
           sam31
           EVENTS ENTRIES=(4)     Set up table with THRDCNT+1 slots
           sam64
           llgtr r4,r1            save pointer to table in R4
*
***********************************************************************
*   "ATTACH" PARALLEL SUB-TASKS IF NOT IN "SINGLE THREAD" MODE        *
***********************************************************************
           do from=(r2)
             lgr R1,R3            POINT  TO CORRECT THREAD WORK AREA
             BRAS R10,PICKEVNT    SELECT NEXT   AVAILABLE EVENT FILE
             IEABRCX DISABLE
             if cij,R8,le,0       None LEFT   ???
*
               XC  MSGS2PTR,MSGS2PTR  No additional parms
               lghi R14,ES_COUNT_ERROR
               J ERRMSG#
             endif
*
             ST R8,workthrd.THRDES  SAVE   "ES"  SET ADDRESS
*
             LA R7,workthrd.TASKECB LOAD ECB ADDRESS
             mvc workthrd.localziip,mainthrd.localziip copy ziip status
             mvc workthrd.localauth,mainthrd.localauth copy auth status
             mvc workthrd.workazip,mainthrd.workazip copy ziip status
             ly r0,mainthrd.snapdcba
             sty r0,workthrd.snapdcba
*
             lgr R1,R3
             ATTACHX EP=MR95THRD,       entry point of subtask         +
               ECB=(7),                 ECB (located in THRDAREA)      +
               SHSPV=15,SZERO=YES       share subpools 0 and 15

             IEABRCX ENABLE
             if cij,r15,ne,0
               MVC ERRDATA,SPACES
               CVD R15,DBLWORK
               OI DBLWORK+L'DBLWORK-1,X'0F'
               UNPK DBLWORK2(8),DBLWORK
               la  r1,DBLWORK2
               st  r1,MSGS2PTR
               la  r1,8
               st  r1,MSGS2LEN
               MVC ERRDATA(8),GPDDNAME
               XC  MSGS3PTR,MSGS3PTR  No additional parms
               lghi R14,ATTACH_FAIL ATTACH UNSUCCESSFUL
               J   ERRMSG#          NO   - ISSUE ERROR MESSAGE
             endif
*
             ST R1,workthrd.tcbaddr SAVE  TCB   ADDRESS
             sam31
             events table=(4),ecb=(7)  SAVE ECB ADDRESS IN  ECB  LIST
             sam64
*
             llgt R3,workthrd.THRDNEXT LOAD NEXT THREAD WORKAREA ADDR
           enddo
           sam31
           la  r7,mainthrd.taskecb  get address of the ECB in THRDMAIN
           events table=(4),ecb=(7) and add to table
           sam64
           drop workthrd,mainthrd
         endif
*        R7 will have the TASKMAIN ecb address here
*        -it is used in the following do loop
*
***********************************************************************
*  WAIT FOR ALL THREADS TO FINISH EXECUTION                           *
***********************************************************************
         sam31
         sysstate amode64=NO

** NOTE  staying in AMODE 31 for now, while we set up the tasks

waitloop do until=(clc,thrddone+2(l'thrdcnt),ge,thrdcnt)  loop till all+
                  the daughters are done

           EVENTS Table=(4),wait=YES Now wait for a subtask to finish

*          EVENTS will return with r1 pointing at a list of completed
*          ECBs

           llgt r1,0(,r1)         get ecb address
           if clrj,r1,eq,r7       Is it the one set up for the ESTAE?
*            then the ESTAE is asking for all tasks to stopped
             st r7,estae_stop     make estae_stop non zero to          +
                                  signal that STATUS STOP issued
             llgt r2,0(,r1)       get the contents of the ECB - which  +
                                  will be the TCB address
             nilf r2,x'00ffffff'  clean out the top byte
             status STOP          stop all the daughters
             status START,TCB=(2) and allow the failing task to finish
           else

*            if we get here then a daughter has finished, so count that
*            so that we can exit this loop if reqd

             asi thrddone,1       Increment done counter

             llgt r15,0(0,r1)      get the ecb contents
             nilf r15,x'00ffffff'  clean out the top byte
             if cl,r15,gt,overall_return_code  is this largest so far?
               st r15,overall_return_code save so we know we're failing
             endif
             if chi,r15,gt,900,or, is completion code above U900? or   +
               lt,r0,estae_stop,nz  ESTAE active?

*              then we are aborting the entire run
               lgh R2,THRDCNT     LOAD NUMBER OF PARALLEL  THREADS
               llgt R3,THRDFRST   LOAD FIRST  THREAD WORK  AREA ADDRESS
workthrd       using (thrdarea,thrdend),r3
               do from=(r2)       loop thru all the threads
                 la R1,workthrd.tcbaddr get pointer to TCB address
                 if lt,r5,0(r1),nz     only DETACH if address non zero
                   DETACH (1),STAE=YES and we need to drive the ESTAE  +
                                       exit so that we clean up any srb
                   xc workthrd.tcbaddr,workthrd.tcbaddr zero pointer
                 endif
                 llgt R3,workthrd.THRDNEXT LOAD NXT THRD WORKAREA ADDR
               enddo

               if lt,r0,estae_stop,nz  Was ESTAE active?
                 STATUS START     then start any stopped tasks
               endif

               leave ,            get out of the loop as all done now
             else
*              task ended with condition code that is of no interest

*              do just detach to clean up now

               aghi r1,-(taskecb-thrdarea) R1 is address of ECB so move+
                      r1 back to THRDAREA start
               lgr r3,r1          r3 now has pointer to workarea
               la r1,workthrd.tcbaddr get pointer to TCB address
               if lt,r5,0(r1),nz  only DETACH if address non zero
                 DETACH (1),STAE=NO       and detach to clean up
                 xc workthrd.tcbaddr,workthrd.tcbaddr zero pointer
               endif
               drop workthrd
             endif
           endif
         enddo ,                  loop waiting for subtasks to finish

         events entries=DEL,table=(4)  delete the EVENTS table

done     ds    0h                 PARALLEL THREADS DONE
         sam64
         sysstate amode64=YES
*
         if TM,WORKFLAG1,MSGLVL_DEBUG,o  Check the message level
           logit msg=tracthd
         endif
         balr  r9,r0
         using *,r9               tell assembler that r9 points here
*
*        llgt  R7,GPEXTRA         LOAD EXTRACT  RECORD BASE REGISTER
                        SPACE 3
***********************************************************************
*  GET EXTRACTION FINISHED DATE/TIME                                  *
***********************************************************************
         XC    endtime,endtime    GET  BEGINNING  TIME
         lay   R2,endtime
         lay   R3,timelist
         TIME  STCK,(R2),LINKAGE=SYSTEM,DATETYPE=YYYYMMDD,             +
               MF=(E,(R3))
*
         drop  r9
*
***********************************************************************
*  All finished if we get here so start closing down                  *
***********************************************************************
         if TM,WORKFLAG1,MSGLVL_DEBUG,o  Check the message level
           logit msg=tracclb
         endif
*
***********************************************************************
*  PRINT  CONTROL REPORT                                              *
*  CLOSE  SHARED  FILES                                               *
*  "DETACH"   SUB-TASKS  IF IN PARALLEL THREAD MODE                   *
***********************************************************************
         if   (cli,localauth,eq,c'A') Authoized ?
*
           MODESET MODE=SUP
*
*          Ask Enclave to update reporting fields
*
           sam31
           sysstate amode64=NO
           IWMEQTME CPUTIME=ENC_CPUTIME,       enclave cp total        +
               ZIIPTIME=ZIIPTIME,              ziipy time              +
               ZIIPQUALTIME=ZIIPQUALTIME,                              +
               ZIIPONCPTIME=ZIIPONCPTIME
           sysstate amode64=YES
           sam64
*          choose to ignore any return code from this query
*
           MODESET MODE=PROB
*
         endif
*
         Larl  R15,CLOSFILe       CLOSE FILES
         BASr  R14,R15
*
         larl  r15,prep_sorts
         basr  r14,r15
*
         larl  r15,isrc_prepare  prepares iref/isrc reports depending
         basr  r14,r15           on GVBMR95R or GVBMR95E
         larl  r15,isrc_report
         basr  r14,r15
*
         larl  r15,ofil_report
         basr  r14,r15
*
         if clc,namepgm,eq,=cl8'GVBMR95E'
           larl  r15,owrt_prepare
           basr  r14,r15
           larl  R15,owrt_report
           basr  R14,R15
*
           larl  r15,lkup_prepare
           basr  r14,r15
           larl  r15,lkup_report
           basr  r14,r15
         endif
*
         larl  r15,final_reports
         basr  r14,r15
*
         if TM,WORKFLAG1,MSGLVL_DEBUG,o  Check the message level
           logit msg=traccld
         endif
*
         larl  r15,term_uexits           Close write exits (asm)
         basr  r14,r15

*
         if cli,localauth,eq,c'A' Authorized?
*
           MODESET MODE=SUP         Following only need SUP state
*
*     disassociate the enclave from the address space
*
           la  r1,encassoc_parm            and point at parmlist
           xc  encassoc_parm,encassoc_parm clear parm list
           mvi encassoc_function_code,encassoc_leave leave function
           lhi r0,x'ffff8000'              set up asid field in r0
           lam r0,r1,encltokn              load token into Ar0/1
           xr  r9,r9              clear r9
           ipk ,                  save current key in r2
           spka 0(r9)              and flip to key 0
                                                           space ,
           sam31
           sysstate amode64=NO
           sysevent ENCASSOC,ENTRY=BRANCH,TYPE=ENCASSOC_LEAVE,         +
               ASID=(0)
           spka 0(r2)             restore the saved key
           if cij,R15,ne,0         not ok
             st r15,return_code      then save R15
             st r0,reason_code            and r0
             basr r15,0              get the current address
             sgr r15,r12           and make it an offset
             st r15,error_address  and save
           else
*                                           leave enclave

             IWMELEAV ETOKEN=ENCLTOKN
             if cij,R15,ne,0       not ok
               st r15,return_code    then save R15
               st r0,reason_code          and r0
               basr r15,0            get the current address
               sgr r15,r12         and make it an offset
               st r15,error_address and save
             else
*
               IWM4EDEL ETOKEN=ENCLTOKN
               if cij,r15,ne,0     not ok
                 st r15,return_code  then save R15
                 st r0,reason_code        and r0
                 basr r15,0          get the current address
                 sgr r15,r12       and make it an offset
                 st r15,error_address and save
               endif
             endif
           endif
           sysstate amode64=YES
           sam64
*
           MODESET MODE=PROB      Back to problem state
*
           if oc,return_code,return_code,nz  test the return code
             unpk dblwork(9),return_code(5)  Unpack the hex - with an  +
                  extra char on both that we will ignore
             tr   dblwork(8),hexconv   and make it all printable
*
             unpk dblwork2(9),reason_code(5)  Unpack the hex
             tr   dblwork2(8),hexconv   and make it all printable
*
             unpk dblwork3(9),error_address(5)  Unpack the hex
             tr   dblwork3(8),hexconv   and make it all printable
*
             GVBMSG LOG,MSGNO=ENCLAVE_DELETE_FAIL,SUBNO=4,             +
               GENENV=GENENV,                                          +
               SUB1=(PGMNAME,L'PGMNAME),                               +
               SUB2=(DBLWORK,L'DBLWORK),                               +
               SUB3=(DBLWORK2,L'DBLWORK2),                             +
               SUB4=(DBLWORK3,L'DBLWORK3),                             +
               MSGBUFFER=(PRNTBUFF,L'PRNTBUFF),                        +
               MF=(E,MSG_AREA)
*
*            bras r9,errformat
*
*            WTO TEXT=PRNTLEN,MF=(E,WTOPARM)
*            ahi   r9,4
*            sth   r9,prntlen
*            logit msg=prntlen
*
             LA  r15,16
             B   ERROREND        End now
*            ABEND 992,DUMP       and abend to signal bad ending?
           endif
         endif
                        SPACE 3
***********************************************************************
*  RETURN                                                             *
***********************************************************************
Return   equ   *
*
         lgf r1,overall_return_code    then propogate the RC
         lgr r15,r1                    copy for the return
         if lt,r0,thread_fail,nz       did a subtask fail?
           if nilf,r1,x'00000FFF',nz   if this is true then kill
             ABEND (1),,,USER          main task with that user code
           else
             lr  r1,r15
             nilf r1,x'00ffffff'
             srl r1,12                 shift the system code right
             ABEND (1),,,SYSTEM
           endif
         endif

         pr    ,                  and return restoring all the data    +
                                  from the stack
***********************************************************************
*  Error - return RC=8 or Abend                                       *
***********************************************************************
Return_err equ   *
         if ltgf,r2,execdadr,p Any user parameters?
           using execdata,r2
           if cli,exec_uabend,eq,c'Y' Abend on user error?
             abend 999                then issue Abend 999
             drop r2
           endif
         endif
*   set      rc=8
         lhi r2,8
         st  r2,overall_return_code
         j   Return
                        SPACE 3
static   loctr
Release_code dc c'042'
*
TRACE    jlu   TRACSUBR               BRANCH TO TRACE ROUTINE
*
code     loctr
***********************************************************************
*  DISPLAY ERROR MESSAGE AND RETURN RC=8 (OR ABEND IF PARM SET)      *
***********************************************************************
ERRMSG#  DS    0H
*
***********************************************************************
*  CHECK FOR MESSAGE NUMBER ROW ABEND                                 *
***********************************************************************
         C     R14,abend_msg
         JNE   ERRMSGPR
*
         DC    XL4'FFFFFFFF'
*
ERRMSGPR ds    0h                 INITIALIZE  RETURN    CODE

*        if (cghi,R14,eq,msg#809)                         Logic Table
*          lghi R15,1                                     Empty ?????
*        else
*          if (cgij,R14,eq,msg#80)                        Logic Table
*            lghi R15,1                                   Empty ?????
*          else
*            lghi r15,8
*          endif
*        endif
         st    R15,return_code    save the return code
*
* Format message and write to log
*
*        Using MSGLIST,r1
         MVI   MSGTYPE,c'L'       Type parameter - write to LOG
         LA    R0,0               No prefix override
         ST    R0,MSGPFX          STORE INTO PARAM. LIST
         LA    R0,GENENV          Address of GENENV
         ST    R0,MSGGENV         STORE INTO PARAM. LIST
         LR    R0,R14             Message number
         ST    R0,MSGNUM          STORE INTO PARAM. LIS
         LA    R0,PRNTBUFF        Provide buffer
         ST    R0,MSGBUFFA        STORE INTO PARAM. LIST
         LA    R0,l'prntbuff      Buffer - rec len + rdw
         ST    R0,MSGBUFFL        STORE INTO PARAM. LIST
*
         MVC   PRNTLINE,SPACES    BLANK OUT   PRINT   LINE
*
         xc    MSG#SUB,MSG#SUB    clear this out
         mvi   MSG#SUB+3,1        and put a one there
         la    r2,PGMNAME         First parm is source name
         la    r3,l'pgmname
*
         la    r4,MSGS1PTR        set pointer
subs     using MSGS1PTR,r4        tell the assembler the mapping
         stm   r2,r3,subs.MSGS1PTR  save the adlen pair
         aghi  r4,l'MSGS1PTR+l'MSGS1LEN move to next pair subs
* check if any parms already set up - up to 3
         do    from=(r15,3)         room for 3 more max before errdata
           llgt  r2,subs.MSGS1PTR   get next parm address if any
           doexit ltgr,r2,r2,z       and exit if zero
           l     r14,MSG#SUB        increment no of parms
           la    r14,1(,r14)
           st    r14,MSG#SUB
           aghi  r4,l'MSGS1PTR+l'MSGS1LEN move pointer
         enddo ,
* Add last parm from ERRDATA
         if    CLC,ERRDATA,ne,SPACES  ANY INDICATIVE DATA ???
           LA  R2,errdata           point at the error data
           la  r3,l'errdata-1       and get the length
           la  r14,0(r3,r2)         point at last char
           la  r3,1(,r3)            and make this actual length
           do  while=(cli,0(r14),eq,c' ') scan until non blank at end
             bctgr r14,0             Move pointer back by one
             bctgr r3,0              reduce field length by one
           enddo
           stm r2,r3,subs.MSGS1PTR  save the adlen pair
           aghi r4,l'MSGS1PTR+l'MSGS1LEN move pointer
           drop subs
           l     r14,MSG#SUB        increment no of parms
           la    r14,1(,r14)
           st    r14,MSG#SUB
         endif
*
         LAY   R1,MSG_AREA        Address parm list area
         L     15,=V(GVBUTMSG)
         BASSM 14,15
*
         xc    MSGS2PTR,MSGS2PTR    make this zero for the next time

         LGF   R15,return_code    LOAD RETURN CODE
*
***********************************************************************
*  PRINT "THREAD ended" MESSAGE                                    *
***********************************************************************
THRDMSG  DC    0H
         ST    R15,return_code    LOAD RETURN CODE
*
         LH    R0,gpthrdno        INDICATE WHICH THREAD
         if cij,r0,gt,0           only give message if id positive
           CVD R0,DBLWORK
           OI  DBLWORK+L'DBLWORK-1,X'0F'
           LA  R14,workarea
           UNPK workarea(3),DBLWORK
*
             GVBMSG LOG,MSGNO=THREAD_END,SUBNO=2,GENENV=GENENV,        +
               SUB1=(PGMNAME,L'PGMNAME),                               +
               SUB2=(WORKAREA,3),                                      +
               MF=(E,MSG_AREA)
         endif
*
         LGF   R15,return_code    LOAD RETURN CODE
***********************************************************************
*  ERROR RETURN/ABEND                                                 *
***********************************************************************
ERROREND DC    0H
         if cij,r15,ne,1          if not  empty reference files (rc=1)
           if ltgf,r2,execdadr,p  Any user parameters?
             using execdata,r2
             if cli,exec_uabend,eq,c'Y' Abend on user error?
               abend 999              then issue Abend 999
               drop r2
             endif
           endif
         endif
*
         pr    ,                  and return restoring all the data    +
                                  from the stack
*
                        EJECT
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*                                                                     *
*        L O G I C   T A B L E   T R A C E   R O U T I N E            *
*                                                                     *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*
         push using
         drop ,
         macro
         printhex &length=?,&output=?
         aif (d'todblwork).skip_mvc1
static   loctr
todblwork mvc  dblwork(0),0(r14)
code     loctr
.skip_mvc1 anop ,
         EX    &length,todblwork
         lay   r14,&output
         ahi   &length,1
         sll   &length,1    double the length
         ahi   &length,-1
         if    cij,&length,gt,23
           lhi  &length,23
         endif
         unpk  workarea(9),dblwork(5)
         unpk  workarea+8(9),dblwork+4(5)
         unpk  workarea+16(9),dblwork+8(5)
         tr    workarea(24),hexconv
         aif (d'toprint).skip_mvc2
static   loctr
toprint  mvc   1(0,r14),workarea
code     loctr
.skip_mvc2 anop ,
         mvi   0(r14),C'x'
         EX    &length,toprint
         ahi   &length,1
         srl   &length,1   restore the length
         ahi   &length,-1
         mend
         macro
         printdfp &output=?
.*       macro to format a DFP number
.*       R14 addresses the accumulator to be output
.*       &output is the low level qualifier (dfp1 or DfP2)that
.*       identifies the output line
         stmg r0,r1,printdfp_save
         ld   fp12,0(0,r14)                load fpr 12 from storage
         ld   fp14,8(0,r14)                 and fpr 14
         ld   fp13,=ld'1.0000000000' Load up desired quantum
         ld   fp15,=ld'1.0000000000'+8 - this is 10 decimals
         qaxtr fp12,fp12,fp13,0 and quantise the input
         cuxtr r0,fp12
         stmg r0,r1,dblwork             save converted result
         lay   r14,print_&output.
dfp      using dfptrace,r14
         mvi   dfp.dfpdata,c' '
         mvc   dfp.dfpdata+1(l'dfpdata-1),dfp.dfpdata
         mvc   dfp.decimals,dfpmask
         aif   (d'dfpmask).maskdone
static   loctr
dfpmask  dc            X'4020202020202020202020202020202020202020202120+
               4b20202020202020202020'
code     loctr
.maskdone anop ,
         ed    dfp.decimals,dblwork
         if ltxtr,fp12,fp12,m               negative?
           mvi dfp.dfpsign,c'-'
         else
           mvi dfp.dfpsign,c'+'
         endif
&temp    setc upper('&output')
         aif  ('&temp' eq 'DFP2').operand_2
         mvc   dfp.operand,=C' Operand 1'
         ago   .drop
.operand_2 anop
         mvc   dfp.operand,=C' Operand 2'
.drop    drop  dfp
         oiy  &output.,l'&output.         set the flag
         lmg  r0,r1,printdfp_save
         mend

* printconst macro definition
*  Macro for writing a constant to the trace file.
*  Constants are kept in floating point format internally, and
*  are converted to a displayable format depending on the NUMBER_MODE
*  parameter (LRGNUM), that is 23 digits total, with either 8 or 3
*  either places
*
static       loctr
dfpmask158 dc X'402020202020202020202020202021204B2020202020202020'
dfpmask203 dc X'4020202020202020202020202020202020202021204B202020'
code         loctr
*
         macro
         printconst &output=?
* R14 -> DFP constant
         ld fp12,0(0,r14)               load fpr 12 from storage
         ld fp14,8(0,r14)                and fpr 14
         if cli,lrgnum,eq,c'Y'          Large numbers (20.3)
           ld fp13,=ld'1.0000'          Load up desired quantum
           ld fp15,=ld'1.0000'+8 -      this is 4 decimals
           mvc &output-1(l'tracedat),dfpmask203
         else                           standard numbers (15.8)
           ld fp13,=ld'1.000000000'     Load up desired quantum
           ld fp15,=ld'1.000000000'+8 - this is 9 decimals
           mvc &output-1(l'tracedat),dfpmask158
         endif
         qaxtr fp12,fp12,fp13,0         and quantise the input
         cuxtr r0,fp12
         stmg r0,r1,dblwork             save converted result
*
         ed &output-1(l'tracedat),dblwork+4
*
         if ltxtr,fp12,fp12,m               negative?
           mvi &output+l'tracedat-1,c'-'
         else
           mvi &output+l'tracedat-1,c'+'
         endif
*
         mend

         using (gvbmr95,code),r12
         using litp_hdr+524288,r2
         using (thrdarea,thrdend),r13 Tell assembler to map the area
         using genfile,file_area
         using savf4sa,savesubr         map the subroutine area
         using logictbl,r5
*
TRACSUBR stmg  R14,R12,SAVF4SAG64RS14     SAVE CURRENT REGISTERS
         entry tracsubr                 make the label visible to bind
*
***********************************************************************
*  SWITCH TO "TCB" MODE IF ZIIP ENABLED                               *
***********************************************************************
         if (ltgf,r15,workazip,nz)  zIIP function available?
           la   r1,TCB_switch     Switch to TCB mode
           bassm r14,r15          call zIIP function
         endif
*
*          ly  r2,SNAPDCBA
*  SNAP        DCB=(r2),PDATA=(REGS),ID=100
*
   LA          R10,0(,R10)                STRIP HIGH ORDER  BIT
*
 do ,label=tracexit                        enclosing do
   if ltgf,r14,lpvaddr,p       check current view code address valid?
*
***********************************************************************
*  INCLUDE HEX DUMP OF EVENT RECORDS IN TRACE                         *
***********************************************************************
     do ,label=trace00
       doexit (LTGF,R1,PARMTBLA,np) "MR95"  PARAMETERS  SPECIFIED ???
*
       if CLI,VIEWTRAC,eq,c'Y'    VIEW  SPECIFIC  TRACE SET ?
         LTGF  R1,LTPARMTB-LOGICTBL(,R14)   TRACE THIS   VIEW?
         doexit (NP)              Not this view, so exit
       endif
*
       do ,label=tracea
         using parmtbl,r1          and map the area
*        This event record in tracing range?
         doexit (clc,GPRECCNT,lt,PARMFROM-PARMTBL(R1)),                +
               do=trace00
         doexit (ltg,r0,PARMTHRU-PARMTBL(,R1),np)
         doexit (clc,GPRECCNT,gt,PARMthru-PARMTBL(R1)),                +
               do=trace00
*
       enddo
       using litp_hdr+524288,r2  address the literal pool header
*      TRACEINPUT (Event record) for this trace?
*                                          any TRACEINPUT specified?
       doexit (CLC,PARMDUMP,eq,SPACES),                                +
               do=trace00
*
       if CLC,GPDDNAME,eq,PARMDUMP,and,                                +
               LTGF,R1,lp_RE_addr,p,and,            LOAD "RE" ROW ADDR +
               clc,GPRECCNT,ne,LTTRACNT-LOGICTBL(R1)
         drop r1     parmtbl
         mvc LTTRACNT-LOGICTBL(L'LTTRACNT,R1),GPRECCNT
*
         LA    R3,0(,R6)          EVENT  RECORD ADDRESS
*
         if CLC,=c'RETK',EQ,LTFUNC-LOGICTBL(R1)
*
           lgf R14,LTluboff-LOGICTBL(,R1)
           llgt r14,0(r14,r2) Get the address
           lgh R4,LBRECLEN-LKUPBUFR(,R14)
         else
*
           llgt R14,EVNTDCBA
           if CLC,=c'RETX',ne,LTFUNC-LOGICTBL(R1),and,                 +
               TM,DCBRECFM-IHADCB(R14),X'80',o    FIXED LENGTH RECORDS
*
             lgf R4,GPRECLEN        COMPUTE EVENT RECORD END (+1)
           else
*
             aghi R3,-4
             lgh R4,0(,R3)         COMPUTE EVENT RECORD END (+1)
           endif
*
         endif
         agr   R4,R3
         ST    R3,SAPACKAR        SAVE STARTING ADDRESS
*
         MVC PRNTLINE,spaces
*
tout     using tracemsg,prntline
         MVC tout.traceDDN,GPDDNAME
*
         lg  r15,GPRECCNT
         cvdg r15,dblwork2
         MVC WORKAREA(L'TRACEMSK),TRACEMSK
         ED    WORKAREA(L'TRACEMSK),dblwork3+2
         MVC tout.traceCNT,WORKAREA+2 RECORD NO.
         OI    tout.traceCNT+9,X'F0'
*
         ENQ (GENEVA,TRACNAME,E,,STEP),RNL=NO
*
         do    until=(crj,r3,ge,r4)
           lgr R15,R4
           sgr R15,R3
           if cgij,R15,gt,32 R15 above 32 ?
             lghi R15,32
           endif

           LA R1,PRNTLINE
           USING DUMPLINE,R1
*
           lgr R0,R3
           sgf R0,SAPACKAR
           ST R0,DBLWORK+4
           UNPK DBLWORK(3),DBLWORK+5(2)
           TR DBLWORK(2),HEXCONV
           MVC DUMPOFF+2(2),DBLWORK
           UNPK DBLWORK(3),DBLWORK+6(2)
           TR DBLWORK(2),HEXCONV
           MVC DUMPOFF+4(2),DBLWORK
           UNPK DBLWORK(3),DBLWORK+7(2)
           TR DBLWORK(2),HEXCONV
           MVC DUMPOFF+6(2),DBLWORK
*
           MVI DUMPAST1,C'*'
           BCTR R15,0
           EX R15,MOVECHAR
static     loctr
MOVECHAR   MVC DUMPCHAR(0),0(R3)
code       loctr
           Lay R14,CHARTBL
           EX R15,TRANCHAR
static     loctr
TRANCHAR   TR DUMPCHAR(0),0(R14)
code       loctr
           LA R15,1(,R15)
           MVI DUMPAST2,C'*'
*
           LA R14,DUMPSPC8-64
           MVI DBLWORK+1,X'04'      set up dblwork so we unpack blank
           do from=(r15)
             MVC DBLWORK+0(1),0(R3)
             UNPK 0(3,R14),DBLWORK(2)
             TR 0(2,R14),HEXCONV
             LA R3,1(,R3)
             LA R14,2(,R14)
           enddo
*
           MVC DUMPHEX1,DUMPSPC8-64+00
           MVC DUMPHEX2,DUMPSPC8-64+08
           MVC DUMPHEX3,DUMPSPC8-64+16
           MVC DUMPHEX4,DUMPSPC8-64+24
           MVC DUMPHEX5,DUMPSPC8-64+32
           MVC DUMPHEX6,DUMPSPC8-64+40
           MVC DUMPHEX7,DUMPSPC8-64+48
*
           MVC DUMPSPC2,SPACES
           MVC DUMPSPC3,SPACES
           MVC DUMPSPC4,SPACES
           MVC DUMPSPC5,SPACES
           MVC DUMPSPC6,SPACES
           MVC DUMPSPC7,SPACES
           MVC DUMPSPC8,SPACES
*
           llgt R1,TRACDCBA             LOAD  DCB ADDRESS
           push using
           using ihadcb,r1             map the dcb
           doexit (tm,dcboflgs,dcbofopn,Z) test for open?
*
           sysstate amode64=NO
           sam31
           if CLIY,TRACOPEN,ne,C'Y'    HEADINGS not done yet?
             MVIY TRACOPEN,C'Y'        set flag to say hdgs done
*
             Lay R0,Trhd1msg           PRINT HEADER 1
             llgt R1,TRACDCBA
             put (1),(0)
*
             Lay R0,Trhd2msg           PRINT HEADER 2
             llgt R1,TRACDCBA
             put (1),(0)
           endif
*
           LA R0,PRNTLINE         PRINT  DUMP LINE
           llgt R1,TRACDCBA
           put (1),(0)
           sam64
           sysstate amode64=YES
*
           MVC PRNTLINE,SPACES
           pop using
*
         enddo
*
         DEQ (GENEVA,TRACNAME,,STEP),RNL=NO
*
       endif
     enddo
***********************************************************************
*  FILTER TRACE OUTPUT BASED ON VIEW# (IF VIEW SPECIFIC TRACING)      *
***********************************************************************
     llgt  R14,lpvaddr     reLOAD "NV"  ROW ADDRESS IN LOGIC TABLE
*
     if ltgf,R1,PARMTBLA,p  "MR95" PARAMETERS  SPECIFIED ???
*
       if CLI,VIEWTRAC,eq,c'Y'   VIEW  SPECIFIC  TRACE OPTION ???
*
         ltgf R1,LTPARMTB-LOGICTBL(,R14)   TRACE THIS   VIEW  ???
         doexit (NP)             exit the trace now
       endif
*
***********************************************************************
*  FILTER TRACE OUTPUT BASED ON DDNAME, RECORD#, FIELD CONTENT        *
***********************************************************************
       doexit (CLC,PARMDDN-PARMTBL(L'PARMDDN,R1),ne,SPACES),and,       +
               (CLC,GPDDNAME,ne,paRMDDN-PARMTBL(R1)) MATCHING DDNAME???
*
       doexit clc,GPRECCNT,lt,PARMFROM-PARMTBL(R1) IN RANGE??
       if ltg,r0,PARMTHRU-PARMTBL(,R1),p
         doexit clc,GPRECCNT,gt,PARMTHRU-PARMTBL(R1)
       endif
*
       LH  R15,PARMVLEN-PARMTBL(,R1)  SPECIFIC VALUE SPECIFIED ??
       if  cij,R15,gt,0               Positive?
         BCTR  R15,0
         lgr   R14,R6
         agh   R14,PARMVOFF-PARMTBL(,R1)  ADD   OFFSET
         EX    R15,TRACVALU               MATCHING VALUE ???
static   loctr
TRACVALU CLC   PARMVALU-PARMTBL(0,R1),0(R14)   TRACE SPECIFIC VALUE
code     loctr
         doexit (ne)                      NO  - EXIT
         llgt  R14,lpvaddr     reLOAD "NV"  ROW ADDRESS IN LOGIC TABLE
       endif
     endif
*
***********************************************************************
*  SEARCH LOGIC TABLE STARTING WITH "NV" FOR ROW FOR THIS GEN CODE    *
***********************************************************************
TRACE10  lgr   R15,R14                    SAVE  PREV  TABLE ROW ADDRESS
TRACE11  agh   R14,0(,R14)                ADVANCE TO  NEXT  ROW
curr     using logictbl,r14
         ltgf  R0,curr.LTCODSEG           ANY  CODE FOR THIS  FUNCTION?
         JNP   TRACE11                    NO  -  BYPASS PREV  ADV
         cgr   R0,R10                     TRACE  IN PREVIOUS  SEG   ???
         JNL   TRACE20                    YES -  PRINT INDICATIVE  INFO
*
         CLC   curr.ltfunc,NV             NEW  VIEW  (GONE TOO FAR) ???
         JE    TRACE15                    YES  EXIT   LOOP
         CLC   curr.ltfunc,ES             END-OF-SET (GONE TOO FAR) ???
         JE    TRACE15                    YES  EXIT   LOOP
         CLC   curr.ltfunc,ET             END-OF-SET (GONE TOO FAR) ???
         JE    TRACE15                    YES  EXIT   LOOP
         CLC   curr.ltfunc,EN             END-OF-TBL (GONE TOO FAR) ???
         JNE   TRACE10                    NO - CONTINUE TBL SCAN
         drop  curr
*
TRACE15  llgt  R15,lpvaddr             POINT BACK TO  BEGINNING OF VIEW
*
***********************************************************************
*  FILTER TRACE OUTPUT BASED ON LOGIC TABLE ROW#, or  Column number,  *
*     and  FUNCTION                                                   *
***********************************************************************
         push  using
         drop  r5
         using logictbl,r15

TRACE20  LTR   R1,R1              "MR95"  PARAMETERS  SPECIFIED ???
         JNP   TRACE30             NO  - TRACE EVERYTHING
* check the column numbers
         lgh   R0,LTseqno
         cgf   R0,PARMFCOL-PARMTBL(,R1)
         JL    TRACABND
*
         ltgf  R14,PARMTCOL-PARMTBL(,R1)
         JNP   TRACE22
         cgr   R0,R14
         JH    TRACABND
TRACE22  equ   *
* check the row numbers
         lgf   R0,LTROWNO
         cgf   R0,PARMROWF-PARMTBL(,R1)
         JL    TRACABND
*
         ltgf  R14,PARMROWT-PARMTBL(,R1)
         JNP   TRACE25
         cgr   R0,R14
         JH    TRACABND
* check if we are tracing this function code
TRACE25  LTGF  R14,PARMFLEN-PARMTBL(,R1)    TRACE SPECIFIC FUNCTION(S)
         JNP   TRACE30
         BCTR  R14,0
         EXrl  R14,TRACFUNC
         JNE   TRACABND
         b     trace30
         DS    0d
TRACFUNC CLC   LTFUNC(0),PARMFUNC-PARMTBL(R1) EXECUTED * *
*
***********************************************************************
*  BEGIN FORMATTING TRACE OUTPUT (DDNAME, REC#, VIEW#, LT ROW#, FUNCT)*
***********************************************************************
TRACE30  Larl  R14,TRACemsg            TRACE MESSAGE
         MVC   PRNTLINE,0(R14)
*
         if LTGF,R1,lp_RE_addr,p
           MVC TOUT.traceDDN,LTDDNAME-LOGICTBL(R1)
         else
           mvc   tout.traceDDN,GPDDNAME     get the DDname
         endif
*
         lg    r0,GPRECCNT
         cvdg  r0,dblwork2
         MVC   WORKAREA(L'TRACEMSK),TRACEMSK
         ED    WORKAREA(L'TRACEMSK),dblwork3+2
         MVC   tout.traceCNT,WORKAREA+2 RECORD NO.
         OI    tout.traceCNT+9,X'F0'

         L     R0,LTVIEW#
         CVD   R0,DBLWORK
         OI    DBLWORK+L'DBLWORK-1,X'0F'
         MVC   WORKAREA(L'TRACEMSK),TRACEMSK
         ED    WORKAREA(L'TRACEMSK),DBLWORK+2
         MVC   tout.traceVW#,WORKAREA+5
*
         L     R0,LTROWNO
         CVD   R0,DBLWORK
         OI    DBLWORK+L'DBLWORK-1,X'0F'
         MVC   WORKAREA(L'TRACEMSK),TRACEMSK
         ED    WORKAREA(L'TRACEMSK),DBLWORK+2
         MVC   tout.traceROW,WORKAREA+5 ROW NUMBER
*
         MVC   tout.traceFUN,LTFUNC
*
         lh    r0,ltseqno
         CVD   R0,DBLWORK
         OI    DBLWORK+L'DBLWORK-1,X'0F'
         UNPK  tout.traceCOL,DBLWORK
     do ,                   so I can use doexit
*
***********************************************************************
*  SELECT FUNCTIONS WHICH HAVE COLUMN/SEQUENCE# AND FIELD ATTRIBUTES  *
***********************************************************************
       llgt    R14,LTFUNTBL
       using functbl,r14
       if CLI,FC_RTYP,EQ,FC_RTYP09 FORMAT 09 FUNCTION ???
***********************************************************************
* VARIABLE VALUE (ACCUMULATOR FUNCTION)   -  RECORD TYPE 09           *
***********************************************************************
         llgt R14,LTACADDR
map_dim  using logictbl,r14
         LH    R1,map_dim.LTVNLEN
*
         lgf r14,map_dim.ltvnlitp          get accumulator offset
         alr r14,r2                        and add literal base
         drop map_dim
         BCTR R1,0
         LH    R0,LTFLDFMT                 FIELD  FORMAT
         select cij,r0,eq
         when (fc_alnum,fc_edit)
           EX R1,TRACMOVE
         when fc_float
           printdfp output=dfp1
         othrwise
           printhex length=r1,output=tout.tracedat
         endsel
*
         leave ,
       endif

       if CLI,FC_RTYP,eq,FC_RTYP10 FORMAT 10 FUNCTION ???
***********************************************************************
* VARIABLE VALUE (ACCUMULATOR FUNCTION)   -  RECORD TYPE 10           *
***********************************************************************
         llgt R14,LTACADDR
map_dim  using logictbl,r14
         LH    R1,map_dim.LTVNLEN          get accum length
         LH    R0,map_dim.LTVNFMT            and the format
*
*
         if TM,map_dim.LTFLAG2,LTLOCAL,nz  local variables are in litp
           lgf r14,map_dim.ltvnlitp          get accumulator offset
           agr r14,r2                 and add literal base
         else
           lgf r14,map_dim.ltvnlitp          get accumulator offset
           ahi  r14,thrdlen           global vars are after thrdarea
           agr  r14,r13
         endif
         drop map_dim
*
         BCTR R1,0
         if clc,=C'SET',ne,ltfunc          if it is NOT a SETx
           select cij,r0,eq
           when (fc_alnum,fc_edit)
             EX R1,TRACMOVE
           when fc_float
             printdfp output=dfp1
           othrwise
             printhex length=r1,output=tout.tracedat
           endsel
         endif
*
         if    clc,=c'CFCA',eq,ltfunc,or,     CFCA ?                   +
               cli,ltsubfun+1,eq,c'C'         xxxC ?
           La R14,LTVVVAL                     ACCUMULATOR CONSTANT
*
           LH R1,LTVVLEN                      get accum length
           LH R0,LTVVFMT                      and the format
         else
           llgt R14,LTvvval
map_dim    using logictbl,r14
           LH R1,map_dim.LTVNLEN           get accum length
           LH R0,map_dim.LTVNFMT             and the format
*
           lgf r14,map_dim.ltvnlitp        get accumulator offset
           agr r14,r2                      and add literal base
           drop map_dim
*
         endif
         BCTR R1,0
         select cij,r0,eq
         when (fc_alnum,fc_edit)
           EX R1,TRACMVV2
         when fc_float
           printdfp output=dfp2
         othrwise
           printhex length=r1,output=tout.tracev2
         endsel
         leave ,
       endif

       doexit cli,FC_RTYP,eq,FC_RTYP03 Type 3 function (F0 format has  +
                                       no field data) e.g. CFCC

       CLI     FC_RTYP,FC_RTYP12 FORMAT 12 FUNCTION ???
       JE      TRACE45
       CLI     FC_RTYP,FC_RTYP13 FORMAT 13 FUNCTION ???
       JE      TRACE45
*
       CLI     LTMAJFUN+1,c'F' is it xF?                (CF or SF)
       JE      TRACE40
       CLC     DT,LTMAJFUN                   DATA   FORMAT FUNCTION ???
       JE      TRACE40
       CLC     ct,LTMAJFUN                   COLUMN FORMAT FUNCTION ???
       JE      TRACE40
       CLC     LK,LTMAJFUN                   BUILD  KEY    FUNCTION ???
       JE      TRACE40
       CLC     SK,LTMAJFUN                   SORT   KEY    FUNCTION ???
       JE      TRACE40
       CLC     =c'CN',LTMAJFUN               CLASS  TEST   FUNCTION ???
       JE      TRACE40
       CLC     =c'CS',LTMAJFUN               CLASS  TEST   FUNCTION ???
       JE      TRACE40
       CLC     =c'CX',LTMAJFUN               CLASS  TEST   FUNCTION ???
       JE      TRACE40
*
       doexit clc,wr,ne,ltmajfun
*
TRACE40 equ    *
*
***********************************************************************
* "WR" FUNCTION                                                       *
***********************************************************************
       CLC     wr,LTMAJFUN
       JNE     TRACE45
*
       MVC     tout.tracePOS(l'ltwrname),LTWRNAME
       MVC     tout.traceDAT(l'ltwrparm),LTWRPARM
       J       TRACE90
*
***********************************************************************
*  FORMAT FIELD POSITION, LENGTH, FORMAT, CONTENT                     *
***********************************************************************
TRACE45 MVI    tout.tracePOS-1,C'|'
*
       LH      R1,LTFLDPOS                         FIELD  POSITION
       AHI     R1,1
       CVD     R1,DBLWORK
       OI      DBLWORK+L'DBLWORK-1,X'0F'
       MVC     WORKAREA(L'TRACEMSK),TRACEMSK
       ED      WORKAREA(L'TRACEMSK),DBLWORK+2
       MVC     tout.tracePOS,WORKAREA+8
*
       LH      R1,LTFLDLEN                         FIELD  LENGTH
       AHI     R1,1
       CVD     R1,DBLWORK
       OI      DBLWORK+L'DBLWORK-1,X'0F'
       MVC     WORKAREA(L'TRACEMSK),TRACEMSK
       ED      WORKAREA(L'TRACEMSK),DBLWORK+2
       MVC     tout.traceLEN,WORKAREA+8
*
       lgh     R14,LTFLDFMT                        FIELD  FORMAT
       SLL     R14,1
       LA      R14,FLDFMT(R14)
       MVC     tout.traceFMT,0(R14)
*
       LH      R0,LTFLDCON                         FIELD  CONTENT
       CVD     R0,DBLWORK
       OI      DBLWORK+L'DBLWORK-1,X'0F'
       UNPK    tout.traceCON,DBLWORK
*
***********************************************************************
* BRANCH IF FUNCTION HAS A SINGLE CONSTANT VALUE                      *
***********************************************************************
       drop    r14
       LA      R14,LTVALUES
*
       CLC     =c'LKDC',LTFUNC                  DATE CONSTANT  ???
       JE      TRACE68
       CLC     =C'LKS ',LTFUNC                  SYMBOLIC  VAR  ???
       JE      TRACE68
       CLI     LTSUBFUN+0,C'C'                     CONSTANT    ???
       JNE     TRACE50
       CLI     LTSUBFUN+1,C' '                     CONSTANT    ???
       Je      TRACE68
*
***********************************************************************
*                                                                     *
***********************************************************************
TRACE50 ds 0h
       doexit clc,=c'LKLR',eq,ltfunc         SET LOOK-UP LOGICAL REC ?
*
***********************************************************************
*                                                                     *
***********************************************************************
       LLC     R1,LTNDEC
       CVD     R1,DBLWORK
       UNPK    tout.TRACEDEC,DBLWORK+7(1)
       OI      tout.TRACEDEC,X'F0'
*
       llgt    R14,LTFUNTBL
       using functbl,r14
       if CLI,FC_RTYP,eq,FC_RTYP05,or,         FORMAT 2  FUNCTION ???  +
               CLI,FC_RTYP,eq,FC_RTYP12,or,    FORMAT 2  FUNCTION ???  +
               CLI,FC_RTYP,eq,FC_RTYP13,andif, FORMAT 2  FUNCTION ???  +
               clc,ct,ne,ltmajfun
         drop r14
*
***********************************************************************
*  PRINT SECOND SET OF FIELD ATTRIBUTES                               *
***********************************************************************
         MVI tout.TRACETPS-1,C'|'
*
         LH    R1,LTCOLPOS                  OUTPUT COLUMN POSITION
         AHI R1,1
         CVD R1,DBLWORK
         OI    DBLWORK+L'DBLWORK-1,X'0F'
         MVC WORKAREA(L'TRACEMSK),TRACEMSK
         ED    WORKAREA(L'TRACEMSK),DBLWORK+2
         MVC tout.TRACETPS,WORKAREA+8
*
         LH    R1,LTCOLLEN                  OUTPUT COLUMN LENGTH
         AHI R1,1
         CVD R1,DBLWORK
         OI    DBLWORK+L'DBLWORK-1,X'0F'
         MVC WORKAREA(L'TRACEMSK),TRACEMSK
         ED    WORKAREA(L'TRACEMSK),DBLWORK+2
         MVC tout.TRACETLN,WORKAREA+8
*
         lgh R14,LTCOLFMT                   OUTPUT COLUMN FORMAT
         SLL R14,1
         LA    R14,FLDFMT(R14)
         MVC tout.TRACETFM,0(R14)
*
         LH    R0,LTCOLCON                  OUTPUT COLUMN CONTENT
         CVD R0,DBLWORK
         OI    DBLWORK+L'DBLWORK-1,X'0F'
         UNPK tout.TRACETCN,DBLWORK
*
         LLC  R1,LTCOLDEC
         CVD  R1,DBLWORK
         UNPK tout.TRACETDC,DBLWORK+7(1)
         OI   tout.TRACETDC,X'F0'
*
       endif
***********************************************************************
*  PRINT FIRST ARGUMENT CONTENT                                       *
***********************************************************************
       Lgh R14,LTFLDPOS
       select cli,lt_opt1,eq
       when    (fc_con)                 Constant?
         if CLC,=c'CFCC',eq,LTFUNC
           lh r1,ltrowlen
           doexit cij,r1,eq,ltf0_len    get out if noop ed
         endif
         la     r14,ltvalues
         if CLI,LTMAJFUN+1,eq,c'F' is it xF? (CF or SF)
           lh r1,ltv1len
           bctr r1,0
         else
           lgh R1,LTFLDLEN
         endif
       when    (fc_acum)                   ACCUMULATOR FUNCTION ???
*
         llgt R14,LTAC2ADR
map_dim  using logictbl,r14
         if TM,map_dim.LTFLAG2,LTLOCAL,nz  local variables are in litp
           lgf r14,map_dim.ltvnlitp     get accumulator offset
           agr r14,r2                 and add literal base
         else
           lgf r14,map_dim.ltvnlitp     get accumulator offset
           ahi  r14,thrdlen           global vars are after thrdarea
           agr  r14,r13
         endif
         lgh R1,LTFLDLEN
         drop map_dim

       when (fc_prev)
         lg    R1,PREVRECA
         agr R14,R1
         lgh R1,LTFLDLEN

       when (fc_evnt)
         lgr R1,R6
         agr R14,R1
         lgh R1,LTFLDLEN

       when (fc_prior)

         l     r1,ltfldfil       Get the area type for prior column

         select cij,r1,eq    test value in r1

           when 1             - sort key offset

             lghi R0,EXSRTKEY-EXTREC

           when 2             - sort key title (ignored)

             xgr  r0,r0       clear

           when 3             - DT area

             llgt R1,LTlognv
             lgh  R0,LTSORTLN-LOGICTBL(,R1)
             ah   R0,LTTITLLN-LOGICTBL(,R1)
             aghi R0,EXSRTKEY-EXTREC

           when 4             - CT area (to be done)

             llgt R1,LTlognv
             lgh  R0,LTSORTLN-LOGICTBL(,R1)
             ah   R0,LTTITLLN-LOGICTBL(,R1)
             ah   R0,LTdataLN-LOGICTBL(,R1)
             aghi R0,EXSRTKEY-EXTREC

         endsel

         agr r0,r7
         agr R14,R0
         lgh R1,LTFLDLEN

       when (fc_lkup)
         if TM,LTFLAGS,LTLKUPRE,z    LOOKUP PREFIX not present ?
*
           if tm,LTflag1,ltlkup_offset,o        test for offset

             lgf R0,LTLUBOFF               LOOKUP  BUFFER   ADDR
             agr R0,R2
             lgr R1,R0                     LOAD LOOKUP BUFR ADDR
             llgt r1,0(,r1) Get the address
             lg R1,LBLSTFND-LKUPBUFR(,R1) LOAD LOOKUP RECORD
           endif
         else
***********************************************************************
* FIRST ARGUMENT IS FROM A LOOK-UP                                    *
***********************************************************************
           lg R3,SAVF4SAG64RS10      LOAD  RETURN  ADDRESS
           LA R3,0(,R3)              CLEAR   HIGH  BIT
*
static     loctr ,
           lkupcode dummy           generate object text for compare
code       loctr
real       using lkup_llgt,r3
*
*          this if is comparing the object code at the return address
*          to see if the instructions match the lookup prefix ones
*          (looks at first and last byte of each instruction)
*
           if (clc,real.lkup_llgt(1),eq,lkup_llgt),and,                +
               (clc,real.lkup_llgt+l'lkup_llgt-1(1),eq,lkup_llgt+l'lkup+
               _llgt-1),and,                                           +
               (clc,real.lkup_lg(1),eq,lkup_lg),and,                   +
               (clc,real.lkup_lg+l'lkup_lg-1(1),eq,lkup_lg+l'lkup_lg-1)
*            if it all matches then we execute the generated prefix
*            code so that it loads R5
             EX 0,real.lkup_llgt EXECUTE NEXT "LOAD R5" INSTRUCTION
             EX 0,real.lkup_lg
             Lgr r1,r5
           endif
         endif

         agr R14,R1
TRACE68  lgh R1,LTFLDLEN
       endsel
*
       MVI tout.TRACEDAT-1,C'|'
*
       if CLI,LTMAJFUN+1,eq,c'F' is it xF? (CF or SF)
         stmg r1,r2,workarea               Save R1 and R2 (TRT)
         xgr r2,r2
static   loctr
testalpha   trt 0(0,r14),alphatrt
alphatrt   dc 256x'01'
         org alphatrt+c' '
         dc x'00'
         org alphatrt+x'4A'      US cent symbol
         dc 7x'00'
         org alphatrt+c'!'
         dc 8x'00'
         org alphatrt+c','
         dc 5x'00'
         org alphatrt+c':'
         dc 6x'00'
         org alphatrt+c'a'
         dc 9x'00'
         org alphatrt+c'j'
         dc 9x'00'
         org alphatrt+c's'
         dc 8x'00'
         org alphatrt+c'A'
         dc 9x'00'
         org alphatrt+c'J'
         dc 9x'00'
         org alphatrt+c'S'
         dc 8x'00'
         org alphatrt+c'0'
         dc 10x'00'
         org ,
code     loctr
         ex r1,testalpha
         Lmg r1,r2,workarea
         if z
           EX R1,TRACMOVE
         else
* if a constant then need to convert from float to displayable
           if cli,lt_opt1,eq,fc_con     constant?
             printconst output=tout.tracedat
             MVI tout.TRACEDAT-1,C'|'
           else
             printhex length=r1,output=tout.tracedat
           endif
         endif

       else
         if clc,=c'SET',ne,ltfunc                   if it is NOT a SET +
                then format the operand
           lghi R0,L'TRACEDAT-1
           if CLi,LTMAJFUN+1,ne,c'F' not CF, not SF
             lghi R0,L'TRACEDAT-1+2+L'TRACEV2
           endif
*
           if cgrj,R1,gt,R0
             lgr R1,R0
           endif
           LH R0,LTFLDFMT                         FIELD  FORMAT
           select cij,r0,eq
           when (fc_alnum,fc_edit)
             EX R1,TRACMOVE
           when fc_float
             printdfp output=dfp1
           othrwise
             printhex length=r1,output=tout.tracedat
           endsel
         endif
       endif
*
***********************************************************************
*    PRINT SECOND ARGUMENT CONTENT                                    *
***********************************************************************
       doexit CLI,LTSUBFUN+1,eq,C' '    no 2nd. arg??
       doexit CLC,LTMAJFUN(3),eq,=c'LKD' date function, so no 2nd arg
*
       select cli,lt_opt2,eq
       when (fc_con)                    Constant?
         la r14,ltvalues
         if CLC,=c'CFCC',eq,LTFUNC      is it CFCC?
           agh R14,LTV1LEN              Point R14 at 2nd constant
           lh    r1,ltv2len
         else
           lh r1,ltv1len
         endif
         bctr r1,0

       when (fc_acum)                      ACCUMULATOR FUNCTION ???
*
         if clc,=c'CFCA',eq,LTFUNC
           llgt R14,LTACADDR               LOAD ACCUMULATOR ADDR ???
         else
           llgt R14,LTAC2ADR
         endif
map_dim   using logictbl,r14
*
         if TM,map_dim.LTFLAG2,LTLOCAL,nz  local variables are in litp
           lgf r14,map_dim.ltvnlitp          get accumulator offset
           agr r14,r2                 and add literal base
         else
           lgf r14,map_dim.ltvnlitp          get accumulator offset
           ahi  r14,thrdlen           global vars are after thrdarea
           agr  r14,r13
         endif
         drop map_dim
         Lghi R1,l'fc_float

       when (fc_prev)
         if CLC,=c'FC',eq,LTMAJFUN+1        is it xFC? (CFC or SFC)
           lgh r14,ltfldpos
           lgh r0,ltfldlen
         else
           Lgh R14,LTcolPOS
           lgh R0,LTcolLEN
         endif
         lg R1,PREVRECA
         agr R14,R1
         lgr R1,r0

       when (fc_evnt)
         if CLC,=c'FC',eq,LTMAJFUN+1        is it xFC? (CFC or SFC)
           lgh r14,ltfldpos
           lgh r0,ltfldlen
         else
           Lgh R14,LTcolPOS
           lgh R0,LTcolLEN
         endif
         lgr R1,R6
         agr R14,R1
         lgr R1,r0

       when (fc_prior)

         if CLC,=c'FC',eq,LTMAJFUN+1        is it xFC? (CFC or SFC)
           lgh r14,ltfldpos
           l   r1,ltfldfil
         else
           Lgh R14,LTcolPOS
           l   R1,LTcolfil
         endif

         select cij,r1,eq    test value in r1

           when 1             - sort key offset

             lghi R0,EXSRTKEY-EXTREC

           when 2             - sort key title (ignored)

             xgr  r0,r0       clear

           when 3             - DT area

             llgt R1,LTlognv
             lgh  R0,LTSORTLN-LOGICTBL(,R1)
             ah   R0,LTTITLLN-LOGICTBL(,R1)
             aghi R0,EXSRTKEY-EXTREC

           when 4             - CT area (to be done)

             llgt R1,LTlognv
             lgh  R0,LTSORTLN-LOGICTBL(,R1)
             ah   R0,LTTITLLN-LOGICTBL(,R1)
             ah   R0,LTdataLN-LOGICTBL(,R1)
             aghi R0,EXSRTKEY-EXTREC

         endsel

         agr r0,r7
         agr R14,R0

         if CLC,=c'FC',eq,LTMAJFUN+1        is it xFC? (CFC or SFC)
           lgh r1,ltfldlen
         else
           lgh R1,LTcolLEN
         endif

       when (fc_lkup)
         if CLC,=c'FC',eq,LTMAJFUN+1        is it xFC? (CFC or SFC)
           lgh r14,ltfldpos
           lgh r0,ltfldlen
         else
           Lgh R14,LTcolPOS
           lgh R0,LTcolLEN
         endif
         if TM,LTFLAGS,LTLKUPRE,z    LOOKUP PREFIX not present ?
*
           if tm,LTflag1,ltlkup_offset,o        test for offset

             lgf R0,LTLUBOFF               LOOKUP  BUFFER   ADDR
             agr R0,R2
             lgr R1,R0                     LOAD LOOKUP BUFR ADDR
             llgt r1,0(,r1) Get the address
             lg R1,LBLSTFND-LKUPBUFR(,R1) LOAD LOOKUP RECORD
           endif
         else
           lg R3,SAVF4SAG64RS10       LOAD  RETURN  ADDRESS
           LA R3,0(,R3)             CLEAR   HIGH  BIT
*
*          this if is comparing the object code at the return address
*          to see if the instructions match the lookup prefix ones
*          (looks at first and last byte of each instruction)
*
           if (clc,real.lkup_llgt(1),eq,lkup_llgt),and,                +
               (clc,real.lkup_llgt+l'lkup_llgt-1(1),eq,lkup_llgt+l'lkup+
               _llgt-1),and,                                           +
               (clc,real.lkup_lg(1),eq,lkup_lg),and,                   +
               (clc,real.lkup_lg+l'lkup_lg-1(1),eq,lkup_lg+l'lkup_lg-1)
*            we have a valid prefix now
*              now just execute the prefix instructions
*              code so that it loads R5

             EX 0,real.lkup_llgt EXECUTE "LOAD R5" INSTRUCTION
             EX 0,real.lkup_lg
             lgr R1,R5
           endif
         endif

         agr R14,R1
         lgr R1,r0
       when (fc_lkup2)
         Lgh R14,LTcolPOS
         lgh R0,LTcolLEN
         if TM,LTFLAGS,LTLKUPRE,z    LOOKUP PREFIX not present ?
*
           if tm,LTflag1,ltlkup_offset,o        test for offset

             lgf R0,LTLUBOFF               LOOKUP  BUFFER   ADDR
             agr R0,R2
             lgr R1,R0                     LOAD LOOKUP BUFR ADDR
             llgt r1,0(,r1) Get the address
             lg R1,LBLSTFND-LKUPBUFR(,R1) LOAD LOOKUP RECORD
           endif
         else
           lg R3,SAVF4SAG64RS10       LOAD  RETURN  ADDRESS
           LA R3,0(,R3)              CLEAR   HIGH  BIT
*
*          this if is comparing the object code at the return address
*          to see if the instructions match the lookup prefix ones
*          (looks at first and last byte of each instruction)
*
           if (clc,real.lkup_llgt(1),eq,lkup_llgt),and,                +
               (clc,real.lkup_llgt+l'lkup_llgt-1(1),eq,lkup_llgt+l'lkup+
               _llgt-1),and,                                           +
               (clc,real.lkup_lg(1),eq,lkup_lg),and,                   +
               (clc,real.lkup_lg+l'lkup_lg-1(1),eq,lkup_lg+l'lkup_lg-1)
*            we have a valid prefix now

*            this is lookup2 - so move to the next prefix
             ahi r3,lkuppref_length

*            now just execute the prefix instructions
*            code so that it loads R1 (the second lookup ptr)
             EX 0,real.lkup_llgt EXECUTE "LOAD R1" INSTRUCTION
             EX 0,real.lkup_lg
           endif
         endif

         agr R14,R1
         lgr R1,r0
       endsel
*
       lghi R0,L'TRACEV2-1
       if cgij,R1,lt,0,or,           R1 negative                       +
               cgrj,R1,gt,r0             or too large
         lgr R1,R0
       endif
       if CLI,LTMAJFUN+1,eq,c'F' is it xF? (CF or SF)
         stmg r1,r2,workarea               Save R1 and R2 (TRT)
         xgr r2,r2
         ex r1,testalpha
         Lmg r1,r2,workarea
         if z
           EX R1,TRACMVV2
         else
* if a constant, need to convert from float
           if cli,lt_opt2,eq,fc_con     constant?
             printconst output=tout.tracev2
*            MVI tout.TRACEv2-1,C' '
           else
             printhex length=r1,output=tout.tracev2
           endif
         endif

       else
         if cli,ltfunc+1,eq,c'F',andif,                      CF|SF and +
               cli,ltsubfun+1,eq,C'C',or,                      .C?  or +
               cli,ltsubfun+1,eq,C'S'                          .S?
           LH R0,LTfldFMT                         FIELD  FORMAT
           if cij,r0,gt,fc_alpha          if this is true then
             lhi r0,fc_float              the constant is a float
           endif
           lh r1,ltv1len                          and its length
           bctr r1,0                                machine length
         else
           LH R0,LTcolFMT                         FIELD  FORMAT
         endif
         select cij,r0,eq
         when (fc_alnum,fc_edit)
           EX R1,TRACMVV2
         when fc_float
           printdfp output=dfp2
         othrwise
           printhex length=r1,output=tout.tracev2
         endsel
       endif
     enddo ,             end of simple do group

     llgt  R14,LTFUNTBL
     if CLI,FC_RTYP-FUNCTBL(R14),eq,FC_RTYP04,or, FORMAT 1 ? or        +
               CLI,FC_RTYP-FUNCTBL(R14),eq,FC_RTYP05  FORMAT 2 ???
*
       L R0,LTFldfil
       CVD R0,DBLWORK
       OI DBLWORK+L'DBLWORK-1,X'0F'
       MVC WORKAREA(L'TRACEMSK),TRACEMSK
       ED WORKAREA(L'TRACEMSK),DBLWORK+2
       MVC tout.TRACEFIL,WORKAREA+4
*
       L R0,LTFLDLR
       CVD R0,DBLWORK
       OI DBLWORK+L'DBLWORK-1,X'0F'
       MVC WORKAREA(L'TRACEMSK),TRACEMSK
       ED WORKAREA(L'TRACEMSK),DBLWORK+2
       MVC tout.TRACEREC,WORKAREA+4
*
       L R0,LTFLDID
       CVD R0,DBLWORK
       OI DBLWORK+L'DBLWORK-1,X'0F'
       MVC WORKAREA(L'TRACEMSK),TRACEMSK
       ED WORKAREA(L'TRACEMSK),DBLWORK+2
       MVC tout.TRACEFLD,WORKAREA+4
     endif
*
     if        (clc,=c'JOIN',eq,LTFUNC),or,                join?       +
               (clc,=c'LU',eq,LTmajFUN)                      or lu
*
       MVI tout.TRACEDAT-1,C'|'
*
       MVC tout.TRACEPOS(l'ltluname),LTLUNAME
       MVC tout.TRACEDAT(l'ltluparm),LTLUPARM
*
       lgf R14,LTLUBOFF
       llgt r14,0(r14,r2) Get the address
       lgf R0,LBLRID-LKUPBUFR(,R14)

       CVD R0,DBLWORK
       OI DBLWORK+L'DBLWORK-1,X'0F'
       MVC WORKAREA(L'TRACEMSK),TRACEMSK
       ED WORKAREA(L'TRACEMSK),DBLWORK+2
       MVC tout.TRACEREC,WORKAREA+4
*
       L R0,LTLUFId
       CVD R0,DBLWORK
       OI DBLWORK+L'DBLWORK-1,X'0F'
       MVC WORKAREA(L'TRACEMSK),TRACEMSK
       ED WORKAREA(L'TRACEMSK),DBLWORK+2
       MVC tout.TRACEfil,WORKAREA+4
*
       L R0,LTLUPATH
       CVD R0,DBLWORK
       OI DBLWORK+L'DBLWORK-1,X'0F'
       MVC WORKAREA(L'TRACEMSK),TRACEMSK
       ED WORKAREA(L'TRACEMSK),DBLWORK+2
       MVC tout.TRACEFLD,WORKAREA+4

     endif
*
TRACE90  lgr   R4,R15                  SAVE  LT  ROW  ADDRESS
     ENQ (GENEVA,TRACNAME,E,,STEP),RNL=NO
*
     llgt R3,TRACDCBA          LOAD  DCB ADDRESS
     using ihadcb,r3
     sysstate amode64=NO
     sam31
     if tm,dcboflgs,dcbofopn,o         Is it open?
       if CLIY,TRACOPEN,ne,c'Y'        headings done yet?
         MVIY TRACOPEN,C'Y'
*
         Lay   R0,Trhd1msg             PRINT HEADER 1
         put (r3),(0)
*
         Lay   R0,Trhd2msg             PRINT HEADER 2
         put (r3),(0)
*
       endif
       LA R0,PRNTLINE             PRINT TRACE MESSAGE
       put (r3),(0)

       if tmy,dfp1,l'dfp1,o
         lay r0,print_dfp1
         put (r3),(0)
       endif

       if tmy,dfp2,l'dfp2,o
         lay r0,print_dfp2
         put (r3),(0)
       endif
       niy dfp1,X'ff'-(l'dfp1+l'dfp2)   and turn off the flags
*
     endif
     sam64
     sysstate amode64=YES
     drop r3
     DEQ (GENEVA,TRACNAME,,STEP),RNL=NO
     lgr R15,R4                 RESTORE LT ROW ADDRESS
*
***********************************************************************
*  CHECK FOR LOGIC TABLE ROW ABEND                                    *
***********************************************************************
TRACABND ds 0h                 "MR95"  PARAMETERS  SPECIFIED ???
     doexit LT,r1,parmtbla,np  "MR95" parameters ?
*
     L     R0,LTROWNO
     if C,R0,eq,abend_lt
       lmg    R14,R12,SAVF4SAG64RS14
       DC     XL4'FFFFFFFF'
     endif

     pop      using
   endif
 enddo ,                                   tracexit do
***********************************************************************
*  SWITCH TO "SRB" MODE IF ZIIP ENABLED                               *
***********************************************************************
 if (ltgf,r15,workazip,nz),and,          zIIP function available?      +
               (cli,thread_mode,eq,C'P') and we are in TCB mode
   la    r1,SRB_switch              Switch to SRB mode
   bassm r14,r15                    Call zIIP module
 endif
* if cli,localziip,eq,c'Y',and,             switching allowed         +
*               cli,thread_mode,eq,c'P'      and in problem state
*   brasl r14,srbswich             CONTINUE in srb mode
* endif
*
 lmg           R14,R12,SAVF4SAG64RS14
 br            r10
 pop using
                        EJECT
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*                                                                     *
*        B E G I N N I N G   O F   S U B - T A S K   C O D E          *
*             (MULTI-THREADING FOR EACH INPUT EVENT FILE)             *
*                                                                     *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*
*
*  This is an AR mode program so we MUST use the stack
*  This code is directly from MVS Assembler Services Guide SA22-7605
*
Subtask  BAKR  R14,0              stack the gprs,ars mode etc.
         SAM64                    Identify will set the amode here to
*                                 A31 for the subtask, so switch now -
*                                 see earlier notes about IDENTIFY
         sac   0                  make sure we are in primary mode
         larl  r12,gvbmr95        set up 1st base

         lae   r13,0(r1,0)        copy the address and alet
         llgtr r13,r13            and clean it
         using (thrdarea,thrdend),r13 Tell assembler to map the area
         using genenv,env_area
         using genparm,parm_area
         using genfile,file_area
         USING MSGLIST,MSG_AREA
         llgtr r1,r1              and clean
         llgtr r2,r2              and clean
         llgtr r3,r3              and clean
         llgtr r4,r4              and clean
         llgtr r5,r5              and clean
         llgtr r6,r6              and clean
         llgtr r7,r7              and clean
         llgtr r8,r8              and clean
         llgtr r9,r9              and clean
         llgtr r10,r10            and clean
         llgtr r11,r11            and clean
         llgtr r14,r14            and clean
         llgtr r15,r15            and clean
*
         XC    LKUPKEY,LKUPKEY    ZERO   ACCESS   REGISTER AREA
         LAM   R0,R10,lkupkey     ZERO ar0-ar10
         LAM   R14,r15,lkupkey     and ar14-ar15
*
         mvc   4(4,r13),=c'F1SA'  Set back pointer to tell everyone    +
                                  that we have used the stack
                        EJECT
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*                                                                     *
*                  M A I N L I N E   L O G I C                        *
*                                                                     *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*
MAIN     mvi   thread_mode,c'P'   Set mode to problem state.
*
         lay   r14,fp_reg_savearea  Point at register save area
         std   fp8,0(0,r14)       save fp8 to fp15
         std   fp9,8(0,r14)
         std   fp10,16(0,r14)
         std   fp11,24(0,r14)
         std   fp12,32(0,r14)
         std   fp13,40(0,r14)
         std   fp14,48(0,r14)
         std   fp15,56(0,r14)

         lzxr  fp8                load a zero in fp8/10
         l     r14,dfp_quantum_ptr  get pointer to quantum from MR96
         ld    fp9,0(0,r14)       and set the FPRs 9/11 to the quantum
         ld    fp11,8(0,r14)

*   The allocation of the pause element for the TCB MUST be done here
*   so that the PET is available at all times
*   (Essentially we must ensure that there is a valid PET before there
*   is any possible use of the PET)
*   If we are APF authourised then the PETs are authorised as well
*   so that they may be used by either a TCB or SRB.
*   The code has been rewritten to assume that a PE is available,
*   irrespective of TCB vs SRB.  In particular, the code in the WRTx
*   routines (which have to single thread) will now use pause/release

***********************************************************************
*      INITIALIZE PAUSE ELEMENT TOKENS AND CURRENT TOKEN POINTERS     *
***********************************************************************
         lay  r15,tcbpet1
         MVC 0(l'TCBPET1,r15),HEXFF        INIT "TCB PE" TOKENS
         lay  r15,tcbpet2
         MVC 0(l'TCBPET2,r15),HEXFF
*
         lay  r15,srbpet1
         MVC 0(l'srbPET1,r15),HEXFF        INIT "TCB PE" TOKENS
         lay  r15,srbpet2
         MVC 0(l'srbPET2,r15),HEXFF
*
         LAY R0,TCBPET1           INIT CURRENT  "TCB PET" POINTERS
         STg R0,TCBPET1A
         LAY R0,TCBPET2
         STg R0,TCBPET2A
*
         LAY R0,SRBPET1           INIT CURRENT  "SRB PET" POINTERS
         STg R0,SRBPET1A
         LAY R0,SRBPET2
         STg R0,SRBPET2A
*
***********************************************************************
* BUILD PARAMETER LIST FOR "TCB" PAUSE ELEMENT ALLOCATION (+TRANSFER)*
***********************************************************************
         lay R0,XFRTCBRC          INITIALIZE PARAMETER LIST
         stg R0,XFRTCBP1
*
         LAY R0,TCBPET1
         stg R0,XFRTCBP3
*
         LAY R0,TCBPET2
         stg R0,XFRTCBP4
*
         LAY R0,DBLWORK2
         stg R0,XFRTCBP5
*
         LAY R0,SRBPET1
         stg R0,XFRTCBP6
*
         LAY R0,DBLWORK3
         stg R0,XFRTCBP7
*
         if cli,localauth,eq,c'A'   Are we authorized?
*          here we are allocating an authourised PET
           LAY R0,PETAUTH
           stg R0,XFRTCBP2
*
           MODESET KEY=ZERO,MODE=SUP key zero needed now for the
*                                       pause element calls
***********************************************************************
*    ALLOCATE "TCB" PAUSE ELEMENT WHILE IN AUTHORIZED STATE           *
***********************************************************************
           lay R1,XFRTCBPL        CALL "IEAVAPE" - ALLOCATE "TCB PE"
           llgt R15,IEA4APE
           BASR R14,R15
           if cij,r15,ne,0
             MVC DBLWORK,=CL8'IEA4APE'
             ST  R15,DBLWORK2     Save return code
*            DC H'0'
             j  PE_error          Write msg to log, and end thread
*
           endif
           MODESET KEY=NZERO,MODE=PROB reset to normal
*
         else  ,                 Not authorised               still    +
                                 need a pet though
           LAY R0,PET_notauth    which needs to be unauthorized
           stg R0,XFRTCBP2

***********************************************************************
*    ALLOCATE "TCB" PAUSE ELEMENT                                     *
***********************************************************************
           lay R1,XFRTCBPL        CALL "IEAVAPE" - ALLOCATE "TCB PE"
           llgt R15,IEA4APE
           BASR R14,R15
           if cij,r15,ne,0
             MVC DBLWORK,=CL8'IEA4APE'
             ST  R15,DBLWORK2     Save return code
*            DC H'0'
             j  PE_error          Write msg to log, and end thread
           endif
         endif
***********************************************************************
*  CHECK FOR PROGRAM "PATCHES"                                        *
***********************************************************************
MAIN_100 llgt  R1,THRDMAIN        CHECK FOR PROGRAM   PATCHES/FIXES
         LA    R14,PATCHAR
         EX    0,CHKPATCH
         EX    0,BRNPATCH
                        SPACE 3
***********************************************************************
*  PERFORM THREAD SPECIFIC EXIT INTERFACE AREA INITIALIZATION ("LE")  *
***********************************************************************
         LARL  R15,EXITINIT       LOAD "LE" AREA INIT SUBROUTINE  ADDR
         oilh  r15,x'8000'        set it up to be amode 31
         BASsm R14,R15            and go there, flipping mode as we go
***********************************************************************
*        Perform the estae set up AFTER any possible CEE setup
*        so that these exits will be first in the queue.
*
*        Set the program mask so that overflow conditions cause a
*        program check - the estae will handle the reporting
*
*        Also set up an ESTAE to report on and clean up from any other
*        unexpected errors.
*
         llgt r2,execdadr         get address of exec area
         using execdata,r2        and map it

         if (cli,EXEC_ESTAE,eq,c'Y')
           LR    r2,r13             make sure r2 is always set up
           lgf   r3,ovflmask        set bits 36 and 37
           spm   r3                 set overflow masks on
           larl r3,taskabnd         get the address of the estae
           XC    WKREENT,WKREENT    clear the parm AREA
           ESTAEX (r3),           R3 -> taskabnd (estae exit code)     +
               CT,                   Create the exit point             +
               PARAM=(R2),        pass thread area addr to the exit    +
               PURGE=HALT,        Halt any outstanding i/o             +
               MF=(E,WKREENT)

         endif

         llgt  R8,THRDES          LOAD "ES" ROW  ADDR

         drop  r2 execdata
         USING LOGICTBL,R8
         xgr   r15,r15
         stg   r15,thrd_evntrec_cnt   initialise
         stg   r15,thrd_evntbyte_cnt  initialise
                        EJECT
***********************************************************************
*  RESET THREAD WORK AREA VARIABLES FOR NEXT EVENT FILE               *
***********************************************************************
RESTART  MVC   LKUPKEY,SPACES     INITIALIZE LOOK-UP  KEY   WORK  AREA
*
         MVC   GPDDNAME,SPACES
         XC    GPLFID,GPLFID
         MVC   EVNTSUBR,SPACES
         XC    EVNTREAD,EVNTREAD
         mvi   gp_call_srb,c' '   blank this out
         mvi   GP_redrive,c' '    and this
         MVI   eofevnt,c' '       clear the eof flag
*
         llgt  R0,GPEXTRA         ZERO EXTRACT RECORD AREA
         LHI   R1,EXTRECL
         XR    R14,R14
         XR    R15,R15
         MVCL  R0,R14
*
         ST    R8,THRDES          SAVE "ES"  ROW ADDR
         ST    R13,LTTHRDWK       SAVE ASSIGNED  WORK AREA ADDR IN "ES"
*
         LLGT  R2,LTESLPAD        LOAD LITERAL   POOL ADDRESS
         ST    R2,THRDLITP
         agfi  r2,f512k           literal pool base now in middle
         using litp_hdr+524288,r2
         sty   r2,lp_base_litp    make sure base has itself
*
***********************************************************************
*  CALL GENERATED "ES" INITIALIZATION CODE (IF ANY)                   *
***********************************************************************
         if ltgf,R15,LTESINIT,P   do we have any init code in this ES?
*
           using nvprolog,r15
           LARL R11,INITRETN      INITIALIZE   RETURN ADDR
           llgt R5,NVNXVIEW        SAVE ORIGINAL  NEXT PROLOG ADDRESS
           ST  R11,NVNXVIEW
           llgt R7,GPEXTRA         LOAD EXTRACT RECORD BASE  REGISTER
           BR  R15                PASS CONTROL TO  CODE (31-BIT MODE)
*
INITRETN   llgt R8,THRDES          LOAD "ES"  ROW ADDR
           LLGT R2,thrdlitp       reload literal pool base
           agfi r2,f512k           literal pool base now in middle
           llgt r15,ltesinit       reload base register for prolog
           ST  R5,NVNXVIEW        RESET ORIGINAL "NEXT VIEW"
           drop r15
         endif
                        EJECT
***********************************************************************
*  CHECK IF THIS "ES" SET OF VIEWS HAS AN EVENT FILE                  *
***********************************************************************
         MVC   gpphase,OP         INDICATE "OPen"  PHASE
*
         llgt  R8,LTFRSTRE        LOAD  "RE"  ROW   ADDR
         ST    R8,THRDRE
         cgijnh r8,0,callexit     READ  EVENT  AVAILABLE  ???          +
                                  NO  - BYPASS EVENT FILE INIT
*
***********************************************************************
*  POPULATE EVENT FILE FIELDS                                         *
***********************************************************************
         MVC   GPDDNAME,LTDDNAME  SAVE NEXT EVENT FILE DDNAME
         MVC   GPLFID,LTFILEID    SAVE NEXT EVENT FILE LFID
         MVC   EVNTSUBR,LTRENAME  SAVE READ SUBROUTINE NAME
         MVC   EVNTREAD,LTREADDR  SAVE READ SUBROUTINE ADDR
         MVC   GP_PF_count,ltrePFcnt SAVE PF count for this LF
***********************************************************************
*  INITIALIZE EVENT FILE DCB                                          *
***********************************************************************
         llgt  R11,EVNTDCBA        LOAD DCB  ADDRESS
         USING IHADCB,R11
         MVC   DCBDDNAM,GPDDNAME  UPDATE DDNAME  IN    DCB
*
         llgt  r11,dcbdcbe
         using dcbe,r11
         LARL  R14,EVNTEOF        SET END-OF-FILE  EXIT  ADDRESS
         oilh  r14,x'8000'
         ST    R14,DCBeEODA
         LArl  R14,SYNADEX0       SET    I/O ERROR    EXIT  ADDRESS
         oilh  r14,x'8000'
         ST    R14,DCBeSYNA
*
         DROP  R11
*
***********************************************************************
*  DYNAMICALLY ALLOCATE EVENT FILE IF DATASET NAME PROVIDED           *
***********************************************************************
         LH    R0,LTFILTYP        LOAD  FILE   TYPE
         if Cij,R0,ne,PIPEDEV     Not a pipe ??

           LH  R0,LTACCMTH        LOAD  ACCESS METHOD ID
           if Cij,R0,ne,DB2SQL,and,     Not DB2   EVENT  FILE  ???     +
               Cij,R0,ne,MSGQUEUE,andif, and not MQI   EVENT  FILE  ???+
               CLC,LTDSNAME,ne,SPACES    Data set NAME"  AVAILABLE  ???
             LARL R15,DYNALLOC    DYNAMICALLY ALLOCATE DATASET (IF NOT)
             BASR R14,R15
           endif
         endif
                        EJECT
***********************************************************************
*  CALL ASSOCIATED I/O DRIVER TO OPEN EVENT FILE                      *
***********************************************************************
         LH    R0,LTACCMTH        LOAD  ACCESS METHOD ID
*
         select cij,r0,eq
           when   SEQFILE         Sequential file ?
             llgf R15,GVBMRBS

           when   KSDSFILE        VSAM  KSDS   FILE  ???
             llgf R15,GVBMRVK

           when   DB2SQL          DB2   EVENT  FILE  ???
             llgf R15,MRSQADDR
             if ltr,r15,r15,z     Not available
               LHI r14,DB2_SQL_UNAVAILABLE
               LHI R15,8
               JZ ERRMSG#
             endif

           when   DB2VSAM         DB2 via VSAM?
             llgf R15,MRDVADDR
             if ltr,r15,r15,z     Not available
               LHI r14,DB2_VSAM_UNAVAILABLE
               LHI R15,8
               JZ ERRMSG#
             endif

           othrwise
             LHI r14,IO_DRIVER_UNAVAILABLE
             MVC  ERRDATA(8),GPDDNAME
             LHI R15,8
             JZ ERRMSG#
         endsel
*
         LA    R0,LTREPARM        POINT  TO READ EXIT PARAMETERS
         sty   R0,GPSTARTA
*
         bassm R14,R15            CALL  I/O   SUBROUTINE (INITIALIZE)
*
         ltgr  R14,R15            SUCCESSFUL  ???
         JNZ   THRDMSG            NO, end thread
                        EJECT
***********************************************************************
*  LOAD "NV" ROW ADDRESS FOR USER EXIT INITIALIZATION                 *
***********************************************************************
CALLEXIT ds    0h
         if cli,GPRECFMT,eq,x'00',or,cli,GPRECFMT,eq,c' '
           llgf  r11,evntdcba        load dcb  address
           using ihadcb,r11
           mvi   GPRECFMT,c'F'       set recfm to Fixed (default
           if    tm,dcbrecfm,dcbrecv,o  If recfm is Variable
             mvi GPRECFMT,c'V'          signal this
           endif
           drop  r11
         endif
         if    cgij,r8,ne,0
               mvc ltrerecl,GPRECLEN  save for final reports
         endif
         llgt  R8,THRDES
         llgt  r2,lteslpad        load the literal pool address
         llgt  R5,LTFRSTNV        START WITH FIRST "NV" IN "ES" SET
         DROP R8
es_r8    using logictbl,r8                                       pgc100
         USING LOGICTBL,R5
*
callexit_lp ds 0h
         agfi  r2,f512k           literal pool base now in middle
         do    inf                loop thru all the logic text
           doexit  clc,ltfunc,eq,es,or,             End of set??       +
               clc,ltfunc,eq,et         or end of token?? - split
*
           if   clc,ltmajfun,eq,wr               is this a write - note+
                            testing ltmajfun only
*
             if CLC,LTWRNAME,NE,SPACES EXIT    SPECIFIED   ???
               MVC ERRDATA(8),LTWRNAME SAVE    EXIT  NAME
*
               LA R0,LTWRPARM     POINT  TO WRITE    PARAMETERS
               sty R0,GPSTARTA
               lgf R1,LTWREXTO      LOAD  "LTWRAREA"   OFFSET
               agr R1,R2
               using ltwrarea,r1
               LA R0,LTWRWORK     LOAD EXIT   WRITE ANCHOR
               sty R0,GPWORKA
*
               mvc gp_error_buffer_len,=a(l'error_buffer) set max len
               xc gp_error_reason,gp_error_reason     clear reason
               lay R1,PARM_AREA
               llgf R15,LTWRADDR     LOAD  EXIT ADDRESS
               BASsm R14,R15       CALL  EXIT WITH INITIALIZE OPTION
               lgf R15,RETNCODE
*
               if (oc,gp_error_reason,gp_error_reason,nz) is the       +
                                           code non zero ==> text
                 lgr r9,r15               save r15
                 l r15,gp_error_buffer_len get length of text
                 sthy r15,error_bufl        and save in prefix
                 lay r3,error_bufl
                 WTO TEXT=(3),MF=(E,WTOPARM)
                 l r15,gp_error_buffer_len get length of text
                 ahi   r15,4
                 sthy  r15,error_bufl
                 ENQ   (GENEVA,LOGNAME,E,,STEP),RNL=NO
                 logit msg=error_bufl
                 DEQ   (GENEVA,LOGNAME,,STEP),RNL=NO
                 lgr   r15,r9              restore r15
               endif
               if cij,r15,gt,8    higher than 8 is bad
*
                 if cij,r15,eq,12 ==> disable view
                   BRAS R9,DISABREQ DISABLE VIEW
                 else
                   j abortex      must be more than 12, crash and burn
                 endif
               endif
             endif
*
           else
***********************************************************************
*    CALL LOOK-UP EXITS WITH INITIALIZE (OP) FUNCTION CODE            *
***********************************************************************
*
             do ,
               doexit (clc,ltfunc,ne,=c'LUEX') exit if NOT lookup exit
               lgf R14,ltluboff     POINT TO LOOK-UP BUFFER
               llgt r14,0(r14,r2) Get the address
               if cgij,r14,gt,0   positive?
                 push using
                 using lkupbufr,r14
*
                 if (TM,LBFLAGS,LBINIT,z) Not initialized ?
                   OI LBFLAGS,LBINIT  mark it as initialized
*
                   MVC ERRDATA(8),LBSUBNAM EXIT NAME
*
                   lay r15,PARM_AREA
                   MVC LBPARML(LBPRMLEN),0(r15)   COPY TEMPLATE
*
                   LA R0,LBSTRTUP      Start up parameters
                   ST R0,LBSTARTA
                   ly R0,GPEXTRA             EXTRACT   RECORD ADDRESS
                   ST R0,LBEXTRA
                   LA R0,LBSUBWRK            WORK AREA ANCHOR
                   ST R0,LBANCHA
                   LA R0,LBLSTRC             RETURN    CODE
                   ST R0,LBRTNCA
                   LA R0,LBLSTFND            RESULT    POINTER
                   ST R0,LBRPTRA
                   LA R0,LBEVENTA            Record address
                   ST R0,LBRECA
*
                   mvc gp_error_buffer_len,=a(l'error_buffer) set max
                   xc gp_error_reason,gp_error_reason     clear reason
                   LA R1,LBPARML             LOAD PARAMETER LIST ADDR
                   llgf R15,LBSUBADR            LOOK-UP   EXIT ADDRESS
                   BASsm R14,R15   CALL  EXIT WITH INITIALIZE OPTION
                   lgf R14,ltluboff Reload R14 with correct pointer
                   llgt r14,0(r14,r2) Get the address
                   lgf R15,LBLSTRC            load return code
*
***********************************************************************
*          DISPLAY ERROR MESSAGE IF REQUESTED                         *
***********************************************************************
                   if (oc,gp_error_reason,gp_error_reason,nz)          +
                                      is the code non zero ==> text
                     lgr r9,r15             save r15
                     l r15,gp_error_buffer_len get length of text
                     sthy r15,error_bufl    and save in prefix
                     lay r3,error_bufl
                     WTO TEXT=(3),MF=(E,WTOPARM)
                     l r15,gp_error_buffer_len get length of text
                     ahi   r15,4
                     sthy  r15,error_bufl
                     ENQ   (GENEVA,LOGNAME,E,,STEP),RNL=NO
                     logit msg=error_bufl
                     DEQ   (GENEVA,LOGNAME,,STEP),RNL=NO
                     lgr r15,r9             restore r15
                   endif
                   if cgij,r15,gt,8 higher than 8 is bad
*
                     if cgij,r15,eq,12 ==> disable view
                       BRAS R9,DISABREQ DISABLE VIEW
                     else
                       j abortex  must be more than 12, crash and burn
                     endif
                   endif
*
                 endif
                 pop using
               endif
             enddo
           endif
*
           agh R5,LTrowlen  LOOP THROUGH logic table
         enddo
         llgt  r5,es_r8.ltfrstre Get 1st RE from this ES/ET set  pgc102
         ltgf  r5,ltnxrtkn      Is there a RETK?                 pgc102
         jz    callexit_fin     N: then finished CALLEXIT        pgc102
         llgt  r2,thrdlitp      Get ES set lit pool addr.        pgc102
         llgt  r8,ltrees        Get the ET for this RETK/RETX    pgc102
         lgf   r15,ltreindx     Get its index                    pgc102
         mghi  r15,8            get correct offset for litpool   pgc102
         aghi  r15,litphdrl     allow for the header             pgc102
         lgf   r15,0(r15,r2)    get lit pool offset value        pgc102
         agr   r2,r15           point at correct lit pool        pgc102
         j     callexit_lp      go process this RETk/ET set      pgc102
callexit_fin ds 0h                                               pgc102

         DROP  R5,r1
         USING LOGICTBL,R8
                        EJECT
***********************************************************************
*  PROCESS THE EVENT FILE HEADER DEPENDING ON THE OPTION SPECIFIED    *
***********************************************************************
RDPHASE  MVC   ERRDATA,spaces     CLEAR EXIT  NAME (IF ANY)
*
         MVC   gpphase,RD         INDICATE READ PHASE
         XC    gpview#,gpview#    ZERO CURRENTLY EXECUTING VIEW
*

         LARL  R10,EVNTCODE        ASSUME  FIRST RECORD IGNORED
         stg   r6,prevreca        and update the workarea pointer
*
         ltgf  R8,THRDRE          READ    EVENT AVAILABLE ???
         JNP   ProcRec            EXECUTE  MACH CODE W/O READ
*
         cgijnh r6,0,evnteof      FIRST RECORD AVAILABLE  (END-OF-FILE)+
                                  NO  - EMPTY  FILE
*
         LArl  R10,evntcode       ASSUME FIRST RECORD IGNORED      @05I
*                                                                  @05I
         LH    R0,LTHDROPT        LOAD  HEADER RECORD VERIFICATION OPT
*
         CHI   R0,NOHDR           HEADER PROCESSING OPTION = "NO"  ???
         JE    ProcRec            YES - BYPASS READ
*
         larl  R10,EVNTLOOP        IGNORE FIRST RECORD
*
         agsi  GPRECCNT,bin1       INCREMENT  RECORD COUNT
*
         CHI   R0,SKIPHDR         HEADER PROCESSING OPTION = "SKIP" ??
         JE    ProcRec            YES - BYPASS PROCESSING
                        SPACE 3
***********************************************************************
*  DOES EVENT FILE HEADER RECORD VERSION NUMBER MATCH CONTROL NUMBER  *
***********************************************************************
         CLC   13+5(3,R6),LTVERNO
         JNE   VerError           CONTINUE IF MATCHING VERSION NUM
*
ProcRec  dc    0h                   Process Record
         if (ltgf,r15,workazip,nz)    zIIP function available?
           la     r1,SRB_sched      Schedule SRB and process record
           bassm r14,r15            Call zIIP module
         else
           BR  R10                  Go process record (call Machcode)
         endif
*
         DROP  R8
*
* Source/event file header record version error
*
VerError dc    0h                   Version Error
         GVBMSG LOG,MSGNO=SOURCE_VERSION_ERROR,SUBNO=1,GENENV=GENENV,  +
               SUB1=(PGMNAME,L'PGMNAME),                               +
               MSGBUFFER=(PRNTBUFF,L'PRNTBUFF),                        +
               MF=(E,MSG_AREA)
*        bras  r9,errformat
*        MVI   PRNTCC,C'1'        NEW   PAGE
*        ENQ   (GENEVA,LOGNAME,E,,STEP),RNL=NO
*        logit
*        DEQ   (GENEVA,LOGNAME,,STEP),RNL=NO
*
         j     Return_err
*
PE_Error dc    0h                   Version Error
         GVBMSG LOG,MSGNO=PE_FAIL,SUBNO=3,GENENV=GENENV,               +
               SUB1=(PGMNAME,L'PGMNAME),                               +
               SUB2=(DBLWORK,L'DBLWORK),                               +
               SUB3=(DBLWORK2,4),                                      +
               MSGBUFFER=(PRNTBUFF,L'PRNTBUFF),                        +
               MF=(E,MSG_AREA)
*
         LA    R15,16             Return code 16 (serious)
         j     thrdmsg            End thread
                        EJECT
static   loctr ,
evntprev j     evntpreva          Go to the real code
code     loctr ,
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*                                                                     *
*  1. PROCESS THE NEXT DETAIL EVENT RECORD (DRIVER FILE)              *
*  2. EXECUTE THE GENERATED MACHINE CODE   (VIEWS) FOR  THIS FILE     *
*                                                                     *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
Evntpreva stg   r6,PREVRECA        SAVE PREVIOUS RECORD ADDRESS
*
EVNTLOOP ds    0h
*
         push using
         llgt  R2,EVNTDCBA        LOAD CURRENT   DCB    ADDRESS
         USING IHADCB,R2
*
         agf   R6,GPRECLEN        ADVANCE  TO NEXT RECORD
         cg    R6,EODADDR         LAST RECORD IN   BUFFER ???
         JNL   EVNTBUFR           YES - READ THE NEXT BLOCK
*
         TM    DCBRECFM,X'80'     FIXED/UNDEFINED LENGTH ???
         JO    evntcode           YES - BYPASS ADJUSTMENT          @05C
         LLH   R0,0(,R6)          SAVE  CURRENT RECORD LENGTH
         AHI   R0,-4
         ST    R0,GPRECLEN
         AHI   R6,4               ADVANCE BEYOND VARIABLE LENGTH RDW
         J     evntcode                                            @05C
*
***********************************************************************
*  SWITCH TO "TCB" MODE IF ZIIP ENABLED                               *
***********************************************************************
EVNTBUFR DS    0H
         USING LOGICTBL,R14
         if (ltgf,r15,workazip,nz),and,  zIIP function available?      +
               (cli,thread_mode,eq,C'S')        and we are in SRB mode
           if  (ltgf,r14,thrdre,p),and,         and Re ptr OK?         +
               (tm,ltflag2,ltnomode,z),and,     and nomode flag off?   +
               (cli,gp_call_srb,ne,c'Y')        i/o not srb savvy?

*            bras R14,tcbswich RESUME EXECUTION  IN "TCB" MODE

             la     r1,TCB_switch     Switch to TCB mode
             bassm r14,r15            Call zIIP module
           endif
         endif
         DROP  R14
***WARNING***WARNING!!!!****DANGER**Will Robinson**DANGER!!!!*********
* EVNTREAD (part of GVBMRBS) assumes that r2 is the DCB pointer.
* It also uses multiple registers without saving, so tread carefully
********************************************************************
         do ,
           sgr R7,R7              NO CURRENT EXTRACT RECORD
           llgf R15,EVNTREAD       LOAD  READ ROUTINE ADDRESS
           BASSM R14,R15          FILL  NEXT BUFFER
           if (ltgf,r15,workazip,nz),and, zIIP function available?     +
               (cli,GP_redrive,eq,c'Y')   routine is asking for switch
             la    r1,TCB_switch      Switch to TCB mode
             bassm r14,r15            Call zIIP module
             iterate ,            and redrive the i/o
           endif
         enddo
*
***********************************************************************
*  SWITCH TO "SRB" MODE IF ZIIP ENABLED                               *
***********************************************************************
         if (ltgf,r15,workazip,nz),and,  zIIP function available?      +
               (cli,thread_mode,eq,C'P')        and we are in TCB mode
           la    r1,SRB_switch      Switch to SRB mode
           bassm r14,r15            Call zIIP module
*          bras  r14,srbswich      CONTINUE WITH GENERATED MACH CODE
         endif
*
         pop   using
*
EVNTCODE STG   R6,RECADDR         Save next Event Record's address
         LAY   R0,RECADDR         Load address of that location
         STY   R0,GPEVENTA        Save pointer in parameter list
         cgijnh  r6,0,evntnorec   no event record (reference phase)
         agsi  GPRECCNT,bin1       INCREMENT  TRANSACTION RECORD COUNT
evntnorec equ *
*
         llgt  R7,GPEXTRA         LOAD   EXTRACT RECORD BASE REGISTER
         USING EXTREC,R7
         llgt  r8,THRDES          Get the ES pointer
         using logictbl,r8          and map it
         LLGT  R2,THRDLITP            reload r2 here
         agfi  r2,f512k           literal pool base now in middle
         llgt  R15,LTESCODE
         BR    R15                PASS  CONTROL TO  CODE (31-BIT MODE)
         drop  r8
                        EJECT
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*                                                                     *
*        I N D E X E D   T A B L E   L O O K U P                      *
*                                                                     *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*
         USING LKUPBUFR,R5
*
static   loctr ,
indextbl j     indextbla          Go to the real code
code     loctr ,
INDEXTBLa ltgf  R15,0(,R14)        INDEX VALUE  TOO   SMALL ???
         JNP   SRCHNOT            YES - RETURN NOT   FOUND
*
         cgf   R15,LBRECCNT       INDEX VALUE  TOO   LARGE ???
         JH    SRCHNOT            YES - RETURN NOT   FOUND
         bctgr R15,0              CONVERT   TO OFFSET
*
         lgh   R14,LBRECLEN       LOAD LOOK-UP TABLE ENTRY LENGTH
         aghi  R14,LKPREFLN       ADD  PREFIX  LENGTH
         MR    R14,R14            COMPUTE LOOKUP TABLE OFFSET
         LG    R4,LBTBLBEG(r15)   LOAD    LOOKUP TABLE BASE   ADDRESS  +
                                  plus    LOOKUP TABLE OFFSET
*
*        LH    R9,LBRECLEN
*        AR    R9,R4
*          ly  r2,SNAPDCBA
*        SNAP  DCB=(r2),PDATA=(REGS),ID=100,STORAGE=((R4),(R9))
         J     SRCHFND            INDICATE FOUND
*
         USING LKUPTBL,R4
SRCHNOT  ds    0h
         agsi  lbnotcnt,bin1       INCREMENT   COUNT
*
         lghi  R0,-1              SET TABLE ENTRY ADDRESS  TO HIGH VAL
         STG   R0,LBLSTFND        SAVE ADDRESS (-1)
*
         if ltgf,r14,LBPARENT,p   LOAD PARENT JOIN LOOK-UP BUFFER ADDR
           STG R0,LBLSTFND-LKUPBUFR(,R14)  store if positive
         endif
*
         BR    R10                RETURN TO NOT FOUND ADDRESS
*
SRCHFND  LA    R14,LKUPDATA       LOAD ADDRESS  OF DATA
         stg   R14,LBLSTFND       SAVE ADDRESS  IN BUFFER PREFI
*
         agsi  lbfndcnt,bin1       INCREMENT   COUNT
         b     l'mc_jump(,r10)    RETURN  TO  FOUND ADDRESS
         DROP  R5,r4
                        EJECT
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*                                                                     *
*        N O R M A L I Z E   Date for CFxx functions                  *
*                                                                     *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*
         USING LOGICTBL,R5
*
static   loctr ,
dateNorm_indirect j dateNorm
code     loctr ,
dateNorm DS    0h
*   Date pointer to by R15
         STG   R15,SAVALADR
         XC    SAMSKADR,SAMSKADR  ZERO  MASK     ADDRESS
         XC    SAMSKLEN,SAMSKLEN  ZERO  MASK     LENGTH
*
         LHI   R0,FC_ALNUM        SET   EDITED   FORMAT    CODE
         STH   R0,SAOUTFMT
         LHI   R0,NORMDATE        SET DATE FORMAT TO CCYYMMDD
         STH   R0,SAOUTCON
         MVHHI SAOUTDEC,0         SET   EDITED   DECIMALS
         MVHHI SAOUTRND,0         SET   EDITED   ROUNDING  FACTOR
         MVI   SAOUTSGN,C'N'      SET   EDITED   SIGN  IND
         MVI   SAOUTJUS,C'L'      SET   JUSTIFICATION CODE
*
         LH    R0,LTFLDLEN        LOAD  DATE-1 LENGTH   (-1)
         AHI   R0,1               RESTORE TRUE FIELD    LENGTH
         STH   R0,SAVALLEN
*
         MVC   SAVALFMT,LTFLDFMT  COPY  FIELD    FORMAT    CODE
         MVC   SAVALCON,LTFLDCON  COPY  FIELD    CONTENT   CODE
         MVC   SAVALDEC+1(1),LTNDEC  COPY  NO.   OF DECIMALS
         MVC   SAVALRND+1(1),LTRNDFAC  COPY  ROUNDING FACTOR
         MVC   SAVALSGN,LTSIGN    COPY  SIGN     INDICATOR
*
*        lgh   r15,ltfldcon       get the content code
*        la    r1,datemask1          and where to save mask
*   ??   bras  r14,build_mask     create mask for later ? what is this?

         LA    R0,workarea        LOAD area for normalized date
         ST    R0,DL96TGTA        SAVE TARGET  ADDRESS
*
         LHI   R15,NORMDATE_l     LOAD  NORMALIZED DATE  LENGTH
         STH   R15,DL96LEN        PASS  EDITED  SIZE TO "GVBDL96"
*
         llgf  R15,GVBDL96a       LOAD "GVBDL96"  ADDRESS
         oill  r15,x'0001'        set amode 64 in link address
         LA    R1,DL96LIST        POINT R1   AT PARAMETER LIST
         bassm R14,R15            CALL "GVBDL96" - FORMAT DATA
*
         if clij,R15,ne,0         UnSUCCESSFUL ???
           LA  R0,B               Indicate bad data
           J   CALL96E
         endif
         br    r10                and return to compare in model code
*
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*                                                                     *
*        N O R M A L I Z E   A N D   C O M P A R E   D A T E S        *
*                                                                     *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*
         USING LOGICTBL,R5
*
static   loctr ,
datecmp0_indirect j datecmp0
code     loctr ,
DATECMP0 stg   R1,SAVALADR        STORE DATE-2   ADDRESS  (ACCUM)
         lgr   R3,R0              SAVE  DATE-1   ADDRESS  (LOOK-UP)
         J     DATECOMP
*
static   loctr ,
datecmp1_indirect j datecmp1
code     loctr ,
DATECMP1 stg   R0,SAVALADR        STORE DATE-1   ADDRESS
         lgr   R3,R1              SAVE  DATE-2   ADDRESS
*
DATECOMP XC    SAMSKADR,SAMSKADR  ZERO  MASK     ADDRESS
         XC    SAMSKLEN,SAMSKLEN  ZERO  MASK     LENGTH
*
         LHI   R0,FC_ALNUM        SET   EDITED   FORMAT    CODE
         STH   R0,SAOUTFMT
         LHI   R0,CYMD            SET   EDITED   CONTENT   CODE
         STH   R0,SAOUTCON
         MVHHI SAOUTDEC,0         SET   EDITED   DECIMALS
         MVHHI SAOUTRND,0         SET   EDITED   ROUNDING  FACTOR
         MVI   SAOUTSGN,C'N'      SET   EDITED   SIGN  IND
         MVI   SAOUTJUS,C'L'      SET   JUSTIFICATION CODE
*
***********************************************************************
*  NORMALIZE DATE 1                                                   *
***********************************************************************
         LH    R0,LTFLDLEN        LOAD  DATE-1 LENGTH   (-1)
         AHI   R0,1               RESTORE TRUE FIELD    LENGTH
         STH   R0,SAVALLEN
*
         MVC   SAVALFMT,LTFLDFMT  COPY  FIELD    FORMAT    CODE
         MVC   SAVALCON,LTFLDCON  COPY  FIELD    CONTENT   CODE
         MVC   SAVALDEC+1(1),LTNDEC   COPY  NO.   OF DECIMALS
         MVC   SAVALRND+1(1),LTRNDFAC COPY  ROUNDING FACTOR
         MVC   SAVALSGN,LTSIGN    COPY  SIGN     INDICATOR
*
         lgh   r15,ltfldcon       get the content code
         la    r1,datemask1          and where to save mask
         bras  r14,build_mask     create mask for later

         LA    R0,date1           LOAD DATE-1  ADDRESS
         ST    R0,DL96TGTA        SAVE TARGET  ADDRESS
*
         LHI   R15,l'date1        LOAD  NORMALIZED DATE  LENGTH
         STH   R15,DL96LEN        PASS  EDITED  SIZE TO "GVBDL96"
*
         llgf  R15,GVBDL96a       LOAD "GVBDL96"  ADDRESS
         oill  r15,x'0001'        set amode 64 in link address
         LA    R1,DL96LIST        POINT R1   AT PARAMETER LIST
         bassm R14,R15            CALL "GVBDL96" - FORMAT DATA
*
         if clij,R15,ne,0         UnSUCCESSFUL ???
           LA  R0,B               Indicate bad data
           J   CALL96E
         endif
*
***********************************************************************
*  NORMALIZE DATE 2                                                   *
***********************************************************************
         stg   R3,SAVALADR        SAVE  DATE-2   ADDRESS
*
         LH    R0,LTCOLLEN        LOAD  DATE-2   LENGTH  (-1)
         AHI   R0,1               RESTORE TRUE   FIELD   LENGTH
         STH   R0,SAVALLEN
*
         MVC   SAVALFMT,LTCOLFMT  COPY  FIELD    FORMAT    CODE
         MVC   SAVALCON,LTCOLCON  COPY  FIELD    CONTENT   CODE
         MVC   SAVALDEC+1(1),LTCOLDEC  COPY  NO.   OF DECIMALS
         MVC   SAVALRND+1(1),LTCOLRND  COPY  ROUNDING FACTOR
         MVC   SAVALSGN,LTCOLSGN  COPY  SIGN     INDICATOR
*
         lgh   r15,ltcolcon        get the content code
         la    r1,datemask2          and where to save mask
         bras  r14,build_mask     create mask for later

         LA    R0,date2           LOAD  DATE-2  ADDRESS
         ST    R0,DL96TGTA        SAVE  TARGET  ADDRESS
*
         LHI   R15,l'date2        LOAD  NORMALIZED DATE  LENGTH
         STH   R15,DL96LEN        PASS  EDITED  SIZE TO "GVBDL96"
*
         llgf  R15,GVBDL96a       LOAD "GVBDL96"  ADDRESS
         oill  r15,x'0001'        set amode 64 in link address
         LA    R1,DL96LIST        POINT R1   AT PARAMETER LIST
         bassm R14,R15            CALL "GVBDL96" - FORMAT DATA
*
         if clij,R15,ne,0         UnSUCCESSFUL ???
           LA  R0,B               Indicate bad data
           J   CALL96E
         endif
*
***********************************************************************
*  COMPARE NORMALIZED DATES                                           *
***********************************************************************
         nc    datemask1,datemask2  logically AND the two masks
         nc    date1,datemask1      mask out date1
         nc    date2,datemask1               date2
         br    r10                and return to compare in model code
*
* code relies on these four fields having the same length
date1     equ  lkupkey+0,8
date2     equ  lkupkey+8,8
datemask1 equ  lkupkey+16,8
datemask2 equ  lkupkey+24,8
*
build_mask ds  0h
*        r15   is the content code
*        r1    -> output mask area
*        r14   return address
         bctgr r15,0              reduce content code by 1
         mghi  r15,concode_l      multiply by length
         llgt  r0,concode_table
         agr   r15,r0             add base
         using concode,r15        and map the table
         using mask,r1

         if    clc,codecc,ne,=x'FFFF' is the century valid?
           mvc   maskcc,=x'0F0F'    valid mask  - the mask being built +
                                    removes any zones
         else
           xc    maskcc,maskcc      make the mask zero
         endif

         if    clc,codeyy,ne,=x'FFFF' is the year valid?
           mvc   maskyy,=x'0F0F'    valid mask
         else
           xc    maskyy,maskyy      make the mask zero
         endif

         if    clc,codemm,ne,=x'FFFF',or,  is the month valid?         +
               clc,codeddd,ne,=x'FFFF'      julian date?
           mvc   maskmm,=x'0F0F'    valid mask
         else
           xc    maskmm,maskmm      make the mask zero
         endif

         if    clc,codedd,ne,=x'FFFF',or, is the date valid?           +
               clc,codeddd,ne,=x'FFFF'      julian date?
           mvc   maskdd,=x'0F0F'    valid mask
         else
           xc    maskdd,maskdd      make the mask zero
         endif

         br    r14
         drop  r1,r15
mask     dsect
maskcc   ds    xl2
maskyy   ds    xl2
maskmm   ds    xl2
maskdd   ds    xl2
*
*        mapping of concode table in gvbdl96
*        series of halfwords - if the value is -1, data is invalid
concode  dsect
codecc   ds    h
codeyy   ds    h
codemm   ds    h
codedd   ds    h
codeddd  ds    h
         ds   5h                  5 entries (not used here)
concode_l equ *-concode           length of each entry in GVBDL96
gvbmr95  csect
static   loctr
concode_table dc v(consrcmp)      Pointer to table in GVBDL96
code     loctr
         DROP  R5
                        EJECT
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*                                                                     *
*        F O R M A T   F I E L D   F O R   O U T P U T                *
*                                                                     *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*
         USING LOGICTBL,R5
*
***********************************************************************
*  Prior Column (extract record)                                     *
***********************************************************************
static   loctr
call96ax_indirect  j call96ax_real
code     loctr
CALL96Ax_real  ds   0h
         l     r15,ltcolfil       Get the area type for prior column

         xgr   r14,r14            clear (just in csse)

         select cij,r15,eq    test value in r15

           when 1             - sort key offset

             lghi R14,EXSRTKEY-EXTREC+1 (to account for the offset)

           when 2             - sort key title (ignored)

           when 3             - DT area

             llgt R15,LTlognv
             lgh  R14,LTSORTLN-LOGICTBL(,R15)
             ah   R14,LTTITLLN-LOGICTBL(,R15)
             aghi R14,EXSRTKEY-EXTREC+1 (to account for the offset)

           when 4             - CT area (to be done)

             llgt R15,LTlognv
             lgh  R14,LTSORTLN-LOGICTBL(,R15)
             ah   R14,LTTITLLN-LOGICTBL(,R15)
             ah   R14,LTdataLN-LOGICTBL(,R15)
             aghi R14,EXSRTKEY-EXTREC+1 (to account for the offset)

         endsel
         agr r14,r7
         J     CALL96AC
***********************************************************************
*  PREVIOUS RECORD SOURCE FIELDS                                      *
***********************************************************************
static   loctr
call96ap_indirect  j call96ap_real
code     loctr
CALL96AP_real  lg R14,PREVRECA          LOAD PREVIOUS RECRD ADDRESS
         J     CALL96AC
*
***********************************************************************
*  LOOK-UP RECORD SOURCE FIELDS                                       *
***********************************************************************
static   loctr
call96al_indirect  j call96al_real
code     loctr
CALL96AL_real lgf   R14,LTLUBOFF           LOAD BUFFER  PREFIX ADDRESS
         llgt r14,0(r14,r2) Get the address
         lg   R14,LBLSTFND-LKUPBUFR(,R14) LOAD LOOK-UP RECORD ADDRESS
         J     CALL96AC
*
static   loctr
call96at_indirect  j     call96at_real
code     loctr
CALL96AT_real lgr   R14,R6        LOAD TRAN    RECORD   ADDRESS
*
CALL96AC ST    R1,DL96TGTA        SAVE TARGET  ADDRESS
*
         agh   R14,LTCOLPOS       ADD  OFFSET  TO BASE  ADDRESS
         stg   R14,SAVALADR
*
         LH    R0,LTCOLLEN        LOAD   FIELD LENGTH   (-1)
         AHI   R0,1               RESTORE TRUE FIELD    LENGTH
         STH   R0,SAVALLEN
*
         MVC   SAVALFMT,LTCOLFMT  COPY  FIELD    FORMAT    CODE
         MVC   SAVALCON,LTCOLCON  COPY  FIELD    CONTENT   CODE
         MVC   SAVALDEC+1(1),LTCOLDEC  COPY  NO.   OF DECIMALS
         MVC   SAVALRND+1(1),LTCOLRND  COPY  ROUNDING FACTOR
         MVC   SAVALSGN,LTCOLSGN  COPY  SIGN     INDICATOR
*
         XC    SAMSKADR,SAMSKADR  ZERO  FIELD    MASK   ADDRESS
         XC    SAMSKLEN,SAMSKLEN  ZERO  FIELD    MASK   LENGTH
*
         LH    R15,LTFLDLEN       LOAD  EDITED  COLUMN   WIDTH
         AHI   R15,1              RESTORE TRUE  COLUMN  LENGTH
         STH   R15,DL96LEN        PASS  EDITED  SIZE TO "GVBDL96"
*
         MVC   SAOUTFMT,LTFLDFMT  SET   EDITED   FORMAT    CODE
         MVC   SAOUTCON,LTFLDCON  SET   EDITED   CONTENT   CODE
         MVC   SAOUTDEC+1(1),LTNDEC   SET   EDITED   DECIMALS
         MVC   SAOUTRND+1(1),LTRNDFAC SET   EDITED   ROUNDING  FACT
         MVC   SAOUTSGN,LTSIGN    SET   EDITED   SIGN  IND
*
         MVI   SAOUTJUS,C'L'      SET   JUSTIFICATION CODE
         CLI   SAOUTFMT+1,FC_ALNUM      ALPHANUMERIC  ???
         JE    CALL96PG
         MVI   SAOUTJUS,C'R'      SET   JUSTIFICATION CODE
*
         J     CALL96PG
*
***********************************************************************
*  ACCUMULATOR                                                        *
***********************************************************************
static   loctr
call96a_indirect  j     call96a
code     loctr
call96a  llgt  R14,LTAC2ADR                LOAD ACCUMULATOR    ADDRESS
map_dim  using logictbl,r14
         lgf   r14,map_dim.ltvnlitp        get accumulator offset
         agr   r14,r2                      and add literal base
         drop  map_dim
         J     CALL96
*
*
static   loctr
call96x_indirect  j     call96x_real
code     loctr
call96x_real   ds 0h
         l     r15,ltfldfil       Get the area type for prior column


         xgr   r14,r14            clear (just in csse)

         select cij,r15,eq    test value in r15

           when 1             - sort key offset

             lghi R14,EXSRTKEY-EXTREC+1 (to account for the offset)

           when 2             - sort key title (ignored)

           when 3             - DT area

             llgt R15,LTlognv
             lgh  R14,LTSORTLN-LOGICTBL(,R15)
             ah   R14,LTTITLLN-LOGICTBL(,R15)
             aghi R14,EXSRTKEY-EXTREC+1 (to account for the offset)

           when 4             - CT area (to be done)

             llgt R15,LTlognv
             lgh  R14,LTSORTLN-LOGICTBL(,R15)
             ah   R14,LTTITLLN-LOGICTBL(,R15)
             ah   R14,LTdataLN-LOGICTBL(,R15)
             aghi R14,EXSRTKEY-EXTREC+1 (to account for the offset)

         endsel
         agr r14,r7
*
         J     CALL96
*
***********************************************************************
*  LOOK-UP RECORD SOURCE FIELDS                                       *
***********************************************************************
static   loctr
call96p_indirect  j     call96p_real
code     loctr
call96p_real   lg R14,prevreca          load previous
*
         J     CALL96
*
static   loctr
call96l_indirect  j     call96l_real
code     loctr
call96l_real lgf   R14,LTLUBOFF           LOAD BUFFER  PREFIX ADDRESS
         llgt r14,0(r14,r2) Get the address
         lg   R14,LBLSTFND-LKUPBUFR(,R14) LOAD LOOK-UP RECORD ADDRESS
*
         J     CALL96
*
***********************************************************************
*  LOOK-UP RECORD SOURCE FIELDS                                       *
***********************************************************************
static   loctr
call96lr_indirect  j     call96lr_real
code     loctr
call96lr_real lgf R14,LTLUBOFF            LOAD BUFFER  PREFIX ADDRESS
         llgt r14,0(r14,r2) Get the address
         lg   R14,LBLSTFND-LKUPBUFR(,R14) LOAD LOOK-UP RECORD ADDRESS
*
         J     CALL96tr_a
*
static   loctr
call96pr_indirect  j     call96pr_real
code     loctr
call96pr_real lg R14,prevreca           LOAD previous address
         J     CALL96tr_a
*
static   loctr
call96xr_indirect  j     call96xr_real
code     loctr
call96xr_real ds 0h
         l     r15,ltcolfil       Get the area type for prior column

         xgr   r14,r14            clear (just in csse)

         select cij,r15,eq    test value in r15

           when 1             - sort key offset

             lghi R14,EXSRTKEY-EXTREC+1 (to account for the offset)

           when 2             - sort key title (ignored)

           when 3             - DT area

             llgt R15,LTlognv
             lgh  R14,LTSORTLN-LOGICTBL(,R15)
             ah   R14,LTTITLLN-LOGICTBL(,R15)
             aghi R14,EXSRTKEY-EXTREC+1 (to account for the offset)

           when 4             - CT area (to be done)

             llgt R15,LTlognv
             lgh  R14,LTSORTLN-LOGICTBL(,R15)
             ah   R14,LTTITLLN-LOGICTBL(,R15)
             ah   R14,LTdataLN-LOGICTBL(,R15)
             aghi R14,EXSRTKEY-EXTREC+1 (to account for the offset)

         endsel
         agr r14,r7
         J     CALL96tr_a
*
***********************************************************************
*  EVENT RECORD SOURCE FIELDS                                         *
***********************************************************************
static   loctr
call96tr_indirect  j     call96tr_real
code     loctr
* this entry into DL96 is the same as 96T except
* that the code here reverses the use of LTFLDxxx and LTCOLxxx
call96tr_real lgr   R14,R6       LOAD TRAN    RECORD ADDRESS
call96tr_a ST R1,DL96TGTA   SAVE TARGET  ADDRESS
*
         agh   R14,ltcolpos       ADD  OFFSET  TO BASE  ADDRESS
         stg   R14,SAVALADR
*
         LH    R0,LTcolLEN        LOAD   FIELD LENGTH   (-1)
         AHI   R0,1               RESTORE TRUE FIELD    LENGTH
         STH   R0,SAVALLEN
*
         MVC   SAVALFMT,LTcolFMT  COPY  FIELD    FORMAT    CODE
         MVC   SAVALCON,LTcolCON  COPY  FIELD    CONTENT   CODE
         MVC   SAVALDEC+1(1),LTcoldec  COPY NO. OF DECIMALS
         MVC   SAVALRND+1(1),LTcolrnd  COPY  ROUNDING FACTOR
         MVC   SAVALSGN,LTcolsgn  COPY  SIGN     INDICATOR
*
         llgt  R15,LTFUNTBL       LOAD FUNCTION TABLE ADDRESS
         if CLI,FC_RTYP-FUNCTBL(R15),eq,fC_RTYP04
*
***********************************************************************
*  FORMAT 1 LOGIC TABLE FUNCTIONS                                     *
***********************************************************************
           XC  SAMSKADR,SAMSKADR  ZERO  FIELD    MASK   ADDRESS
           XC  SAMSKLEN,SAMSKLEN  ZERO  FIELD    MASK   LENGTH
*
           LH  R15,SAVALCON       SET OUTPUT  CONTENT = SOURCE CONTENT
*
           if CLC,LTMAJFUN,eq,CT        "CT"  AREA     FUNCTION  ???
*                                 YES - CONVERT  TO  GENEVA NUMBER
             STH R15,SAOUTCON     SET   OUTPUT   CONTENT
*
             LHI R15,FC_PACK      SET   EDITED   FORMAT    CODE
             STH R15,SAOUTFMT
*
             if CLI,LRGNUM,eq,C'Y'
               MVHHI SAOUTDEC,3
             else
               MVHHI SAOUTDEC,8   SET   EDITED   DECIMALS
             endif
*
             MVHHI SAOUTRND,0     ZERO  EDITED   ROUNDING  FACT
             MVI SAOUTSGN,C'Y'    SET   EDITED   SIGN  IND
             MVI SAOUTJUS,C'R'    SET   JUSTIFICATION CODE
*
             LHI R0,L'COLDATA     SET   OUTPUT   LENGTH
           elseif CLC,LTMAJFUN,eq,cf        COMPARE CONVERSION  ???
             STH R15,SAOUTCON     SET   OUTPUT   CONTENT
*
             LHI R15,FC_float     SET   EDITED   FORMAT    CODE
             STH R15,SAOUTFMT
*
             MVHHI SAOUTDEC,8
*
             MVHHI SAOUTRND,0     ZERO  EDITED   ROUNDING  FACT
             MVI SAOUTSGN,C'Y'    SET   EDITED   SIGN  IND
             MVI SAOUTJUS,C'R'    SET   JUSTIFICATION CODE
*
             LHI R0,L'fc_float    SET   OUTPUT   LENGTH
           else
*
             MVC SAOUTFMT,LTFLDFMT SET  EDITED   FORMAT    CODE
             MVC SAOUTCON,LTFLDCON SET  EDITED   CONTENT   CODE
             MVC SAOUTDEC+1(1),LTNDEC   SET EDITED DECIMALS
             MVC SAOUTRND+1(1),LTRNDFAC SET EDITED ROUNDING FACT
             MVC SAOUTSGN,LTSIGN  SET   EDITED   SIGN  IND
*
             MVI SAOUTJUS,C'L'    SET   JUSTIFICATION CODE
             if CLI,SAOUTFMT+1,ne,FC_ALNUM   not alphanumeric
               MVI SAOUTJUS,C'R'  SET   JUSTIFICATION CODE
             endif
           endif
           STH R0,DL96LEN         OUTPUT LENGTH = INPUT  LENGTH
*
         else
***********************************************************************
*  FORMAT 2 LOGIC TABLE FUNCTIONS                                     *
***********************************************************************
           LH  R15,LTfldCON       LOAD  OUTPUT CONTENT CODE
*
           if CLC,LTMAJFUN,eq,cf        COMPARE CONVERSION ???
             XC SAMSKADR,SAMSKADR ZERO  FIELD    MASK   ADDRESS
             XC SAMSKLEN,SAMSKLEN ZERO  FIELD    MASK   LENGTH
             STH R15,SAOUTCON     SET   OUTPUT   CONTENT
*
             LHI R15,FC_float     SET   EDITED   FORMAT    CODE
             STH R15,SAOUTFMT
*
             MVHHI SAOUTDEC,8
*
             MVHHI SAOUTRND,0     ZERO  EDITED   ROUNDING  FACT
             MVI SAOUTSGN,C'Y'    SET   EDITED   SIGN  IND
             MVI SAOUTJUS,C'R'    SET   JUSTIFICATION CODE
*
             LHI R0,L'fc_float    SET   OUTPUT   LENGTH
             STH R0,DL96LEN
*
           else
             LA R15,LTCOLMSK      SAVE  FIELD    MASK   ADDRESS
             ST R15,SAMSKADR
             LH R15,LTMSKLEN      SAVE  FIELD    MASK    LENGTH
             STH R15,SAMSKLEN
*
             MVC SAOUTFMT,LTFLDFMT COPY EDITED   FORMAT    CODE
             MVC SAOUTCON,LTFLDCON COPY EDITED   CONTENT   CODE
             MVC SAOUTDEC+1(1),LTNDEC   COPY  EDITED   DECIMALS
             MVC SAOUTRND+1(1),LTrndfac COPY EDITED ROUNDING  FACT
             MVC SAOUTSGN,LTsign  COPY  EDITED   SIGN  IND
             MVC SAOUTJUS,LTCOLJUS COPY JUSTIFICATION CODE
*
             LH R15,LTfldLEN      LOAD  EDITED  COLUMN   WIDTH
             EXrl R15,BLNKTGT     INITIALIZE TARGET AREA TO SPACES
             AHI R15,1            RESTORE TRUE  COLUMN  LENGTH
             STH R15,DL96LEN      PASS  EDITED  SIZE TO "GVBDL96"
           endif
*
*
         endif
         J     CALL96PG
static   loctr
call96t_indirect  j     call96t_real
code     loctr
call96t_real   lgr   R14,R6                 LOAD TRAN    RECORD ADDRESS
*
***********************************************************************
*  COMMON LOGIC FOR FORMAT 1 AND 2 LOGIC TABLE FUNCTIONS              *
***********************************************************************
static   loctr
call96_indirect j   call96
code     loctr
CALL96   ST    R1,DL96TGTA        SAVE TARGET  ADDRESS
*
         agh   R14,LTFLDPOS       ADD  OFFSET  TO BASE  ADDRESS
         stg   R14,SAVALADR
*
         LH    R0,LTFLDLEN        LOAD   FIELD LENGTH   (-1)
         AHI   R0,1               RESTORE TRUE FIELD    LENGTH
         STH   R0,SAVALLEN
*
         MVC   SAVALFMT,LTFLDFMT  COPY  FIELD    FORMAT    CODE
         MVC   SAVALCON,LTFLDCON  COPY  FIELD    CONTENT   CODE
         MVC   SAVALDEC+1(1),LTNDEC   COPY  NO.   OF DECIMALS
         MVC   SAVALRND+1(1),LTRNDFAC COPY  ROUNDING FACTOR
         MVC   SAVALSGN,LTSIGN    COPY  SIGN     INDICATOR
*
         llgt  R15,LTFUNTBL-LOGICTBL(,R5)   LOAD FUNCTION TABLE ADDRESS
         CLI   FC_RTYP-FUNCTBL(R15),FC_RTYP04
         JNE   CALL96F5
*
***********************************************************************
*  FORMAT 1 LOGIC TABLE FUNCTIONS                                     *
***********************************************************************
         XC    SAMSKADR,SAMSKADR  ZERO  FIELD    MASK   ADDRESS
         XC    SAMSKLEN,SAMSKLEN  ZERO  FIELD    MASK   LENGTH
*
         LH    R15,SAVALCON       SET OUTPUT  CONTENT = SOURCE CONTENT
*
         CLC   LTMAJFUN,CT        "CT"  AREA     FUNCTION  ???
         JE    CALL96CT
*
         CLC   LTMAJFUN,cf        COMPARE CONVERSION  ???
         JE    CALL96CE
*
         STH   R0,DL96LEN         OUTPUT LENGTH = INPUT  LENGTH
*
         MVC   SAOUTFMT,LTFLDFMT  SET   EDITED   FORMAT    CODE
         MVC   SAOUTCON,LTFLDCON  SET   EDITED   CONTENT   CODE
         MVC   SAOUTDEC+1(1),LTNDEC   SET   EDITED   DECIMALS
         MVC   SAOUTRND+1(1),LTRNDFAC SET   EDITED   ROUNDING  FACT
         MVC   SAOUTSGN,LTSIGN    SET   EDITED   SIGN  IND
*
         MVI   SAOUTJUS,C'L'      SET   JUSTIFICATION CODE
         CLI   SAOUTFMT+1,FC_ALNUM      ALPHANUMERIC  ???
         JE    CALL96pg
         MVI   SAOUTJUS,C'R'      SET   JUSTIFICATION CODE
*
         J     CALL96pg
*
***********************************************************************
*  FORMAT 2 LOGIC TABLE FUNCTIONS                                     *
***********************************************************************
CALL96F5 LH    R15,LTCOLCON       LOAD  OUTPUT CONTENT CODE
*
         CLC   LTMAJFUN,cf        COMPARE CONVERSION ???
         JE    CALL96CE           YES - CONVERT  TO  GENEVA NUMBER
*
         LA    R15,LTCOLMSK       SAVE  FIELD    MASK   ADDRESS
         ST    R15,SAMSKADR
         LH    R15,LTMSKLEN       SAVE  FIELD    MASK    LENGTH
         STH   R15,SAMSKLEN
*
         MVC   SAOUTFMT,LTCOLFMT  COPY  EDITED   FORMAT    CODE
         MVC   SAOUTCON,LTCOLCON  COPY  EDITED   CONTENT   CODE
         MVC   SAOUTDEC+1(1),LTCOLDEC  COPY EDITED  DECIMALS
         MVC   SAOUTRND+1(1),LTCOLRND  COPY EDITED  ROUNDING  FACT
         MVC   SAOUTSGN,LTCOLSGN  COPY  EDITED   SIGN  IND
         MVC   SAOUTJUS,LTCOLJUS  COPY  JUSTIFICATION CODE
*
         LH    R15,LTCOLLEN       LOAD  EDITED  COLUMN   WIDTH
         EXrl  R15,BLNKTGT        INITIALIZE TARGET AREA TO SPACES
         AHI   R15,1              RESTORE TRUE  COLUMN  LENGTH
         STH   R15,DL96LEN        PASS  EDITED  SIZE TO "GVBDL96"
*
         J     CALL96pg
*
CALL96CT STH   R15,SAOUTCON       SET   OUTPUT   CONTENT
*
         XC SAMSKADR,SAMSKADR ZERO      FIELD    MASK   ADDRESS
         XC SAMSKLEN,SAMSKLEN ZERO      FIELD    MASK   LENGTH
         LHI   R15,FC_PACK        SET   EDITED   FORMAT    CODE
         STH   R15,SAOUTFMT

*
         if clc,=C'CFLC',eq,ltfunc,or,          CFLC or                +
               clc,=C'CFEC',eq,ltfunc,andif,    CFEC and               +
               clc,ltfldfmt,eq,=y(fc_edit),or,     edit                +
               clc,ltfldfmt,eq,=y(fc_mask),orif,   mask                +
               clc,ltmajfun,eq,=c'CT'              Is CTx?
*   This code MUST match the similar code in GVBMR96 just after
*   label LTBLF1L  - the CFxC model code expects two packed numbers
*   in Geneva format
*
           MVHHI SAOUTDEC,8         this must match the code in MR96
           if cli,lrgnum,eq,c'Y'  large format numbers?
             MVHHI saoutdec,3       then set 3 dec places
           endif
*
           MVI SAOUTJUS,C'L'      SET   JUSTIFICATION CODE
         else
           MVHHI SAOUTDEC,0
           MVI SAOUTJUS,C'R'      SET   JUSTIFICATION CODE
         endif
         MVHHI   SAOUTRND,0       ZERO  EDITED   ROUNDING  FACT
         MVI   SAOUTSGN,C'Y'      SET   EDITED   SIGN  IND
*
         LHI   R0,L'COLDATA       SET   OUTPUT   LENGTH
         STH   R0,DL96LEN
*
         J     CALL96pg
*
CALL96CE STH   R15,SAOUTCON       SET   OUTPUT   CONTENT
*
         XC SAMSKADR,SAMSKADR ZERO      FIELD    MASK   ADDRESS
         XC SAMSKLEN,SAMSKLEN ZERO      FIELD    MASK   LENGTH
         LHI   R15,FC_float      SET   EDITED   FORMAT    CODE
         STH   R15,SAOUTFMT

*
*   This code MUST match the similar code in GVBMR96 just after
*   label LTBLF1L  - the CFxC model code expects two dfp numbers
*
         MVHHI SAOUTDEC,8           this must match the code in MR96
*
         MVI   SAOUTJUS,C'L'      SET   JUSTIFICATION CODE
         MVHHI SAOUTRND,0         ZERO  EDITED   ROUNDING  FACT
         MVI   SAOUTSGN,C'Y'      SET   EDITED   SIGN  IND
*
         LHI   R0,L'fc_float      SET   OUTPUT   LENGTH
         STH   R0,DL96LEN
*
         J     CALL96PG
*
         DS   0D
BLNKTGT  MVC   0(0,R1),SPACES     * * * *   E X E C U T E D   * * * *
*
         DROP  R5
                        EJECT
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*                                                                     *
*        W R I T E   E X T R A C T   F I L E   R E C O R D S          *
*                                                                     *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*
         USING LOGICTBL,R5
         USING COLEXTR,R8
*
static   loctr ,
wrtext_indirect j wrtext
code     loctr ,
WRTEXT   llgt  R9,LTWREXTA        LOAD EXTRACT FILE CONTROL ELEMENT ADR
         USING EXTFILE,R9
*
         lgr   R14,R8             SAVE CURRENT COLUMN ADDRESS
         lgf   R3,LTWREXTO        LOAD WRITE   EXTRACT AREA ADDRESS
         agr   R3,R2
         USING LTWRAREA,R3
*
*
         sgr   R8,R7              COMPUTE ACTUAL  RECORD  LENGTH
         if cgh,R8,lt,EXTMINLN    below minimum?
           lgh R8,EXTMINLN        NO  -   USE  MINIMUM
         endif
         STH   R8,EXRECLEN        SET  LENGTH  IN "RDW"
*
         lgr   r8,r7
         agf   r8,ltwr_offset_ct  point to first CT column
*
         sthh  r12,exncol
         sgr   R14,R8             COMPUTE LENGTH  OF COLUMN DATA
         jz    wrtxbypd
         SRDL  R14,32
         LHI   R0,COLDATAL        COMPUTE NUMBER  OF COLUMNS
         DR    R14,R0
         STH   R15,EXNCOL
                        EJECT
wrtxbypd ds    0h
         MVC   EXVIEW#,LTWRVIEW   COPY FLAGGED VIEW ID
*
         llgt  R1,LTLOGNV         get logic table pointer
r1logic  using logictbl,r1
         MVC   EXSORTLN(6),r1logic.LTSORTLN SORTLEN,TITLLEN,DATALEN
         drop  r1logic
*
         agsi  LTWRCNTI,bin1      INCREMENT INPUT RECORD COUNT
*
         XC    RETNCODE,RETNCODE  ZERO WRITE PGM RETURN CODE
         mvc   gp_error_buffer_len,=a(l'error_buffer) set max length
         xc    gp_error_reason,gp_error_reason        clear reason
*
         llgf  R15,LTWRADDR       get address
         ltgr  R15,r15            USER EXIT SPECIFIED ???
         JZ    WRTXENQ            NO  - BYPASS CALL
*
WRTXCALL DS    0H
         LA    R0,LTWRPARM        POINT  TO WRITE    PARAMETERS
         sty   R0,GPSTARTA
         LA    R0,LTWRWORK
         sty   R0,GPWORKA
         stg   R7,RETNPTR         SET RETURN POINTER
         lay   R1,PARM_AREA
         BASsm R14,R15            CALL USER   EXIT
*
         if    (oc,gp_error_reason,gp_error_reason,nz)
           bras  r9,errwtoa       issue "wto" if non-zero reason code
           llgt  R9,LTWREXTA      RESTORE FILE CONT AREA ADDR
         endif
*
         lg    R7,RETNPTR         LOAD RETURN POINTER
         lgf   R15,RETNCODE       LOAD RETURN CODE
*
         cghi  R15,8              SKIP  THIS  RECORD  ???
         JE    WRTXXIT            YES - BYPASS WRITE
*
         cghi  R15,12             DISABLE VIEW ???
         JL    WRTXDCHK           Check and make sure not a dummy   pgc
         JNE   WRTXABOR
*
         llgt  R1,LTlognv         LOAD VIEW logic table row addr
         MVI   LTSTATUS-LOGICTBL(R1),C'W'  YES - INDICATE ERROR
         Larl  R14,WEXITmsg                SET INDICATIVE DATA
         MVC   ERRDATA(L'WEXITMSG),0(R14)
         BRAS  R9,DISABREQ                 DISABLE THIS REQUEST
         llgt  R9,LTWREXTA                 RESTORE FILE CONT AREA ADDR
         J     WRTXXIT
*
WRTXABOR MVC   ERRDATA(8),LTWRNAME
         B     ABORTEX            ABORT RUN          (16)
                        SPACE 3
wrtxdchk ds    0h
         ltgf  r4,extrecad        Is there a place to put this rec pgc
         jnp   wrtxxit            n: then unable to write it

WRTXENQ  LA    R1,WAITECB         LOAD THIS THREAD'S WAIT   ECB ADDRESS
         XR    R14,R14            ZERO REGISTER (NOT IN-USE VALUE)
         ST    R14,0(,R1)         INITIALIZE   ECB
         LNR   R0,R1              NEGATIVE VERSION OF ECB ADDRESS
*
WRTXRTRY CS    R14,R0,EXTINUSE    TEST IN-USE FLAG ???
         JE    WRTXNEW            BRANCH  IF  ZERO (NOT IN-USE)
         ST    R14,4(,R1)         SAVE PREVIOUS VALUE IN LINKED LIST
         CS    R14,R1,EXTINUSE    MOVE THIS THREAD'S VALUE TO FLAG
         lgr   r15,r14
         lghi  R14,0              RESET REGISTER BACK TO ZERO
         JNE   WRTXRTRY           TRY AGAIN IF FLAG CHANGED IN MEANTIME
*
         stg   r15,dblwork2
         stg   r0,dblwork3
         stg   r1,dblwork4
*
* We use the Pause element - if we have an authorised PE then
*  we need to be in supervisor mode and key zero
*
         if    cli,thread_mode,eq,c'S' In supervisor mode?
***********************************************************************
*  PAUSE "SRB"                                                        *
***********************************************************************
           push using
           using savf4sa,savesrb
           lmg r0,r1,srbpet1a      get current pointers
           stmg r0,r1,xfrsrbp3     save into parmlist
           lay R1,xfrsrbpl        CALL "IEAVPSE" - PAUSE
           stg r13,SAVF4SAPREV
           stg r2,savesrb     save r2 as ipk uses it
           la r13,savesrb
           xr r0,r0               clear r0
           ipk ,                  save current key in r2
           spka 0(r0)              and flip to key 0
           pop using
         else
           push using
           using savf4sa,savetcb
           lmg r0,r1,tcbpet1a      get current pointers
           stmg r0,r1,xfrtcbp3     save into parmlist
*          if (cli,localziip,eq,c'Y')
           if (cli,localauth,eq,c'A')
             MODESET KEY=ZERO,MODE=SUP key zero needed now for the
*                                       pause element calls
           endif
           lay R1,xfrtcbpl        CALL "IEAVPSE" - PAUSE
           stg r13,SAVF4SAPREV
           la r13,savetcb
           pop using
         endif
         llgt R15,IEA4PSE
         BASR R14,R15
         if cij,r15,ne,0
           MVC DBLWORK,=CL8'IEA4PSE'
           ST    R15,DBLWORK2     Save return code
           j    PE_error          Write msg to log, and end thread
*          DC H'0'
         endif
sa_map   using savf4sa,thrdarea
         lg    R13,sa_map.SAVF4SAPREV
         drop  sa_map
         if    cli,thread_mode,eq,c'S'      and in srb mode
           spka 0(r2)             restore the saved key
           lgf    r1,ovflmask       set bits 36 and 37           pgc120
           spm r1                   set overflow masks on pgc120
           lg r2,savesrb           restore r2
           lmg r0,r1,srbpet1a      get current pointers
           stg r1,srbpet1a            and flip to correct positions
           stg r0,srbpet2a
         else
*          if (cli,localziip,eq,c'Y')
           if (cli,localauth,eq,c'A')
             MODESET KEY=NZERO,MODE=PROB
           endif
           lmg r0,r1,tcbpet1a      get current pointers
           stg r1,tcbpet1a            and flip to correct positions
           stg r0,tcbpet2a
         endif
WRTXNEW  do inf
           llgt R4,EXTRECAD        LOAD   TARGET ADDRESS FOR NEW RECORD
           lgh R15,EXRECLEN       LOAD   RECORD LENGTH
           if TM,EXTRECFM,X'40',z VARIABLE  OR  UNDEFINED ???
             lgh R15,EXTLRECL      NO  -   USE   FIXED  LENGTH
           endif
           lgr R0,R4              COMPUTE TRIAL END-OF-BUFFER  ADDRESS
           agr R0,R15
           doexit (cgf,R0,le,EXTEOBAD) If record fits, exit loop now
*
***********************************************************************
*  SWITCH TO "TCB" MODE IF ZIIP ENABLED                               *
***********************************************************************
           if (ltgf,r15,workazip,nz),and,  zIIP function available?    +
               (cli,thread_mode,eq,C'S')        and we are in SRB mode
             la     r1,TCB_switch     Switch to TCB mode
             bassm r14,r15            Call zIIP module
           endif
*          here if record overflows buffer
*
           llgt R1,EXTDECBC        LOAD  CURRENT DECB PREFIX ADDRESS
           llgt R15,16(,R1)        LOAD   BUFFER ADDR FROM   DECB
           sgr R4,R15             COMPUTE BLOCK LENGTH
           if TM,EXTRECFM,X'40',o     VARIABLE   OR UNDEFINED   ???
             STH R4,0(,R15)       BUILD   BLOCK DESCRIPTOR  WORD  (BDW)
           endif
           STH R4,10(,R1)         PLACE  LENGTH IN    DECB
*
           ltgf R15,EXTDCBA        DCB ALLOCATED ???
           JNP WRTXPIPE           NO  - CHECK IF PIPE
*
           TM  48(R15),X'10'      EXTRACT FILE  STILL OPEN  ???
           JO  WRTXPUT            YES -  CONTINUE
           MVI 4(R1),X'7F'        NO  -  PRETEND  I/O COMPLETED
           llgt R1,EXTDECBC        LOAD  ADDRESS OF NEXT DECB PREFIX
           llgt R1,0(,R1)
           ST  R1,EXTDECBC        SAVE  ADDRESS OF NEXT DECB PREFIX
           j   WRTXnowt           and bypass the check (closed d/set)
*
WRTXPIPE   llgt R15,LTWR200A       LOAD VDP 200 RECORD ADDRESS
           ltgf R15,VDP0200b_FILE_READER-VDP0200b_FILE_RECORD(,R15)
           JNZ WRTXPUT
*
           MVI 4(R1),X'7F'        NO  -  PRETEND  I/O COMPLETED
           J   WRTXSKIP
*
WRTXPUT    aghi R1,4               POINT TO DECB (FOLLOWING PREFIX)
           XC  0(4,R1),0(R1)      CLEAR ECB
           llgf R15,EXTPUT_6431    LOAD  WRITE  ROUTINE ADDRESS
           bassm R14,R15           WRITE PHYSICAL BLOCK (31-BIT MODE)
*
WRTXSKIP   llgt R1,EXTDECBC        LOAD  ADDRESS OF NEXT DECB PREFIX
           llgt R1,0(,R1)
           ST  R1,EXTDECBC        SAVE  ADDRESS OF NEXT DECB PREFIX
*
           aghi R1,4               POINT TO ECB
           llgf R15,extchk_6431    LOAD  CHECK  ROUTINE ADDRESS
           bassm R14,R15           WRITE PHYSICAL BLOCK (31-BIT MODE)
           llgt R1,EXTDECBC        RESTORE DECB PREFIX  ADDRESS
*
WRTXNOWT   llgt R15,16(,R1)        LOAD  BUFFER ADDRESS FROM DECB
           if TM,EXTRECFM,X'40',o     VARIABLE  OR UNDEFINED    ???
             LA R0,4(,R15)        SKIP  BDW
           else                   YES - LEAVE  ROOM  FOR   "BDW"
             lgr R0,R15            NO  - START  AT BEGINNING
           endif
           ST  R0,EXTRECAD        INITIALIZE NEXT RECORD ADDRESS
*
           agh R15,EXTBLKSI
           ST  R15,EXTEOBAD
*
***********************************************************************
*    SWITCH TO "SRB" MODE IF ZIIP ENABLED                             *
***********************************************************************
           if (ltgf,r15,workazip,nz),and,  zIIP function available?    +
               (cli,thread_mode,eq,C'P')   and in problem state (TCB)
             la     r1,SRB_switch     Switch to SRB mode
             bassm r14,r15            Call zIIP module
           endif

*         if  cli,localziip,eq,c'Y',and,   switching allowed          +
*              cli,thread_mode,eq,c'P'      and in problem state (TCB)
*            LArl R14,WRTXNEW       CONTINUE WITH "WR_EX"
*            J SRBSWICH
*          else ,
*            J WRTXNEW
*          endif
         enddo    ,                   This jumps back to WRTXNEW
                        SPACE 3
         ST    R0,EXTRECAD        UPDATE ADDRESS  FOR NEXT RECORD
*
         agsi  EXTCNT,bin1        INCREMENT   EXTRACT FILE RECORD COUNT
         agsi  thrd_extrrec_cnt,bin1    for thread total later
*
         lgr   R0,R15             ASSUME FIXED
         lg    r1,thrd_extrbyte_cnt  Get thread byte count
         agr   r1,r0                  add this record to total
         ag    r0,extbytec           Increment extract byte count
         stg   r0,extbytec             and save it
         stg   r1,thrd_extrbyte_cnt  and save thread byte count
*
         if CH,R15,gt,EXTLRECL
*
           lghi R14,RECORD_GT_LRECL INDICATE RECORD TOO LARGE
           MVC ERRDATA(8),EXTDDNAM copy ddname
           cvd  r15,dblwork        record length
           OI   DBLWORK+L'DBLWORK-1,X'0F'
           UNPK ERRDATA+10(6),DBLWORK
           XC    MSGS2PTR,MSGS2PTR  No additional parms
           st   r14,dblwork       Save msgid to use as flag later  pgc2
           j   wrtxdeq            Before stopping this make sure   pgc2
*                                 we release the next on queue     pgc2
*
         endif
         LA    R1,EXTREC          MOVE   THIS EXTRACT RECORD TO BUFFER
         if TM,EXTRECFM,X'40',z   VARIABLE OR UNDEFINED  ???
           LA  R1,EXTREC+4        NO  - IGNORE  "RDW"
         endif
*
*
         LA    R15,255(,R15)      ROUND UP TO  256 MULTIPLE
         SRLg  R0,r15,8
         J     WRTEXEND
WRTEXMLP MVC   0(256,R4),0(R1)
         LA    R1,256(,R1)
         LA    R4,256(,R4)
WRTEXEND BRCT  R0,WRTEXMLP
         EX    R15,WRTEXMVC       MOVE RECORD FROM DATA SPACE
static   loctr
         DS   0D
WRTEXMVC MVC   0(0,R4),0(R1)      * * * * E X E C U T E D * * * *
code     loctr
*
*        LH    R15,0(,R7)
*        AR    R15,R7
*        BCTR  R15,0
*        BRAS  R9,SNAPIT2
*        L     R9,LTWREXTA        RESTORE  LOOK-UP  BUFFER ADDRESS
                        SPACE 3
         agsi  LTWRCNTO,bin1      INCREMENT RECORD COUNT
*
         if clc,LTWRCNTO,ge,LTWRLMT    EXTRACT RECORD LIMIT REACHED
*
           llgt R1,LTlognv               LOAD logic table NV ADDR
           MVI LTSTATUS-LOGICTBL(R1),C'L'  YES - INDICATE LIMIT REACHED
           Larl R14,LIMITmsg               SET INDICATIVE DATA
           MVC ERRDATA(L'LIMITMSG),0(R14)
           BRAS R9,DISABREQ                DISABLE THIS REQUEST
           llgt R9,LTWREXTA                 RESTORE FILE CONT AREA ADDR
         endif
                        SPACE 3
WRTXDEQ  lgf   R1,EXTINUSE        LOAD IN-USE FLAG  VALUE
WRTXPOST ltgfr R1,R1              ANY  THREAD BESIDE THIS ONE WAITING
         JNP   WRTXRSET           NO  -  EXIT
*
         llgf  r15,4(,r1)         Load ptr to next thread's ecb    pgc2
         cs    r1,r15,extinuse    Next thread's ecb addr to flag   pgc2
         jne   wrtxpost           Retry unlock if changed          pgc2
*                                                                  pgc2
*        Need to check if we are ending this thread, if not then   pgc2
*        carry on as normal. Otherwise we need to check if this    pgc2
*        thread is now the last in queue ie the 2nd last in queue  pgc2
*        points to the complement of the WAITECB for this thread.  pgc2
*        In this case the 2nd last thread is now the end of queue. pgc2
*                                                                  pgc2
         l     r14,dblwork        See if we flagged RECORD_GT_LRECL
         chi   r14,RECORD_GT_LRECL Was there an LRECL error? pgc2
         jne   wrtxpost_10        N: then carry on as normal       pgc2
         lgr   r15,r1                                              pgc2
wrtxpost_02 ds 0h                                                  pgc2
         ltgf  r14,4(,r15)        Get next on queue                pgc2
         jnp   wrtxpost_07        Here if negative                 pgc2
wrtxpost_03 ds 0h                                                  pgc2
         ltgf  r0,4(,R14)         Get next on queue                pgc2
         jnp   wrtxpost_05        Here if negative                 pgc2
         lgr   r15,r14            Point at 2nd and start there     pgc2
         lgr   r14,r0             Point at 2nd and start there     pgc2
         j     wrtxpost_03        and try again                    pgc2
wrtxpost_05 ds 0h                                                  pgc2
         lngr  r0,r14             Get negative of ECB              pgc2
         st    r0,4(,r15)         Save this as last in previous    pgc2
         j     wrtxpost_10        Carry on and post next on queue  pgc2
wrtxpost_07 ds 0h                                                  pgc2
         lngr  r0,r15             Get negative of ECB              pgc2
         cs    r15,r0,extinuse    Make the flag negative           pgc2
         jne   wrtxpost_02                                         pgc2
*                                                                  pgc2
wrtxpost_10 ds 0h                                                  pgc2
*
         la    r14,thread_mode-waitecb(,r1) point at flag
*        locate the appropiate pause element token
*        and then set up to release that PE
         if    cli,0(r14),eq,c'S'    this test is to make sure that    +
                                   the waiting element is an SRB
           lg    r0,srbpet1a-waitecb(,r1) shift r1 to correct address
         else
           lg    r0,tcbpet1a-waitecb(,r1) get the tcb pe pointer
         endif
         xgr r1,r1                 clear the release code address
         if cli,thread_mode,eq,c'S'    then an SRB active
           push using
           using savf4sa,savesrb
           stmg r0,r1,xfrsrbp3    save in parm
           lay r1,xfrsrbpl   release srb which will clean up
           stg r13,SAVF4SAPREV
           stg r2,savesrb     save r2 as ipk uses it
           la r13,savesrb
           xr r0,r0               clear r0
           ipk ,                  save current key in r2
           spka 0(r0)              and flip to key 0
           pop using
         else
           push using
           using savf4sa,savetcb
           stmg r0,r1,xfrtcbp3    save in parm
*          if (cli,localziip,eq,c'Y')
           if (cli,localauth,eq,c'A')
             MODESET KEY=ZERO,MODE=SUP key zero needed now for the
*                                       pause element calls
           endif
           lay   r1,xfrtcbpl
           stg r13,SAVF4SAPREV
           la r13,savetcb
           pop using
         endif
         llgt r15,iea4rls        and finish
         basr r14,r15
sa_map   using savf4sa,thrdarea
         lg    R13,sa_map.SAVF4SAPREV
         drop  sa_map
         if cij,r15,ne,0      if this fails, then end thread
           MVC DBLWORK,=CL8'IEA4RLS'
           ST    R15,DBLWORK2     Save return code
           j    PE_error          Write msg to log, and end thread
*          dc h'0'
         endif
         if cli,thread_mode,eq,c'S'    then an SRB active
           spka 0(r2)             restore the saved key
           lg r2,savesrb           restore r2
           lgf    r1,ovflmask       set bits 36 and 37           pgc120
           spm r1                   set overflow masks on pgc120
         else
*          if (cli,localziip,eq,c'Y')
           if (cli,localauth,eq,c'A')
             MODESET KEY=NZERO,MODE=PROB
           endif
         endif
         J     WRTX05             INCREMENT  VIEW'S EXTRACT  COUNT
*
WRTXRSET XR    R0,R0              RESET FLAG BACK TO NO ONE  WAITING
         CS    R1,R0,EXTINUSE
         JNE   WRTXPOST           RETRY UNLOCK IF CHANGED IN MEANTIME
                        SPACE 3
wrtx05   ds    0h                                                  pgc2
         l     r14,dblwork        Get possible RECORD_GT_LRECL     pgc2
         chi   r14,RECORD_GT_LRECL Was there an LRECL error?       pgc2
         jne   wrtx07             n: then carry on                 pgc2
         xc    dblwork(4),dblwork clear msg                        pgc2
         j     errmsg#            quit                             pgc2
wrtx07   ds    0h                                                  pgc2
         llgt  R7,GPEXTRA         RESTORE ORIGINAL EXTRACT RECORD ADDR
         CLC   RETNCODE,F4        WRITE SUBROUTINE SPECIFIED "RECALL"
         JNE   WRTXXIT            NO  - RETURN
         llgf  R15,LTWRADDR       LOAD  SUBROUTINE ADDRESS
         J     WRTXCALL           RECALL WRITE  SUBROUTINE
*
WRTXXIT  br    R10              RETURN (SWITCH TO 31-BIT MODE)
*
         DROP  R3
         DROP  R5
         DROP  R8                 "CT"    COLUMN "DSECT"
         DROP  R9                 EXTRACT FILE  CONTROL  ELEMENT
                        EJECT
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*                                                                     *
*        W R I T E   D A T A   A R E A                                *
*                                                                     *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         USING LOGICTBL,R5
*
static   loctr ,
wrtdt_indirect j wrtdt
code     loctr ,
WRTDT    llgt  R9,LTWREXTA        LOAD EXTRACT FILE CONTROL ELEMENT ADR
         USING EXTFILE,R9
*
         lgr   R14,R8             SAVE CURRENT COLUMN ADDRESS
         lgf   R3,LTWREXTO        LOAD WRITE   EXTRACT AREA ADDRESS
         agr   R3,R2
         USING LTWRAREA,R3
*
         sgr   R8,R7              COMPUTE ACTUAL  RECORD  LENGTH
         ch    R8,EXTMINLN        DOES LENGTH  EXCEED MINIMUM ???
         JNL   *+8                YES -   USE  ACTUAL
         LH    R8,EXTMINLN        NO  -   USE  MINIMUM
         STH   R8,EXRECLEN        SET  LENGTH  IN "RDW"
*
         lgr   r8,r7
         agf   r8,ltwr_offset_ct  point to first CT column
*
         sthh  r12,exncol
         SR    R14,R8             COMPUTE LENGTH  OF COLUMN DATA
         jz    wrtdbypd
         SRDL  R14,32
         LHI   R0,COLDATAL        COMPUTE NUMBER  OF COLUMNS
         DR    R14,R0
         STH   R15,EXNCOL
                        EJECT
wrtdbypd ds    0h
         MVC   EXVIEW#,LTWRVIEW   COPY FLAGGED VIEW ID
*
         llgt  R1,LTlognv         COPY SORTLEN,TITLLEN,DATALEN
         MVC   EXSORTLN(6),LTSORTLN-LOGICTBL(R1)
*
         agsi  LTWRCNTI,bin1      INCREMENT INPUT RECORD COUNT
*
         stfh  r12,RETNCODE       ZERO WRITE PGM RETURN CODE
         mvc   gp_error_buffer_len,=a(l'error_buffer) set max length
         stfh  r12,gp_error_reason     clear reason
*
         llgf  R15,LTWRADDR       get the address
         ltgr  R15,r15            USER EXIT SPECIFIED   ???
         JZ    WRTDENQ            NO  - BYPASS CALL
*
WRTDCALL DS    0H
*
         LA    R0,LTWRPARM        POINT  TO WRITE    PARAMETERS
         sty   R0,GPSTARTA
         LA    R0,LTWRWORK
         sty   R0,GPWORKA
         stg   R7,RETNPTR         SET RETURN POINTER
         lay   R1,PARM_AREA
         BASsm R14,R15            CALL USER   EXIT
*
         if    (oc,gp_error_reason,gp_error_reason,nz)
           bras  r9,errwtoa       issue "wto" if non-zero reason code
           llgt  R9,LTWREXTA      RESTORE FILE CONT AREA ADDR
         endif
*
         lg    R7,RETNPTR         LOAD RETURN POINTER
         lgf   R15,RETNCODE       LOAD RETURN CODE
*
         CHI   R15,8              SKIP  THIS  RECORD  ???
         JE    WRTDXIT            YES - BYPASS WRITE
*
         CHI   R15,12             DISABLE  VIEW  ???
         JL    WRTDENQ            NO  - WRITE RECORD
         JNE   WRTDABOR
*
         llgt  R1,LTlognv         LOAD logic table NV address
         MVI   LTSTATUS-LOGICTBL(R1),C'W'  YES - INDICATE ERROR
         Larl  R14,WEXITmsg                SET INDICATIVE DATA
         MVC   ERRDATA(L'WEXITMSG),0(R14)
         BRAS  R9,DISABREQ                 DISABLE THIS REQUEST
         llgt  R9,LTWREXTA                 RESTORE FILE CONT AREA ADDR
         J     WRTDXIT
*
WRTDABOR MVC   ERRDATA(8),LTWRNAME
         B     ABORTEX            ABORT RUN          (16)
                        SPACE 3
WRTDENQ  LA    R1,WAITECB         LOAD THIS THREAD'S WAIT   ECB ADDRESS
         XR    R14,R14            ZERO REGISTER (NOT IN-USE VALUE)
         ST    R14,0(,R1)         INITIALIZE   ECB
         lngr  R0,R1              NEGATIVE VERSION OF ECB ADDRESS
*
WRTDRTRY CS    R14,R0,EXTINUSE    TEST IN-USE FLAG ???
         JE    WRTDNEW            BRANCH  IF  ZERO (NOT IN-USE)
         ST    R14,4(,R1)         SAVE PREVIOUS VALUE IN LINKED LIST
         CS    R14,R1,EXTINUSE    MOVE THIS THREAD'S VALUE TO FLAG
         lghi  R14,0              RESET REGISTER BACK TO ZERO
         JNE   WRTDRTRY           TRY AGAIN IF FLAG CHANGED IN MEANTIME
*
         if    cli,thread_mode,eq,c'S'      and in srb mode
***********************************************************************
*  PAUSE "SRB"                                                        *
***********************************************************************
           push using
           using savf4sa,savesrb
           lmg r0,r1,srbpet1a      get current pointers
           stmg r0,r1,xfrsrbp3     save into parmlist
           lay R1,xfrsrbpl        CALL "IEAVPSE" - PAUSE
           stg r13,SAVF4SAPREV
           stg r2,savesrb     save r2 as ipk uses it
           la r13,savesrb
           xr r0,r0               clear r0
           ipk ,                  save current key in r2
           spka 0(r0)              and flip to key 0
           pop using
         else
           push using
           using savf4sa,savetcb
           lmg r0,r1,tcbpet1a      get current pointers
           stmg r0,r1,xfrtcbp3     save into parmlist
           if (cli,localauth,eq,c'A')
             MODESET KEY=ZERO,MODE=SUP key zero needed now for the
*                                       pause element calls
           endif
           lay R1,xfrtcbpl         CALL "IEAVPSE" - PAUSE
           stg r13,SAVF4SAPREV
           la r13,savetcb
           pop using
         endif
         llgt R15,IEA4PSE
         BASR R14,R15
         if cij,r15,ne,0      if this fails, then end thread
           MVC DBLWORK,=CL8'IEA4PSE'
           ST    R15,DBLWORK2     Save return code
           j    PE_error          Write msg to log, and end thread
*          DC H'0'
         endif
sa_map   using savf4sa,thrdarea
         lg    R13,sa_map.SAVF4SAPREV
         drop  sa_map
         if    cli,thread_mode,eq,c'S'      and in srb mode
           spka 0(r2)             restore the saved key
           lgf    r1,ovflmask       set bits 36 and 37           pgc120
           spm r1                   set overflow masks on pgc120
           lg r2,savesrb           restore r2
           lmg r0,r1,srbpet1a      get current pointers
           stg r1,srbpet1a            and flip to correct positions
           stg r0,srbpet2a
         else
           if (cli,localauth,eq,c'A')
             MODESET KEY=NZERO,MODE=PROB
           endif
           lmg r0,r1,tcbpet1a      get current pointers
           stg r1,tcbpet1a            and flip to correct positions
           stg r0,tcbpet2a
         endif
*
WRTDNEW  do inf
           llgt R4,EXTRECAD        LOAD  TARGET ADDRESS FOR NEW RECORD
           lgr R0,R4              COPY  TARGET ADDRESS
*
           if TM,EXTRECFM,X'80',o FIXED  OR  UNDEFINED ???
             lgh R15,EXTLRECL     Yes - use fixed length
           else
             aghi R0,4
             if lt,r1,ltwraddr,nz  user exit defined ???
               lgh R15,0(,R7)      LOAD  LENGTH FROM    RDW
               aghi R15,-4
             else
               if  clc,ltfunc,eq,wr_in   write input file
                 llgt R1,LTlogNV     LOAD logic table "NV" ROW ADDRESS
                 if TM,LTFLAG2-LOGICTBL(R1),LTRTOKEN,z
                   lgf R15,GPRECLEN ASSUME NO EXIT
                 else ,
                   llgt R1,LTVIEWRE-LOGICTBL(,R1)
                   lgf r1,ltreindx-logictbl(,r1) .Get index for RETK
                   mghi r1,8        .Length of each litp entry
                   aghi r1,litphdrl  . plus the header
                   agf r1,lp_base_litp . plus start of base litp
                   llgt r1,4-524288(,r1) . Get lookup buffer address
*??WRTX            if TM,LBFLAGS+1-LKUPBUFR(R1),LBWRTX,z
*
                     lgh R15,LBRECLEN-LKUPBUFR(,R1)
                     if cgij,r15,le,0   not positive length
                       lgf r15,GPRECLEN use the event record length
                       sth r15,lbreclen-lkupbufr(,r1)
                     endif
*??WRTX            else
*??WRTX              LA R1,0(,R6) EVENT  RECORD ADDRESS
*??WRTX              aghi R1,-4
*??WRTX              lgh R15,0(,R1) EVENT RECORD LENGTH
*??WRTX              aghi R15,-4
*??WRTX            endif
                 endif
               else
                 llgt R1,LTlognv                logic table NV address
                 lgh R15,LTDATALN-LOGICTBL(,R1) Get DATA area length
               endif
             endif
           endif
           agr R0,R15           COMPUTE TRIAL END-OF-BUFFER  ADDRESS
           doexit (cgf,R0,le,EXTEOBAD) If record fits, exit loop now
*
*
***********************************************************************
*  SWITCH TO "TCB" MODE IF ZIIP ENABLED                               *
***********************************************************************
           if (ltgf,r15,workazip,nz),and,  zIIP function available?    +
               (cli,thread_mode,eq,C'S')        and we are in SRB mode
             la     r1,TCB_switch     Switch to TCB mode
             bassm r14,r15            Call zIIP module
           endif
*         if  cli,localziip,eq,c'Y',and,   switching allowed          +
*              cli,thread_mode,eq,c'S'      and in sprvsr state (SRB)
*            bras R14,tcbswich RESUME EXECUTION  IN "TCB" MODE
*          endif
*          here if record overflows buffer
*
           llgt R1,EXTDECBC        LOAD  CURRENT DECB PREFIX ADDRESS
           llgt R15,16(,R1)        LOAD   BUFFER ADDR FROM   DECB
           sgr  R4,R15             COMPUTE BLOCK LENGTH
           if TM,EXTRECFM,X'40',o     VARIABLE   OR UNDEFINED   ???
             STH R4,0(,R15)       BUILD   BLOCK DESCRIPTOR  WORD  (BDW)
           endif
           STH R4,10(,R1)         PLACE  LENGTH IN    DECB
*
           ltgf R15,EXTDCBA        DCB  ALLOCATED ???
           JNP WRTDPIPE           NO  - CHECK IF PIPE
*
           TM  48(R15),X'10'      FILE  STILL OPEN ???
           JO  WRTDPUT            YES - CONTINUE
           MVI 4(R1),X'7F'        NO  -  PRETEND  I/O COMPLETED
           llgt R1,EXTDECBC        LOAD  ADDRESS OF NEXT DECB PREFIX
           llgt R1,0(,R1)
           ST  R1,EXTDECBC        SAVE  ADDRESS OF NEXT DECB PREFIX
           j   WRTdnowt           and bypass the check (closed d/set)
*
WRTDPIPE   llgt R15,LTWR200A       LOAD VDP 200 RECORD ADDRESS
           ltgf R15,VDP0200b_FILE_READER-VDP0200b_FILE_RECORD(,R15)
           JNZ WRTDPUT
*
           MVI 4(R1),X'7F'        NO  -  PRETEND  I/O COMPLETED
           J   WRTDSKIP
*
WRTDPUT    aghi R1,4               POINT TO DECB (FOLLOWING PREFIX)
           stfh r12,0(,R1)         CLEAR ECB
           llgf R15,EXTPUT_6431    LOAD  WRITE  ROUTINE ADDRESS
           bassm R14,R15          WRITE PHYSICAL BLOCK (31-BIT MODE)
*
WRTDSKIP   llgt R1,EXTDECBC        LOAD  ADDRESS OF NEXT DECB PREFIX
           llgt R1,0(,R1)
           ST  R1,EXTDECBC        SAVE  ADDRESS OF NEXT DECB PREFIX
*
           aghi R1,4               POINT TO ECB
           llgf R15,extchk_6431    LOAD  CHECK  ROUTINE ADDRESS
           bassm R14,R15          WRITE PHYSICAL BLOCK (31-BIT MODE)
           llgt R1,EXTDECBC        RESTORE DECB PREFIX  ADDRESS
*
WRTDNOWT   llgt R15,16(,R1)        LOAD  BUFFER ADDRESS FROM DECB
           LA  R0,4(,R15)         SKIP  BDW
           TM  EXTRECFM,X'40'     VARIABLE  OR UNDEFINED    ???
           JO  *+8                YES - LEAVE  ROOM  FOR   "BDW"
           lgr R0,R15             NO  - START  AT BEGINNING
           ST  R0,EXTRECAD        INITIALIZE NEXT RECORD ADDRESS
*
           agh R15,EXTBLKSI
           ST  R15,EXTEOBAD
*
***********************************************************************
*    SWITCH TO "SRB" MODE IF ZIIP ENABLED                             *
***********************************************************************
           if (ltgf,r15,workazip,nz),and,  zIIP function available?    +
               (cli,thread_mode,eq,C'P')        and we are in TCB mode
             la     r1,SRB_switch     Switch to SRB mode
             bassm r14,r15            Call zIIP module
           endif
*         if  cli,localziip,eq,c'Y',and,   switching allowed          +
*              cli,thread_mode,eq,c'P'      and in problem state (TCB)
*            LArl R14,WRTDNEW       CONTINUE WITH "WR_DT"
*            J SRBSWICH
*          else ,
*            J WRTDNEW
*          endif
         enddo  ,                   loop to WRTDNEW
*
         ST    R0,EXTRECAD        UPDATE ADDRESS FOR NEXT RECORD
*
         agsi  EXTCNT,bin1        INCREMENT  EXTRACT FILE RECORD COUNT
         agsi  thrd_extrrec_cnt,bin1    for thread total later
*
         lgr  R0,R15              assume fixed
         if TM,EXTRECFM,X'80',z   not FIXED  OR   UNDEFINED  ???
           aghi R0,4
           STH R0,0(,R4)
           STHH R12,2(,R4)
           aghi R4,4
         endif
*
         lg    r1,thrd_extrbyte_cnt  Get thread byte count
         agr   r1,r0                  add this record to total
         ag    r0,extbytec           Increment extract byte count
         stg   r0,extbytec             and save it
         stg   r1,thrd_extrbyte_cnt  and save thread byte count
*
         if cgh,R15,gt,EXTLRECL
*
           lghi R14,RECORD_GT_LRECL INDICATE RECORD TOO LARGE
           MVC ERRDATA(8),EXTDDNAM copy ddname
           LAY  R0,ERRDATA         PICKUP  PARAMETER address
           cvd  r15,dblwork        record length
           OI   DBLWORK+L'DBLWORK-1,X'0F'
           UNPK ERRDATA+10(6),DBLWORK
           XC    MSGS2PTR,MSGS2PTR  No additional parms
           st  r14,dblwork        Save msgid to use as flag later  pgc2
           j   wrtddeq            Before stopping this make sure   pgc2
*                                 we release the next on queue     pgc2
         endif
*
WRTDMV   CLC   LTFUNC,WR_IN       COPY  INPUT ???
         JNE   WRTDMVXT           NO  - USE   EXTRACT   AREA
*
         lgr   R14,R6             ASSUME  NO EXIT
         lt    R1,LTWRADDR        USER EXIT SPECIFIED   ???
         JZ    WRTDMVCR           NO  - BYPASS CALL
*
         LA    R14,4(,R7)         SKIP  RDW
         J     WRTDMVCR
*
WRTDMVXT llgt  R1,LTlogNV         Logic table NV address
         LA    R14,EXSRTKEY       LOAD  EXTRACT RECORD  SORT KEY ADDR
         lgh   R0,LTSORTLN-LOGICTBL(,R1)
         ah    R0,LTTITLLN-LOGICTBL(,R1)
         agr   r14,r0            Address the DATA area
*
WRTDMVCR LA    R15,255(,R15)      ROUND UP TO  256 MULTIPLE
         SRLg  R0,r15,8
         J     WRTDEND
static   loctr ,
         ds   0d
WRTDMVC  MVC   0(0,R4),0(R14)     * * * * E X E C U T E D * * * *
code     loctr ,
WRTDMVCL MVC   0(256,R4),0(R14)
         LA    R14,256(,R14)
         LA    R4,256(,R4)
WRTDEND  BRCT  R0,WRTDMVCL
         EX    R15,WRTDMVC        MOVE RECORD FROM DATA SPACE
                        SPACE 3
WRTDCNT  agsi  LTWRCNTO,bin1      INCREMENT RECORD COUNT
*
         clc   LTWRCNTO,LTWRLMT            EXTRACT REC LIMIT REACHED
         Jl    WRTDDEQ                     NO  - CONTINUE
*
         llgt  R1,LTLogNV                  LOAD logictbl NV ADDR
         MVI   LTSTATUS-LOGICTBL(R1),C'L'  YES - INDICATE LIMIT REACHED
         LARL  R14,LIMITmsg                SET INDICATIVE DATA
         MVC   ERRDATA(L'LIMITMSG),0(R14)
         BRAS  R9,DISABREQ                 DISABLE THIS REQUEST
         llgt  R9,LTWREXTA                 RESTORE FILE CONT AREA ADDR
                        SPACE 3
WRTDDEQ  lgf   R1,EXTINUSE        LOAD IN-USE FLAG  VALUE
WRTDPOST ltgfr R1,R1              ANY  THREAD BESIDE THIS ONE WAITING
         JNP   WRTDRSET           NO  -  EXIT
*
         llgf  r15,4(,r1)         Load ptr to next thread's ecb    pgc2
         cs    r1,r15,extinuse    Next thread's ecb addr to flag   pgc2
         jne   wrtdpost           Retry unlock if changed          pgc2
*                                                                  pgc2
*        Need to check if we are ending this thread, if not then   pgc2
*        carry on as normal. Otherwise we need to check if this    pgc2
*        thread is now the last in queue ie the 2nd last in queue  pgc2
*        points to the complement of the WAITECB for this thread.  pgc2
*        In this case the 2nd last thread is now the end of queue. pgc2
*                                                                  pgc2
         l     r14,dblwork       See if we flagged RECORD_GT_LRECL pgc2
         chi   r14,RECORD_GT_LRECL Was there an LRECL error?       pgc2
         jne   wrtdpost_10        N: then carry on as normal       pgc2
         lgr   r15,r1                                              pgc2
wrtdpost_02 ds 0h                                                  pgc2
         ltgf  r14,4(,r15)        Get next on queue                pgc2
         jnp   wrtdpost_07        Here if negative                 pgc2
wrtdpost_03 ds 0h                                                  pgc2
         ltgf  r0,4(,R14)         Get next on queue                pgc2
         jnp   wrtdpost_05        Here if negative                 pgc2
         lgr   r15,r14            Point at 2nd and start there     pgc2
         lgr   r14,r0             Point at 2nd and start there     pgc2
         j     wrtdpost_03        and try again                    pgc2
wrtdpost_05 ds 0h                                                  pgc2
         lngr  r0,r14             Get negative of ECB              pgc2
         st    r0,4(,r15)         Save this as last in previous    pgc2
         j     wrtdpost_10        Carry on and post next on queue  pgc2
wrtdpost_07 ds 0h                                                  pgc2
         lngr  r0,r15             Get negative of ECB              pgc2
         cs    r15,r0,extinuse    Make the flag negative           pgc2
         jne   wrtdpost_02                                         pgc2
*                                                                  pgc2
wrtdpost_10 ds 0h                                                  pgc2
*
         la    r14,thread_mode-waitecb(,r1) point at flag
*        locate the appropiate pause element token
*        and then set up to release that PE
         if    cli,0(r14),eq,c'S'    this test is to make sure that    +
                                   the waiting element is an SRB
           lg    r0,srbpet1a-waitecb(,r1) shift r1 to correct address
         else
           lg    r0,tcbpet1a-waitecb(,r1) get the tcb pe pointer
         endif
         xgr r1,r1                 clear the release code address
         if cli,thread_mode,eq,c'S'    then an SRB active
           push using
           using savf4sa,savesrb
           stmg r0,r1,xfrsrbp3    save in parm
           lay r1,xfrsrbpl   release srb which will clean up
           stg r13,SAVF4SAPREV
           stg r2,savesrb     save r2 as ipk uses it
           la r13,savesrb
           xr r0,r0               clear r0
           ipk ,                  save current key in r2
           spka 0(r0)              and flip to key 0
           pop using
         else
           push using
           using savf4sa,savetcb
           stmg r0,r1,xfrtcbp3    save in parm
           if (cli,localauth,eq,c'A')
             MODESET KEY=ZERO,MODE=SUP key zero needed now for the
*                                       pause element calls
           endif
           lay   r1,xfrtcbpl
           stg r13,SAVF4SAPREV
           la r13,savetcb
           pop using
         endif
         llgt r15,iea4rls        and finish
         basr r14,r15
sa_map   using savf4sa,thrdarea
         lg    R13,sa_map.SAVF4SAPREV
         drop  sa_map
         if cij,r15,ne,0      if this fails, then end thread
           MVC DBLWORK,=CL8'IEA4RLS'
           ST    R15,DBLWORK2     Save return code
           j    PE_error          Write msg to log, and end thread
*          DC H'0'
         endif
         if cli,thread_mode,eq,c'S'    then an SRB active
           spka 0(r2)             restore the saved key
           l r2,savesrb           restore r2
           lgf    r1,ovflmask       set bits 36 and 37           pgc120
           spm r1                   set overflow masks on pgc120
         else
           if (cli,localauth,eq,c'A')
             MODESET KEY=NZERO,MODE=PROB
           endif
         endif
         J     WRTD05             INCREMENT  VIEW'S  EXTRACT COUNT
*
WRTDRSET XR    R0,R0              RESET FLAG BACK TO NO  ONE WAITING
         CS    R1,R0,EXTINUSE
         JNE   WRTDPOST           RETRY UNLOCK IF CHANGED IN MEANTIME
                        SPACE 3
wrtd05   ds    0h                                                  pgc2
         l     r14,dblwork        get possible RECORD_GT_LRECL pgc2
         chi   r14,RECORD_GT_LRECL was there an lrecl error?    pgc2
         jne   wrtd07             n: then carry on                 pgc2
*        clijne r14,RECORD_GT_LRECL,wrtd07
*pgcxc   xc    dblwork(4),dblwork clear msg                        pgc2
         stfh  R12,dblwork        clear msg                        pgc2
         j     errmsg#            quit                             pgc2
wrtd07   ds    0h                                                  pgc2
         llgt  R7,GPEXTRA         RESTORE ORIGINAL EXTRACT RECORD ADDR
         CLC   RETNCODE,F4        WRITE SUBROUTINE SPECIFIED "RECALL"
         JNE   WRTDXIT            NO  - RETURN
         llgf  R15,LTWRADDR       LOAD  SUBROUTINE ADDRESS
         J     WRTDCALL           RECALL WRITE  SUBROUTINE
*
WRTDXIT  ds    0h               RETURN (SWITCH TO 31-BIT MODE)
         br    R10              RETURN (SWITCH TO 31-BIT MODE)
*
         DROP  R3
         DROP  R5
         DROP  R9                 EXTRACT  FILE  CONTROL  ELEMENT
*

static   loctr ,
RRLKCOMP CLC   LKUPKEY(0),0(R4)   * * * * *   E X E C U T E D   * * * *
                        SPACE 3
         USING COLEXTR,R8
MULTZAP  ZAP   COLDATA,0(0,R14)   * * * * *   E X E C U T E D   * * * *
MULTPACK PACK  COLDATA,0(0,R14)   * * * * *   E X E C U T E D   * * * *
MULTNULL CLC   0(0,R1),SPACES     * * * * *   E X E C U T E D   * * * *
         DROP  R8
*
OCCZAP   ZAP   DBLWORK,0(0,R14)   * * * * *   E X E C U T E D   * * * *
OCCPACK  PACK  DBLWORK,0(0,R14)   * * * * *   E X E C U T E D   * * * *
*
         DS   0D
MVCR1R14 MVC   0(0,R1),0(R14)     * * * * *   E X E C U T E D   * * * *
         DS   0D
MVCR14R1 MVC   0(0,R14),0(R1)     * * * * *   E X E C U T E D   * * * *
         DS   0D
CHKPATCH CLC   BEGDATE-THRDAREA(4,R1),0(R14)  E X E C U T E D   * * * *
BRNPATCH JH    EVNTEOF            * * * * *   E X E C U T E D   * * * *
         DS   0D
SORTCLC  CLC   0(0,R14),0(R1)     * * * * *   E X E C U T E D   * * * *
*
EVNTEOF_indirect J     EVNTEOF    INDIRECT BRANCH TO ACTUAL LOGIC
ABORTEX_indirect  J    ABORTEX    INDIRECT BRANCH TO ACTUAL LOGIC
                        EJECT
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*                                                                     *
*        C O N S T A N T S                                            *
*                                                                     *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*
         LTORG
         DS   0D
*
f512k    equ   524288               512 k
MEGROUND DC    FD'1048575'
F4       DC    F'4'
F8       DC    F'8'
F100     DC    F'100'
F400     DC    F'400'
MAXSECS  DC    A(24*3600)
MAXHNDRD DC    A(24*3600*100)
*
PETAUTH  DC  a(IEA_AUTHORIZED)      PAUSE ELEMENT AUTHORIZED
PET_NOTAUTH  DC a(IEA_UNAUTHORIZED) PAUSE ELEMENT NotAUTHORIZED
*
MODE31   DS   0XL4
OPENPARM DC    XL8'8000000000000000'
*
bin1     equ   1
P000     DC    P'0'
P001     DC    P'1'
P003     DC    P'3'
P008     DC    P'8'
P010     DC    P'10'
ZACCUM   DC    PL(ACCUMLEN)'0'
*
C01      DC    CL2'01'
C02      DC    CL2'02'
C03      DC    CL2'03'
SHR      DC    CL3'SHR'
NE       DC    CL2'NE'
DN       DC    CL2'DN'            "DAYS BETWEEN" NEGATIVE
DM       DC    CL2'DM'            DAYS-IN-MONTH
EXTR     DC    CL4'EXTR'          EXTR  DDNAME   PREFIX
TOKN     DC    CL4'TOKN'          TOKN LKUPBUFR eyecatcher
*
GVBMRBS  DC    V(GVBMRBS)         BSAM    EVENT  FILE  READ ROUTINE
GVBMRVK  DC    V(GVBMRVK)         VSAM    KSDS   FILE  READ ROUTINE
GVBMRFP  DC    A(0)               * * * *  T E M P O R A R Y  * * * *
GVBMRMQ  DC    A(0)               WEBSPHERE "MQ"
*
GVBMR96  DC    V(GVBMR96)         "GVBMR96" INITIALIZATION
GVBTP90  DC    V(GVBTP90)         "GVBTP90" VSAM    I/O
*        extrn gvbdl96x
*vbdl96x amode 64
GVBDL96a DC    V(GVBDL96x)        "GVBDL96" DATA    FORMAT  CONVERSIONS
GVBUR35  DC    V(GVBUR35)         "GVBUR35" DYNAMIC ALLOCATION
GVBDAYS  DC    V(GVBDAYS)         "GVBDAYS" COMPUTE DAYS BETWEEN
GVBSRCHR DC    V(GVBSRCHR)        Perform lookup -- predefined CLC's
*
IEA4APE  DC    V(IEA4APE)         PAUSE ELEMENT - ALLOCATE
IEA4PSE  DC    V(IEA4PSE)         PAUSE ELEMENT - PAUSE
IEA4XFR  DC    V(IEA4XFR)         PAUSE ELEMENT - TRANSFER
IEA4RLS  DC    V(IEA4RLS)         PAUSE ELEMENT - RELEASE
IEA4DPE  DC    V(IEA4DPE)         PAUSE ELEMENT - DEALLOCATE
*
         WXTRN GVBMRZP
ZIIPADDR DC    V(GVBMRZP)
*
         WXTRN GVBMRSQ
MRSQADDR DC    V(GVBMRSQ)         DB2 SQL TEXT READ ROUTINE
*
         WXTRN GVBMRDV
MRDVADDR DC    V(GVBMRDV)
*
COUNTMSK_14 dc XL14'40206B2020206B2020206B202120'
COUNTMSK DC    XL15'4020206B2020206B2020206B202120'
COUNTMSK_18 DC XL18'40206B2020206B2020206B2020206B202120'
BYTEMSK  DC    XL20'402020206B2020206B2020206B2020206B202120'
TRACEMSK DC    XL12'402020202020202020202120'
NUMMASK  DC    XL08'4020202020202120'
PCTMSK   DC    XL12'4020202020202020214B2020'
*
GENEVA   DC    CL8'GENEVA  '          MAJOR  ENQ  NODE
GENEVATH DC    CL8'GENEVATH'          MAJOR  ENQ  NODE THREAD LEVEL
PGMNAME  DC    CL8'GVBMR95 '          MINOR  ENQ  NODE
ENQSTAT  DC    CL8'BUFSTATS'          MINOR  ENQ  NODE for buffer stats
tracname DC    CL8'MR95TRAC'          MINOR  ENQ  NODE for trace file
LOGNAME  DC    CL8'MR95LOG '          MINOR  ENQ  NODE for log file
VIEW     DC    C'VIEW DEF'
BAD      DC    C'Bad data'
MSK      DC    C'Overflow'
FNDLABEL DC    C'F:'
NOTLABEL DC    C'NF:'
INLABEL  DC    C' IN: '           INPUT  RECORD  LABEL
BYTELBL  DC    C'BYTES: '         OUTPUT  BYTES  LABEL
THREAD   DC    CL5'THRED'
MAINEYEB DC    CL8'THRDMAIN'      MAIN DRIVER WORK AREA "EYEBALL"
SUMAEYEB DC    CL8'SUMWAREA'      EXTRACT  SUMMARY AREA "EYEBALL"
logfeyeb dc    cl8'Logfile'       MR95 log file eyecatcher
sorteyeb dc    cl8'SORTEYEB'      MR95 report sorting area
*
NV       DC    CL4'NV  '
CF       DC    CL2'CF'
SK       DC    CL2'SK'
LK       DC    CL2'LK'
DT       DC    CL2'DT'
CT       DC    CL2'CT'
WR       DC    CL2'WR'
WR_IN    DC    CL4'WRIN'
WR_TK    DC    CL4'WRTK'
WR_TX    DC    CL4'WRTX'
WR_XT    DC    CL4'WRXT'
WR_SU    DC    CL4'WRSU'
*
         ORG   *-240
HEXCONV  EQU   *
         ORG   *+240
         DC    CL16'0123456789ABCDEF'
*
TRACOPEN DC    C'N'             OPEN ATTEMPTED ON TRACE DATASET
*
M        DC    C'M'             MASK/OVERFLOW ERROR
B        DC    C'B'             BAD  DATA     ERROR
*
I        DC    CL2'I '            INPUT  MODE
ES       DC    CL4'ES  '          END-OF-SET
ET       DC    CL4'ET  '          END-OF-SET
EN       DC    CL2'EN'            END-OF-TABLE
IN       DC    CL2'IN'            VSAM   INFORMATION
OP       DC    CL2'OP'            VSAM   OPEN
CL       DC    CL2'CL'            VSAM   CLOSE
RD       DC    CL2'RD'            VSAM   READ
LO       DC    CL2'LO'            VSAM   LOCATE
SB       DC    CL2'SB'            VSAM   START   BROWSE
BR       DC    CL2'BR'            VSAM   BROWSE
*
                        SPACE 3
DIMTBL   DC    X'001F1C1F1E1F1E1F1F1E1F1E1F'    DAYS IN MONTH
*
*UMPARM  SNAP  SDATA=(CB,DM,IO),                                       X
               PDATA=(PSW,REGS,SA,JPA,SUBTASKS),SUBPLST=SPLADDR,MF=L
*PLADDR  DS   0F                   FULLWORD BOUNDARY
*        DC    X'0001'             NUMBER OF ENTRIES IN THE LIST
*        DC    X'0000'             SUBPOOL 0  (SUBPOOL 15 IS SKIPPED)
                        EJECT
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*                                                                     *
*        T E X T   A D D R E S S   T A B L E S                        *
*                                                                     *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*
PATCHAR  DC   4XL01'FF'           PATCH AREA (0YYYYDDD)
*
ASTERISK DC  40CL01'*'            Moved to make other parts addressable
*
*
          ds   0d
encassoc_parm ds 0xl24    Sysevent encassoc parmlist
encassoc_function_code ds x       Function code 1 Join 2 leave
encassoc_join         equ 1         Join
encassoc_leave        equ 2         Leave
encassoc_jointype      ds x
                       ds xl22    reserved
                        SPACE 3
SNAPDCB  DCB   DSORG=PS,DDNAME=EXTRDUMP,MACRF=(W),                     X
               RECFM=VBA,LRECL=125,BLKSIZE=1632
* note - the BLKSIZE value is required by the SNAP service
         ds 0d
SNAPDCB_L equ  *-snapdcb
*
*snapit  DS   0H
*          ly  r2,SNAPDCBA
*        SNAP  DCB=(r2),PDATA=(REGS),ID=110
*        BR    R9
*
*SNAPIT2 DS    0H
*          ly  r2,SNAPDCBA
*        SNAP  DCB=(r2),PDATA=(REGS),ID=111,STORAGE=((R7),(R15))
*        BR    R9
*
INTERMSG DS   0CL54
INTTYPE  DC    CL08'Bad Data'
         DC    CL04' Rec'
INTRECNT DC    CL12' '
         DC    CL04' Pos'
INTFLDPS DC    CL05' '
         DC    CL04' Len'
INTFLDLN DC    CL05'   '
         DC    CL04' LTR'
INTROWNO DC    CL08' '
                        EJECT
equals   dc    cl80'===================================================x
               ============================='
errwto   j     errwtoa              go to the real code
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*                                                                     *
*        I S S U E   "W T O"  F O R   C A L L E D   E X I T S         *
*                                                                     *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
code     loctr ,
           push  using
           using savf4sa,savesubr          map the savearea
errwtoa    stg   r3,SAVF4SAG64RS3          save r3
*
           l     r15,gp_error_buffer_len   get length of text
           sthy   r15,error_bufl            and save in prefix
           LAy    R3,ERROR_BUFL
           IF  (cli,localziip,eq,c'Y'),and,      TCB/SRB switch allowed+
               (cli,thread_mode,eq,C'S')        and we are in SRB mode
             xr r0,r0             clear r9
             stg r2,dblwork
             xr r2,r2             clear r9
             ipk ,                save current key in r2
             spka 0(r0)            and flip to key 0
             sam31
             sysstate amode64=NO
             WTO TEXT=(3),MF=(E,WTOPARM),LINKAGE=BRANCH
             sysstate amode64=YES
             sam64
             spka 0(r2)            and flip to key 0
             lg  r2,dblwork
           else ,
             WTO TEXT=(3),MF=(E,WTOPARM)
           endif
*
           lg    r3,SAVF4SAG64RS14        restore r3
           br    r9
           pop   using
                        EJECT
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*                                                                     *
*        D I S A B L E   V I E W                                      *
*                                                                     *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*
*
static   loctr ,
disabreq_model j disabreq             skip along to the real code
code     loctr ,
DISABREQ DS    0H
         push  using
         using savf4sa,savesubr
         stmg  r14,r12,SAVF4SAG64RS14
*
*        R5 is the logictbl entry on entry
*
         using logictbl,r5
*
         llgt  R14,ltviewnv
         using nvprolog,r14
         OI    NVNOP+1,X'F0'           ACTIVATE VIEW   BYPASS
         L     R1,nvviewid
         drop  r14
*
         CVD   R1,DBLWORK
         OI    DBLWORK+L'DBLWORK-1,X'0F'
         LA    R14,workarea
         MVC   DBLWORK2,NUMMASK
         ED    DBLWORK2,DBLWORK+4      VIEW number
*
         GVBMSG LOG,MSGNO=DISABLE_VIEW,SUBNO=3,GENENV=GENENV,          +
               SUB1=(PGMNAME,L'PGMNAME),                               +
               SUB2=(DBLWORK2,L'DBLWORK2),                             +
               SUB3=(GPDDNAME,L'GPDDNAME),                             +
               SUB4=(ERRDATA,L'ERRDATA),                               +
               MSGBUFFER=(PRNTBUFF,L'PRNTBUFF),                        +
               MF=(E,MSG_AREA)
*
         MVC   ERRDATA,SPACES     RESET INDICATIVE  DATA
*
         lmg   r14,r12,SAVF4SAG64RS14
         BR    R9                 RETURN
         drop  r5                 forget logic table mapping
         pop   using
*
                        EJECT
         ieabrcx DISABLE
static   loctr
BRNCHEOF B     EVNTEOF_indirect
code     loctr
         ieabrcx ENABLE
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*                                                                     *
*            E N D   O F   E V E N T   F I L E   D A T A              *
*                                                                     *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*
EVNTEOF  ds    0h
         sam64                we enter in amode 31
         larl  R12,gvbmr95
***********************************************************************
*  SWITCH TO "TCB" MODE IF ZIIP ENABLED                               *
***********************************************************************
         if (ltgf,r15,workazip,nz),and,    zIIP function available?    +
               (cli,thread_mode,eq,C'S')   in supervisor state?
           la       r1,TCB_switch          Switch to TCB mode
           bassm r14,r15                   Call zIIP module
         endif
*
         XC    gpview#,gpview#    CLEAR CURRENTLY EXECUTING VIEW
*
         llgt  R7,GPEXTRA         LOAD  EXTRACT RECORD BASE REGISTER
*
***********************************************************************
*  PRINT "THREAD FINISHED" MESSAGE                                    *
***********************************************************************
*
         if clc,namepgm,eq,=cl8'GVBMR95E',or,clc,gpddname,ne,spaces
*
           LH    R0,gpthrdno        INDICATE WHICH THREAD
           CVD   R0,DBLWORK4
           OI    DBLWORK4+L'DBLWORK4-1,X'0F'
           UNPK  DBLWORK(3),DBLWORK4
*
           lg    r0,GPRECCNT
           cvdg  r0,dblwork3
           MVC   errdata(L'BYTEMSK),BYTEMSK
           ED    errdata(L'BYTEMSK),dblwork3+8
*
           GVBMSG WTO,MSGNO=THREAD_FINISHED,SUBNO=4,GENENV=GENENV,     +
               SUB1=(PGMNAME,L'PGMNAME),                               +
               SUB2=(DBLWORK,3),                                       +
               SUB3=(GPDDNAME,L'GPDDNAME),                             +
               SUB4=(ERRDATA,L'ERRDATA),                               +
               MSGBUFFER=(PRNTBUFF,L'PRNTBUFF),                        +
               MF=(E,MSG_AREA)
*
           GVBMSG LOG,MSGNO=THREAD_FINISHED,SUBNO=4,GENENV=GENENV,     +
               SUB1=(PGMNAME,L'PGMNAME),                               +
               SUB2=(DBLWORK,3),                                       +
               SUB3=(GPDDNAME,L'GPDDNAME),                             +
               SUB4=(ERRDATA,L'ERRDATA),                               +
               MSGBUFFER=(PRNTBUFF,L'PRNTBUFF),                        +
               MF=(E,MSG_AREA)
*
         endif
*
***********************************************************************
*  CLOSE AND FREE EVENT FILE                                          *
***********************************************************************
         llgt  R3,EVNTDCBA        LOAD  EVENT FILE DCB ADDRESS
         TM    48(R3),X'10'       FILE  OPEN (NOT JUST PLACEHOLDER) ???
         JNO   CKPIPE             NO  - BYPASS CLOSE
         if ltgf,r1,evntpgfs,nz     anything page fixed?
           llgt r2,evntpgfe          get end address
           PGSER R,FREE,A=(1),EA=(2) unfix pages
           xc evntpgfs,evntpgfs   signal no more page fix
           xc evntpgfe,evntpgfe   signal no more page fix
         endif
*
         MVC WKREENT(8),OPENPARM      INITIALIZE PARAMETER AREA
*
EVNTFREE sam31
         sysstate amode64=NO
         CLOSE ((R3),FREE),MODE=31,MF=(E,WKREENT)  CLOSE  EVENT FILE
         sam64
                        SPACE 3
         sysstate amode64=YES
*
         bras  r9,Free_Evnt_io_buf free any IO buffers
*
***********************************************************************
*  WRITE HEADER RECORDS TO EXTRACT FILES FOR VIEWS IN THIS "ES" SET   *
***********************************************************************
CKPIPE   ds    0h
         LARL  R15,WRTHDR         WRITE HEADER RECORDS FOR THIS FILE
         BASR  R14,R15
*
***********************************************************************
*  INCREMENT END-OF-FILE COUNTERS FOR PIPE "CREATING" THREADS         *
***********************************************************************
         Larl  R15,PIPEEOF        CALL  PIPE   END-OF-FILE ROUTINE
         BASR  R14,R15
*
***********************************************************************
*  SET-UP FOR NEXT EVENT FILE IF ANY                                  *
***********************************************************************
*
         lg    r15,GPRECCNT       Get number of event records
         ltgf  R8,THRDRE          LOAD CURRENT "RE"  ROW  ADDRESS
         USING LOGICTBL,R8
         jnp   byp_store
         stg   r15,ltfilcnt       save count in "RE" as well
byp_store ds   0h
         lgr   r14,r15            save it
         ag    r15,thrd_evntrec_cnt add to thread total
         stg   r15,thrd_evntrec_cnt and save it
         msgf  r14,GPRECLEN       work out number of bytes
         ag    r14,thrd_evntbyte_cnt add to total thread bytes
         stg   r14,thrd_evntbyte_cnt and save it
         xc    GPRECCNT,GPRECCNT     and zero counter
*
***********************************************************************
*  ANY "ES" SETS WHICH MUST EXECUTE IN THIS SAME THREAD               *
***********************************************************************
         llgt  R8,THRDES          LOAD CURRENT "ES"  ROW  ADDRESS
         USING LOGICTBL,R8
*
         ltgf  R8,LTSAMES#        ANY SAME THREAD  CONCATENATED FILES
         JP    RESTART            reuse the thread
         DROP R8
*
         llgt  R14,EXECDADR       LOAD PARAMETER DATA ADDRESS
         USING EXECDATA,R14
         if CLI,EXECSNGL,ne,C'1'  Not just the FIRST THREAD ??
           DROP R14
***********************************************************************
*  SELECT NEXT AVAILABLE "ES" SET COMPATIBLE WITH THIS THREAD TYPE    *
***********************************************************************
           lgr  R1,R13            POINT  TO CORRECT THREAD WORK AREA
           BRAS R10,PICKEVNT      SELECT NEXT  EVENT FILE
           cgijh R8,0,restart     ANY    LEFT    ???                   +
                                  RESTART THREAD WITH NXT EVNT FILE
*
         endif
*

***********************************************************************
*  NO MORE WORK FOR THIS THREAD                                       *
***********************************************************************
         BRAS  R10,CLPHASE        PERFORM "CL" PHASE CALLS
         xc    retncode,retncode  set 0 return code
*
         if (ltgf,r15,workazip,nz)  zIIP function available?
           la     r1,SRB_end      Clean up the SRB
           bassm r14,r15
         endif
*
         estaex 0                 clean up estae
         xr r14,r14               clear r14
         spm r14                  set all program masks off
*
         lay   r14,fp_reg_savearea  Point at register save area
         ld    fp8,0(0,r14)       restore fp8 to fp15
         ld    fp9,8(0,r14)
         ld    fp10,16(0,r14)
         ld    fp11,24(0,r14)
         ld    fp12,32(0,r14)
         ld    fp13,40(0,r14)
         ld    fp14,48(0,r14)
         ld    fp15,56(0,r14)

         llgt  R14,EXECDADR       LOAD PARAMETER DATA ADDRESS
         USING EXECDATA,R14
         lgf  r15,retncode        set return code
         if CLI,EXECSNGL,ne,C'1',and,   test for subtasks active       +
               CLI,EXECSNGL,ne,C'A'
           DROP R14
***********************************************************************
*    SUB-TASK RETURN                                                  *
***********************************************************************
*
           pr  ,                  return restoring all the data        +
                                  from the stack
         else  ,  running as a single task under main tcb
           llgt r13,thrdmain      need to set back to main thread area
           st r15,overall_return_code
           j done
         endif
*
***********************************************************************
*   Free Event file IO buffers before reusing the thread              *
***********************************************************************
Free_Evnt_io_buf ds 0h
*
* serialise to update buffer stats
*
         ENQ (GENEVA,ENQSTAT,E,,STEP),RNL=NO
         if cij,r15,ne,0
*          WTO 'GVBMR95 - Buffer stats "ENQ" FAILED'
* This just means that the stats might not be acurate
           GVBMSG LOG,MSGNO=STATS_ENQ_FAIL,SUBNO=1,GENENV=GENENV,      +
               SUB1=(PGMNAME,L'PGMNAME),                               +
               MSGBUFFER=(PRNTBUFF,L'PRNTBUFF),                        +
               MF=(E,MSG_AREA)
         endif
*
         xr     r2,r2
         llgt r1,Evntbufp           Address event buffer pool
         if cij,r1,gt,0             positive
           llgt r0,Evntbufps        get buffer pool size
           lr   r2,r0               save for later
           FREEMAIN RC,LV=(0),A=(1) free it
* add message to say freemain failed? or just ignore?
         endif
*
         llgt r1,Evntdecbp          DECBs
         if cij,r1,gt,0             positive
           LA    R14,DECBLEN        Length of DECB
           lgh   R15,Evntbufno      no of buffers/DECBs
           MR    R14,R14
           lr    r0,r15
           ar    r2,r15             save total freed
           FREEMAIN RC,LV=(0),A=(1) free
         endif
*
         if cij,r2,gt,0             positive
d1         using thrdarea,r14
           ly    r14,thrdmain          Get the initial thread area
           ly    r1,d1.read_buffer_tot Get total size of buffers used
           sr    r1,r2                 subtract freemained value
           sty   r1,d1.read_buffer_tot
           drop  d1
*
         endif
         DEQ (GENEVA,ENQSTAT,,STEP),RNL=NO
*
         br r9
*
                        EJECT
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*                                                                     *
*        E X I T   A B O R T   I N D I C A T E D   (ABNORMAL END)     *
*                                                                     *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
ABORTEX  larl  R12,gvbmr95
*
***********************************************************************
*  SWITCH TO "TCB" MODE IF ZIIP ENABLED                               *
***********************************************************************
         if (ltgf,r15,workazip,nz),and,  zIIP function available?      +
               (cli,thread_mode,eq,C'S')        and we are in SRB mode
           la     r1,TCB_switch          Switch to TCB mode
           bassm r14,r15                 Call zIIP module
         endif
*       if cli,localziip,eq,c'Y',and,     ziip active ?               +
*              (cli,thread_mode,eq,c'S')   Supervisor state?
*          bras R14,tcbswich RESUME EXECUTION    IN "TCB" MODE
*        endif
*
         GVBMSG LOG,MSGNO=EXIT_ABORT,SUBNO=2,GENENV=GENENV,            +
               SUB1=(PGMNAME,L'PGMNAME),                               +
               SUB2=(ERRDATA,L'ERRDATA),                               +
               MSGBUFFER=(PRNTBUFF,L'PRNTBUFF),                        +
               MF=(E,MSG_AREA)
*
         abend 998
*
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*                                                                     *
*        E V E N T   F I L E   I / O   E R R O R   (ABNORMAL END)     *
*                                                                     *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
SYNADEX0 larl  R12,gvbmr95
*
***********************************************************************
*  SWITCH TO "TCB" MODE IF ZIIP ENABLED                               *
***********************************************************************
         if (ltgf,r15,workazip,nz),and,  zIIP function available?      +
               (cli,thread_mode,eq,C'S')        and we are in SRB mode
           la     r1,TCB_switch          Switch to TCB mode
           bassm r14,r15                 Call zIIP module
         endif
* error from User exit ?
         OC    gp_error_reason,gp_error_reason
         BRZ   SYNADMSG
* Then WTO the returned error message
         L     R15,gp_error_buffer_len
         STH   R15,PRNTLEN
         BCTR  R15,0
         LA    R14,PRNTLINE
         L     R1,gp_error_buffer_ptr
         EX    R15,MVCR14R1
         WTO TEXT=PRNTLEN,MF=(E,WTOPARM)
         l     r15,gp_error_buffer_len get length of text
         ahi   r15,4
         sthy  r15,error_bufl
         ENQ   (GENEVA,LOGNAME,E,,STEP),RNL=NO
         logit msg=error_bufl
         DEQ   (GENEVA,LOGNAME,,STEP),RNL=NO
* Otherwise I/O error
synadmsg ds    0h
         LH    R0,gpthrdno        INDICATE WHICH THREAD
         CVD   R0,DBLWORK
         OI    DBLWORK+L'DBLWORK-1,X'0F'
         UNPK  errdata(3),DBLWORK
*
         GVBMSG LOG,MSGNO=IO_ERROR,SUBNO=3,GENENV=GENENV,              +
               SUB1=(PGMNAME,L'PGMNAME),                               +
               SUB2=(GPDDNAME,L'GPDDNAME),                             +
               SUB3=(ERRDATA,3),                                       +
               MSGBUFFER=(PRNTBUFF,L'PRNTBUFF),                        +
               MF=(E,MSG_AREA)
*        ly    r9,msg_bufl        get the message length
*        sth   r9,prntlen
*
*        WTO TEXT=PRNTLEN,MF=(E,WTOPARM)
*        ahi   r9,4
*        sth   r9,prntlen
*
         ABEND 998
*
                        EJECT
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*                                                                     *
*        T H R E A D   A B N O R M A L   E N D   L O G I C            *
*                                                                     *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*
*
*
*    This is the ESTAI recovery routine.
*
*    Detailed environment considerations are in
*    MVS Authorized Assembler Sevices Guide SA22-7608 Chapter 18
*
*    Some important considerations are:
*      o - SDWA available or not? (GPR0 = X'0C' on entry)
*          If no SDWA then no savearea either
*      o - SDWACLUP on - retry NOT allowed
*
*    Registers at entry if SDWA available
*       0   Values indicate level of I/O processing
*       1   ptr to SDWA
*       2   ptr to parameter area
*      13   ptr to 144 byte register save area
*      14   Return address
*      15   Entry point of recovery routine
*
         ENTRY TASKABND
TASKABND ds    0h
*
         push  using
         drop  ,                       drop everything
*
         using (thrdarea,thrdend),r8  tell assembler to map thrdarea
         using genenv,env_area
         using genparm,parm_area
         using genfile,file_area
mother   using (thrdarea,thrdend),r5   and how to map mother workarea
recsa    using savf4sa,r13

         if    (cij,r0,eq,12)          if true then no SDWA or savearea
           lgr r8,r2              get the parm address
           lg   r8,0(,r8)          Get the actual parm into r8
*
*          attempt to update thread_fail in the mother workarea
*
           LH  R0,gpthrdno        get WHICH THREAD
           llgt r5,thrdmain        get mother workarea
           if  lt,r6,mother.thread_fail,z check to see if touched
             cs  r6,r0,mother.thread_fail locked update of thread_fail
           endif
           sgr   r15,r15                 clear r15 - percolate
           br    r14                     and return
         endif
         stmg r14,r12,recsa.SAVF4SAG64RS14    save registers

         lgr   r3,r1                   copy the sdwa address
         using sdwa,r3

         llgt  R8,SDWAPARM          LOAD PARAMETER LIST ADDRESS(R13)
         lg    r8,0(,r8)          Get the actual parm into r8

         larl  R12,gvbmr95          REBUILD   BASE REGISTERS
         using (gvbmr95,code),r12

         llgt  R14,EXECDADR       LOAD  PARAMETER DATA  ADDRESS
         USING EXECDATA,R14
         if CLI,EXECSNGL,ne,c'1',and, Not 1st THREAD ONLY and          +
               CLI,EXECSNGL,ne,C'A'   not One THREAD MODE ???
           DROP R14               then we have subtasks
           llgt r5,thrdmain       get the thrdmain address
           la   r1,mother.taskecb get the ecb address
           llgt r10,tcbaddr       use my tcb addr as completion code
           POST (1),(10),LINKAGE=SYSTEM  and post the mother task so   +
                         that all other TCBs are stopped (for now)
         endif
*
         if cli,thread_mode,eq,c'P'   then we are in the TCB so
           if (ltgf,r15,workazip,nz) zIIP function available?
*          now clean_up_PE needs R13 to point to the Thread work area
*          so save the current r13 in r10
             lgr r10,r13
             lgr r13,r8           and set r13 to the correct address
             la   r1,SRB_end      Clean up the SRB
             bassm r14,r15
             lgr r13,r10
           endif
         endif

         mvc   error_address,sdwanxt1 get address portion of psw
         llgt r14,sdwaxpad              get address of pointers
         using sdwaptrs,r14             and map the area
         if ltgf,r15,sdwaxeme,nz        load pointer to extension
           using sdwarc4,r15
           lay r10,registers
           mvc 0(l'sdwag64,r10),sdwag64 and copy error registers
           drop r15
         endif

         lgf   r15,sdwacmpf           get completion code
         if tmlh,r15,sdwarcf*256,o,and,   check if reason code valid?  +
               ltgf,r10,sdwasrvp,nz         and the pointer is available

           using sdwarc1,r10          map the area
           mvc reason_code,sdwacrc      and copy reason code
           drop r10
         else
           xc reason_code,reason_code otherwise clean this
         endif
         drop r14
         nilf  r15,X'00ffffff'        clean top byte
*
*        attempt to update thread_fail in the mother workarea
*

         LH    R7,gpthrdno        INDICATE WHICH THREAD
         llgt  r5,thrdmain        get mother's workarea
         sgr   r6,r6              create a zero
*        then we are possibly the first to fail
         if  cs,r6,r7,eq,mother.thread_fail locked update 2 thread_fail
           if clfi,r15,ne,x'0033e000'  Issue message if not 33e
             UNPK print_return_code(7),SDWACMPC(4)
             TR print_return_code,HEXCONV
*            LAy R1,msg_sub2a          address destination
*            using msg_sub2a,r1        and tell the assembler
*            LA R14,print_return_code
*            xc msg_sub3l,msg_sub3l    clear
*            mvi msg_sub3l+l'msg_sub3l-1,l'print_return_code set length
*            st r14,msg_sub3a          save the address of the data
*
             l r0,gpview#
             CVD R0,DBLWORK4
             OI DBLWORK4+L'DBLWORK4-1,X'0F'
             UNPK errdata(8),DBLWORK4
*
             CVD R7,DBLWORK4       format the thread ID
             OI DBLWORK4+L'DBLWORK4-1,X'0F'
             UNPK DBLWORK(3),DBLWORK4
**           La R14,MSG#09
*            now errformat expects R13 to point to the Thread work area
*              so save the current r13 in r10
             lgr r10,r13
             lgr r13,r8            and set r13 to the correct address
             stmy r0,r12,estae_rsa save all the current registers      +
                                    as errformat destroys them
         GVBMSG LOG,MSGNO=THREAD_ABEND,SUBNO=4,GENENV=GENENV,          +
               SUB1=(PGMNAME,L'PGMNAME),                               +
               SUB2=(DBLWORK,3),                                       +
               SUB3=(print_return_code,L'print_return_code),           +
               SUB4=(ERRDATA,8),                VIEW ID                +
               MF=(E,MSG_AREA)
*            bras r9,errformat
             lmy r0,r12,estae_rsa  restore the current registers
             lgr r13,r10           fix r13
*            ly r9,msg_bufl       get the message length
*            sth r9,prntlen
*
*            WTO TEXT=PRNTLEN,MF=(E,WTOPARM)
*            llgt r11,error_address  get the failing psw address
*            lg r10,registers+((r10)*l'registers) load failing r10
*            nilf r11,X'7FFFFFFF' clean off the amode
*            nilf r10,X'7FFFFFFF'
*            xgr r6,r6             clean r6

             do ,
               if cl,r11,ge,mother.codebeg,and,                        +
               cl,r11,lt,mother.codeend
*              then r11 points into the machine code so use that value
                 lgr r6,r11        get failing address into r6 and use
                 bas r9,scan_lt   scan_lt - return row in r6
                 leave ,          and exit the do
               endif
               if cl,r10,ge,mother.codebeg,and,                        +
               cl,r10,lt,mother.codeend
*              then r10 points into the machine code so use that value
                 lgr r6,r10        get failing address into r6 and use
                 bas r9,scan_lt   scan_lt - return row in r6
                 leave ,          and exit the do
               endif
               lg r11,registers+((r14)*l'registers) load failing r14
               nilf r11,X'7FFFFFFF' clean off the amode
               if cl,r11,ge,mother.codebeg,and,                        +
               cl,r11,lt,mother.codeend
*               then r14 points into the machine code so use that value
                 lgr r6,r11        get failing address into r6 and use
                 bas r9,scan_lt   scan_lt - return row in r6
                 leave ,          and exit the do
               endif
               lg r11,registers+((r15)*l'registers) load failing r15
               nilf r11,X'7FFFFFFF' clean off the amode
               if cl,r11,ge,mother.codebeg,and,                        +
               cl,r11,lt,mother.codeend
*               then r15 points into the machine code so use that value
                 lgr r6,r11        get failing address into r6 and use
                 bas r9,scan_lt   scan_lt - return row in r6
                 leave ,          and exit the do
               endif
*              add future tests here - nothing here for now
             enddo

*          R6 has the possible failing row number by now
*            lay r14,workarea2
*            using workarea2,r14
             cvd  r6,workarea
             mvc  DBLWORK(l'nummask),nummask
             ed   DBLWORK(l'nummask),workarea+4
*            drop r14
*            LAy R1,msg_sub2a            address destination
*            using msg_sub2a,r1          and tell the assembler
*            xc  msg_sub2l,msg_sub2l     clear
*            mvi msg_sub2l+l'msg_sub2l-1,8 and set length
*            st  r14,msg_sub2a           save the address of the data
*            La  R14,MSG#602
             lgr  r10,r13
             lgr  r13,r8             and set r13 to the correct address
             stmg r0,r12,estae_rsa   save all the current registers    +
                                      as errformat destroys them
*
         GVBMSG LOG,MSGNO=FAILING_ROW,SUBNO=2,GENENV=GENENV,           +
               SUB1=(PGMNAME,L'PGMNAME),                               +
               SUB2=(DBLWORK,8),                                       +
               MF=(E,MSG_AREA)
*          now errformat expects R13 to point to the Thread work area
*          so save the current r13 in r5
*            bras r9,errformat
             lmg  r0,r12,estae_rsa   restore the current registers
             lgr  r13,r10            fix r13
*            ly  r9,msg_bufl        get the message length
*            sth r9,prntlen
*
*            WTO TEXT=PRNTLEN,MF=(E,WTOPARM)
*
           endif

           setrp RC=0,            then percolate                       +
               DUMP=YES,          ask for a dump                       +
               REGS=(14,12),      restore from savearea                +
               WKAREA=(r3)        R3->SDWA
         else ,                   otherwise
           setrp RC=0,            percolate                            +
               DUMP=IGNORE,       no dump as this is not the failing 1 +
               REGS=(14,12),      restore from savearea                +
               WKAREA=(r3)        R3->SDWA
         endif

* scan_lt - routine to locate the first and last lt entries for the
*           current view.  Checks to see if r6 is within the generated
*           code and if so returns the LTROWNO
*           if not found, returns 0
scan_lt  ds    0h
         llgt  r14,thrdes         get the es logic entry
eslt     using logictbl,r14
         using logictbl,r15
         llgt  r15,eslt.ltfrstnv  get the first nv pointer
lt_outer do ,
           do until=(clgrj,r15,ge,r14) scan just these entries
             lgr r1,r15            get the current lt
current_lt   using logictbl,r1      and map it
             agh r15,ltrowlen      index to the next entry so r15 now  +
                points at the next lt entry
             if clgf,r6,ge,current_lt.ltcodseg,and,                    +
               clgf,r6,le,ltcodseg   Does R6 point in here?
               lgf r6,current_Lt.ltrowno yes - so get the row and leave
               leave lt_outer
             endif
           enddo
           xgr r6,r6               no entry found, so return 0
         enddo
         br    r9
         drop ,
         pop using
                        EJECT
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*                                                                     *
*        C A L L   "G V B D L 9 6"   C O M M O N   C O D E            *
*                                                                     *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*
         USING LOGICTBL,R5
*
***********************************************************************
*  CALL "GVBDL96"                                                     *
***********************************************************************
CALL96PG llgf  R15,GVBDL96a       LOAD "GVBDL96"  ADDRESS
         oill  r15,x'0001'        set amode 64 in link address
         LA    R1,DL96LIST        POINT R1   AT PARAMETER LIST
         bassm R14,R15            CALL "GVBDL96" - FORMAT DATA
*
         cije  R15,0,call96ok     SUCCESSFUL ???
*
         CLI   SAFMTERR,X'02'     FIELD  OVERFLOW (TRUNCATION) ???
         JNE   CALL96B            NO  -  CHECK  OTHER  ERRORS
*
         CLI   SAVALFMT+1,FC_ALNUM SOURCE  DATA TYPE ALPHANUMERIC ???
         Jne   CALL96o             YES - BRANCH
*
*        L     R3,DL96TGTA
*        LH    R9,LTCOLLEN
*        AR    R9,R3
*          ly  r2,SNAPDCBA
*        SNAP  DCB=(r2),PDATA=(REGS),ID=040,STORAGE=((R3),(R9))
*
call96ok equ *
         xgr   R1,R1
         TM    LTFLAGS,LTOMITFB
         JO    *+8
         lghi  R1,l'mc_jump
*
***********************************************************************
*  INVERT DESCENDING SORT KEYS                                        *
***********************************************************************
         CLC   LTFUNC,=c'KSLK'    SORT  KEY  BUILD ???
         JE    CALL96K            YES - CHECK  FOR DESCENDING SEQ
         CLC   LTMAJFUN,SK        SORT  KEY  BUILD ???
         BNE   0(R10,R1)          NO  - RETURN  TO "TRUE"  ADDRESS
*
CALL96K  CLI   LTSRTSEQ,C'D'      DESCENDING   SEQUENCE   ???
         BNE   0(R10,R1)          NO  - RETURN  TO "TRUE"  ADDRESS
*
         llgt  R14,DL96TGTA       LOAD  TARGET ADDRESS
         LH    R15,LTCOLLEN       LOAD  SORT FIELD LENGTH(FORMATTED)
         EXrl  R15,SORTDESC       COMPLEMENT SORT  KEY
         B     0(R10,R1)          NO  - RETURN  TO "TRUE"  ADDRESS

         DS   0D
SORTDESC XC    0(0,R14),HEXFF     * * * *   E X E C U T E D   * * * *
*
***********************************************************************
*  FORMATTED VALUE OVERFLOW (TRUNCATION)                              *
***********************************************************************
CALL96O  LA    R0,M               INDICATE MASK/OVERFLOW ERROR
         j     get_fill_char
***********************************************************************
*  BAD NUMERIC DATA                                                   *
***********************************************************************
CALL96B  LA    R0,B               INDICATE BAD   DATA ERROR

Get_fill_char  ds 0h
         llgt  R14,ltlognv        LOAD "NV" ROW ADDRESS  IN LOGIC TABLE
         if ltgf,R1,LT1000A-LOGICTBL(,R14),p
         LA R1,VDP1000B_FILL_TRUNCATION_VALUE-VDP1000B_VIEW_RECORD(,R1)
         else
           LA  R1,ASTERISK        POINT TO DEFAULT OF ASTERISKS
         endif

***********************************************************************
*  COMMON "GVBDL96" ERROR PROCESSING                                  *
***********************************************************************
CALL96E  llgt  R14,DL96TGTA       LOAD  TARGET ADDRESS
         if cli,saoutfmt+1,ne,fc_bin    Do not do this for binary
           LH  R15,DL96LEN        LOAD  TARGET LENGTH
           BCTR R15,0
           EXrl R15,FILLASTR       FILL  RESULT WITH ASTERISKS/WHATEVER
         endif
*
         llgt  R14,ltlognv        LOAD "NV" ROW ADDRESS  IN LOGIC TABLE
         CLI   LTSTATUS-LOGICTBL(R14),C'B'  PREVIOUS CONDITION NOTED ?
         Je    CALL96Xx                     YES - EXIT
*
         lgr   R1,R0                        LOAD STATUS LETTER ADDRESS
         MVC   LTSTATUS-LOGICTBL(1,R14),0(R1)
*
         llgt  R15,LTFUNTBL                 LOAD FUNCTION TABLE ADDRESS
         CLI   FC_RTYP-FUNCTBL(R15),FC_RTYP12
         JE    CALL96M
*
         CLI   LTSTATUS-LOGICTBL(R14),C'M'   MASK  ERROR  ???
         JE    CALL96Xx                      YES - BYPASS DISABLE/abend
*
CALL96M  MVC   ERRDATA(L'INTERMSG),intermsg  COPY  BAD   DATA  TEMPLATE
*
         MVC   ERRDATA+INTTYPE-INTERMSG(l'bad),BAD ASSUME BAD   DATA
         CLI   LTSTATUS-LOGICTBL(R14),C'B'         BAD   DATA    ???
         JE    *+10                                YES - CONTINUE
         MVC   ERRDATA+INTTYPE-INTERMSG(l'msk),MSK NO  - MASK ERROR
*                                            note: overflows are masked
         lg    r1,GPRECCNT
         cvdg  r1,dblwork
         MVC   ERRDATA+INTRECNT-INTERMSG(L'INTRECNT),TRACEMSK
         ED    ERRDATA+INTRECNT-INTERMSG(L'INTRECNT),DBLWORK+8+2
         OI    ERRDATA+INTRECNT-INTERMSG+L'INTRECNT-1,X'F0'
         MVI   ERRDATA+INTRECNT-INTERMSG,C'='
*
         L     R1,LTROWNO         LOGIC   TABLE  ROW  NUMBER
         CVD   R1,DBLWORK
         OI    DBLWORK+L'DBLWORK-1,X'0F'
         MVC   ERRDATA+INTROWNO-INTERMSG(L'INTROWNO),NUMMASK
         ED    ERRDATA+INTROWNO-INTERMSG(L'INTROWNO),DBLWORK+4
         MVI   ERRDATA+INTROWNO-INTERMSG,C'='
*
         CLC   LTMAJFUN,DT        DATA   FORMAT FUNCTION ???
         JE    CALL96F
         CLC   LTMAJFUN,SK        SORT      KEY FUNCTION ???
         JE    CALL96F
         CLC   LTMAJFUN,LK        LOOK-UP   KEY FUNCTION ???
         JE    CALL96F
         CLC   LTMAJFUN,CT        COLUMN FORMAT FUNCTION ???
         JNE   CALL96_abend
*
CALL96F  LH    R1,LTFLDPOS        FIELD  POSITION
         AHI   R1,1
         CVD   R1,DBLWORK
         OI    DBLWORK+L'DBLWORK-1,X'0F'
         MVC   WORKAREA(8),NUMMASK
         ED    WORKAREA(8),DBLWORK+4
         MVC   ERRDATA+INTFLDPS-INTERMSG(L'INTFLDPS),WORKAREA+3
         MVI   ERRDATA+INTFLDPS-INTERMSG,C'='
*
         LH    R1,LTFLDLEN        FIELD   LENGTH
         AHI   R1,1
         CVD   R1,DBLWORK
         OI    DBLWORK+L'DBLWORK-1,X'0F'
         MVC   WORKAREA(8),NUMMASK
         ED    WORKAREA(8),DBLWORK+4
         MVC   ERRDATA+INTFLDLN-INTERMSG(L'INTFLDLN),WORKAREA+3
         MVI   ERRDATA+INTFLDLN-INTERMSG,C'='
*
CALL96_abend   equ *
         XC    MSGS2PTR,MSGS2PTR  No additional parms
         LA    R14,EXIT_ABORT
         j     errmsg#
*
CALL96Xx xgr   R1,R1              SET RETURN OFFSET = 0(ASSUME OMITTED)
         TM    LTFLAGS,LTOMITFB   FALSE BRANCH OMITTED  ???
         JO    *+8                YES - ASSUMPTION  CORRECT
         lghi  R1,l'mc_jump       NO  - SET RETURN  OFFSET = l'mc_jump
*
         B     0(R10,R1)          RETURN TO "TRUE"  ADDRESS
*
         DS   0D
FILLASTR MVC   0(0,R14),0(R1)     * * * *   E X E C U T E D   * * * *
         DROP  R5
                        EJECT
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*                                                                     *
*        V S A M   F U N C T I O N   C A L L S   (CALL "GVBTP90")     *
*                                                                     *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*
         USING LKUPBUFR,R5
*
VSREAD   MVC   PAFUNC,RD          INITIALIZE FUNCTION CODE
         J     VSRECBUF           INITIALIZE RECORD BUFFER LEN & ADDR
                        SPACE 3
VSLOCATE MVC   PAFUNC,LO          INITIALIZE FUNCTION CODE
         J     VSRECBUF           INITIALIZE RECORD BUFFER LEN & ADDR
                        SPACE 3
VSSTART  MVC   PAFUNC,SB          INITIALIZE FUNCTION CODE
         J     VSRECBUF           INITIALIZE RECORD BUFFER LEN & ADDR
                        SPACE 3
VSBROWSE MVC   PAFUNC,BR          INITIALIZE FUNCTION CODE
*
VSRECBUF LH    R14,LBRECLEN       LOAD   MAX RECORD   LENGTH
         STH   R14,PARECLEN       PASS   TO "GVBTP90"
*
         LA    R14,LBDATA         RETURN DATA DIRECTLY INTO BUFFER AREA
         ST    R14,TP90RECA
*
         J     VSCALL             CALL  I/O ROUTINE
                        SPACE 3
VSCLOSE  MVC   PAFUNC,CL          INITIALIZE FUNCTION CODE
         J     VSCALL             CALL   I/O ROUTINE
                        EJECT
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*                                                                     *
*        V S A M   O P E N / F I L E   I N F O R M A T I O N          *
*                                                                     *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*
         USING LOGICTBL,R8
*
VSOPEN   MVC   PAFUNC,OP          INITIALIZE FUNCTION CODE
         MVC   PADDNAME,LTFILEID  INITIALIZE DDNAME
         J     VSCALL2            CALL   I/O ROUTINE
                        SPACE 3
VSINFO   MVC   PAFUNC,IN          INITIALIZE FUNCTION  CODE
         MVC   PADDNAME,LTFILEID  INITIALIZE DDNAME
*
         LA    R14,WORKAREA       RETURN INFO INTO WORKAREA
         ST    R14,TP90RECA
*
         J     VSCALL2            CALL   I/O ROUTINE
*
         DROP  R8
                        SPACE 5
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*                                                                     *
*        V S A M   I / O   H A N D L E R   C A L L S                  *
*                                                                     *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*
VSCALL   MVC   PADDNAME,LBDDNAME  INITIALIZE DDNAME
VSCALL2  MVI   PAFTYPE,C'V'       INITIALIZE FILE     TYPE
         MVC   PAFMODE,I          INITIALIZE FILE     MODE
*
         LA    R1,TP90LIST        POINT R1 TO PARAMETER LIST
         llgf  R15,GVBTP90        LOAD  ADDRESS OF "GVBTP90"
         bassm R14,R15            CALL  I/O ROUTINE
*
         br    R9               RETURN TO POINT OF CALL
*
         DROP  R5
                        EJECT
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*                                                                     *
*        F U N C T I O N   A D D R E S S   T A B L E                  *
*                                                                     *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*
*
*        this is the table of major functions,
*        See Majrftab for the layout
*
         copy majrftab
code     loctr
*
*
*        Code in GVBMR96 is strongly dependent on this table so
*        take care changing it.
*
*        If adding any new funtions, make sure that the longer
*        entries are first (for example, 'DTC' must preceed 'DT')
*
*        The address in this table points to:
*
*        1) the actual function table entry to be used (eg 'HD')
*
*        2) A vector - used when one of the operand types is fixed -
*           Vector are 26 function table  addresses
*           first half are for unsigned inputs, second are for signed.
*           The address is selected by indexing into the 13 values
*           using the source format - the first entry being the
*           default if the source format is zero.
*           If the source is binary, then the index will point at the
*           model for 1, 2 or 4 byte operands - if the length is 8,
*           then the next function table entry is used
*           ( See the function table enty addc_01 and the following
*             entry for an example)
*
*        3) An array - used when both operand types may vary
*           The array is 26*26 entries -
*
*           the array is effectively 4 arrays:
*                source unsigned       source signed
*       target   1                     2
*     unsigned
*
*       target   3                     4
*       signed
*
*           and the operand types and signs are used to select
*           the correct function table entry.
*           there is an extra step for binary formats - the
*           pointer in the array will be to the bin124/bin124
*           entry and in the function table this will be followed
*           by the bin124/bin8, bin8/bin124 and bin8/bin8 entries
*           (that is source/target) if both binary.
*           If only one is binary then the bin8 entry will follow
*
*           Also note that the operand types (fc_acum etc.) are ONLY
*           in this table, and that if this table is zero, then code
*           in GVBMR96 uses the function code in the logic table to
*           set the correct value
*           For example, ADDE will use the third entry below and
*           the second operand will be set to FC_EVNT by MR96 on
*           account of the 'E' in the function code.
*
GVBmaj_t DS   0D                  major function table
         macro
&function array_ent &target,&source,&code_point
.*
.*   This macro generates a function code entry
.*   The label is the function code
.*
.*   First operand is the target type
.*   Second operand is the source
.*   Third operand is the address of one of
.*      1) an array of model code entries
.*      2) a vector of model code entries
.*      3) model code entry
.*
.* Internally a seqeunce number is also generated - this is used
.* in MR96 to select the correct processing
.* An informative MNOTE displays the function code and seqence no
.*
.*
         gbla &array_count
&len seta k'&function-1
&upper_func setc upper('&function')
&array_count seta &array_count+1
         dc     cl4'&upper_func.',xl1'&len.',al1(&target),al1(&source),+
               al1(&array_count.),&code_point
                  mnote *,'&upper_func. index &array_count. T=&target.,+
               S=&source.'
         mend

*********************************************************************
*                                                                   *
* If new Function codes are needed just add them onto the end of    *
* the current entries - the search is sequential and looks for an   *
* exact match so the only requirement is that shorter codes go after*
* longer ones with the same prefix characters                       *
* (there is a case statement in MR96 that depends on the array      *
*  number of each entry - so only tack new entries on the end and   *
* adjust the selection case statement to include the new entries)   *
*                                                                   *
* If you do insert codes, then use the listing where the index value*
* for each code is reported, and make sure that the case macro in   *
* MR96 (just after label ltouter) uses the correct value for each   *
* code                                                              *
*                                                                   *
* As noted above, there is no need for these codes to be in order   *
*                                                                   *
*********************************************************************
         gbla &array_count
&array_count seta 0
   print gen,data
ADDA     array_ent fc_acum,fc_acum,a(adda)
ADDC     array_ent fc_acum,fc_con,a(addc_vector)
ADD      array_ent fc_acum,0,a(add_vector)

CFAA     array_ent fc_acum,fc_acum,a(cfaa_vector)
CFAC     array_ent fc_acum,fc_con,a(cf_ac_01)
CFA      array_ent fc_acum,0,a(cfax_vector)

CFCA     array_ent fc_acum,fc_con,a(cf_ca_01)       reversed
CFCC     array_ent fc_con,fc_con,a(cf_cc_00)
CFC      array_ent fc_con,0,a(cfcx_vector)

CFEA     array_ent fc_acum,fc_evnt,a(cfea_vector)      reversed
CFEC     array_ent fc_evnt,fc_con,a(cfxc_vector)

CFLA     array_ent fc_acum,fc_lkup,a(cfea_vector)   reversed
CFLC     array_ent fc_lkup,fc_con,a(cfxc_vector)

CFPA     array_ent fc_acum,fc_prev,a(cfea_vector)  reversed
CFPC     array_ent fc_prev,fc_con,a(cfxc_vector)

CFXA     array_ent fc_acum,fc_prior,a(cfea_vector)
CFXC     array_ent fc_prior,fc_con,a(cfxc_vector)
CF       array_ent 0,0,a(cf_array)

CN       array_ent 0,fc_con,a(cn_vector)
CS       array_ent 0,fc_con,a(cs_e_01)
CTA      array_ent fc_acum,fc_ctar,a(Ct_A_02)
CTC      array_ent fc_ctar,fc_con,a(Ct_c_01)
CT       array_ent 0,fc_ctar,a(ct_vector)
CX       array_ent 0,fc_con,a(cx_e_01)

DIM      array_ent 0,0,a(dimfunc)

DIVA     array_ent fc_acum,fc_acum,a(diva)
DIVC     array_ent fc_con,fc_acum,a(divc)      reversed
DIV      array_ent fc_acum,0,a(Div_vector)

DTA      array_ent fc_acum,fc_dtar,a(dta_array)  reversed
DTC      array_ent fc_dtar,fc_con,a(dt_c)
DT       array_ent 0,fc_dtar,a(dt_array)         reversed

EN       array_ent 0,0,a(mr95EN)
ES       array_ent 0,0,a(esfunc)
ET       array_ent 0,0,a(etfunc)

GEN      array_ent 0,0,a(noop)
GO       array_ent 0,0,a(goto)

HD       array_ent 0,0,a(hd_01)
JO       array_ent fc_con,fc_lkey,a(lk_jn_01)
KS       array_ent fc_tkey,0,a(ks_lk_01)

LKC      array_ent fc_lkey,fc_con,a(dt_c)

LKDC     array_ent fc_lkey,fc_con,a(lk_dc_01)
LKD      array_ent 0,fc_lkey,a(lkdl_vector)

LKLR     array_ent fc_con,fc_lkey,a(lk_lr_01)
LKS      array_ent fc_lkey,fc_con,a(dt_c)
LK       array_ent 0,fc_lkey,a(dt_array)
LU       array_ent 0,0,a(lu_sm)

MULA     array_ent fc_acum,fc_acum,a(mula)
MULC     array_ent fc_con,fc_acum,a(mulc)      reversed
MUL      array_ent fc_acum,0,a(mul_vector)

NO       array_ent 0,0,a(noop)
NV       array_ent 0,0,a(nvfunc)
RE       array_ent 0,0,a(REfunc)

SETA     array_ent fc_acum,fc_acum,a(seta)
SETC     array_ent fc_con,fc_acum,a(setc_vector)  reversed
SET      array_ent fc_acum,0,a(Set_vector)

SKA      array_ent fc_acum,fc_skey,a(dta_array)  reversed?
SKC      array_ent fc_skey,fc_con,a(sk_c)
SK       array_ent 0,fc_skey,a(sk_array)

SUBA     array_ent fc_acum,fc_acum,a(suba)
SUBC     array_ent fc_con,fc_acum,a(subc_vector)    reversed
SUB      array_ent fc_acum,0,a(sub_vector)

WR       array_ent 0,0,a(wr_xt_01)

SFEC     array_ent fc_evnt,fc_con,a(sf_xc_01)
SFLC     array_ent fc_lkup,fc_con,a(sf_xc_01)
SFPC     array_ent fc_prev,fc_con,a(sf_xc_01)
SFXC     array_ent fc_prior,fc_con,a(sf_xc_01)

SFC      array_ent fc_con,0,a(sf_cx_01)

SF       array_ent 0,0,a(sf_xx_01)

FNEC     array_ent fc_evnt,fc_con,a(fn_xc_01)
FNLC     array_ent fc_lkup,fc_con,a(fn_xc_01)
FNPC     array_ent fc_prev,fc_con,a(fn_xc_01)
FNXC     array_ent fc_prior,fc_con,a(fn_xc_01)

FNCC     array_ent fc_con,fc_con,a(fn_cc_01) done 7NOV19
FNC      array_ent fc_con,0,a(fn_cx_01)

FN       array_ent 0,0,a(fn_xx_01)

   print nogen,nodata
max_index equ &array_count
GVBmaj_C DC   AL02((*-GVBmaj_t)/major_func_entl)
         ASSERT ((*-GVBmaj_t)/major_func_entl),EQ,max_index
*
*       the selection arrays are 2 dimensional arrays of 4 byte ptrs.
*       the first index is the target format - which selects the row
*       and the second index is the source format - selects the column
*       the entries in both are ordered in the same order as the
*       fc_type values
*       so each inner array is 13 x 13 and there are four (UU,US,SU,SS)
*       selected by the signs of the target and source
* note I have used the first entry in the function table as the target
* and the second as the source format (this is the inverse of the
* description in the FUNCTBL dsect)
* each row has 13 pointers
* first one is the default for unassigned format followed by 12 entries
* 0,alnum, alpha, num, pack, sortp, bin, sortb, bcd, mask, edit, float
* and geneva# - of these alpha and geneva are always 0 (unused)
* dc a(def),a(alnum),a(0),a(num),a(pack),a(sortp),a(bin)     xxxxx
* dc a(sortb),a(bcd),a(mask),a(edit),a(float),a(0)           target
*
* NOTE:  March 2014 - new float type introduced using extended decimal
*        float format (16 bytes) - internal accumulators changed to
*        16 byte DFP values and corresponding changes made to code
*        models and generation
*
 aif (d'row_length).skip_define
row_length equ (fc_gen#+1)*4
array_size equ (fc_gen#+1)*row_length
.skip_define anop ,
cfaa_vector   ds 0f
*                                                              unsign
  dc a(cf_aa_01),3a(0),a(cf_aa_02),a(0),a(cf_aa_03),4a(0)
  dc a(cf_aa_04),a(0)
*                                                                sign
  dc a(cf_aa_01),3a(0),a(cf_aa_02),a(0),a(cf_aa_03),4a(0)
  dc a(cf_aa_04),a(0)
cfea_vector   ds 0f
*                                                              unsign
  dc a(0),a(cf_ea_01),a(0),a(cf_ea_03),a(cf_ea_02),a(cf_ea_07)
  dc a(cf_ea_04u),a(cf_ea_08),a(cf_ea_05),a(0),a(cf_ea_09),2a(0)
*                                                                sign
  dc a(0),a(cf_ea_01),a(0),a(cf_ea_03),a(cf_ea_02),a(cf_ea_07)
  dc a(cf_ea_04),a(cf_ea_08),a(cf_ea_05),a(0),a(cf_ea_09),2a(0)
cfxc_vector   ds 0f
*                                                              unsign
  dc a(cf_ec_01),a(cf_ec_01),a(0),a(cf_ec_03),a(cf_ec_02),a(cf_ec_04)
  dc a(cf_ec_05u),a(cf_ec_06),a(cf_ec_08),a(0),a(cf_ec_07),2a(0)
*                                                                sign
  dc a(cf_ec_01),a(cf_ec_01),a(0),a(cf_ec_03),a(cf_ec_02),a(cf_ec_04)
  dc a(cf_ec_05),a(cf_ec_06),a(cf_ec_08),a(0),a(cf_ec_07),2a(0)
cfcx_vector   ds 0f
*                                                              unsign
  dc a(cf_ce_01),a(cf_ce_01),a(0),a(cf_ce_03),a(cf_ce_02),a(cf_ce_04)
  dc a(cf_ce_05u),a(cf_ce_06),a(cf_ce_08),a(0),a(cf_ce_07),2a(0)
*
  dc a(cf_ce_01),a(cf_ce_01),a(0),a(cf_ce_03),a(cf_ce_02),a(cf_ce_04)
  dc a(cf_ce_05),a(cf_ce_06),a(cf_ce_08),a(0),a(cf_ce_07),2a(0)
*
cfax_vector   ds 0f
  dc a(cf_ax_01),a(cf_ax_01),a(0),a(cf_ax_03),a(cf_ax_02),a(cf_ax_04)
  dc a(cf_ax_05u),a(cf_ax_06),a(cf_ax_08),a(0),a(cf_ax_07),2a(0)
*                                                                sign
  dc a(cf_ax_01),a(cf_ax_01),a(0),a(cf_ax_03),a(cf_ax_02),a(cf_ax_04)
  dc a(cf_ax_05),a(cf_ax_06),a(cf_ax_08),a(0),a(cf_ax_07),2a(0)
ct_vector     ds 0f
*                                                              unsign
  dc 2a(ct_e_01),a(0),a(ct_e_03),a(ct_e_02),a(ct_e_01)
  dc a(ct_e_04),6a(ct_e_01)
*                                                                sign
  dc 2a(ct_e_01),a(0),a(ct_e_03),a(ct_e_02),a(ct_e_01)
  dc a(ct_e_05),6a(ct_e_01)
lkdl_vector   ds 0f
*                                                              unsign
  dc 2a(lk_dl_01),a(0),a(lk_dl_03),a(lk_dl_02),a(0),a(lk_dl_04),6a(0)
*                                                                sign
  dc 2a(lk_dl_01),a(0),a(lk_dl_01),a(lk_dl_01),a(0),a(lk_dl_01),6a(0)
cn_vector   ds 0f
*                                                              unsign
  dc a(cn_e_01),3a(0),a(cn_e_02),a(0),a(cn_e_03),6a(0)
*                                                                sign
  dc a(cn_e_01),3a(0),a(cn_e_02),a(0),a(cn_e_03),6a(0)
addc_vector ds 0f
*                                                              unsign
  dc 4a(0),a(addc_02),a(0),a(addc_01),4a(0),a(addc_03),a(0)
*                                                                sign
  dc 4a(0),a(addc_02),a(0),a(addc_01),4a(0),a(addc_03),a(0)
add_vector ds 0f
*                                                              unsign
  dc 3a(0),a(adde_02),a(adde_01),a(adde_04),a(adde_03u)
  dc a(adde_05),a(adde_06),a(0),a(adde_07),2a(0)
*                                                                sign
  dc 3a(0),a(adde_02),a(adde_01),a(adde_04),a(adde_03)
  dc a(adde_05),a(adde_06),a(0),a(adde_07),2a(0)
*                                                                sign
subc_vector ds 0f
*                                                              unsign
  dc 4a(0),a(subc_02),a(0),a(subc_01),4a(0),a(subc_03),a(0)
*                                                                sign
  dc 4a(0),a(subc_02),a(0),a(subc_01),4a(0),a(subc_03),a(0)
sub_vector ds 0f
*                                                              unsign
  dc 3a(0),a(sube_02),a(sube_01),a(sube_04),a(sube_03u)
  dc a(sube_05),a(sube_06),a(0),a(sube_07),2a(0)
*                                                                sign
  dc 3a(0),a(sube_02),a(sube_01),a(sube_04),a(sube_03)
  dc a(sube_05),a(sube_06),a(0),a(sube_07),2a(0)
mul_vector ds 0f
*                                                              unsign
  dc 3a(0),a(mule_02),a(mule_01),a(mule_04),a(mule_03u)
  dc a(mule_05),a(mule_06),a(0),a(mule_07),2a(0)
*                                                                sign
  dc 3a(0),a(mule_02),a(mule_01),a(mule_04),a(mule_03)
  dc a(mule_05),a(mule_06),a(0),a(mule_07),2a(0)
div_vector ds 0f
*                                                              unsign
  dc 3a(0),a(dive_02),a(dive_01),a(dive_04),a(dive_03u)
  dc a(dive_05),a(dive_06),a(0),a(dive_07),2a(0)
*                                                                sign
  dc 3a(0),a(dive_02),a(dive_01),a(dive_04),a(dive_03)
  dc a(dive_05),a(dive_06),a(0),a(dive_07),2a(0)

dta_array  ds 0f
  dc  (array_size)f'0'  Define entire array with default model
  org dta_array
* this first array is for unsigned targets / unsigned source
  dc a(dt_a_01)                                  start undefn
  org dta_array+(fc_alnum)*row_length      get to start fc_alnum
  dc 2a(dt_a_01),2a(0),a(dt_a_01),8a(0)
  org dta_array+(fc_pack)*row_length       get to start fc_pack
  dc 2a(dt_a_01),a(0),a(dt_a_05),a(dt_a_03),a(dt_a_01)
  dc a(dt_a_07),4a(dt_a_01),a(dt_a_03),a(0)     jdtest
  org dta_array+(fc_bin)*row_length        get to start fc_bin
  dc 6a(0),a(dt_a_08),6a(0)
  org dta_array+(fc_mask)*row_length       get to start fc_mask
  dc 2a(dt_a_01),2a(0),a(dt_a_01),8a(0)
* this 2nd   array is for unsigned targets /   signed source
dta_us equ dta_array+array_size
  org dta_us
  dc a(dt_a_01)                                  start undefn
  org dta_us+(fc_alnum)*row_length      get to start fc_alnum
  dc 2a(dt_a_01),2a(0),a(dt_a_01),8a(0)
  org dta_us+(fc_pack)*row_length       get to start fc_pack
  dc 2a(dt_a_01),a(0),a(dt_a_05),a(dt_a_03),a(dt_a_01)
  dc a(dt_a_07),4a(dt_a_01),a(dt_a_03),a(0)     jdtest
  org dta_us+(fc_bin)*row_length        get to start fc_bin
  dc 6a(0),a(dt_a_08),6a(0)
  org dta_us+(fc_mask)*row_length       get to start fc_mask
  dc 2a(dt_a_01),2a(0),a(dt_a_01),8a(0)
*
* this 3rd   array is for   signed targets / unsigned source
dta_sign equ dta_array+2*array_size
  org dta_sign
  dc a(dt_a_01)                                  start undefn
  org dta_sign+(fc_alnum)*row_length      get to start fc_alnum
  dc 2a(dt_a_01),2a(0),a(dt_a_01),8a(0)
  org dta_sign+(fc_pack)*row_length       get to start fc_pack
  dc 2a(dt_a_01),a(0),a(dt_a_04),a(dt_a_02),a(dt_a_01)
  dc a(dt_a_06),4a(dt_a_01),a(dt_a_02f),a(0)     jdtest
  org dta_sign+(fc_bin)*row_length         get to start fc_bin
  dc 6a(0),a(dt_a_08),6a(0)
  org dta_sign+(fc_mask)*row_length        get to start fc_mask
  dc 2a(dt_a_01),2a(0),a(dt_a_01),8a(0)
* this 4th   array is for   signed targets /   signed source
dta_ss equ dta_sign+array_size
  org dta_ss
  dc a(dt_a_01)                                  start undefn
  org dta_ss+(fc_alnum)*row_length      get to start fc_alnumun
  dc 2a(dt_a_01),2a(0),a(dt_a_01),8a(0)                fc_alnum
  org dta_ss+(fc_pack)*row_length       get to start fc_pack
  dc 2a(dt_a_01),a(0),a(dt_a_04),a(dt_a_02),a(dt_a_01)  fc_pack
  dc a(dt_a_06),4a(dt_a_01),a(dt_a_02f),a(0)     jdtest
  org dta_ss+(fc_bin)*row_length         get to start fc_bin
  dc 6a(0),a(dt_a_08),6a(0)                             fc_bin
  org dta_ss+(fc_mask)*row_length        get to start fc_mask
  dc 2a(dt_a_01),2a(0),a(dt_a_01),8a(0)                 fc_mask
  org ,
*
dt_array   ds 0f
  dc  (array_size)f'0'  Define entire array with default model
  org dt_array
* this first array is for unsigned targets / unsigned source
  dc a(dt_e_01)                                  start undefn
  org dt_array+(fc_alnum)*row_length      get to start fc_alnum
  dc a(dt_e_01),a(dt_e_02)
*
  org dt_array+(fc_num)*row_length        get to start fc_num
  dc 2a(dt_e_01),a(0),a(dt_e_12),a(dt_e_06),a(dt_e_01)
  dc a(dt_e_18),6a(dt_e_01)
*                                                      fc_pack
  dc 2a(dt_e_01),a(0),a(dt_e_10),a(dt_e_04),a(dt_e_01)
  dc a(dt_e_16),6a(dt_e_01)
*                                                      fc_psort
  dc 2a(dt_e_01),a(0),10a(dt_e_01)
*                                                      fc_bin
  dc 2a(dt_e_01),a(0),a(dt_e_14),a(dt_e_08),a(dt_e_01)
  dc a(dt_e_19),6a(dt_e_01)
*                                                      fc_sortb
  dc 2a(dt_e_01),a(0),10a(dt_e_01)
*                                                      fc_bcd
  dc 2a(dt_e_01),a(0),10a(dt_e_01)
  org dt_array+(fc_mask)*row_length       get to start fc_mask
  dc 2a(dt_e_01),a(0),10a(dt_e_01)
  org dt_array+(fc_edit)*row_length       get to start fc_edit
  dc 2a(dt_e_01),a(0),10a(dt_e_01)
*
*
* this 2nd   array is for unsigned targets /   signed source
dt_us equ dt_array+array_size
  org dt_us
  dc a(dt_e_01)                                  start undefn
  org dt_us+(fc_alnum)*row_length      get to start fc_alnum
  dc a(dt_e_01),a(dt_e_02)
  org dt_us+(fc_num)*row_length        get to start fc_num
  dc 2a(dt_e_01),a(0),a(dt_e_12),a(dt_e_06),a(dt_e_01)
  dc a(dt_e_17a),6a(dt_e_01)
*                                                      fc_pack
  dc 2a(dt_e_01),a(0),a(dt_e_10),a(dt_e_04),a(dt_e_01)
  dc a(dt_e_15a),6a(dt_e_01)
*                                                      fc_psort
  dc 2a(dt_e_01),a(0),10a(dt_e_01)
*                                                      fc_bin
  dc 2a(dt_e_01),a(0),a(dt_e_14),a(dt_e_08),a(dt_e_01)
  dc a(dt_e_21),6a(dt_e_01)
*                                                      fc_sortb
  dc 2a(dt_e_01),a(0),10a(dt_e_01)
*                                                      fc_bcd
  dc 2a(dt_e_01),a(0),10a(dt_e_01)
*
  org dt_us+(fc_mask)*row_length          get to start fc_mask
  dc 2a(dt_e_01),a(0),10a(dt_e_01)
*
  org dt_us+(fc_edit)*row_length          get to start fc_edit
  dc 2a(dt_e_01),a(0),10a(dt_e_01)
*
* this 3rd   array is for   signed targets / unsigned source
dt_sign equ dt_array+2*array_size
  org dt_sign
  dc a(dt_e_01)                                  start undefn
  org dt_sign+(fc_alnum)*row_length       get to start fc_alnum
  dc a(dt_e_01),a(dt_e_02)
  org dt_sign+(fc_num)*row_length         get to start fc_num
  dc 2a(dt_e_01),a(0),a(dt_e_11),a(dt_e_05),a(dt_e_01)
  dc a(dt_e_18a),6a(dt_e_01)
*                                                      fc_pack
  dc 2a(dt_e_01),a(0),a(dt_e_09),a(dt_e_03),a(dt_e_01)
  dc a(dt_e_16a),6a(dt_e_01)
*                                                      fc_psort
  dc 2a(dt_e_01),a(0),10a(dt_e_01)
*                                                      fc_bin
  dc 2a(dt_e_01),a(0),a(dt_e_13),a(dt_e_07),a(dt_e_01)
  dc a(dt_e_22),6a(dt_e_01)
*                                                      fc_sortb
  dc 2a(dt_e_01),a(0),10a(dt_e_01)
*                                                      fc_bcd
  dc 2a(dt_e_01),a(0),10a(dt_e_01)
  org dt_sign+(fc_mask)*row_length        get to start fc_mask
  dc 2a(dt_e_01),a(0),10a(dt_e_01)
  org dt_sign+(fc_edit)*row_length        get to start fc_edit
  dc 2a(dt_e_01),a(0),10a(dt_e_01)
* this 4th   array is for   signed targets /   signed source
dt_ss equ dt_sign+array_size
  org dt_ss
  dc a(dt_e_01)                                  start undefn
  org dt_ss+(fc_alnum)*row_length       get to start fc_alnum
  dc a(dt_e_01),a(dt_e_02)
  org dt_ss+(fc_num)*row_length          get to start fc_num
  dc 2a(dt_e_01),a(0),a(dt_e_11),a(dt_e_05),a(dt_e_01)
  dc a(dt_e_17),6a(dt_e_01)
*                                                      fc_pack
  dc 2a(dt_e_01),a(0),a(dt_e_09),a(dt_e_03),a(dt_e_01)
  dc a(dt_e_15),6a(dt_e_01)
*                                                      fc_psort
  dc 2a(dt_e_01),a(0),10a(dt_e_01)
*                                                      fc_bin
  dc 2a(dt_e_01),a(0),a(dt_e_13),a(dt_e_07),a(dt_e_01)
  dc a(dt_e_20),6a(dt_e_01)
*                                                      fc_sortb
  dc 2a(dt_e_01),a(0),10a(dt_e_01)
*                                                      fc_bcd
  dc 2a(dt_e_01),a(0),10a(dt_e_01)
  org dt_ss+(fc_mask)*row_length          get to start fc_mask
  dc 2a(dt_e_01),a(0),10a(dt_e_01)
  org dt_ss+(fc_edit)*row_length          get to start fc_edit
  dc 2a(dt_e_01),a(0),10a(dt_e_01)
  org ,
sk_array ds  0f
  dc  (array_size)f'0'  Define entire array with default model
  org sk_array
* this first array is for unsigned targets / unsigned source
  dc a(sk_e_01)                                  start undefn
  org sk_array+(fc_alnum)*row_length      get to start fc_alnum
  dc a(sk_e_01),a(sk_e_02)
*
  org sk_array+(fc_num)*row_length        get to start fc_num
  dc a(sk_e_01),a(sk_e_02),a(0),a(sk_e_12),a(sk_e_06),a(sk_e_01)
  dc a(sk_e_18),6a(sk_e_01)
*                                                      fc_pack
  dc 2a(sk_e_01),a(0),a(sk_e_10),a(sk_e_04),a(sk_e_01),a(sk_e_16)
  dc 6a(sk_e_01)
*                                                      fc_psort
  dc 2a(sk_e_01),a(0),10a(sk_e_01)
*                                                      fc_bin
  dc 2a(sk_e_01),a(0),a(sk_e_14),a(sk_e_08),a(sk_e_01),a(sk_e_19)
  dc 6a(sk_e_01)
*                                                      fc_sortb
  dc 2a(sk_e_01),a(0),10a(sk_e_01)
*                                                      fc_bcd
  dc 2a(sk_e_01),a(0),10a(sk_e_01)
  org sk_array+(fc_mask)*row_length       get to start fc_mask
  dc 2a(sk_e_01),a(0),10a(sk_e_01)
  org sk_array+(fc_edit)*row_length       get to start fc_edit
  dc 2a(sk_e_01),a(0),10a(sk_e_01)
*
* this 2nd   array is for unsigned targets /   signed source
sk_us equ sk_array+array_size
  org sk_us
  dc a(sk_e_01)                                  start undefn
  org sk_us+(fc_alnum)*row_length      get to start fc_alnum
  dc a(sk_e_01),a(sk_e_02)
*
  org sk_us+(fc_num)*row_length        get to start fc_num
  dc a(sk_e_01),a(sk_e_02),a(0),a(sk_e_12),a(sk_e_06),a(sk_e_01)
  dc a(sk_e_17a),6a(sk_e_01)
*                                                      fc_pack    sign
  dc 2a(sk_e_01),a(0),a(sk_e_10),a(sk_e_04),a(sk_e_01),a(sk_e_15a)
  dc 6a(sk_e_01)
*                                                      fc_psort
  dc 2a(sk_e_01),a(0),10a(sk_e_01)
*                                                      fc_bin
  dc 2a(sk_e_01),a(0),a(sk_e_14),a(sk_e_08),a(sk_e_01),a(sk_e_21)
  dc 6a(sk_e_01)
*                                                      fc_sortb
  dc 2a(sk_e_01),a(0),10a(sk_e_01)
*                                                      fc_bcd
  dc 2a(sk_e_01),a(0),10a(sk_e_01)
  org sk_us+(fc_mask)*row_length          get to start fc_mask
  dc 2a(sk_e_01),a(0),10a(sk_e_01)
  org sk_us+(fc_edit)*row_length          get to start fc_edit
  dc 2a(sk_e_01),a(0),10a(sk_e_01)
*
* this 3rd   array is for   signed targets / unsigned source
sk_sign equ sk_array+2*array_size
  org sk_sign
  dc a(sk_e_01)                                  start undefn   unsign
*
  org sk_sign+(fc_alnum)*row_length       get to start fc_alnum unsign
  dc a(sk_e_01),a(sk_e_02)
*
  org sk_sign+(fc_num)*row_length         get to start fc_num   unsign
  dc 2a(sk_e_01),a(0),a(sk_e_11),a(sk_e_05),a(sk_e_01),a(sk_e_18a)
  dc 6a(sk_e_01)
*                                                      fc_pack  unsign
  dc 2a(sk_e_01),a(0),a(sk_e_09),a(sk_e_03),a(sk_e_01),a(sk_e_16a)
  dc 6a(sk_e_01)
*                                                      fc_psort
  dc 2a(sk_e_01),a(0),10a(sk_e_01)
*                                                      fc_bin
  dc 2a(sk_e_01),a(0),a(sk_e_13),a(sk_e_07),a(sk_e_01),a(sk_e_22)
  dc 6a(sk_e_01)
*                                                      fc_sortb
  dc 2a(sk_e_01),a(0),10a(sk_e_01)
*                                                      fc_bcd
  dc 2a(sk_e_01),a(0),10a(sk_e_01)
  org sk_sign+(fc_mask)*row_length        get to start fc_mask
  dc 2a(sk_e_01),a(0),10a(sk_e_01)
  org sk_sign+(fc_edit)*row_length        get to start fc_edit
  dc 2a(sk_e_01),a(0),10a(sk_e_01)
* this 4th   array is for   signed targets /   signed source
sk_ss equ sk_sign+array_size
  org sk_ss
  dc a(sk_e_01)                                  start undefn
*
  org sk_ss+(fc_alnum)*row_length       get to start fc_alnum
  dc a(sk_e_01),a(sk_e_02)
*
  org sk_ss+(fc_num)*row_length         get to start fc_num
  dc 2a(sk_e_01),a(0),a(sk_e_11),a(sk_e_05),a(sk_e_01),a(sk_e_17)
  dc 6a(sk_e_01)
*                                                      fc_pack
  dc 2a(sk_e_01),a(0),a(sk_e_09),a(sk_e_03),a(sk_e_01),a(sk_e_15)
  dc 6a(sk_e_01)
*                                                      fc_psort
  dc 2a(sk_e_01),a(0),10a(sk_e_01)
*                                                      fc_bin
  dc 2a(sk_e_01),a(0),a(sk_e_13),a(sk_e_07),a(sk_e_01),a(sk_e_20)
  dc 6a(sk_e_01)
*                                                      fc_sortb
  dc 2a(sk_e_01),a(0),10a(sk_e_01)
*                                                      fc_bcd
  dc 2a(sk_e_01),a(0),10a(sk_e_01)
  org sk_ss+(fc_mask)*row_length          get to start fc_mask
  dc 2a(sk_e_01),a(0),10a(sk_e_01)
  org sk_ss+(fc_edit)*row_length          get to start fc_edit
  dc 2a(sk_e_01),a(0),10a(sk_e_01)
                                                          space
  org   ,
  macro
.*
.* Macro generates a row for the selection array.  It will create
.*  a series of DC A with symbols generated from the two parameters
.*  suffixed by 'alpha,num,pack,sortp,bin,sortb,bcd,mask,edit'
.* These names are derived from the FCSRCFMT and FCTGTFMT related
.* equates in GVBMR95C (for example, fc_pack)
.* (Note FCSRCFMT and FCTGTFMT are no longer used and may be removed
.*  at a later date)
.*
  rowgen &prefix=?,&coltype=?,&default=N
  gblc &bintype
  aif ('&default' eq 'N').no_default
  dc  a(&prefix._def)
  ago .default_done
.no_default anop
  dc  a(0)
.default_done anop
&label setc  '&prefix._&coltype.'
  dc  a(&label._alnum,0,&label._num,&label._pack)
  dc  a(&label._sortp,&label._bin&bintype)
  dc  a(&label._sortb,&label._bcd)
  dc  a(0,&label._edit,0,0)
  mend
*
* The prefix here is cfxx for compare field for all except bin
* The following will be treated as signed in all cases
*   numeric(zoned), packed, sortable packed, sortable binary,
*   and edit
* BCD is treated as unsigned
* Binary - prefixes uu, us, su and ss
*   essentially if a binary value is marked as u, then it is
*   treated as an absolute value
*   The exception here being that BIN8 is always signed
*
cf_array ds   0f
  dc  (array_size)f'0'  Define entire array with default model
* this first array is for unsigned targets / unsigned source
  gblc &bintype
&bintype setc 'u'        set this for unsigned source
  org cf_array+(fc_alnum)*row_length      get to start fc_alnum
  rowgen prefix=cfxx,coltype=alnum
*
  org cf_array+(fc_num)*row_length        get to start fc_num
  rowgen prefix=cfxx,coltype=num
*
  org cf_array+(fc_pack)*row_length       get to start fc_pack
  rowgen prefix=cfxx,coltype=pack
*
  org cf_array+(fc_sortp)*row_length       get to start fc_sortp
  rowgen prefix=cfxx,coltype=sortp
*
  org cf_array+(fc_bin)*row_length        get to start fc_bin
&bintype setc ''        set to null for binary fields
  rowgen prefix=cfuu,coltype=bin
*
&bintype setc 'u'        set this for unsigned source
  org cf_array+(fc_sortb)*row_length      get to start fc_sortb
  rowgen prefix=cfxx,coltype=sortb
*
  org cf_array+(fc_bcd)*row_length        get to start fc_bcd
  rowgen prefix=cfxx,coltype=bcd
*
  org cf_array+(fc_edit)*row_length       get to start fc_edit
  rowgen prefix=cfxx,coltype=edit
*
* this 2nd   array is for unsigned targets /   signed source
cf_us equ cf_array+array_size
&bintype setc 's'
  org cf_us+(fc_alnum)*row_length         get to start fc_alnum
  rowgen prefix=cfxx,coltype=alnum
*
  org cf_us+(fc_num)*row_length           get to start fc_num
  rowgen prefix=cfxx,coltype=num
*
  org cf_us+(fc_pack)*row_length          get to start fc_pack
  rowgen prefix=cfxx,coltype=pack
*
  org cf_us+(fc_sortp)*row_length          get to start fc_sortp
  rowgen prefix=cfxx,coltype=sortp
*
&bintype setc ''        set to null for binary fields
  org cf_us+(fc_bin)*row_length           get to start fc_bin
  rowgen prefix=cfus,coltype=bin
&bintype setc 's'
*
  org cf_us+(fc_sortb)*row_length         get to start fc_sortb
  rowgen prefix=cfxx,coltype=sortb
*
  org cf_us+(fc_bcd)*row_length           get to start fc_bcd
  rowgen prefix=cfxx,coltype=bcd
*
  org cf_us+(fc_edit)*row_length          get to start fc_edit
  rowgen prefix=cfxx,coltype=edit
*
* this 3rd   array is for   signed targets / unsigned source
cf_sign equ cf_array+2*array_size
&bintype setc 'u'
  org cf_sign+(fc_alnum)*row_length       get to start fc_alnum
  rowgen prefix=cfxx,coltype=alnum
*
  org cf_sign+(fc_num)*row_length         get to start fc_num
  rowgen prefix=cfxx,coltype=num
*
  org cf_sign+(fc_pack)*row_length        get to start fc_pack
  rowgen prefix=cfxx,coltype=pack
*
  org cf_sign+(fc_sortp)*row_length        get to start fc_sortp
  rowgen prefix=cfxx,coltype=sortp
*
&bintype setc ''        set to null for binary fields
  org cf_sign+(fc_bin)*row_length         get to start fc_bin
  rowgen prefix=cfsu,coltype=bin
&bintype setc 'u'
*
  org cf_sign+(fc_sortb)*row_length       get to start fc_sortb
  rowgen prefix=cfxx,coltype=sortb
*
  org cf_sign+(fc_bcd)*row_length         get to start fc_bcd
  rowgen prefix=cfxx,coltype=bcd
*
  org cf_sign+(fc_edit)*row_length        get to start fc_edit
  rowgen prefix=cfxx,coltype=edit
* this 4th   array is for   signed targets /   signed source
cf_ss equ cf_sign+array_size
&bintype setc 's'
  org cf_ss+(fc_alnum)*row_length         get to start fc_alnum
  rowgen prefix=cfxx,coltype=alnum
*
  org cf_ss+(fc_num)*row_length           get to start fc_num
  rowgen prefix=cfxx,coltype=num
*
  org cf_ss+(fc_pack)*row_length          get to start fc_pack
  rowgen prefix=cfxx,coltype=pack
*
  org cf_ss+(fc_sortp)*row_length          get to start fc_sortp
  rowgen prefix=cfxx,coltype=sortp
*
&bintype setc ''        set to null for binary fields
  org cf_ss+(fc_bin)*row_length           get to start fc_bin
  rowgen prefix=cfss,coltype=bin
&bintype setc 's'
*
  org cf_ss+(fc_sortb)*row_length         get to start fc_sortb
  rowgen prefix=cfxx,coltype=sortb
*
  org cf_ss+(fc_bcd)*row_length           get to start fc_bcd
  rowgen prefix=cfxx,coltype=bcd
*
  org cf_ss+(fc_edit)*row_length          get to start fc_edit
  rowgen prefix=cfxx,coltype=edit
                                                          space
  org   ,
setc_vector ds 0f
*                                                              unsign
  dc 4a(0),a(setc_01),a(0),a(setc_01),4a(0),a(setc_02),a(0)
*                                                                sign
  dc 4a(0),a(setc_01),a(0),a(setc_01),4a(0),a(setc_02),a(0)
set_vector ds 0f
* this is a vector of entries - the target is fixed by the function
* (an accumulator) so this vector just uses the source format to index
  dc 2a(sete_01),a(0),a(sete_03),a(sete_02),a(sete_01),a(sete_05)
  dc 6a(sete_01)                                        unsigned set
  dc 2a(sete_01),a(0),a(sete_03),a(sete_02),a(sete_01),a(sete_04)
  dc 6a(sete_01)                                          signed set
GVBFUNTB DS   0D                  FUNCTION CODE TABLE
*        Do NOT change the order of these entries without checking the
*        selection code in GVBMR96
*
*  Note:  FCSUBBSN, FCSUBBUN, FCSUBSTU and FCSUBUTS with both operands
*         BINary now must have in order four model entries as follows:
*             1st op len    2nd op len
*         1)     1-4             1-4
*         2)     1-4             8
*         3)       8             1-4
*         4)       8             8
*
*         (the selection code in GVBMR86 is written to expect this
*          layout for those FCSUB types and BINary operands)
*
HD_01    DC    CL4'HD  ',AL1(FC_RTYP01)         HEADER
         DC    AL2(0),AL2(0)
         DC    AL4(0),AL4(0)
         DC    AL2(0),AL2(0),AL2(0)
*
DIMfunc  DC    CL4'DIM ',AL1(FC_RTYP09)         VARIABLE NAME - BOOL
         DC    AL2(0),AL2(0)
         DC    AL4(0),AL4(0)
         DC    AL2(0),AL2(0),AL2(0)
*
REFUNC   DC    CL4'RE  ',AL1(FC_RTYP06)
         DC    AL2(0),AL2(0)
         DC    AL4(0),AL4(0)
         DC    AL2(0),AL2(0),AL2(0)
*
NVFunc   DC    CL4'NV  ',AL1(FC_RTYP02)
         DC    AL2(MDLNVL),AL2(MDLNVP)
         DC    AL4(MR95NV),AL4(MDLNVR)
         DC    AL2(0),AL2(0),AL2(0)
*
LU_SM    DC    CL4'LUSM',AL1(FC_RTYP06)
         DC    AL2(MDLLUSML),AL2(MDLLUSMP)
         DC    AL4(MDLLUSM),AL4(MDLLUSMR)
         DC    AL2(0),AL2(0),AL2(0)
*
LU_EX_01 DC    CL4'LUEX',AL1(FC_RTYP06)                LOOK-UP EXIT
         DC    AL2(MDLLUEXL),AL2(MDLLUEXP)
         DC    AL4(MDLLUEX),AL4(MDLLUEXR)
         DC    AL2(0),AL2(0),AL2(0)
*
GOTO     DC    CL4'GOTO',AL1(FC_RTYP03)                GOTO
         DC    AL2(MDLGOTOL),AL2(MDLGOTOP)
         DC    AL4(MDLGOTO),AL4(MDLGOTOR)
         DC    AL2(0),AL2(0),AL2(0)
*
CF_cc_00 DC    CL4'CFCC',AL1(FC_RTYP03)                CFCC
         DC    AL2(MDLCFCCL),AL2(MDLCFCCP)
         DC    AL4(MDLCFCC),AL4(MDLCFCCR)
         DC    AL2(0),AL2(0),AL2(0)
*
*   >>>>>>>     WARNING WILL  ROBINSON   <<<<<<<<<
*   >>>>>>>     WARNING WILL  ROBINSON   <<<<<<<<<
*   >>>>>>>     WARNING WILL  ROBINSON   <<<<<<<<<
*        The NOOP function code needs to be after the CFCC
*        for our code in routine Process_cfcc in GVBMR96
*        to work correctly
NOOP     DC    CL4'NOOP',AL1(FC_RTYP03)                NOOP
         DC    AL2(0),AL2(0)
         DC    AL4(0),AL4(0)
         DC    AL2(0),AL2(0),AL2(0)
*
WR_XT_01 DC    CL4'WRXT',AL1(FC_RTYP07)                WRITE - EXTRACT
         DC    AL2(MDLWRXTL),AL2(MDLWRXTP)
         DC    AL4(MDLWRXT),AL4(MDLWRXTR)
         DC    AL2(0),AL2(0),AL2(0)
*
WR_DT_01 DC    CL4'WRDT',AL1(FC_RTYP07)                WRITE - "DT"
         DC    AL2(MDLWRDTL),AL2(MDLWRDTP)
         DC    AL4(MDLWRDT),AL4(MDLWRDTR)
         DC    AL2(0),AL2(0),AL2(0)
*
WR_IN_01 DC    CL4'WRIN',AL1(FC_RTYP07)                WRITE - INPUT
         DC    AL2(MDLWRDTL),AL2(MDLWRDTP)
         DC    AL4(MDLWRDT),AL4(MDLWRDTR)
         DC    AL2(0),AL2(0),AL2(0)
*
WR_SU_01 DC    CL4'WRSU',AL1(FC_RTYP07)                WRITE - SUMMARIZ
         DC    AL2(MDLWRSUL),AL2(MDLWRSUP)
         DC    AL4(MDLWRSU),AL4(MDLWRSUR)
         DC    AL2(0),AL2(0),AL2(0)
*
WR_EX_01 DC    CL4'WREX',AL1(FC_RTYP07)                WRITE - EXTRACT
         DC    AL2(MDLWRXTL),AL2(MDLWRXTP)
         DC    AL4(MDLWRXT),AL4(MDLWRXTR)
         DC    AL2(0),AL2(0),AL2(0)
*
WR_TK_01 DC    CL4'WRTK',AL1(FC_RTYP07)                WRITE - TOKEN/DT
         DC    AL2(MDLWRTKL),AL2(MDLWRTKP)
         DC    AL4(MDLWRTK),AL4(MDLWRTKR)
         DC    AL2(0),AL2(0),AL2(0)
*
WR_TX_01 DC    CL4'WRTX',AL1(FC_RTYP07)                WRITE - TOKEN/EX
         DC    AL2(MDLWRTXL),AL2(MDLWRTXP)
         DC    AL4(MDLWRTX),AL4(MDLWRTXR)
         DC    AL2(0),AL2(0),AL2(0)
*
ETFUNC   DC    CL4'ET  ',AL1(FC_RTYP03)                "END-OF-TOKEN"
         DC    AL2(MDLETL),AL2(MDLETP)
         DC    AL4(MDLET),AL4(MDLETR)
         DC    AL2(0),AL2(0),AL2(0)
*
ESfunc   DC    CL4'ES  ',AL1(FC_RTYP03)                "END-OF-SET"
         DC    AL2(MDLESL),AL2(MDLESP)
         DC    AL4(MDLES),AL4(MDLESR)
         DC    AL2(0),AL2(0),AL2(0)
*
         DC    CL4'ES  ',AL1(FC_RTYP03)   "END-OF-SET" (WITH LIMIT)
         DC    AL2(MDLESRLL),AL2(MDLESRLP)
         DC    AL4(MDLESRL),AL4(MDLESRLR)
         DC    AL2(FCSUBLIM),AL2(0),AL2(0)
*
MR95EN   DC    CL4'EN  ',AL1(FC_RTYP03)                "END-OF-TABLE"
         DC    AL2(MDLENL),AL2(MDLENP)
         DC    AL4(MDLEN),AL4(MDLENR)
         DC    AL2(0),AL2(0),AL2(0)
*
***********************************************************************
*        ACCUMULATOR FUNCTIONS                                        *
***********************************************************************
SETC_01  DC    CL4'SETC',AL1(FC_RTYP10)         VARIABLE set  - bin4
         DC    AL2(MDLsC01L),AL2(MDLsC01P)
         DC    AL4(MDLsC01),AL4(MDLsC01R)
         DC    AL2(0),AL2(0),AL2(0)
*
         DC    CL4'SETC',AL1(FC_RTYP10)         VARIABLE set  - bin8
         DC    AL2(MDLsC01_B8L),AL2(MDLsC01_B8P)
         DC    AL4(MDLsC01_B8),AL4(MDLsC01_B8R)
         DC    AL2(FCSUBB8),AL2(0),AL2(0)
*
*
SETC_02  DC    CL4'SETC',AL1(FC_RTYP10)         VARIABLE set  - dfp
         DC    AL2(MDLsC02L),AL2(MDLsC02P)
         DC    AL4(MDLsC02),AL4(MDLsC02R)
         DC    AL2(0),AL2(0),AL2(0)
*
***********************************************************************
*        SET ACCUMULATOR  -  GENERIC                                  *
***********************************************************************
SETE_01  DC    CL4'SET ',AL1(FC_RTYP12)                SET  ACCUM
         DC    AL2(MDLAC18L),AL2(MDLAC18P)
         DC    AL4(MDLAC18),AL4(MDLAC18R)
         DC    AL2(0),AL2(0),AL2(0)
         DC    CL4'SET ',AL1(FC_RTYP12)                SET  ACCUM
         DC    AL2(MDLAC18L),AL2(MDLAC18P)
         DC    AL4(MDLAC18),AL4(MDLAC18R)
         DC    AL2(0),AL2(0),AL2(0)
*
***********************************************************************
*        SET ACCUMULATOR  -  PACKED                                   *
***********************************************************************
SETE_02  DC    CL4'SET ',AL1(FC_RTYP12)                SET  ACCUM
         DC    AL2(MDLAC19L),AL2(MDLAC19P)
         DC    AL4(MDLAC19),AL4(MDLAC19R)
         DC    AL2(0),AL2(0),AL2(0)
*
***********************************************************************
*        SET ACCUMULATOR  -  NUMERIC                                  *
***********************************************************************
SETE_03  DC    CL4'SET ',AL1(FC_RTYP12)                SET  ACCUM
         DC    AL2(MDLAC20L),AL2(MDLAC20P)
         DC    AL4(MDLAC20),AL4(MDLAC20R)
         DC    AL2(0),AL2(0),AL2(0)
*
***********************************************************************
*        SET ACCUMULATOR  -  BINARY                                   *
***********************************************************************
SETE_04  DC    CL4'SET ',AL1(FC_RTYP12)                SET  ACCUM
         DC    AL2(MDLAC21L),AL2(MDLAC21P)
         DC    AL4(MDLAC21),AL4(MDLAC21R)
         DC    AL2(0),AL2(0),AL2(0)
*
***********************************************************************
*        SET ACCUMULATOR  -  BINARY 8 byte                            *
***********************************************************************
         DC    CL4'SET ',AL1(FC_RTYP12)                SET  ACCUM
         DC    AL2(MDLAC21_b8L),AL2(MDLAC21_b8P)
         DC    AL4(MDLAC21_b8),AL4(MDLAC21_b8R)
         DC    AL2(FCSUBB8),al2(0),AL2(0)
*
***********************************************************************
*        SET ACCUMULATOR  -  BINARY                                   *
***********************************************************************
SETE_05  DC    CL4'SET ',AL1(FC_RTYP12)                SET  ACCUM
         DC    AL2(MDLAC21uL),AL2(MDLAC21uP)
         DC    AL4(MDLAC21u),AL4(MDLAC21uR)
         DC    AL2(FCSUButs),al2(0),AL2(0)
*
         DC    CL4'SET ',AL1(FC_RTYP12)                SET  ACCUM
         DC    AL2(MDLAC21_b8L),AL2(MDLAC21_b8P)
         DC    AL4(MDLAC21_b8),AL4(MDLAC21_b8R)
         DC    AL2(FCSUBB8),al2(0),AL2(0)
*
*
***********************************************************************
*        ACCUMULATOR FUNCTIONS                                        *
***********************************************************************
SETA     DC    CL4'SETA',AL1(FC_RTYP10)         VARIABLE SET  - ACCUM
         DC    AL2(MDLAC28L),AL2(MDLAC28P)
         DC    AL4(MDLAC28),AL4(MDLAC28R)
         DC    AL2(0),AL2(0),AL2(0)
*
***********************************************************************
*        ADD TO ACCUMULATOR  -  BINARY                                *
***********************************************************************
ADDC_01  DC    CL4'ADDC',AL1(FC_RTYP10)         VARIABLE ADD  - CON
         DC    AL2(MDLAC03L),AL2(MDLAC03P)
         DC    AL4(MDLAC03),AL4(MDLAC03R)
         DC    AL2(0),AL2(0),AL2(0)
*
         DC    CL4'ADDC',AL1(FC_RTYP10)         VARIABLE ADD  - CON
         DC    AL2(MDLAC03_b8L),AL2(MDLAC03_b8P)
         DC    AL4(MDLAC03_b8),AL4(MDLAC03_b8R)
         DC    AL2(FCSUBB8),al2(0),AL2(0)
*
*
ADDC_02  DC    CL4'ADDC',AL1(FC_RTYP10)         VARIABLE ADD  - CON
         DC    AL2(MDLAC24L),AL2(MDLAC24P)
         DC    AL4(MDLAC24),AL4(MDLAC24R)
         DC    AL2(0),AL2(0),AL2(0)
*
ADDC_03  DC    CL4'ADDC',AL1(FC_RTYP10)         VARIABLE ADD  - CON
         DC    AL2(MDLAC23L),AL2(MDLAC23P)
         DC    AL4(MDLAC23),AL4(MDLAC23R)
         DC    AL2(0),AL2(0),AL2(0)
*
ADDE_01  DC    CL4'ADDE',AL1(FC_RTYP12)         VARIABLE ADD  - EVENT
         DC    AL2(MDLAC06L),AL2(MDLAC06P)
         DC    AL4(MDLAC06),AL4(MDLAC06R)
         DC    AL2(0),AL2(0),AL2(0)
*
ADDE_02  DC    CL4'ADDE',AL1(FC_RTYP12)         VARIABLE ADD  - EVENT
         DC    AL2(MDLAC07L),AL2(MDLAC07P)
         DC    AL4(MDLAC07),AL4(MDLAC07R)
         DC    AL2(0),AL2(0),AL2(0)
*
ADDE_03  DC    CL4'ADDE',AL1(FC_RTYP12)         VARIABLE ADD  - EVENT
         DC    AL2(MDLAC08L),AL2(MDLAC08P)
         DC    AL4(MDLAC08),AL4(MDLAC08R)
         DC    AL2(0),AL2(0),AL2(0)
*
         DC    CL4'ADDE',AL1(FC_RTYP12)         VARIABLE ADD  - EVENT
         DC    AL2(MDLAC08_b8L),AL2(MDLAC08_b8P)
         DC    AL4(MDLAC08_b8),AL4(MDLAC08_b8R)
         DC    AL2(FCSUBB8),al2(0),AL2(0)
*
ADDE_03u DC    CL4'ADDE',AL1(FC_RTYP12)         VARIABLE ADD  - EVENT
         DC    AL2(MDLAC08uL),AL2(MDLAC08uP)
         DC    AL4(MDLAC08u),AL4(MDLAC08uR)
         DC    AL2(FCSUButs),al2(0),AL2(0)      unsigned input
*
         DC    CL4'ADDE',AL1(FC_RTYP12)         VARIABLE ADD  - EVENT
         DC    AL2(MDLAC08_b8L),AL2(MDLAC08_b8P)
         DC    AL4(MDLAC08_b8),AL4(MDLAC08_b8R)
         DC    AL2(FCSUBB8),al2(0),AL2(0)
*
ADDE_04  DC    CL4'ADDE',AL1(FC_RTYP12)         VARIABLE ADD  - EVENT
         DC    AL2(MDLAC43L),AL2(MDLAC43P)
         DC    AL4(MDLAC43),AL4(MDLAC43R)
         DC    AL2(0),AL2(0),AL2(0)
*
ADDE_05  DC    CL4'ADDE',AL1(FC_RTYP12)         VARIABLE ADD  - EVENT
         DC    AL2(MDLAC44L),AL2(MDLAC44P)
         DC    AL4(MDLAC44),AL4(MDLAC44R)
         DC    AL2(0),AL2(0),AL2(0)
*
         DC    CL4'ADDE',AL1(FC_RTYP12)         VARIABLE ADD  - EVENT
         DC    AL2(MDLAC44_b8L),AL2(MDLAC44_b8P)
         DC    AL4(MDLAC44_b8),AL4(MDLAC44_b8R)
         DC    AL2(0),AL2(0),AL2(0)
*
ADDE_06  DC    CL4'ADDE',AL1(FC_RTYP12)         VARIABLE ADD  - EVENT
         DC    AL2(MDLAC45L),AL2(MDLAC45P)
         DC    AL4(MDLAC45),AL4(MDLAC45R)
         DC    AL2(0),AL2(0),AL2(0)
*
ADDE_07  DC    CL4'ADDE',AL1(FC_RTYP12)         VARIABLE ADD  - EVENT
         DC    AL2(MDLAC46L),AL2(MDLAC46P)
         DC    AL4(MDLAC46),AL4(MDLAC46R)
         DC    AL2(0),AL2(0),AL2(0)
*
ADDA     DC    CL4'ADDA',AL1(FC_RTYP10)         VARIABLE ADD  - ACCUM
         DC    AL2(MDLAC29L),AL2(MDLAC29P)
         DC    AL4(MDLAC29),AL4(MDLAC29R)
         DC    AL2(0),AL2(0),AL2(0)
*
SUBC_01  DC    CL4'SUBC',AL1(FC_RTYP10)         VARIABLE SUB  - CON
         DC    AL2(MDLAC05L),AL2(MDLAC05P)
         DC    AL4(MDLAC05),AL4(MDLAC05R)
         DC    AL2(0),AL2(0),AL2(0)
*
         DC    CL4'SUBC',AL1(FC_RTYP10)         VARIABLE SUB  - CON
         DC    AL2(MDLAC05_b8L),AL2(MDLAC05_b8P)
         DC    AL4(MDLAC05_b8),AL4(MDLAC05_b8R)
         DC    AL2(FCSUBB8),al2(0),AL2(0)
*
SUBC_02  DC    CL4'SUBC',AL1(FC_RTYP10)         VARIABLE SUB  - CON
         DC    AL2(MDLAC25L),AL2(MDLAC25P)
         DC    AL4(MDLAC25),AL4(MDLAC25R)
         DC    AL2(0),AL2(0),AL2(0)
*
SUBC_03  DC    CL4'SUBC',AL1(FC_RTYP10)         VARIABLE SUB  - CON
         DC    AL2(MDLAC22L),AL2(MDLAC22P)
         DC    AL4(MDLAC22),AL4(MDLAC22R)
         DC    AL2(0),AL2(0),AL2(0)
*
SUBE_01  DC    CL4'SUBE',AL1(FC_RTYP12)         VARIABLE SUB  - EVENT
         DC    AL2(MDLAC09L),AL2(MDLAC09P)
         DC    AL4(MDLAC09),AL4(MDLAC09R)
         DC    AL2(0),AL2(0),AL2(0)
*
SUBE_02  DC    CL4'SUBE',AL1(FC_RTYP12)         VARIABLE SUB  - EVENT
         DC    AL2(MDLAC10L),AL2(MDLAC10P)
         DC    AL4(MDLAC10),AL4(MDLAC10R)
         DC    AL2(0),AL2(0),AL2(0)
*
SUBE_03  DC    CL4'SUBE',AL1(FC_RTYP12)         VARIABLE SUB  - EVENT
         DC    AL2(MDLAC11L),AL2(MDLAC11P)
         DC    AL4(MDLAC11),AL4(MDLAC11R)
         DC    AL2(0),AL2(0),AL2(0)
*
         DC    CL4'SUBE',AL1(FC_RTYP12)         VARIABLE SUB  - EVENT
         DC    AL2(MDLAC11_b8L),AL2(MDLAC11_b8P)
         DC    AL4(MDLAC11_b8),AL4(MDLAC11_b8R)
         DC    AL2(fcsubb8),AL2(0),AL2(0)
*
SUBE_03u DC    CL4'SUBE',AL1(FC_RTYP12)         VARIABLE SUB  - EVENT
         DC    AL2(MDLAC11uL),AL2(MDLAC11uP)
         DC    AL4(MDLAC11u),AL4(MDLAC11uR)
         DC    AL2(FCSUButs),al2(0),AL2(0)      unsigned input
*
         DC    CL4'SUBE',AL1(FC_RTYP12)         VARIABLE SUB  - EVENT
         DC    AL2(MDLAC11_b8L),AL2(MDLAC11_b8P)
         DC    AL4(MDLAC11_b8),AL4(MDLAC11_b8R)
         DC    AL2(fcsubb8),AL2(0),AL2(0)
*
subE_04  DC    CL4'SUBE',AL1(FC_RTYP12)         VARIABLE ADD  - EVENT
         DC    AL2(MDLAC47L),AL2(MDLAC47P)
         DC    AL4(MDLAC47),AL4(MDLAC47R)
         DC    AL2(0),AL2(0),AL2(0)
*
SUBE_05  DC    CL4'SUBE',AL1(FC_RTYP12)         VARIABLE ADD  - EVENT
         DC    AL2(MDLAC48L),AL2(MDLAC48P)
         DC    AL4(MDLAC48),AL4(MDLAC48R)
         DC    AL2(0),AL2(0),AL2(0)
*
         DC    CL4'SUBE',AL1(FC_RTYP12)         VARIABLE ADD  - EVENT
         DC    AL2(MDLAC48_b8L),AL2(MDLAC48_b8P)
         DC    AL4(MDLAC48_b8),AL4(MDLAC48_b8R)
         DC    AL2(0),AL2(0),AL2(0)
*
SUBE_06  DC    CL4'SUBE',AL1(FC_RTYP12)         VARIABLE ADD  - EVENT
         DC    AL2(MDLAC49L),AL2(MDLAC49P)
         DC    AL4(MDLAC49),AL4(MDLAC49R)
         DC    AL2(0),AL2(0),AL2(0)
*
SUBE_07  DC    CL4'SUBE',AL1(FC_RTYP12)         VARIABLE ADD  - EVENT
         DC    AL2(MDLAC50L),AL2(MDLAC50P)
         DC    AL4(MDLAC50),AL4(MDLAC50R)
         DC    AL2(0),AL2(0),AL2(0)
*
SUBA     DC    CL4'SUBA',AL1(FC_RTYP10)         VARIABLE SUB  - ACCUM
         DC    AL2(MDLAC30L),AL2(MDLAC30P)
         DC    AL4(MDLAC30),AL4(MDLAC30R)
         DC    AL2(0),AL2(0),AL2(0)
*
MULC     DC    CL4'MULC',AL1(FC_RTYP10)         VARIABLE MULT - CON
         DC    AL2(MDLAC26L),AL2(MDLAC26P)
         DC    AL4(MDLAC26),AL4(MDLAC26R)
         DC    AL2(0),AL2(0),AL2(0)
*
MULE_01  DC    CL4'MULE',AL1(FC_RTYP12)         VARIABLE MULT - EVENT
         DC    AL2(MDLAC12L),AL2(MDLAC12P)
         DC    AL4(MDLAC12),AL4(MDLAC12R)
         DC    AL2(0),AL2(0),AL2(0)
*
MULE_02  DC    CL4'MULE',AL1(FC_RTYP12)         VARIABLE MULT - EVENT
         DC    AL2(MDLAC13L),AL2(MDLAC13P)
         DC    AL4(MDLAC13),AL4(MDLAC13R)
         DC    AL2(0),AL2(0),AL2(0)
*
MULE_03  DC    CL4'MULE',AL1(FC_RTYP12)         VARIABLE MULT - EVENT
         DC    AL2(MDLAC14L),AL2(MDLAC14P)
         DC    AL4(MDLAC14),AL4(MDLAC14R)
         DC    AL2(0),AL2(0),AL2(0)
*
         DC    CL4'MULE',AL1(FC_RTYP12)         VARIABLE MULT - EVENT
         DC    AL2(MDLAC14_b8L),AL2(MDLAC14_b8P)
         DC    AL4(MDLAC14_b8),AL4(MDLAC14_b8R)
         DC    AL2(fcsubb8),AL2(0),AL2(0)
*
MULE_03u DC    CL4'MULE',AL1(FC_RTYP12)         VARIABLE MULT - EVENT
         DC    AL2(MDLAC14uL),AL2(MDLAC14uP)
         DC    AL4(MDLAC14u),AL4(MDLAC14uR)
         DC    AL2(FCSUButs),al2(0),AL2(0)      unsigned input
*
         DC    CL4'MULE',AL1(FC_RTYP12)         VARIABLE MULT - EVENT
         DC    AL2(MDLAC14_b8L),AL2(MDLAC14_b8P)
         DC    AL4(MDLAC14_b8),AL4(MDLAC14_b8R)
         DC    AL2(fcsubb8),AL2(0),AL2(0)
*
MULE_04  DC    CL4'MULE',AL1(FC_RTYP12)         VARIABLE ADD  - EVENT
         DC    AL2(MDLAC51L),AL2(MDLAC51P)
         DC    AL4(MDLAC51),AL4(MDLAC51R)
         DC    AL2(0),AL2(0),AL2(0)
*
MULE_05  DC    CL4'MULE',AL1(FC_RTYP12)         VARIABLE ADD  - EVENT
         DC    AL2(MDLAC52L),AL2(MDLAC52P)
         DC    AL4(MDLAC52),AL4(MDLAC52R)
         DC    AL2(0),AL2(0),AL2(0)
*
         DC    CL4'MULE',AL1(FC_RTYP12)         VARIABLE ADD  - EVENT
         DC    AL2(MDLAC52_b8L),AL2(MDLAC52_b8P)
         DC    AL4(MDLAC52_b8),AL4(MDLAC52_b8R)
         DC    AL2(0),AL2(0),AL2(0)
*
MULE_06  DC    CL4'MULE',AL1(FC_RTYP12)         VARIABLE ADD  - EVENT
         DC    AL2(MDLAC53L),AL2(MDLAC53P)
         DC    AL4(MDLAC53),AL4(MDLAC53R)
         DC    AL2(0),AL2(0),AL2(0)
*
MULE_07  DC    CL4'MULE',AL1(FC_RTYP12)         VARIABLE ADD  - EVENT
         DC    AL2(MDLAC54L),AL2(MDLAC54P)
         DC    AL4(MDLAC54),AL4(MDLAC54R)
         DC    AL2(0),AL2(0),AL2(0)
*
MULA     DC    CL4'MULA',AL1(FC_RTYP10)         VARIABLE MULT - ACCUM
         DC    AL2(MDLAC31L),AL2(MDLAC31P)
         DC    AL4(MDLAC31),AL4(MDLAC31R)
         DC    AL2(0),AL2(0),AL2(0)
*
DIVC     DC    CL4'DIVC',AL1(FC_RTYP10)         VARIABLE DIV  - CON
         DC    AL2(MDLAC27L),AL2(MDLAC27P)
         DC    AL4(MDLAC27),AL4(MDLAC27R)
         DC    AL2(0),AL2(0),AL2(0)
*
DIVE_01  DC    CL4'DIVE',AL1(FC_RTYP12)         VARIABLE DIVIDE - EVENT
         DC    AL2(MDLAC15L),AL2(MDLAC15P)
         DC    AL4(MDLAC15),AL4(MDLAC15R)
         DC    AL2(0),AL2(0),AL2(0)
*
DIVE_02  DC    CL4'DIVE',AL1(FC_RTYP12)         VARIABLE DIVIDE - EVENT
         DC    AL2(MDLAC16L),AL2(MDLAC16P)
         DC    AL4(MDLAC16),AL4(MDLAC16R)
         DC    AL2(0),AL2(0),AL2(0)
*
DIVE_03  DC    CL4'DIVE',AL1(FC_RTYP12)         VARIABLE DIVIDE - EVENT
         DC    AL2(MDLAC17L),AL2(MDLAC17P)
         DC    AL4(MDLAC17),AL4(MDLAC17R)
         DC    AL2(0),AL2(0),AL2(0)
*
         DC    CL4'DIVE',AL1(FC_RTYP12)         VARIABLE DIVIDE _ event
         DC    AL2(MDLAC17_b8L),AL2(MDLAC17_b8P)
         DC    AL4(MDLAC17_b8),AL4(MDLAC17_b8R)
         DC    AL2(fcsubb8),AL2(0),AL2(0)
*
DIVE_03u DC    CL4'DIVE',AL1(FC_RTYP12)         VARIABLE DIVIDE - EVENT
         DC    AL2(MDLAC17uL),AL2(MDLAC17uP)
         DC    AL4(MDLAC17u),AL4(MDLAC17uR)
         DC    AL2(FCSUButs),al2(0),AL2(0)      unsigned input
*
         DC    CL4'DIVE',AL1(FC_RTYP12)         VARIABLE DIVIDE _ event
         DC    AL2(MDLAC17_b8L),AL2(MDLAC17_b8P)
         DC    AL4(MDLAC17_b8),AL4(MDLAC17_b8R)
         DC    AL2(fcsubb8),AL2(0),AL2(0)
*
DIVE_04  DC    CL4'DIVE',AL1(FC_RTYP12)         VARIABLE ADD  - EVENT
         DC    AL2(MDLAC55L),AL2(MDLAC55P)
         DC    AL4(MDLAC55),AL4(MDLAC55R)
         DC    AL2(0),AL2(0),AL2(0)
*
DIVE_05  DC    CL4'DIVE',AL1(FC_RTYP12)         VARIABLE ADD  - EVENT
         DC    AL2(MDLAC56L),AL2(MDLAC56P)
         DC    AL4(MDLAC56),AL4(MDLAC56R)
         DC    AL2(0),AL2(0),AL2(0)
*
         DC    CL4'DIVE',AL1(FC_RTYP12)         VARIABLE ADD  - EVENT
         DC    AL2(MDLAC56_b8L),AL2(MDLAC56_b8P)
         DC    AL4(MDLAC56_b8),AL4(MDLAC56_b8R)
         DC    AL2(0),AL2(0),AL2(0)
*
DIVE_06  DC    CL4'DIVE',AL1(FC_RTYP12)         VARIABLE ADD  - EVENT
         DC    AL2(MDLAC57L),AL2(MDLAC57P)
         DC    AL4(MDLAC57),AL4(MDLAC57R)
         DC    AL2(0),AL2(0),AL2(0)
*
DIVE_07  DC    CL4'DIVE',AL1(FC_RTYP12)         VARIABLE ADD  - EVENT
         DC    AL2(MDLAC58L),AL2(MDLAC58P)
         DC    AL4(MDLAC58),AL4(MDLAC58R)
         DC    AL2(0),AL2(0),AL2(0)
*
*
DIVA     DC    CL4'DIVA',AL1(FC_RTYP10)         VARIABLE DIV  - ACCUM
         DC    AL2(MDLAC32L),AL2(MDLAC32P)
         DC    AL4(MDLAC32),AL4(MDLAC32R)
         DC    AL2(0),AL2(0),AL2(0)
*
***********************************************************************
*        Substring compare - SFx TO CONSTANT                          *
***********************************************************************
sf_xc_01 DC    CL4'SFxC',AL1(FC_RTYP04)                COMPARE
         DC    AL2(MDLSFXCL),AL2(MDLSFXCP)
         DC    AL4(MDLSFXC),AL4(MDLSFXCR)
         DC    AL2(0),AL2(0),AL2(0)
*
***********************************************************************
*        Substring compare - SFC TO x                                 *
**********su***********************************************************
sf_cx_01 DC    CL4'SFCx',AL1(FC_RTYP04)                COMPARE
         DC    AL2(MDLSFCXL),AL2(MDLSFCXP)
         DC    AL4(MDLSFCX),AL4(MDLSFCXR)
         DC    AL2(0),AL2(0),AL2(0)
*
***********************************************************************
*        Substring compare - SFx TO x                                 *
**********su***********************************************************
sf_xx_01 DC    CL4'SFxx',AL1(FC_RTYP05)                COMPARE
         DC    AL2(MDLSFxXL),AL2(MDLSFxXP)
         DC    AL4(MDLSFxX),AL4(MDLSFxxR)
         DC    AL2(0),AL2(0),AL2(0)
*
***********************************************************************
*        COMPARE FIELD  -  CONSTANT TO CONSTANT                       *
***********************************************************************
CF_CC_01 DC    CL4'CFCC',AL1(FC_RTYP04)                COMPARE
         DC    AL2(MDLCFC0L),AL2(MDLCFC0P)
         DC    AL4(MDLCFC0),AL4(MDLCFC0R)
         DC    AL2(0),AL2(0),AL2(0)
*
***********************************************************************
*        COMPARE FIELD  -  EVENT TO CONSTANT                          *
***********************************************************************
CF_EC_01 DC    CL4'CFEC',AL1(FC_RTYP04)                COMPARE
         DC    AL2(MDLCFC1L),AL2(MDLCFC1P)
         DC    AL4(MDLCFC1),AL4(MDLCFC1R)
         DC    AL2(0),AL2(0),AL2(0)
*
         DC    CL4'CFEC',AL1(FC_RTYP04)            for any bin8s
         DC    AL2(MDLCFC1L),AL2(MDLCFC1P)
         DC    AL4(MDLCFC1),AL4(MDLCFC1R)
         DC    AL2(0),AL2(0),AL2(0)
*
CF_EC_02 DC    CL4'CFEC',AL1(FC_RTYP04)                COMPARE
         DC    AL2(MDLCFC2L),AL2(MDLCFC2P)
         DC    AL4(MDLCFC2),AL4(MDLCFC2R)
         DC    AL2(0),AL2(0),AL2(0)
*
CF_EC_03 DC    CL4'CFEC',AL1(FC_RTYP04)                COMPARE
         DC    AL2(MDLCFC3L),AL2(MDLCFC3P)
         DC    AL4(MDLCFC3),AL4(MDLCFC3R)
         DC    AL2(0),AL2(0),AL2(0)
*
CF_EC_04 DC    CL4'CFEC',AL1(FC_RTYP04)                COMPARE
         DC    AL2(MDLCFC4L),AL2(MDLCFC4P)
         DC    AL4(MDLCFC4),AL4(MDLCFC4R)
         DC    AL2(0),AL2(0),AL2(0)
*
CF_EC_05u DC    CL4'CFEC',AL1(FC_RTYP04)                COMPARE
         DC    AL2(MDLCFC5uL),AL2(MDLCFC5uP)
         DC    AL4(MDLCFC5u),AL4(MDLCFC5uR)
         DC    AL2(0),AL2(0),AL2(0)
*
         DC    CL4'CFEC',AL1(FC_RTYP04)                COMPARE
         DC    AL2(MDLCFc5_88L),AL2(MDLCFc5_88P)
         DC    AL4(MDLCFc5_88),AL4(MDLCFc5_88R)
         DC    AL2(0),AL2(0),AL2(0)
*
CF_EC_05 DC    CL4'CFEC',AL1(FC_RTYP04)                COMPARE
         DC    AL2(MDLCFC5L),AL2(MDLCFC5P)
         DC    AL4(MDLCFC5),AL4(MDLCFC5R)
         DC    AL2(0),AL2(0),AL2(0)
*
         DC    CL4'CFEC',AL1(FC_RTYP04)                COMPARE
         DC    AL2(MDLCFc5_88L),AL2(MDLCFc5_88P)
         DC    AL4(MDLCFc5_88),AL4(MDLCFc5_88R)
         DC    AL2(0),AL2(0),AL2(0)
*
CF_EC_06 DC    CL4'CFEC',AL1(FC_RTYP04)                COMPARE
         DC    AL2(MDLCFC6L),AL2(MDLCFC6P)
         DC    AL4(MDLCFC6),AL4(MDLCFC6R)
         DC    AL2(0),AL2(0),AL2(0)
*
         DC    CL4'CFEC',AL1(FC_RTYP04)                COMPARE
         DC    AL2(MDLCFc6_88L),AL2(MDLCFc6_88P)
         DC    AL4(MDLCFc6_88),AL4(MDLCFc6_88R)
         DC    AL2(0),AL2(0),AL2(0)
*
CF_EC_07 DC    CL4'CFEC',AL1(FC_RTYP04)                COMPARE
         DC    AL2(MDLCF57L),AL2(MDLCF57P)
         DC    AL4(MDLCF57),AL4(MDLCF57R)
         DC    AL2(0),AL2(0),AL2(0)
*
CF_EC_08 DC    CL4'CFEC',AL1(FC_RTYP04)                COMPARE
         DC    AL2(MDLCFc8L),AL2(MDLCFc8P)
         DC    AL4(MDLCFc8),AL4(MDLCFc8R)
         DC    AL2(0),AL2(0),AL2(0)
*
         entry cf_ec_09
CF_EC_09 alias c'CFXCDATE'
CF_EC_09 DC    CL4'CFEC',AL1(FC_RTYP04)                CFEC date
         DC    AL2(MDLCFC9L),AL2(MDLCFC9P)
         DC    AL4(MDLCFC9),AL4(MDLCFC9R)
         DC    AL2(0),AL2(0),AL2(0)
*
cf_ce_01 DC    CL4'CFCx',AL1(FC_RTYP04)                COMPARE
         DC    AL2(MDLCFCx1L),AL2(MDLCFCx1P)
         DC    AL4(MDLCFCx1),AL4(MDLCFCx1R)
         DC    AL2(0),AL2(0),AL2(0)
*
         DC    CL4'CFCx',AL1(FC_RTYP04)            for any bin8s
         DC    AL2(MDLCFCx1L),AL2(MDLCFCx1P)
         DC    AL4(MDLCFCx1),AL4(MDLCFCx1R)
         DC    AL2(0),AL2(0),AL2(0)
*
cf_ce_02 DC    CL4'CFCx',AL1(FC_RTYP04)                COMPARE
         DC    AL2(MDLCFCx2L),AL2(MDLCFCx2P)
         DC    AL4(MDLCFCx2),AL4(MDLCFCx2R)
         DC    AL2(0),AL2(0),AL2(0)
*
cf_ce_03 DC    CL4'CFCx',AL1(FC_RTYP04)                COMPARE
         DC    AL2(MDLCFCx3L),AL2(MDLCFCx3P)
         DC    AL4(MDLCFCx3),AL4(MDLCFCx3R)
         DC    AL2(0),AL2(0),AL2(0)
*
cf_ce_04 DC    CL4'CFCx',AL1(FC_RTYP04)                COMPARE
         DC    AL2(MDLCFCx4L),AL2(MDLCFCx4P)
         DC    AL4(MDLCFCx4),AL4(MDLCFCx4R)
         DC    AL2(0),AL2(0),AL2(0)
*
cf_ce_05u DC    CL4'CFCx',AL1(FC_RTYP04)                COMPARE
         DC    AL2(MDLCFCx5uL),AL2(MDLCFCx5uP)
         DC    AL4(MDLCFCx5u),AL4(MDLCFCx5uR)
         DC    AL2(0),AL2(0),AL2(0)
*
         DC    CL4'CFCx',AL1(FC_RTYP04)                COMPARE
         DC    AL2(MDLCFCx5_88L),AL2(MDLCFCx5_88P)
         DC    AL4(MDLCFCx5_88),AL4(MDLCFCx5_88R)
         DC    AL2(0),AL2(0),AL2(0)
*
cf_ce_05 DC    CL4'CFCx',AL1(FC_RTYP04)                COMPARE
         DC    AL2(MDLCFCx5L),AL2(MDLCFCx5P)
         DC    AL4(MDLCFCx5),AL4(MDLCFCx5R)
         DC    AL2(0),AL2(0),AL2(0)
*
         DC    CL4'CFCx',AL1(FC_RTYP04)                COMPARE
         DC    AL2(MDLCFCx5_88L),AL2(MDLCFCx5_88P)
         DC    AL4(MDLCFCx5_88),AL4(MDLCFCx5_88R)
         DC    AL2(0),AL2(0),AL2(0)
*
cf_ce_06 DC    CL4'CFCx',AL1(FC_RTYP04)                COMPARE
         DC    AL2(MDLCFCx6L),AL2(MDLCFCx6P)
         DC    AL4(MDLCFCx6),AL4(MDLCFCx6R)
         DC    AL2(0),AL2(0),AL2(0)
*
         DC    CL4'CFCx',AL1(FC_RTYP04)                COMPARE
         DC    AL2(MDLCFCx6_88L),AL2(MDLCFCx6_88P)
         DC    AL4(MDLCFCx6_88),AL4(MDLCFCx6_88R)
         DC    AL2(0),AL2(0),AL2(0)
*
cf_ce_07 DC    CL4'CFCx',AL1(FC_RTYP04)                COMPARE
         DC    AL2(MDLCFx7L),AL2(MDLCFx7P)
         DC    AL4(MDLCFx7),AL4(MDLCFx7R)
         DC    AL2(0),AL2(0),AL2(0)
*
cf_ce_08 DC    CL4'CFCx',AL1(FC_RTYP04)                COMPARE
         DC    AL2(MDLCFCx8L),AL2(MDLCFCx8P)
         DC    AL4(MDLCFCx8),AL4(MDLCFCx8R)
         DC    AL2(0),AL2(0),AL2(0)
*
         entry cf_ce_09
CF_CE_09 alias c'CFCXDATE'
cf_ce_09 DC    CL4'CFCx',AL1(FC_RTYP04)                COMPARE
         DC    AL2(MDLCFCx9L),AL2(MDLCFCx9P)
         DC    AL4(MDLCFCx9),AL4(MDLCFCx9R)
         DC    AL2(0),AL2(0),AL2(0)
*
cf_ax_01 DC    CL4'CFAx',AL1(FC_RTYP04)                COMPARE
         DC    AL2(MDLCFAx1L),AL2(MDLCFAx1P)
         DC    AL4(MDLCFAx1),AL4(MDLCFAx1R)
         DC    AL2(0),AL2(0),AL2(0)
*
         DC    CL4'CFAx',AL1(FC_RTYP04)            for any bin8s
         DC    AL2(MDLCFAx1L),AL2(MDLCFAx1P)
         DC    AL4(MDLCFAx1),AL4(MDLCFAx1R)
         DC    AL2(0),AL2(0),AL2(0)
*
cf_ax_02 DC    CL4'CFAx',AL1(FC_RTYP04)                COMPARE
         DC    AL2(MDLCFAx2L),AL2(MDLCFAx2P)
         DC    AL4(MDLCFAx2),AL4(MDLCFAx2R)
         DC    AL2(0),AL2(0),AL2(0)
*
cf_ax_03 DC    CL4'CFAx',AL1(FC_RTYP04)                COMPARE
         DC    AL2(MDLCFAx3L),AL2(MDLCFAx3P)
         DC    AL4(MDLCFAx3),AL4(MDLCFAx3R)
         DC    AL2(0),AL2(0),AL2(0)
*
cf_ax_04 DC    CL4'CFAx',AL1(FC_RTYP04)                COMPARE
         DC    AL2(MDLCFAx4L),AL2(MDLCFAx4P)
         DC    AL4(MDLCFAx4),AL4(MDLCFAx4R)
         DC    AL2(0),AL2(0),AL2(0)
*
cf_ax_05u DC    CL4'CFAx',AL1(FC_RTYP04)                COMPARE
         DC    AL2(MDLCFAx5uL),AL2(MDLCFAx5uP)
         DC    AL4(MDLCFAx5u),AL4(MDLCFAx5uR)
         DC    AL2(0),AL2(0),AL2(0)
*
         DC    CL4'CFAx',AL1(FC_RTYP04)                COMPARE
         DC    AL2(MDLCFAx5_88L),AL2(MDLCFAx5_88P)
         DC    AL4(MDLCFAx5_88),AL4(MDLCFAx5_88R)
         DC    AL2(0),AL2(0),AL2(0)
*
cf_ax_05 DC    CL4'CFAx',AL1(FC_RTYP04)                COMPARE
         DC    AL2(MDLCFAx5L),AL2(MDLCFAx5P)
         DC    AL4(MDLCFAx5),AL4(MDLCFAx5R)
         DC    AL2(0),AL2(0),AL2(0)
*
         DC    CL4'CFAx',AL1(FC_RTYP04)                COMPARE
         DC    AL2(MDLCFAx5_88L),AL2(MDLCFAx5_88P)
         DC    AL4(MDLCFAx5_88),AL4(MDLCFAx5_88R)
         DC    AL2(0),AL2(0),AL2(0)
*
cf_ax_06 DC    CL4'CFAx',AL1(FC_RTYP04)                COMPARE
         DC    AL2(MDLCFAx6L),AL2(MDLCFAx6P)
         DC    AL4(MDLCFAx6),AL4(MDLCFAx6R)
         DC    AL2(0),AL2(0),AL2(0)
*
         DC    CL4'CFAx',AL1(FC_RTYP04)                COMPARE
         DC    AL2(MDLCFAx6_88L),AL2(MDLCFAx6_88P)
         DC    AL4(MDLCFAx6_88),AL4(MDLCFAx6_88R)
         DC    AL2(0),AL2(0),AL2(0)
*
cf_ax_07 DC    CL4'CFAx',AL1(FC_RTYP04)                COMPARE
         DC    AL2(MDLCFAx7L),AL2(MDLCFAx7P)
         DC    AL4(MDLCFAx7),AL4(MDLCFAx7R)
         DC    AL2(0),AL2(0),AL2(0)
*
cf_ax_08 DC    CL4'CFAx',AL1(FC_RTYP04)                COMPARE
         DC    AL2(MDLCFAx8L),AL2(MDLCFAx8P)
         DC    AL4(MDLCFAx8),AL4(MDLCFAx8R)
         DC    AL2(0),AL2(0),AL2(0)
*
                        EJECT
***********************************************************************
*        COMPARE FIELD  -  EVENT TO EVENT                             *
*        Note: The label name denotes cfxx_target_source              *
***********************************************************************
cfxx_alnum_alnum equ cf_ee_01
cfxx_num_alnum   equ cf_ee_01
cfxx_pack_alnum  equ cf_ee_01
cfxx_sortp_alnum equ cf_ee_01
cfuu_bin_alnum   equ cf_ee_01
cfsu_bin_alnum   equ cf_ee_01
cfus_bin_alnum   equ cf_ee_01
cfss_bin_alnum   equ cf_ee_01
cfxx_sortb_alnum equ cf_ee_01
cfxx_bcd_alnum   equ cf_ee_01
cfxx_edit_alnum  equ cf_ee_01
CF_EE_01 DC    CL4'CFEE',AL1(FC_RTYP05)                COMPARE
         DC    AL2(MDLCF01L),AL2(MDLCF01P)           DIFF LENGTH
         DC    AL4(MDLCF01),AL4(MDLCF01R)
         DC    AL2(0),AL2(0),AL2(0)
*
         DC    CL4'CFEE',AL1(FC_RTYP05)                COMPARE
         DC    AL2(MDLCF01L),AL2(MDLCF01P)           DIFF LENGTH
         DC    AL4(MDLCF01),AL4(MDLCF01R)
         DC    AL2(0),AL2(0),AL2(0)
*
cfxx_sortp_num   DC CL4'CFEE',AL1(FC_RTYP05)            COMPARE
         DC    AL2(MDLCF19L),AL2(MDLCF19P)
         DC    AL4(MDLCF19),AL4(MDLCF19R)
         DC    AL2(0),AL2(0),AL2(0)
*
cfxx_sortp_pack  DC CL4'CFEE',AL1(FC_RTYP05)            COMPARE
         DC    AL2(MDLCF28L),AL2(MDLCF28P)
         DC    AL4(MDLCF28),AL4(MDLCF28R)
         DC    AL2(0),AL2(0),AL2(0)
*
cfxx_sortp_sortp DC CL4'CFEE',AL1(FC_RTYP05)            COMPARE
         DC    AL2(MDLCF29L),AL2(MDLCF29P)
         DC    AL4(MDLCF29),AL4(MDLCF29R)
         DC    AL2(0),AL2(0),AL2(0)
*
cfxx_sortp_binu  DC CL4'CFEE',AL1(FC_RTYP05)            COMPARE
         DC    AL2(MDLCF38uL),AL2(MDLCF38uP)
         DC    AL4(MDLCF38u),AL4(MDLCF38uR)
         DC    AL2(0),AL2(0),AL2(0)
*
                 DC CL4'CFEE',AL1(FC_RTYP05)            COMPARE
         DC    AL2(MDLCF38_b8L),AL2(MDLCF38_b8P)
         DC    AL4(MDLCF38_b8),AL4(MDLCF38_b8R)
         DC    AL2(0),AL2(0),AL2(0)
*
cfxx_sortp_bins DC CL4'CFEE',AL1(FC_RTYP05)            COMPARE
         DC    AL2(MDLCF38L),AL2(MDLCF38P)
         DC    AL4(MDLCF38),AL4(MDLCF38R)
         DC    AL2(0),AL2(0),AL2(0)
*
                 DC CL4'CFEE',AL1(FC_RTYP05)            COMPARE
         DC    AL2(MDLCF38_b8L),AL2(MDLCF38_b8P)
         DC    AL4(MDLCF38_b8),AL4(MDLCF38_b8R)
         DC    AL2(0),AL2(0),AL2(0)
*
cfxx_sortp_sortb DC CL4'CFEE',AL1(FC_RTYP05)            COMPARE
         DC    AL2(MDLCF39L),AL2(MDLCF39P)
         DC    AL4(MDLCF39),AL4(MDLCF39R)
         DC    AL2(0),AL2(0),AL2(0)
*
                 DC CL4'CFEE',AL1(FC_RTYP05)            COMPARE
         DC    AL2(MDLCF39_b8L),AL2(MDLCF39_b8P)
         DC    AL4(MDLCF39_b8),AL4(MDLCF39_b8R)
         DC    AL2(0),AL2(0),AL2(0)
*
cfxx_sortp_bcd  DC CL4'CFEE',AL1(FC_RTYP05)            COMPARE
         DC    AL2(MDLCF40L),AL2(MDLCF40P)
         DC    AL4(MDLCF40),AL4(MDLCF40R)
         DC    AL2(0),AL2(0),AL2(0)
*
cfxx_sortp_edit  DC CL4'CFEE',AL1(FC_RTYP05)            COMPARE
        DC    AL2(MDLCF33L),AL2(MDLCF33P)
        DC    AL4(MDLCF33),AL4(MDLCF33R)
        DC    AL2(0),AL2(0),AL2(0)
*
cfus_bin_num  equ cfuu_bin_num
cfuu_bin_num  DC    CL4'CFEE',AL1(FC_RTYP05)                COMPARE
         DC    AL2(MDLCF09uL),AL2(MDLCF09uP)
         DC    AL4(MDLCF09u),AL4(MDLCF09uR)
         DC    AL2(0),AL2(0),AL2(0)
*
         DC    CL4'CFEE',AL1(FC_RTYP05)                COMPARE
         DC    AL2(MDLCF09_b8L),AL2(MDLCF09_b8P)
         DC    AL4(MDLCF09_b8),AL4(MDLCF09_b8R)
         DC    AL2(fcsubb8),AL2(0),AL2(0)
*
cfus_bin_pack equ cfuu_bin_pack
cfuu_bin_pack DC    CL4'CFEE',AL1(FC_RTYP05)                COMPARE
         DC    AL2(MDLCF05uL),AL2(MDLCF05uP)
         DC    AL4(MDLCF05u),AL4(MDLCF05uR)
         DC    AL2(0),AL2(0),AL2(0)
*
         DC    CL4'CFEE',AL1(FC_RTYP05)                COMPARE
         DC    AL2(MDLcf05_b8L),AL2(MDLcf05_b8P)
         DC    AL4(MDLcf05_b8),AL4(MDLcf05_b8R)
         DC    AL2(fcsubb8),AL2(0),AL2(0)
*
cfus_bin_sortp equ cfuu_bin_sortp
cfuu_bin_sortp   DC CL4'CFEE',AL1(FC_RTYP05)            COMPARE
         DC    AL2(MDLCF34uL),AL2(MDLCF34uP)
         DC    AL4(MDLCF34u),AL4(MDLCF34uR)
         DC    AL2(0),AL2(0),AL2(0)
*
                 DC CL4'CFEE',AL1(FC_RTYP05)            COMPARE
         DC    AL2(MDLCF34_b8L),AL2(MDLCF34_b8P)
         DC    AL4(MDLCF34_b8),AL4(MDLCF34_b8R)
         DC    AL2(0),AL2(0),AL2(0)
*
cfus_bin_bin    DC CL4'CFEE',AL1(FC_RTYP05)            COMPARE
         DC    AL2(MDLCF13usL),AL2(MDLCF13usP)
         DC    AL4(MDLCF13us),AL4(MDLCF13usR)
         DC    AL2(FCSUBBSN),AL2(0),AL2(0)
*
         DC    CL4'CFEE',AL1(FC_RTYP05)                COMPARE
         DC    AL2(MDLCF13us_b8L),AL2(MDLCF13us_b8P)
         DC    AL4(MDLCF13us_b8),AL4(MDLCF13us_b8R)
         DC    AL2(fcsubbsn),AL2(0),al2(1)
*
         DC    CL4'CFEE',AL1(FC_RTYP05)                COMPARE
         DC    AL2(MDLCF13us_8bL),AL2(MDLCF13us_8bP)
         DC    AL4(MDLCF13us_8b),AL4(MDLCF13us_8bR)
         DC    AL2(fcsubbsn),AL2(0),al2(1)
*
         DC    CL4'CFEE',AL1(FC_RTYP05)                COMPARE
         DC    AL2(MDLCF13_88L),AL2(MDLCF13_88P)
         DC    AL4(MDLCF13_88),AL4(MDLCF13_88R)
         DC    AL2(fcsubbsn),AL2(0),al2(1)
*
cfuu_bin_bin    DC CL4'CFEE',AL1(FC_RTYP05)            COMPARE
         DC    AL2(MDLCF13uuL),AL2(MDLCF13uuP)
         DC    AL4(MDLCF13uu),AL4(MDLCF13uuR)
         DC    AL2(FCSUBBSN),AL2(0),AL2(0)
*
         DC    CL4'CFEE',AL1(FC_RTYP05)                COMPARE
         DC    AL2(MDLCF13uu_b8L),AL2(MDLCF13uu_b8P)
         DC    AL4(MDLCF13uu_b8),AL4(MDLCF13uu_b8R)
         DC    AL2(fcsubbsn),AL2(0),al2(1)
*
         DC    CL4'CFEE',AL1(FC_RTYP05)                COMPARE
         DC    AL2(MDLCF13uu_8bL),AL2(MDLCF13uu_8bP)
         DC    AL4(MDLCF13uu_8b),AL4(MDLCF13uu_8bR)
         DC    AL2(fcsubbsn),AL2(0),al2(1)
*
         DC    CL4'CFEE',AL1(FC_RTYP05)                COMPARE
         DC    AL2(MDLCF13_88L),AL2(MDLCF13_88P)
         DC    AL4(MDLCF13_88),AL4(MDLCF13_88R)
         DC    AL2(fcsubbsn),AL2(0),al2(1)
*
cfus_bin_sortb equ cfuu_bin_sortb
cfuu_bin_sortb DC CL4'CFEE',AL1(FC_RTYP05)                COMPARE
         DC    AL2(mdlcf35uL),AL2(mdlcf35uP)
         DC    AL4(mdlcf35u),AL4(mdlcf35uR)
         DC    AL2(FCSUBBSN),AL2(0),AL2(0)
*
         DC    CL4'CFEE',AL1(FC_RTYP05)                COMPARE
         DC    AL2(mdlcf35_b8L),AL2(mdlcf35_b8P)
         DC    AL4(mdlcf35_b8),AL4(mdlcf35_b8R)
         DC    AL2(fcsubbsn),AL2(0),al2(1)
*
         DC    CL4'CFEE',AL1(FC_RTYP05)                COMPARE
         DC    AL2(mdlcf35u_8bL),AL2(mdlcf35u_8bP)
         DC    AL4(mdlcf35u_8b),AL4(mdlcf35u_8bR)
         DC    AL2(fcsubbsn),AL2(0),al2(1)
*
         DC    CL4'CFEE',AL1(FC_RTYP05)                COMPARE
         DC    AL2(mdlcf35_88L),AL2(mdlcf35_88P)
         DC    AL4(mdlcf35_88),AL4(mdlcf35_88R)
         DC    AL2(fcsubbsn),AL2(0),al2(1)
*
cfus_bin_bcd   equ cfuu_bin_bcd
cfuu_bin_bcd  DC    CL4'CFEE',AL1(FC_RTYP05)                COMPARE
         DC    AL2(MDLCF36uL),AL2(MDLCF36uP)
         DC    AL4(MDLCF36u),AL4(MDLCF36uR)
         DC    AL2(0),AL2(0),AL2(0)
*
         DC    CL4'CFEE',AL1(FC_RTYP05)                COMPARE
         DC    AL2(MDLcf36_b8L),AL2(MDLcf36_b8P)
         DC    AL4(MDLcf36_b8),AL4(MDLcf36_b8R)
         DC    AL2(fcsubb8),AL2(0),AL2(0)
*
cfus_bin_edit  equ cfuu_bin_edit
cfuu_bin_edit DC    CL4'CFEE',AL1(FC_RTYP05)                COMPARE
        DC    AL2(MDLCF37uL),AL2(MDLCF37uP)
        DC    AL4(MDLCF37u),AL4(MDLCF37uR)
        DC    AL2(0),AL2(0),AL2(0)

        DC    CL4'CFEE',AL1(FC_RTYP05)                COMPARE
        DC    AL2(MDLcf37_b8L),AL2(MDLcf37_b8P)
        DC    AL4(MDLcf37_b8),AL4(MDLcf37_b8R)
        DC    AL2(fcsubb8),AL2(0),AL2(0)
*
cfss_bin_num  equ cfsu_bin_num
cfsu_bin_num  DC    CL4'CFEE',AL1(FC_RTYP05)                COMPARE
         DC    AL2(MDLCF09L),AL2(MDLCF09P)
         DC    AL4(MDLCF09),AL4(MDLCF09R)
         DC    AL2(0),AL2(0),AL2(0)
*
         DC    CL4'CFEE',AL1(FC_RTYP05)                COMPARE
         DC    AL2(MDLCF09_b8L),AL2(MDLCF09_b8P)
         DC    AL4(MDLCF09_b8),AL4(MDLCF09_b8R)
         DC    AL2(fcsubb8),AL2(0),AL2(0)
*
cfss_bin_pack equ cfsu_bin_pack
cfsu_bin_pack DC    CL4'CFEE',AL1(FC_RTYP05)                COMPARE
         DC    AL2(MDLCF05L),AL2(MDLCF05P)
         DC    AL4(MDLCF05),AL4(MDLCF05R)
         DC    AL2(0),AL2(0),AL2(0)
*
         DC    CL4'CFEE',AL1(FC_RTYP05)                COMPARE
         DC    AL2(MDLcf05_b8L),AL2(MDLcf05_b8P)
         DC    AL4(MDLcf05_b8),AL4(MDLcf05_b8R)
         DC    AL2(fcsubb8),AL2(0),AL2(0)
*
cfss_bin_sortp equ cfsu_bin_sortp
cfsu_bin_sortp   DC CL4'CFEE',AL1(FC_RTYP05)            COMPARE
         DC    AL2(MDLCF34L),AL2(MDLCF34P)
         DC    AL4(MDLCF34),AL4(MDLCF34R)
         DC    AL2(0),AL2(0),AL2(0)
*
                 DC CL4'CFEE',AL1(FC_RTYP05)            COMPARE
         DC    AL2(MDLCF34_b8L),AL2(MDLCF34_b8P)
         DC    AL4(MDLCF34_b8),AL4(MDLCF34_b8R)
         DC    AL2(0),AL2(0),AL2(0)
*
cfsu_bin_bin  DC CL4'CFEE',AL1(FC_RTYP05)                COMPARE
         DC    AL2(MDLcf13suL),AL2(MDLcf13suP)
         DC    AL4(MDLcf13su),AL4(MDLcf13suR)
         DC    AL2(FCSUBBSN),AL2(0),AL2(0)
*
         DC    CL4'CFEE',AL1(FC_RTYP05)                COMPARE
         DC    AL2(MDLcf13su_b8L),AL2(MDLcf13su_b8P)
         DC    AL4(MDLcf13su_b8),AL4(MDLcf13su_b8R)
         DC    AL2(fcsubbsn),AL2(0),al2(1)
*
         DC    CL4'CFEE',AL1(FC_RTYP05)                COMPARE
         DC    AL2(MDLcf13su_8bL),AL2(MDLcf13su_8bP)
         DC    AL4(MDLcf13su_8b),AL4(MDLcf13su_8bR)
         DC    AL2(fcsubbsn),AL2(0),al2(1)
*
         DC    CL4'CFEE',AL1(FC_RTYP05)                COMPARE
         DC    AL2(MDLCF13_88L),AL2(MDLCF13_88P)
         DC    AL4(MDLCF13_88),AL4(MDLCF13_88R)
         DC    AL2(fcsubbsn),AL2(0),al2(1)
*
cfss_bin_bin  DC CL4'CFEE',AL1(FC_RTYP05)                COMPARE
         DC    AL2(MDLCF13L),AL2(MDLCF13P)
         DC    AL4(MDLCF13),AL4(MDLCF13R)
         DC    AL2(FCSUBBSN),AL2(0),AL2(0)
*
         DC    CL4'CFEE',AL1(FC_RTYP05)                COMPARE
         DC    AL2(MDLCF13_b8L),AL2(MDLCF13_b8P)
         DC    AL4(MDLCF13_b8),AL4(MDLCF13_b8R)
         DC    AL2(fcsubbsn),AL2(0),al2(1)
*
         DC    CL4'CFEE',AL1(FC_RTYP05)                COMPARE
         DC    AL2(MDLCF13_8bL),AL2(MDLCF13_8bP)
         DC    AL4(MDLCF13_8b),AL4(MDLCF13_8bR)
         DC    AL2(fcsubbsn),AL2(0),al2(1)
*
         DC    CL4'CFEE',AL1(FC_RTYP05)                COMPARE
         DC    AL2(MDLCF13_88L),AL2(MDLCF13_88P)
         DC    AL4(MDLCF13_88),AL4(MDLCF13_88R)
         DC    AL2(fcsubbsn),AL2(0),al2(1)
*
cfss_bin_sortb equ cfsu_bin_sortb
cfsu_bin_sortb DC CL4'CFEE',AL1(FC_RTYP05)                COMPARE
         DC    AL2(mdlcf35L),AL2(mdlcf35P)
         DC    AL4(mdlcf35),AL4(mdlcf35R)
         DC    AL2(FCSUBBSN),AL2(0),AL2(0)
*
         DC    CL4'CFEE',AL1(FC_RTYP05)                COMPARE
         DC    AL2(mdlcf35_b8L),AL2(mdlcf35_b8P)
         DC    AL4(mdlcf35_b8),AL4(mdlcf35_b8R)
         DC    AL2(fcsubbsn),AL2(0),al2(1)
*
         DC    CL4'CFEE',AL1(FC_RTYP05)                COMPARE
         DC    AL2(mdlcf35_8bL),AL2(mdlcf35_8bP)
         DC    AL4(mdlcf35_8b),AL4(mdlcf35_8bR)
         DC    AL2(fcsubbsn),AL2(0),al2(1)
*
         DC    CL4'CFEE',AL1(FC_RTYP05)                COMPARE
         DC    AL2(mdlcf35_88L),AL2(mdlcf35_88P)
         DC    AL4(mdlcf35_88),AL4(mdlcf35_88R)
         DC    AL2(fcsubbsn),AL2(0),al2(1)
*
cfss_bin_bcd  equ cfsu_bin_bcd
cfsu_bin_bcd  DC    CL4'CFEE',AL1(FC_RTYP05)                COMPARE
         DC    AL2(MDLCF36L),AL2(MDLCF36P)
         DC    AL4(MDLCF36),AL4(MDLCF36R)
         DC    AL2(0),AL2(0),AL2(0)
*
         DC    CL4'CFEE',AL1(FC_RTYP05)                COMPARE
         DC    AL2(MDLcf36_b8L),AL2(MDLcf36_b8P)
         DC    AL4(MDLcf36_b8),AL4(MDLcf36_b8R)
         DC    AL2(fcsubb8),AL2(0),AL2(0)
*
cfss_bin_edit equ cfsu_bin_edit
cfsu_bin_edit DC    CL4'CFEE',AL1(FC_RTYP05)                COMPARE
        DC    AL2(MDLCF37L),AL2(MDLCF37P)
        DC    AL4(MDLCF37),AL4(MDLCF37R)
        DC    AL2(0),AL2(0),AL2(0)

        DC    CL4'CFEE',AL1(FC_RTYP05)                COMPARE
        DC    AL2(MDLcf37_b8L),AL2(MDLcf37_b8P)
        DC    AL4(MDLcf37_b8),AL4(MDLcf37_b8R)
        DC    AL2(fcsubb8),AL2(0),AL2(0)
*
cfxx_sortb_num DC  CL4'CFEE',AL1(FC_RTYP05)                COMPARE
         DC    AL2(mdlcf83L),AL2(mdlcf83P)
         DC    AL4(mdlcf83),AL4(mdlcf83R)
         DC    AL2(0),AL2(0),AL2(0)
*
         DC    CL4'CFEE',AL1(FC_RTYP05)                COMPARE
         DC    AL2(mdlcf83_b8L),AL2(mdlcf83_b8P)
         DC    AL4(mdlcf83_b8),AL4(mdlcf83_b8R)
         DC    AL2(fcsubb8),AL2(0),AL2(0)
*
cfxx_sortb_pack  DC  CL4'CFEE',AL1(FC_RTYP05)                COMPARE
         DC    AL2(mdlcf84L),AL2(mdlcf84P)
         DC    AL4(mdlcf84),AL4(mdlcf84R)
         DC    AL2(0),AL2(0),AL2(0)
*
         DC    CL4'CFEE',AL1(FC_RTYP05)                COMPARE
         DC    AL2(mdlcf84_b8L),AL2(mdlcf84_b8P)
         DC    AL4(mdlcf84_b8),AL4(mdlcf84_b8R)
         DC    AL2(fcsubb8),AL2(0),AL2(0)
*
cfxx_sortb_sortp DC  CL4'CFEE',AL1(FC_RTYP05)                COMPARE
         DC    AL2(mdlcf85L),AL2(mdlcf85P)
         DC    AL4(mdlcf85),AL4(mdlcf85R)
         DC    AL2(0),AL2(0),AL2(0)
*
         DC    CL4'CFEE',AL1(FC_RTYP05)                COMPARE
         DC    AL2(mdlcf85_b8L),AL2(mdlcf85_b8P)
         DC    AL4(mdlcf85_b8),AL4(mdlcf85_b8R)
         DC    AL2(fcsubb8),AL2(0),AL2(0)
*
cfxx_sortb_binu DC CL4'CFEE',AL1(FC_RTYP05)                COMPARE
         DC    AL2(MDLcf42uL),AL2(MDLcf42uP)
         DC    AL4(MDLcf42u),AL4(MDLcf42uR)
         DC    AL2(FCSUBBSN),AL2(0),AL2(0)
*
         DC    CL4'CFEE',AL1(FC_RTYP05)                COMPARE
         DC    AL2(MDLcf42u_b8L),AL2(MDLcf42u_b8P)
         DC    AL4(MDLcf42u_b8),AL4(MDLcf42u_b8R)
         DC    AL2(fcsubbsn),AL2(0),al2(1)
*
         DC    CL4'CFEE',AL1(FC_RTYP05)                COMPARE
         DC    AL2(MDLcf42_8bL),AL2(MDLcf42_8bP)
         DC    AL4(MDLcf42_8b),AL4(MDLcf42_8bR)
         DC    AL2(fcsubbsn),AL2(0),al2(1)
*
         DC    CL4'CFEE',AL1(FC_RTYP05)                COMPARE
         DC    AL2(MDLcf42_88L),AL2(MDLcf42_88P)
         DC    AL4(MDLcf42_88),AL4(MDLcf42_88R)
         DC    AL2(fcsubbsn),AL2(0),al2(1)
*
cfxx_sortb_bins DC CL4'CFEE',AL1(FC_RTYP05)                COMPARE
         DC    AL2(MDLcf42L),AL2(MDLcf42P)
         DC    AL4(MDLcf42),AL4(MDLcf42R)
         DC    AL2(FCSUBBSN),AL2(0),AL2(0)
*
         DC    CL4'CFEE',AL1(FC_RTYP05)                COMPARE
         DC    AL2(MDLcf42_b8L),AL2(MDLcf42_b8P)
         DC    AL4(MDLcf42_b8),AL4(MDLcf42_b8R)
         DC    AL2(fcsubbsn),AL2(0),al2(1)
*
         DC    CL4'CFEE',AL1(FC_RTYP05)                COMPARE
         DC    AL2(MDLcf42_8bL),AL2(MDLcf42_8bP)
         DC    AL4(MDLcf42_8b),AL4(MDLcf42_8bR)
         DC    AL2(fcsubbsn),AL2(0),al2(1)
*
         DC    CL4'CFEE',AL1(FC_RTYP05)                COMPARE
         DC    AL2(MDLcf42_88L),AL2(MDLcf42_88P)
         DC    AL4(MDLcf42_88),AL4(MDLcf42_88R)
         DC    AL2(fcsubbsn),AL2(0),al2(1)
*
cfxx_sortb_sortb DC CL4'CFEE',AL1(FC_RTYP05)                COMPARE
         DC    AL2(MDLcf46L),AL2(MDLcf46P)
         DC    AL4(MDLcf46),AL4(MDLcf46R)
         DC    AL2(FCSUBBSN),AL2(0),AL2(0)
*
         DC    CL4'CFEE',AL1(FC_RTYP05)                COMPARE
         DC    AL2(MDLcf46_b8L),AL2(MDLcf46_b8P)
         DC    AL4(MDLcf46_b8),AL4(MDLcf46_b8R)
         DC    AL2(fcsubbsn),AL2(0),al2(1)
*
         DC    CL4'CFEE',AL1(FC_RTYP05)                COMPARE
         DC    AL2(MDLcf46_8bL),AL2(MDLcf46_8bP)
         DC    AL4(MDLcf46_8b),AL4(MDLcf46_8bR)
         DC    AL2(fcsubbsn),AL2(0),al2(1)
*
         DC    CL4'CFEE',AL1(FC_RTYP05)                COMPARE
         DC    AL2(MDLcf46_88L),AL2(MDLcf46_88P)
         DC    AL4(MDLcf46_88),AL4(MDLcf46_88R)
         DC    AL2(fcsubbsn),AL2(0),al2(1)
*
cfxx_sortb_bcd  DC  CL4'CFEE',AL1(FC_RTYP05)                COMPARE
         DC    AL2(MDLcf50L),AL2(MDLcf50P)
         DC    AL4(MDLcf50),AL4(MDLcf50R)
         DC    AL2(0),AL2(0),AL2(0)
*
         DC    CL4'CFEE',AL1(FC_RTYP05)                COMPARE
         DC    AL2(MDLcf50_b8L),AL2(MDLcf50_b8P)
         DC    AL4(MDLcf50_b8),AL4(MDLcf50_b8R)
         DC    AL2(fcsubb8),AL2(0),AL2(0)
*
cfxx_sortb_edit  DC  CL4'CFEE',AL1(FC_RTYP05)                COMPARE
        DC    AL2(MDLcf54L),AL2(MDLcf54P)
        DC    AL4(MDLcf54),AL4(MDLcf54R)
        DC    AL2(0),AL2(0),AL2(0)

        DC    CL4'CFEE',AL1(FC_RTYP05)                COMPARE
        DC    AL2(MDLcf54_b8L),AL2(MDLcf54_b8P)
        DC    AL4(MDLcf54_b8),AL4(MDLcf54_b8R)
        DC    AL2(fcsubb8),AL2(0),AL2(0)
*
cfxx_bcd_num   DC  CL4'CFEE',AL1(FC_RTYP05)                COMPARE
         DC    AL2(MDLCF55L),AL2(MDLCF55P)
         DC    AL4(MDLCF55),AL4(MDLCF55R)
         DC    AL2(0),AL2(0),AL2(0)
*
cfxx_bcd_pack  DC  CL4'CFEE',AL1(FC_RTYP05)                COMPARE
         DC    AL2(MDLCF56L),AL2(MDLCF56P)
         DC    AL4(MDLCF56),AL4(MDLCF56R)
         DC    AL2(0),AL2(0),AL2(0)
*
cfxx_bcd_sortp DC  CL4'CFEE',AL1(FC_RTYP05)                COMPARE
         DC    AL2(MDLCF66L),AL2(MDLCF66P)
         DC    AL4(MDLCF66),AL4(MDLCF66R)
         DC    AL2(0),AL2(0),AL2(0)
*
cfxx_bcd_bins DC    CL4'CFEE',AL1(FC_RTYP05)                COMPARE
         DC    AL2(MDLCF67L),AL2(MDLCF67P)
         DC    AL4(MDLCF67),AL4(MDLCF67R)
         DC    AL2(0),AL2(0),AL2(0)
*
         DC    CL4'CFEE',AL1(FC_RTYP05)                COMPARE
         DC    AL2(MDLcf67_b8L),AL2(MDLcf67_b8P)
         DC    AL4(MDLcf67_b8),AL4(MDLcf67_b8R)
         DC    AL2(fcsubb8),AL2(0),AL2(0)
*
*
cfxx_bcd_binu DC    CL4'CFEE',AL1(FC_RTYP05)                COMPARE
         DC    AL2(MDLCF67uL),AL2(MDLCF67uP)
         DC    AL4(MDLCF67u),AL4(MDLCF67uR)
         DC    AL2(0),AL2(0),AL2(0)
*
         DC    CL4'CFEE',AL1(FC_RTYP05)                COMPARE
         DC    AL2(MDLcf67_b8L),AL2(MDLcf67_b8P)
         DC    AL4(MDLcf67_b8),AL4(MDLcf67_b8R)
         DC    AL2(fcsubb8),AL2(0),AL2(0)
*
cfxx_bcd_sortb  DC    CL4'CFEE',AL1(FC_RTYP05)                COMPARE
         DC    AL2(MDLCF68L),AL2(MDLCF68P)
         DC    AL4(MDLCF68),AL4(MDLCF68R)
         DC    AL2(0),AL2(0),AL2(0)
*
         DC    CL4'CFEE',AL1(FC_RTYP05)                COMPARE
         DC    AL2(MDLcf68_b8L),AL2(MDLcf68_b8P)
         DC    AL4(MDLcf68_b8),AL4(MDLcf68_b8R)
         DC    AL2(fcsubb8),AL2(0),AL2(0)
*
cfxx_bcd_bcd   DC  CL4'CFEE',AL1(FC_RTYP05)                COMPARE
         DC    AL2(MDLCF69L),AL2(MDLCF69P)
         DC    AL4(MDLCF69),AL4(MDLCF69R)
         DC    AL2(0),AL2(0),AL2(0)
*
cfxx_bcd_edit  DC  CL4'CFEE',AL1(FC_RTYP05)                COMPARE
        DC    AL2(MDLCF75L),AL2(MDLCF75P)
        DC    AL4(MDLCF75),AL4(MDLCF75R)
        DC    AL2(0),AL2(0),AL2(0)

cfxx_edit_num  DC  CL4'CFEE',AL1(FC_RTYP05)                COMPARE
         DC    AL2(MDLCF76L),AL2(MDLCF76P)
         DC    AL4(MDLCF76),AL4(MDLCF76R)
         DC    AL2(0),AL2(0),AL2(0)

cfxx_edit_pack DC  CL4'CFEE',AL1(FC_RTYP05)                COMPARE
        DC    AL2(MDLCF77L),AL2(MDLCF77P)
        DC    AL4(MDLCF77),AL4(MDLCF77R)
        DC    AL2(0),AL2(0),AL2(0)

cfxx_edit_sortp DC  CL4'CFEE',AL1(FC_RTYP05)                COMPARE
        DC    AL2(MDLCF78L),AL2(MDLCF78P)
        DC    AL4(MDLCF78),AL4(MDLCF78R)
        DC    AL2(0),AL2(0),AL2(0)

cfxx_edit_bins DC    CL4'CFEE',AL1(FC_RTYP05)                COMPARE
        DC    AL2(MDLCF79L),AL2(MDLCF79P)
        DC    AL4(MDLCF79),AL4(MDLCF79R)
        DC    AL2(0),AL2(0),AL2(0)

        DC    CL4'CFEE',AL1(FC_RTYP05)                COMPARE
        DC    AL2(MDLcf79_b8L),AL2(MDLcf79_b8P)
        DC    AL4(MDLcf79_b8),AL4(MDLcf79_b8R)
        DC    AL2(fcsubb8),AL2(0),AL2(0)

cfxx_edit_binu DC    CL4'CFEE',AL1(FC_RTYP05)                COMPARE
        DC    AL2(MDLCF79uL),AL2(MDLCF79uP)
        DC    AL4(MDLCF79u),AL4(MDLCF79uR)
        DC    AL2(0),AL2(0),AL2(0)

        DC    CL4'CFEE',AL1(FC_RTYP05)                COMPARE
        DC    AL2(MDLcf79_b8L),AL2(MDLcf79_b8P)
        DC    AL4(MDLcf79_b8),AL4(MDLcf79_b8R)
        DC    AL2(fcsubb8),AL2(0),AL2(0)

cfxx_edit_sortb  DC    CL4'CFEE',AL1(FC_RTYP05)                COMPARE
        DC    AL2(MDLCF80L),AL2(MDLCF80P)
        DC    AL4(MDLCF80),AL4(MDLCF80R)
        DC    AL2(0),AL2(0),AL2(0)

        DC    CL4'CFEE',AL1(FC_RTYP05)                COMPARE
        DC    AL2(MDLcf80_b8L),AL2(MDLcf80_b8P)
        DC    AL4(MDLcf80_b8),AL4(MDLcf80_b8R)
        DC    AL2(fcsubb8),AL2(0),AL2(0)

cfxx_edit_bcd   DC  CL4'CFEE',AL1(FC_RTYP05)                COMPARE
        DC    AL2(MDLCF81L),AL2(MDLCF81P)
        DC    AL4(MDLCF81),AL4(MDLCF81R)
        DC    AL2(0),AL2(0),AL2(0)

cfxx_edit_edit  DC  CL4'CFEE',AL1(FC_RTYP05)                COMPARE
        DC    AL2(MDLCF82L),AL2(MDLCF82P)
        DC    AL4(MDLCF82),AL4(MDLCF82R)
        DC    AL2(0),AL2(0),AL2(0)

*
cfxx_pack_num  DC    CL4'CFEE',AL1(FC_RTYP05)                COMPARE
         DC    AL2(MDLCF07L),AL2(MDLCF07P)
         DC    AL4(MDLCF07),AL4(MDLCF07R)
         DC    AL2(0),AL2(0),AL2(0)
*
cfxx_pack_pack DC    CL4'CFEE',AL1(FC_RTYP05)                COMPARE
         DC    AL2(MDLCF03L),AL2(MDLCF03P)
         DC    AL4(MDLCF03),AL4(MDLCF03R)
         DC    AL2(0),AL2(0),AL2(0)
*
cfxx_pack_sortp DC CL4'CFEE',AL1(FC_RTYP05)            COMPARE
         DC    AL2(MDLCF02L),AL2(MDLCF02P)
         DC    AL4(MDLCF02),AL4(MDLCF02R)
         DC    AL2(0),AL2(0),AL2(0)
*
cfxx_pack_binu  DC CL4'CFEE',AL1(FC_RTYP05)            COMPARE
         DC    AL2(MDLCF11uL),AL2(MDLCF11uP)
         DC    AL4(MDLCF11u),AL4(MDLCF11uR)
         DC    AL2(0),AL2(0),AL2(0)
*
         DC    CL4'CFEE',AL1(FC_RTYP05)                COMPARE
         DC    AL2(MDLCF11_b8L),AL2(MDLCF11_b8P)
         DC    AL4(MDLCF11_b8),AL4(MDLCF11_b8R)
         DC    AL2(fcsubb8),AL2(0),AL2(0)
*
cfxx_pack_bins  DC CL4'CFEE',AL1(FC_RTYP05)            COMPARE
         DC    AL2(MDLCF11L),AL2(MDLCF11P)
         DC    AL4(MDLCF11),AL4(MDLCF11R)
         DC    AL2(0),AL2(0),AL2(0)
*
         DC    CL4'CFEE',AL1(FC_RTYP05)                COMPARE
         DC    AL2(MDLCF11_b8L),AL2(MDLCF11_b8P)
         DC    AL4(MDLCF11_b8),AL4(MDLCF11_b8R)
         DC    AL2(fcsubb8),AL2(0),AL2(0)
*
cfxx_pack_sortb DC CL4'CFEE',AL1(FC_RTYP05)            COMPARE
         DC    AL2(mdlcf06L),AL2(mdlcf06P)
         DC    AL4(mdlcf06),AL4(mdlcf06R)
         DC    AL2(0),AL2(0),AL2(0)
*
         DC    CL4'CFEE',AL1(FC_RTYP05)                COMPARE
         DC    AL2(mdlcf06_b8L),AL2(mdlcf06_b8P)
         DC    AL4(mdlcf06_b8),AL4(mdlcf06_b8R)
         DC    AL2(fcsubb8),AL2(0),AL2(0)
*
cfxx_pack_bcd   DC CL4'CFEE',AL1(FC_RTYP05)            COMPARE
         DC    AL2(mdlcf10L),AL2(mdlcf10P)
         DC    AL4(MDLCF10),AL4(mdlcf10R)
         DC    AL2(0),AL2(0),AL2(0)
*
cfxx_pack_edit  DC CL4'CFEE',AL1(FC_RTYP05)            COMPARE
        DC    AL2(MDLCF14L),AL2(MDLCF14P)
        DC    AL4(MDLCF14),AL4(MDLCF14R)
        DC    AL2(0),AL2(0),AL2(0)

cfxx_alnum_num   equ cfxx_num_num
cfxx_num_num   DC  CL4'CFEE',AL1(FC_RTYP05)                COMPARE
         DC    AL2(MDLCF08L),AL2(MDLCF08P)
         DC    AL4(MDLCF08),AL4(MDLCF08R)
         DC    AL2(0),AL2(0),AL2(0)
*
cfxx_alnum_pack  equ cfxx_num_pack
cfxx_num_pack  DC  CL4'CFEE',AL1(FC_RTYP05)                COMPARE
         DC    AL2(MDLCF04L),AL2(MDLCF04P)
         DC    AL4(MDLCF04),AL4(MDLCF04R)
         DC    AL2(0),AL2(0),AL2(0)
*
cfxx_alnum_sortp equ cfxx_num_sortp
cfxx_num_sortp DC  CL4'CFEE',AL1(FC_RTYP05)                COMPARE
         DC    AL2(MDLCF15L),AL2(MDLCF15P)
         DC    AL4(MDLCF15),AL4(MDLCF15R)
         DC    AL2(0),AL2(0),AL2(0)
*
cfxx_alnum_bins  equ cfxx_num_bins
cfxx_num_bins  DC  CL4'CFEE',AL1(FC_RTYP05)                COMPARE
         DC    AL2(MDLCF12L),AL2(MDLCF12P)
         DC    AL4(MDLCF12),AL4(MDLCF12R)
         DC    AL2(0),AL2(0),AL2(0)
*
         DC    CL4'CFEE',AL1(FC_RTYP05)                COMPARE
         DC    AL2(MDLCF12_b8L),AL2(MDLCF12_b8P)
         DC    AL4(MDLCF12_b8),AL4(MDLCF12_b8R)
         DC    AL2(fcsubb8),AL2(0),AL2(0)
*
cfxx_alnum_binu  equ cfxx_num_binu
cfxx_num_binu  DC  CL4'CFEE',AL1(FC_RTYP05)                COMPARE
         DC    AL2(MDLCF12uL),AL2(MDLCF12uP)
         DC    AL4(MDLCF12u),AL4(MDLCF12uR)
         DC    AL2(0),AL2(0),AL2(0)
*
         DC    CL4'CFEE',AL1(FC_RTYP05)                COMPARE
         DC    AL2(MDLCF12_b8L),AL2(MDLCF12_b8P)
         DC    AL4(MDLCF12_b8),AL4(MDLCF12_b8R)
         DC    AL2(fcsubb8),AL2(0),AL2(0)
*
cfxx_alnum_sortb equ cfxx_num_sortb
cfxx_num_sortb DC  CL4'CFEE',AL1(FC_RTYP05)                COMPARE
         DC    AL2(MDLCF16L),AL2(MDLCF16P)
         DC    AL4(MDLCF16),AL4(MDLCF16R)
         DC    AL2(0),AL2(0),AL2(0)
*
         DC    CL4'CFEE',AL1(FC_RTYP05)                COMPARE
         DC    AL2(mdlcf16_b8L),AL2(mdlcf16_b8P)
         DC    AL4(mdlcf16_b8),AL4(mdlcf16_b8R)
         DC    AL2(fcsubb8),AL2(0),AL2(0)
*
cfxx_alnum_bcd   equ cfxx_num_bcd
cfxx_num_bcd   DC  CL4'CFEE',AL1(FC_RTYP05)                COMPARE
         DC    AL2(MDLCF17L),AL2(MDLCF17P)
         DC    AL4(MDLCF17),AL4(MDLCF17R)
         DC    AL2(0),AL2(0),AL2(0)
*
cfxx_alnum_edit  equ cfxx_num_edit
cfxx_num_edit  DC  CL4'CFEE',AL1(FC_RTYP05)                COMPARE
        DC    AL2(MDLCF18L),AL2(MDLCF18P)
        DC    AL4(MDLCF18),AL4(MDLCF18R)
        DC    AL2(0),AL2(0),AL2(0)
         entry cf_ee_17
cf_ee_17 alias c'CFEEDATE'
CF_EE_17 DC    CL4'CFEE',AL1(FC_RTYP05)                COMPARE
         DC    AL2(MDLCF00L),AL2(MDLCF00P)
         DC    AL4(MDLCF00),AL4(MDLCF00R)
         DC    AL2(FCSUBNDT),AL2(0),AL2(0)
                        EJECT
***********************************************************************
*        COMPARE FIELD  -  ACCUMULATOR                                *
***********************************************************************
CF_CA_01 DC    CL4'CFCA',AL1(FC_RTYP10)                COMPARE
         DC    AL2(MDLCF20L),AL2(MDLCF20P)
         DC    AL4(MDLCF20),AL4(MDLCF20R)
         DC    AL2(0),AL2(0),AL2(0)
*
CF_ac_01 DC    CL4'CFAC',AL1(FC_RTYP10)                COMPARE
         DC    AL2(mdlcf2arL),AL2(mdlcf2arP)
         DC    AL4(mdlcf2ar),AL4(mdlcf2arR)
         DC    AL2(0),AL2(0),AL2(0)
*
***********************************************************************
*        COMPARE FIELD  -  ACCUMULATOR                                *
***********************************************************************
CF_EA_01 DC    CL4'CFEA',AL1(FC_RTYP12)                COMPARE
         DC    AL2(MDLCF24L),AL2(MDLCF24P)
         DC    AL4(MDLCF24),AL4(MDLCF24R)
         DC    AL2(0),AL2(0),AL2(0)
*
***********************************************************************
*        COMPARE FIELD  -  ACCUMULATOR                                *
***********************************************************************
CF_EA_02 DC    CL4'CFEA',AL1(FC_RTYP12)                COMPARE
         DC    AL2(MDLCF21L),AL2(MDLCF21P)
         DC    AL4(MDLCF21),AL4(MDLCF21R)
         DC    AL2(0),AL2(0),AL2(0)
*
***********************************************************************
*        COMPARE FIELD  -  ACCUMULATOR                                *
***********************************************************************
CF_EA_07 DC    CL4'CFEA',AL1(FC_RTYP12)                COMPARE
         DC    AL2(MDLCF25L),AL2(MDLCF25P)
         DC    AL4(MDLCF25),AL4(MDLCF25R)
         DC    AL2(0),AL2(0),AL2(0)
*
***********************************************************************
*        COMPARE FIELD  -  ACCUMULATOR                                *
***********************************************************************
CF_EA_03 DC    CL4'CFEA',AL1(FC_RTYP12)                COMPARE
         DC    AL2(MDLCF22L),AL2(MDLCF22P)
         DC    AL4(MDLCF22),AL4(MDLCF22R)
         DC    AL2(0),AL2(0),AL2(0)
*
***********************************************************************
*        COMPARE FIELD  -  ACCUMULATOR                                *
***********************************************************************
CF_EA_04u DC    CL4'CFEA',AL1(FC_RTYP12)                COMPARE
         DC    AL2(MDLCF23uL),AL2(MDLCF23uP)
         DC    AL4(MDLCF23u),AL4(MDLCF23uR)
         DC    AL2(0),AL2(0),AL2(0)
*
***********************************************************************
*        COMPARE FIELD  -  ACCUMULATOR                                *
***********************************************************************
            DC CL4'CFEA',AL1(FC_RTYP12)                COMPARE
         DC    AL2(MDLcf23_b8L),AL2(MDLcf23_b8P)
         DC    AL4(MDLcf23_b8),AL4(MDLcf23_b8R)
         DC    AL2(FCSUBB8),al2(0),AL2(0)
*
***********************************************************************
*        COMPARE FIELD  -  ACCUMULATOR                                *
***********************************************************************
CF_EA_04 DC    CL4'CFEA',AL1(FC_RTYP12)                COMPARE
         DC    AL2(MDLCF23L),AL2(MDLCF23P)
         DC    AL4(MDLCF23),AL4(MDLCF23R)
         DC    AL2(0),AL2(0),AL2(0)
*
***********************************************************************
*        COMPARE FIELD  -  ACCUMULATOR                                *
***********************************************************************
            DC CL4'CFEA',AL1(FC_RTYP12)                COMPARE
         DC    AL2(MDLcf23_b8L),AL2(MDLcf23_b8P)
         DC    AL4(MDLcf23_b8),AL4(MDLcf23_b8R)
         DC    AL2(FCSUBB8),al2(0),AL2(0)
*
***********************************************************************
*        COMPARE FIELD  -  ACCUMULATOR                                *
***********************************************************************
CF_EA_08 DC    CL4'CFEA',AL1(FC_RTYP12)                COMPARE
         DC    AL2(MDLCF26L),AL2(MDLCF26P)
         DC    AL4(MDLCF26),AL4(MDLCF26R)
         DC    AL2(0),AL2(0),AL2(0)
*
***********************************************************************
*        COMPARE FIELD  -  ACCUMULATOR                                *
***********************************************************************
            DC CL4'CFEA',AL1(FC_RTYP12)                COMPARE
         DC    AL2(MDLcf26_b8L),AL2(MDLcf26_b8P)
         DC    AL4(MDLcf26_b8),AL4(MDLcf26_b8R)
         DC    AL2(FCSUBB8),al2(0),AL2(0)
*
***********************************************************************
*        COMPARE FIELD  -  ACCUMULATOR                                *
***********************************************************************
CF_EA_05 DC    CL4'CFEA',AL1(FC_RTYP12)                COMPARE
         DC    AL2(MDLCF73L),AL2(MDLCF73P)
         DC    AL4(MDLCF73),AL4(MDLCF73R)
         DC    AL2(0),AL2(0),AL2(0)
*
***********************************************************************
*        COMPARE FIELD  -  ACCUMULATOR                                *
***********************************************************************
         entry cf_ea_06
cf_ea_06 alias c'CFXADATE'
CF_EA_06 DC    CL4'CFEA',AL1(FC_RTYP12)                COMPARE
         DC    AL2(MDLCF59L),AL2(MDLCF59P)
         DC    AL4(MDLCF59),AL4(MDLCF59R)
         DC    AL2(FCSUBNDT),AL2(0),AL2(0)
*
***********************************************************************
*        COMPARE FIELD  -  ACCUMULATOR                                *
***********************************************************************
CF_EA_09 DC    CL4'CFEA',AL1(FC_RTYP12)                COMPARE
         DC    AL2(MDLCF27L),AL2(MDLCF27P)
         DC    AL4(MDLCF27),AL4(MDLCF27R)
         DC    AL2(0),AL2(0),AL2(0)
***********************************************************************
*        COMPARE FIELD  -  ACCUMULATOR / ACCUMULATOR                  *
***********************************************************************
CF_AA_01 DC    CL4'CFAA',AL1(FC_RTYP10)                COMPARE
         DC    AL2(MDLCF70L),AL2(MDLCF70P)
         DC    AL4(MDLCF70),AL4(MDLCF70R)
         DC    AL2(0),AL2(0),AL2(0)
*
***********************************************************************
*        COMPARE FIELD  -  ACCUMULATOR / ACCUMULATOR                  *
***********************************************************************
CF_AA_02 DC    CL4'CFAA',AL1(FC_RTYP10)                COMPARE
         DC    AL2(MDLCF71L),AL2(MDLCF71P)
         DC    AL4(MDLCF71),AL4(MDLCF71R)
         DC    AL2(0),AL2(0),AL2(0)
*
***********************************************************************
*        COMPARE FIELD  -  ACCUMULATOR / ACCUMULATOR                  *
***********************************************************************
CF_AA_03 DC    CL4'CFAA',AL1(FC_RTYP10)                COMPARE
         DC    AL2(MDLCF72L),AL2(MDLCF72P)
         DC    AL4(MDLCF72),AL4(MDLCF72R)
         DC    AL2(0),AL2(0),AL2(0)
*
***********************************************************************
*        COMPARE FIELD  -  ACCUMULATOR / ACCUMULATOR                  *
***********************************************************************
         DC    CL4'CFAA',AL1(FC_RTYP10)                COMPARE
         DC    AL2(MDLcf72_b8L),AL2(MDLcf72_b8P)
         DC    AL4(MDLcf72_b8),AL4(MDLcf72_b8R)
         DC    AL2(fcsubb8),AL2(0),AL2(0)
***********************************************************************
*        COMPARE FIELD  -  ACCUMULATOR / ACCUMULATOR                  *
***********************************************************************
CF_AA_04 DC    CL4'CFAA',AL1(FC_RTYP10)                COMPARE
         DC    AL2(MDLCF74L),AL2(MDLCF74P)
         DC    AL4(MDLCF74),AL4(MDLCF74R)
         DC    AL2(0),AL2(0),AL2(0)
*
***********************************************************************
*        CLASS TEST  -  SPACES                                        *
***********************************************************************
CS_E_01  DC    CL4'CSE ',AL1(FC_RTYP04)                CLASS - SPACES
         DC    AL2(MDLCF60L),AL2(MDLCF60P)
         DC    AL4(MDLCF60),AL4(MDLCF60R)
         DC    AL2(0),AL2(0),AL2(0)
*
CN_E_01  DC    CL4'CNE ',AL1(FC_RTYP04)                CLASS - NUMERIC
         DC    AL2(MDLCF61L),AL2(MDLCF61P)
         DC    AL4(MDLCF61),AL4(MDLCF61R)
         DC    AL2(0),AL2(0),AL2(0)
*
CN_E_02  DC    CL4'CNE ',AL1(FC_RTYP04)                CLASS - NUMERIC
         DC    AL2(MDLCF62L),AL2(MDLCF62P)
         DC    AL4(MDLCF62),AL4(MDLCF62R)
         DC    AL2(0),AL2(0),AL2(0)
*
CN_E_03  DC    CL4'CNE ',AL1(FC_RTYP04)                CLASS - NUMERIC
         DC    AL2(MDLGOTOL),AL2(MDLGOTOP)
         DC    AL4(MDLGOTO),AL4(MDLGOTOR)
         DC    AL2(0),AL2(0),AL2(0)
*
         DC    CL4'CNE ',AL1(FC_RTYP04)                CLASS - NUMERIC
         DC    AL2(MDLGOTOL),AL2(MDLGOTOP)
         DC    AL4(MDLGOTO),AL4(MDLGOTOR)
         DC    AL2(0),AL2(0),AL2(0)
*
         DC    CL4'CNE ',AL1(FC_RTYP04)                CLASS - NUMERIC
         DC    AL2(MDLGOTOL),AL2(MDLGOTOP)
         DC    AL4(MDLGOTO),AL4(MDLGOTOR)
         DC    AL2(0),AL2(0),AL2(0)
*
         DC    CL4'CNE ',AL1(FC_RTYP04)                CLASS - NUMERIC
         DC    AL2(MDLGOTOL),AL2(MDLGOTOP)
         DC    AL4(MDLGOTO),AL4(MDLGOTOR)
         DC    AL2(0),AL2(0),AL2(0)
*
CX_E_01  DC    CL4'CXE ',AL1(FC_RTYP04)                CLASS - LOWVAL
         DC    AL2(MDLCF63L),AL2(MDLCF63P)
         DC    AL4(MDLCF63),AL4(MDLCF63R)
         DC    AL2(0),AL2(0),AL2(0)
*
                         EJECT
***********************************************************************
*        DAYS BETWEEN                                                 *
***********************************************************************
FN_cC_01 DC    CL4'FNCC',AL1(FC_RTYP13)               DAYS BETWEEN
         DC    AL2(MDLFNccL),AL2(MDLFNccP)
         DC    AL4(MDLFNcc),AL4(MDLFNccR)
         DC    AL2(0),AL2(0),AL2(0)
                         SPACE 3
FN_xC_01 DC    CL4'FNxC',AL1(FC_RTYP13)               DAYS BETWEEN
         DC    AL2(MDLFNxcL),AL2(MDLFNxcP)
         DC    AL4(MDLFNxc),AL4(MDLFNxcR)
         DC    AL2(0),AL2(0),AL2(0)
                         SPACE 3
FN_cx_01 DC    CL4'FNCx',AL1(FC_RTYP13)               DAYS BETWEEN
         DC    AL2(MDLFNcxL),AL2(MDLFNcxP)
         DC    AL4(MDLFNcx),AL4(MDLFNcxR)
         DC    AL2(0),AL2(0),AL2(0)
                         SPACE 3
FN_xx_01 DC    CL4'FNxx',AL1(FC_RTYP13)               DAYS BETWEEN
         DC    AL2(MDLFNxxL),AL2(MDLFNxxP)
         DC    AL4(MDLFNxx),AL4(MDLFNxxR)
         DC    AL2(0),AL2(0),AL2(0)
                         EJECT
***********************************************************************
*        CONSTANT        TO  LOOK-UP KEY AREA                         *
***********************************************************************
LK_C     DC    CL4'LKC ',AL1(FC_RTYP04)              LOOK-UP KEY AREA
         DC    AL2(MDLDT34L),AL2(MDLDT34P)
         DC    AL4(MDLDT34),AL4(MDLDT34R)
         DC    AL2(0),AL2(0),AL2(0)
*
***********************************************************************
*        CONSTANT        TO  LOOK-UP KEY AREA                         *
***********************************************************************
LK_S_01  DC    CL4'LKS ',AL1(FC_RTYP04)              LOOK-UP KEY AREA
         DC    AL2(MDLDT34L),AL2(MDLDT34P)
         DC    AL4(MDLDT34),AL4(MDLDT34R)
         DC    AL2(0),AL2(0),AL2(0)
                        EJECT
***********************************************************************
*        LOGICAL RECORD ID  TO  LOOK-UP KEY AREA                      *
***********************************************************************
LK_LR_01 DC    CL4'LKLR',AL1(FC_RTYP04)                LOOK-UP KEY
         DC    AL2(MDLLK01L),AL2(MDLLK01P)
         DC    AL4(MDLLK01),AL4(MDLLK01R)
         DC    AL2(0),AL2(0),AL2(0)
*
***********************************************************************
*        OPTIMIZED LOGICAL RECORD ID  TO  LOOK-UP KEY AREA            *
***********************************************************************
LK_JN_01 DC    CL4'JOIN',AL1(FC_RTYP04)                LOOK-UP KEY
         DC    AL2(MDLLK02L),AL2(MDLLK02P)
         DC    AL4(MDLLK02),AL4(MDLLK02R)
         DC    AL2(0),AL2(0),AL2(0)
*
***********************************************************************
*        DATE CONSTANT      TO  LOOK-UP KEY AREA                      *
***********************************************************************
LK_DC_01 DC    CL4'LKDC',AL1(FC_RTYP04)                LOOK-UP KEY
         DC    AL2(MDLDT34L),AL2(MDLDT34P)
         DC    AL4(MDLDT34),AL4(MDLDT34R)
         DC    AL2(0),AL2(0),AL2(0)
*
***********************************************************************
*        DATE EVENT RECORD  TO  LOOK-UP KEY AREA                      *
***********************************************************************
LK_DE_01 DC    CL4'LKDE',AL1(FC_RTYP05)                LOOK-UP KEY
         DC    AL2(MDLDT01L),AL2(MDLDT01P)
         DC    AL4(MDLDT01),AL4(MDLDT01R)
         DC    AL2(0),AL2(0),AL2(0)
*
LK_DE_02 DC    CL4'LKDE',AL1(FC_RTYP05)              LOOK-UP KEY AREA
         DC    AL2(MDLDT09L),AL2(MDLDT09P)
         DC    AL4(MDLDT09),AL4(MDLDT09R)
         DC    AL2(0),al2(0),AL2(0)
*
LK_DE_03 DC    CL4'LKDE',AL1(FC_RTYP05)              LOOK-UP KEY AREA
         DC    AL2(MDLDT15L),AL2(MDLDT15P)
         DC    AL4(MDLDT15),AL4(MDLDT15R)
         DC    AL2(0),al2(0),AL2(0)
*
LK_DE_04 DC    CL4'LKDE',AL1(FC_RTYP05)              LOOK-UP KEY AREA
         DC    AL2(MDLDT20L),AL2(MDLDT20P)
         DC    AL4(MDLDT20),AL4(MDLDT20R)
         DC    AL2(FCSUBBUN),AL2(0),AL2(0)
*
***********************************************************************
*        DATE LOOK-UP RECORD  TO  LOOK-UP KEY AREA                    *
***********************************************************************
LK_DL_01 DC    CL4'LKDL',AL1(FC_RTYP05)                LOOK-UP KEY
         DC    AL2(MDLDT01L),AL2(MDLDT01P)
         DC    AL4(MDLDT01),AL4(MDLDT01R)
         DC    AL2(0),AL2(0),AL2(0)
*
LK_DL_02 DC    CL4'LKDL',AL1(FC_RTYP05)              LOOK-UP KEY AREA
         DC    AL2(MDLDT09L),AL2(MDLDT09P)
         DC    AL4(MDLDT09),AL4(MDLDT09R)
         DC    AL2(0),AL2(0),AL2(0)
*
LK_DL_03 DC    CL4'LKDL',AL1(FC_RTYP05)              LOOK-UP KEY AREA
         DC    AL2(MDLDT15L),AL2(MDLDT15P)
         DC    AL4(MDLDT15),AL4(MDLDT15R)
         DC    AL2(0),AL2(0),AL2(0)
*
LK_DL_04 DC    CL4'LKDL',AL1(FC_RTYP05)              LOOK-UP KEY AREA
         DC    AL2(MDLDT20L),AL2(MDLDT20P)
         DC    AL4(MDLDT20),AL4(MDLDT20R)
         DC    AL2(FCSUBBUN),AL2(0),AL2(0)
*
***********************************************************************
*        DATE ACCUMULATOR     TO  LOOK-UP KEY AREA                    *
***********************************************************************
LK_DA_01 DC    CL4'LKDA',AL1(FC_RTYP12)              LOOK-UP KEY AREA
         DC    AL2(MDLDT50L),AL2(MDLDT50P)
         DC    AL4(MDLDT50),AL4(MDLDT50R)
         DC    AL2(0),AL2(0),AL2(0)
*
***********************************************************************
*        LOOK-UP KEY  TO  EXTRACT RECORD TITLE KEY AREA               *
***********************************************************************
KS_LK_01 DC    CL4'KSLK',AL1(FC_RTYP04)                TITLE KEY AREA
         DC    AL2(MDLKS01L),AL2(MDLKS01P)
         DC    AL4(MDLKS01),AL4(MDLKS01R)
         DC    AL2(0),AL2(0),AL2(0)
                         EJECT
***********************************************************************
*        CONSTANT        TO  SORT KEY AREA                            *
***********************************************************************
SK_C     DC    CL4'SKC ',AL1(FC_RTYP04)               SORT KEY AREA
         DC    AL2(MDLSK34L),AL2(MDLSK34P)
         DC    AL4(MDLSK34),AL4(MDLSK34R)
         DC    AL2(0),AL2(0),AL2(0)
*
***********************************************************************
*        EVENT RECORD    TO  SORT KEY AREA                            *
***********************************************************************
SK_E_02  DC    CL4'SKE ',AL1(FC_RTYP05)               SORT KEY AREA
         DC    AL2(MDLSK03L),AL2(MDLSK03P)             DIFF  LENGTH
         DC    AL4(MDLSK03),AL4(MDLSK03R)
         DC    AL2(FCSUBLE),AL2(0),AL2(0)
*
         DC    CL4'SKE ',AL1(FC_RTYP05)               SORT KEY AREA
         DC    AL2(MDLSK02L),AL2(MDLSK02P)             DIFF  LENGTH
         DC    AL4(MDLSK02),AL4(MDLSK02R)
         DC    AL2(0),AL2(0),AL2(0)
*
sk_E_03  DC    CL4'SKE ',AL1(FC_RTYP05)                "DT" COLUMN
         DC    AL2(MDLSK04L),AL2(MDLSK04P)
         DC    AL4(MDLSK04),AL4(MDLSK04R)
         DC    AL2(FCSUBCOM),AL2(0),AL2(0)         source/target match
*
         DC    CL4'SKE ',AL1(FC_RTYP05)               SORT KEY AREA
         DC    AL2(MDLSK02L),AL2(MDLSK02P)            SAME  ATTRIBUTES
         DC    AL4(MDLSK02),AL4(MDLSK02R)
         DC    AL2(0),AL2(0),AL2(0)
*
SK_E_04  DC    CL4'SKE ',AL1(FC_RTYP05)               SORT KEY AREA
         DC    AL2(MDLSK05L),AL2(MDLSK05P)
         DC    AL4(MDLSK05),AL4(MDLSK05R)
         DC    AL2(FCSUBcom),AL2(0),AL2(0)
*
         DC    CL4'SKE ',AL1(FC_RTYP05)               SORT KEY AREA
         DC    AL2(MDLSK02L),AL2(MDLSK02P)            SAME  ATTRIBUTES
         DC    AL4(MDLSK02),AL4(MDLSK02R)
         DC    AL2(0),AL2(0),AL2(0)
*
SK_E_05  DC    CL4'SKE ',AL1(FC_RTYP05)               SORT KEY AREA
         DC    AL2(MDLSK06L),AL2(MDLSK06P)
         DC    AL4(MDLSK06),AL4(MDLSK06R)
         DC    AL2(FCSUBDEC),AL2(0),AL2(0)
*
         DC    CL4'SKE ',AL1(FC_RTYP05)               SORT KEY AREA
         DC    AL2(MDLSK24L),AL2(MDLSK24P)            SAME  ATTRIBUTES
         DC    AL4(MDLSK24),AL4(MDLSK24R)
         DC    AL2(0),AL2(0),AL2(0)
*
SK_E_06  DC    CL4'SKE ',AL1(FC_RTYP05)               SORT KEY AREA
         DC    AL2(MDLSK07L),AL2(MDLSK07P)
         DC    AL4(MDLSK07),AL4(MDLSK07R)
         DC    AL2(FCSUBDEC),AL2(0),AL2(0)
*
         DC    CL4'SKE ',AL1(FC_RTYP05)                "DT" COLUMN
         DC    AL2(MDLSK24L),AL2(MDLSK24P)
         DC    AL4(MDLSK24),AL4(MDLSK24R)
         DC    AL2(0),AL2(0),AL2(0)
*
SK_E_07  DC    CL4'SKE ',AL1(FC_RTYP05)               SORT KEY AREA
         DC    AL2(MDLSK08L),AL2(MDLSK08P)
         DC    AL4(MDLSK08),AL4(MDLSK08R)
         DC    AL2(0),AL2(0),AL2(0)
*
SK_E_07_b8 DC  CL4'SKE ',AL1(FC_RTYP05)               SORT KEY AREA
         DC    AL2(MDLSK08_b8L),AL2(MDLSK08_b8P)
         DC    AL4(MDLSK08_b8),AL4(MDLSK08_b8R)
         DC    AL2(FCSUBB8),AL2(0),AL2(0)
*
SK_E_08  DC    CL4'SKE ',AL1(FC_RTYP05)               SORT KEY AREA
         DC    AL2(MDLSK09L),AL2(MDLSK09P)
         DC    AL4(MDLSK09),AL4(MDLSK09R)
         DC    AL2(0),AL2(0),AL2(0)
*
SK_E_08_b8 DC  CL4'SKE ',AL1(FC_RTYP05)               SORT KEY AREA
         DC    AL2(MDLSK09_b8L),AL2(MDLSK09_b8P)
         DC    AL4(MDLSK09_b8),AL4(MDLSK09_b8R)
         DC    AL2(FCSUBB8),AL2(0),AL2(0)
*
SK_E_09  DC    CL4'SKE ',AL1(FC_RTYP05)               SORT KEY AREA
         DC    AL2(MDLSK10L),AL2(MDLSK10P)
         DC    AL4(MDLSK10),AL4(MDLSK10R)
         DC    AL2(FCSUBDEC),AL2(0),AL2(0)
*
         DC    CL4'SKE ',AL1(FC_RTYP05)                "DT" COLUMN
         DC    AL2(MDLSK25L),AL2(MDLSK25P)
         DC    AL4(MDLSK25),AL4(MDLSK25R)
         DC    AL2(0),AL2(0),AL2(0)
*
SK_E_10  DC    CL4'SKE ',AL1(FC_RTYP05)               SORT KEY AREA
         DC    AL2(MDLSK11L),AL2(MDLSK11P)
         DC    AL4(MDLSK11),AL4(MDLSK11R)
         DC    AL2(FCSUBDEC),AL2(0),AL2(0)
*
         DC    CL4'SKE ',AL1(FC_RTYP05)                "DT" COLUMN
         DC    AL2(MDLSK25L),AL2(MDLSK25P)
         DC    AL4(MDLSK25),AL4(MDLSK25R)
         DC    AL2(0),AL2(0),AL2(0)
*
SK_E_11  DC    CL4'SKE ',AL1(FC_RTYP05)               SORT KEY AREA
         DC    AL2(MDLSK12L),AL2(MDLSK12P)
         DC    AL4(MDLSK12),AL4(MDLSK12R)
         DC    AL2(0),AL2(0),AL2(0)
*
SK_E_12  DC    CL4'SKE ',AL1(FC_RTYP05)               SORT KEY AREA
         DC    AL2(MDLSK13L),AL2(MDLSK13P)
         DC    AL4(MDLSK13),AL4(MDLSK13R)
         DC    AL2(0),AL2(0),AL2(0)
*
SK_E_13  DC    CL4'SKE ',AL1(FC_RTYP05)               SORT KEY AREA
         DC    AL2(MDLSK14L),AL2(MDLSK14P)
         DC    AL4(MDLSK14),AL4(MDLSK14R)
         DC    AL2(0),AL2(0),AL2(0)
*
SK_E_13_b8 DC  CL4'SKE ',AL1(FC_RTYP05)               SORT KEY AREA
         DC    AL2(MDLSK14_b8L),AL2(MDLSK14_b8P)
         DC    AL4(MDLSK14_b8),AL4(MDLSK14_b8R)
         DC    AL2(FCSUBb8),AL2(0),AL2(0)
*
SK_E_14  DC    CL4'SKE ',AL1(FC_RTYP05)               SORT KEY AREA
         DC    AL2(MDLSK15L),AL2(MDLSK15P)
         DC    AL4(MDLSK15),AL4(MDLSK15R)
         DC    AL2(0),AL2(0),AL2(0)
*
SK_E_14_b8 DC  CL4'SKE ',AL1(FC_RTYP05)               SORT KEY AREA
         DC    AL2(MDLSK15_b8L),AL2(MDLSK15_b8P)
         DC    AL4(MDLSK15_b8),AL4(MDLSK15_b8R)
         DC    AL2(FCSUBb8),AL2(0),AL2(0)
*
SK_E_15  DC    CL4'SKE ',AL1(FC_RTYP05)               SORT KEY AREA
         DC    AL2(MDLSK16L),AL2(MDLSK16P)
         DC    AL4(MDLSK16),AL4(MDLSK16R)
         DC    AL2(FCSUBbsn),AL2(0),AL2(0)
*
SK_E_15_b8 DC  CL4'SKE ',AL1(FC_RTYP05)               SORT KEY AREA
         DC    AL2(MDLSK16_b8L),AL2(MDLSK16_b8P)
         DC    AL4(MDLSK16_b8),AL4(MDLSK16_b8R)
         DC    AL2(FCSUBb8),AL2(0),AL2(0)
*
SK_E_15a DC    CL4'SKE ',AL1(FC_RTYP05)               SORT KEY AREA
         DC    AL2(MDLSK51L),AL2(MDLSK51P)
         DC    AL4(MDLSK51),AL4(MDLSK51R)
         DC    AL2(FCSUBbsn),AL2(0),AL2(0)
*
SK_E_15a_b8 DC  CL4'SKE ',AL1(FC_RTYP05)               SORT KEY AREA
         DC    AL2(MDLSK51_b8L),AL2(MDLSK51_b8P)
         DC    AL4(MDLSK51_b8),AL4(MDLSK51_b8R)
         DC    AL2(FCSUBb8),AL2(0),AL2(0)
*
SK_E_16  DC    CL4'SKE ',AL1(FC_RTYP05)               SORT KEY AREA
         DC    AL2(MDLSK17L),AL2(MDLSK17P)
         DC    AL4(MDLSK17),AL4(MDLSK17R)
         DC    AL2(FCSUBbun),AL2(0),AL2(0)
*
SK_E_16_b8 DC  CL4'SKE ',AL1(FC_RTYP05)               SORT KEY AREA
         DC    AL2(MDLSK52_b8L),AL2(MDLSK52_b8P)
         DC    AL4(MDLSK52_b8),AL4(MDLSK52_b8R)
         DC    AL2(FCSUBb8),AL2(0),AL2(0)
*
SK_E_16a DC    CL4'SKE ',AL1(FC_RTYP05)               SORT KEY AREA
         DC    AL2(MDLSK52L),AL2(MDLSK52P)
         DC    AL4(MDLSK52),AL4(MDLSK52R)
         DC    AL2(FCSUBb8),AL2(0),AL2(0)
*
SK_E_16_b8a dc CL4'SKE ',AL1(FC_RTYP05)               SORT KEY AREA
         DC    AL2(MDLSK52_b8L),AL2(MDLSK52_b8P)
         DC    AL4(MDLSK52_b8),AL4(MDLSK52_b8R)
         DC    AL2(FCSUBb8),AL2(0),AL2(0)
*
SK_E_17  DC    CL4'SKE ',AL1(FC_RTYP05)               SORT KEY AREA
         DC    AL2(MDLSK18L),AL2(MDLSK18P)
         DC    AL4(MDLSK18),AL4(MDLSK18R)
         DC    AL2(0),AL2(0),AL2(0)
*
SK_E_17_b8 DC  CL4'SKE ',AL1(FC_RTYP05)               SORT KEY AREA
         DC    AL2(MDLSK18_b8L),AL2(MDLSK18_b8P)
         DC    AL4(MDLSK18_b8),AL4(MDLSK18_b8R)
         DC    AL2(FCSUBb8),AL2(0),AL2(0)
*
SK_E_17a DC    CL4'SKE ',AL1(FC_RTYP05)               SORT KEY AREA
         DC    AL2(MDLSK53L),AL2(MDLSK53P)
         DC    AL4(MDLSK53),AL4(MDLSK53R)
         DC    AL2(FCSUBb8),AL2(0),AL2(0)
*
SK_E_17_b8a dc CL4'SKE ',AL1(FC_RTYP05)               SORT KEY AREA
         DC    AL2(MDLSK53_b8L),AL2(MDLSK53_b8P)
         DC    AL4(MDLSK53_b8),AL4(MDLSK53_b8R)
         DC    AL2(FCSUBb8),AL2(0),AL2(0)
*
SK_E_18  DC    CL4'SKE ',AL1(FC_RTYP05)               SORT KEY AREA
         DC    AL2(MDLSK19L),AL2(MDLSK19P)
         DC    AL4(MDLSK19),AL4(MDLSK19R)
         DC    AL2(FCSUBbun),AL2(0),AL2(0)
*
SK_E_18_b8 dc CL4'SKE ',AL1(FC_RTYP05)               SORT KEY AREA
         DC    AL2(MDLSK54_b8L),AL2(MDLSK54_b8P)
         DC    AL4(MDLSK54_b8),AL4(MDLSK54_b8R)
         DC    AL2(FCSUBb8),AL2(0),AL2(0)
*
SK_E_18a DC    CL4'SKE ',AL1(FC_RTYP05)               SORT KEY AREA
         DC    AL2(MDLSK54L),AL2(MDLSK54P)
         DC    AL4(MDLSK54),AL4(MDLSK54R)
         DC    AL2(FCSUBb8),AL2(0),AL2(0)
*
SK_E_18_b8a dc CL4'SKE ',AL1(FC_RTYP05)               SORT KEY AREA
         DC    AL2(MDLSK54_b8L),AL2(MDLSK54_b8P)
         DC    AL4(MDLSK54_b8),AL4(MDLSK54_b8R)
         DC    AL2(FCSUBb8),AL2(0),AL2(0)
*
SK_E_19  DC    CL4'SKE ',AL1(FC_RTYP05)               SORT KEY AREA
         DC    AL2(MDLSK20L),AL2(MDLSK20P)
         DC    AL4(MDLSK20),AL4(MDLSK20R)
         DC    AL2(FCSUBBUN),AL2(0),AL2(0)
*
SK_E_19_b8 DC  CL4'SKE ',AL1(FC_RTYP05)               SORT KEY AREA
         DC    AL2(MDLSK22_b8L),AL2(MDLSK22_b8P)
         DC    AL4(MDLSK22_b8),AL4(MDLSK22_b8R)
         DC    AL2(fcsubbsn),AL2(0),al2(1)
*
SK_E_19_8b DC  CL4'SKE ',AL1(FC_RTYP05)               SORT KEY AREA
         DC    AL2(MDLSK22_8bL),AL2(MDLSK22_8bP)
         DC    AL4(MDLSK22_8b),AL4(MDLSK22_8bR)
         DC    AL2(fcsubbsn),AL2(0),al2(1)
*
SK_E_19_88 DC  CL4'SKE ',AL1(FC_RTYP05)               SORT KEY AREA
         DC    AL2(MDLSK22_88L),AL2(MDLSK22_88P)
         DC    AL4(MDLSK22_88),AL4(MDLSK22_88R)
         DC    AL2(fcsubbsn),AL2(0),al2(1)
*
SK_E_20  DC    CL4'SKE ',AL1(FC_RTYP05)               SORT KEY AREA
         DC    AL2(MDLSK21L),AL2(MDLSK21P)
         DC    AL4(MDLSK21),AL4(MDLSK21R)
         DC    AL2(FCSUBBSN),AL2(0),AL2(0)
*
SK_E_20_b8 DC  CL4'SKE ',AL1(FC_RTYP05)               SORT KEY AREA
         DC    AL2(MDLSK21_b8L),AL2(MDLSK21_b8P)
         DC    AL4(MDLSK21_b8),AL4(MDLSK21_b8R)
         DC    AL2(fcsubbsn),AL2(0),al2(1)
*
SK_E_20_8b DC  CL4'SKE ',AL1(FC_RTYP05)               SORT KEY AREA
         DC    AL2(MDLSK21_8bL),AL2(MDLSK21_8bP)
         DC    AL4(MDLSK21_8b),AL4(MDLSK21_8bR)
         DC    AL2(fcsubbsn),AL2(0),al2(1)
*
SK_E_20_88 DC  CL4'SKE ',AL1(FC_RTYP05)               SORT KEY AREA
         DC    AL2(MDLSK21_88L),AL2(MDLSK21_88P)
         DC    AL4(MDLSK21_88),AL4(MDLSK21_88R)
         DC    AL2(fcsubbsn),AL2(0),al2(1)
*
SK_E_21  DC    CL4'SKE ',AL1(FC_RTYP05)               SORT KEY AREA
         DC    AL2(MDLSK22L),AL2(MDLSK22P)
         DC    AL4(MDLSK22),AL4(MDLSK22R)
         DC    AL2(FCSUBSTU),AL2(0),AL2(0)
*
*  this next entry is special - see code in LTBLMDLS
*  case 10 for selection
*
SK_E_21_b8 DC  CL4'SKE ',AL1(FC_RTYP05)               SORT KEY AREA
         DC    AL2(MDLSK22_b8L),AL2(MDLSK22_b8P)
         DC    AL4(MDLSK22_b8),AL4(MDLSK22_b8R)
         DC    AL2(fcsubstu),AL2(0),al2(1)
*
SK_E_21_8b DC  CL4'SKE ',AL1(FC_RTYP05)               SORT KEY AREA
         DC    AL2(MDLSK22_8bL),AL2(MDLSK22_8bP)
         DC    AL4(MDLSK22_8b),AL4(MDLSK22_8bR)
         DC    AL2(fcsubstu),AL2(0),al2(1)
*
SK_E_21_88 DC  CL4'SKE ',AL1(FC_RTYP05)               SORT KEY AREA
         DC    AL2(MDLSK22_88L),AL2(MDLSK22_88P)
         DC    AL4(MDLSK22_88),AL4(MDLSK22_88R)
         DC    AL2(fcsubstu),AL2(0),al2(1)
*
SK_E_22  DC    CL4'SKE ',AL1(FC_RTYP05)               SORT KEY AREA
         DC    AL2(MDLSK23L),AL2(MDLSK23P)
         DC    AL4(MDLSK23),AL4(MDLSK23R)
         DC    AL2(FCSUBUTS),AL2(0),AL2(0)
*
*  this next entry is special - see code in LTBLMDLS
*  case 11 for selection
*
SK_E_22_b8 DC  CL4'SKE ',AL1(FC_RTYP05)               SORT KEY AREA
         DC    AL2(MDLSK23_b8L),AL2(MDLSK23_b8P)
         DC    AL4(MDLSK23_b8),AL4(MDLSK23_b8R)
         DC    AL2(fcsubuts),AL2(0),al2(1)
*
SK_E_22_8b DC  CL4'SKE ',AL1(FC_RTYP05)               SORT KEY AREA
         DC    AL2(MDLSK23_8bL),AL2(MDLSK23_8bP)
         DC    AL4(MDLSK23_8b),AL4(MDLSK23_8bR)
         DC    AL2(fcsubuts),AL2(0),al2(1)
*
SK_E_22_88 DC  CL4'SKE ',AL1(FC_RTYP05)               SORT KEY AREA
         DC    AL2(MDLSK23_88L),AL2(MDLSK23_88P)
         DC    AL4(MDLSK23_88),AL4(MDLSK23_88R)
         DC    AL2(fcsubuts),AL2(0),al2(1)
*
SK_E_21_8 DC   CL4'SKE ',AL1(FC_RTYP05)               SORT KEY AREA
          DC   AL2(MDLSK39L),AL2(MDLSK39P)
          DC   AL4(MDLSK39),AL4(MDLSK39R)
          DC   AL2(FCSUBB8_SS),AL2(0),AL2(0)
*
SK_E_22_8 DC   CL4'SKE ',AL1(FC_RTYP05)               SORT KEY AREA
          DC   AL2(MDLSK40L),AL2(MDLSK40P)
          DC   AL4(MDLSK40),AL4(MDLSK40R)
          DC   AL2(FCSUBB8_SU),AL2(0),AL2(0)
*
SK_E_23_8 DC   CL4'SKE ',AL1(FC_RTYP05)               SORT KEY AREA
          DC   AL2(MDLSK41L),AL2(MDLSK41P)
          DC   AL4(MDLSK41),AL4(MDLSK41R)
          DC   AL2(FCSUBB8_US),AL2(0),AL2(0)
*
SK_E_25  DC    CL4'SKE ',AL1(FC_RTYP05)                "DT" COLUMN
         DC    AL2(MDLSK03L),AL2(MDLSK03P)              DIFF LEN
         DC    AL4(MDLSK03),AL4(MDLSK03R)
         DC    AL2(0),AL2(0),AL2(0)
*
***********************************************************************
*        EVENT RECORD    TO  SORT KEY AREA  (LONG FIELD POSITION)     *
***********************************************************************
                         EJECT
***********************************************************************
*        LOOK-UP RECORD  TO  SORT KEY AREA                            *
***********************************************************************
SK_L_01  DC    CL4'SKL ',AL1(FC_RTYP05)               SORT KEY AREA
         DC    AL2(MDLSK01L),AL2(MDLSK01P)
         DC    AL4(MDLSK01),AL4(MDLSK01R)
         DC    AL2(0),AL2(0),AL2(0)
                        EJECT
***********************************************************************
*        "SK" SORT KEY  -  ACCUMULATOR                                *
***********************************************************************
*
SK_A_01  DC    CL4'SKA ',AL1(FC_RTYP12)                "SK" COLUMN
         DC    AL2(MDLSK37L),AL2(MDLSK37P)
         DC    AL4(MDLSK37),AL4(MDLSK37R)
         DC    AL2(0),AL2(0),AL2(0)
*
SK_A_02  DC    CL4'SKA ',AL1(FC_RTYP12)                "DT" COLUMN
         DC    AL2(MDLDT27L),AL2(MDLDT27P)
         DC    AL4(MDLDT27),AL4(MDLDT27R)
         DC    AL2(0),AL2(0),AL2(0)
*
SK_A_03  DC    CL4'SKA ',AL1(FC_RTYP12)                "DT" COLUMN
         DC    AL2(MDLDT28L),AL2(MDLDT28P)
         DC    AL4(MDLDT28),AL4(MDLDT28R)
         DC    AL2(0),AL2(0),AL2(0)
*
SK_A_04  DC    CL4'SKA ',AL1(FC_RTYP12)                "DT" COLUMN
         DC    AL2(MDLDT29L),AL2(MDLDT29P)
         DC    AL4(MDLDT29),AL4(MDLDT29R)
         DC    AL2(0),AL2(0),AL2(0)
*
SK_A_05  DC    CL4'SKA ',AL1(FC_RTYP12)                "DT" COLUMN
         DC    AL2(MDLDT30L),AL2(MDLDT30P)
         DC    AL4(MDLDT30),AL4(MDLDT30R)
         DC    AL2(0),AL2(0),AL2(0)
*
SK_A_06  DC    CL4'SKA ',AL1(FC_RTYP12)                "DT" COLUMN
         DC    AL2(MDLDT31L),AL2(MDLDT31P)
         DC    AL4(MDLDT31),AL4(MDLDT31R)
         DC    AL2(0),AL2(0),AL2(0)
*
SK_A_06_b8  DC CL4'SKA ',AL1(FC_RTYP12)                "DT" COLUMN
         DC    AL2(MDLDT31_b8L),AL2(MDLDT31_b8P)
         DC    AL4(MDLDT31_b8),AL4(MDLDT31_b8R)
         DC    AL2(FCSUBb8),AL2(0),AL2(0)
*
SK_A_07  DC    CL4'SKA ',AL1(FC_RTYP12)                "DT" COLUMN
         DC    AL2(MDLDT32L),AL2(MDLDT32P)
         DC    AL4(MDLDT32),AL4(MDLDT32R)
         DC    AL2(0),AL2(0),AL2(0)
*
SK_A_08  DC    CL4'SKA ',AL1(FC_RTYP12)                "DT" COLUMN
         DC    AL2(MDLDT33L),AL2(MDLDT33P)
         DC    AL4(MDLDT33),AL4(MDLDT33R)
         DC    AL2(0),AL2(0),AL2(0)
                         EJECT
***********************************************************************
*        CONSTANT        TO  "DT" EXTRACT DATA AREA                   *
***********************************************************************
DT_C     DC    CL4'DTC ',AL1(FC_RTYP04)                "DT" COLUMN
         DC    AL2(MDLDT34L),AL2(MDLDT34P)
         DC    AL4(MDLDT34),AL4(MDLDT34R)
         DC    AL2(0),AL2(0),AL2(0)
*
***********************************************************************
*        EVENT RECORD    TO  "DT" EXTRACT DATA AREA                   *
***********************************************************************
SK_E_01  equ   dt_e_01
DT_E_01  DC    CL4'DTE ',AL1(FC_RTYP05)                "DT" COLUMN
         DC    AL2(MDLDT00L),AL2(MDLDT00P)
         DC    AL4(MDLDT00),AL4(MDLDT00R)
         DC    AL2(0),AL2(0),AL2(0)
*
*   this copy of dt_e_01 is here to handle the case
*   where this default entry is used, and one of the operands is
*   a BIN8.
*
*   Any entry here that MIGHT be selected with both BINARY operands
*   must have the following four entries in order
*        source  / target
*        BIN 124 / Bin 124  (entry in the array)
*        BIN 124 / Bin 8
*        BIN 8   / Bin 124
*        BIN 8   / Bin 8
*
*   Any entry here that MIGHT be selected with a BINARY operand
*   either source or target must have a following entry to handle
*   any possible BIN 8 operand.
*
*   (GVBMR96 code in routine array_select is dependent on this order)
*
         DC    CL4'DTE ',AL1(FC_RTYP05)                "DT" COLUMN
         DC    AL2(MDLDT00L),AL2(MDLDT00P)
         DC    AL4(MDLDT00),AL4(MDLDT00R)
         DC    AL2(0),AL2(0),AL2(0)
*
         DC    CL4'DTE ',AL1(FC_RTYP05)                "DT" COLUMN
         DC    AL2(MDLDT00L),AL2(MDLDT00P)
         DC    AL4(MDLDT00),AL4(MDLDT00R)
         DC    AL2(0),AL2(0),AL2(0)
*
         DC    CL4'DTE ',AL1(FC_RTYP05)                "DT" COLUMN
         DC    AL2(MDLDT00L),AL2(MDLDT00P)
         DC    AL4(MDLDT00),AL4(MDLDT00R)
         DC    AL2(0),AL2(0),AL2(0)
*
DT_E_02  DC    CL4'DTE ',AL1(FC_RTYP05)                "DT" COLUMN
         DC    AL2(MDLDT03L),AL2(MDLDT03P)             DIFF  LENGTH
         DC    AL4(MDLDT03),AL4(MDLDT03R)
         DC    AL2(FCSUBLE),AL2(0),AL2(0)
*
         DC    CL4'DTE ',AL1(FC_RTYP05)                "DT" COLUMN
         DC    AL2(MDLDT02L),AL2(MDLDT02P)             DIFF  LENGTH
         DC    AL4(MDLDT02),AL4(MDLDT02R)
         DC    AL2(0),AL2(0),AL2(0)
*
DT_E_03  DC    CL4'DTE ',AL1(FC_RTYP05)                "DT" COLUMN
         DC    AL2(MDLDT04L),AL2(MDLDT04P)
         DC    AL4(MDLDT04),AL4(MDLDT04R)
         DC    AL2(FCSUBCOM),AL2(0),AL2(0)         source/target match
*
         DC    CL4'DTE ',AL1(FC_RTYP05)                "DT" COLUMN
         DC    AL2(MDLDT02L),AL2(MDLDT02P)
         DC    AL4(MDLDT02),AL4(MDLDT02R)
         DC    AL2(0),AL2(0),AL2(0)
*
DT_E_04  DC    CL4'DTE ',AL1(FC_RTYP05)                "DT" COLUMN
         DC    AL2(MDLDT05L),AL2(MDLDT05P)
         DC    AL4(MDLDT05),AL4(MDLDT05R)
         DC    AL2(FCSUBCOM),AL2(0),AL2(0)         source/target match
*
         DC    CL4'DTE ',AL1(FC_RTYP05)                "DT" COLUMN
         DC    AL2(MDLDT02L),AL2(MDLDT02P)
         DC    AL4(MDLDT02),AL4(MDLDT02R)
         DC    AL2(0),AL2(0),AL2(0)
*
DT_E_05  DC    CL4'DTE ',AL1(FC_RTYP05)                "DT" COLUMN
         DC    AL2(MDLDT06L),AL2(MDLDT06P)
         DC    AL4(MDLDT06),AL4(MDLDT06R)
         DC    AL2(FCSUBDEC),AL2(0),AL2(0)
*
         DC    CL4'DTE ',AL1(FC_RTYP05)                "DT" COLUMN
         DC    AL2(MDLDT24L),AL2(MDLDT24P)
         DC    AL4(MDLDT24),AL4(MDLDT24R)
         DC    AL2(0),AL2(0),AL2(0)
*
DT_E_06  DC    CL4'DTE ',AL1(FC_RTYP05)                "DT" COLUMN
         DC    AL2(MDLDT07L),AL2(MDLDT07P)
         DC    AL4(MDLDT07),AL4(MDLDT07R)
         DC    AL2(FCSUBDEC),AL2(0),AL2(0)
*
         DC    CL4'DTE ',AL1(FC_RTYP05)                "DT" COLUMN
         DC    AL2(MDLDT24L),AL2(MDLDT24P)
         DC    AL4(MDLDT24),AL4(MDLDT24R)
         DC    AL2(0),AL2(0),AL2(0)
*
DT_E_07  DC    CL4'DTE ',AL1(FC_RTYP05)                "DT" COLUMN
         DC    AL2(MDLDT08L),AL2(MDLDT08P)
         DC    AL4(MDLDT08),AL4(MDLDT08R)
         DC    AL2(0),AL2(0),AL2(0)
*
            DC CL4'DTE ',AL1(FC_RTYP05)                 "DT" column
         DC    AL2(mdldt08_b8l),AL2(mdldt08_b8P)
         DC    AL4(mdldt08_b8),AL4(mdldt08_b8R)
         DC    AL2(FCSUBb8),AL2(0),AL2(0)
*
DT_E_08  DC    CL4'DTE ',AL1(FC_RTYP05)                "DT" COLUMN
         DC    AL2(MDLDT09L),AL2(MDLDT09P)
         DC    AL4(MDLDT09),AL4(MDLDT09R)
         DC    AL2(0),AL2(0),AL2(0)
*
            DC CL4'DTE ',AL1(FC_RTYP05)                "DT" COLUMN
         DC    AL2(MDLDt09_b8L),AL2(MDLDt09_b8P)
         DC    AL4(MDLDt09_b8),AL4(MDLDt09_b8R)
         DC    AL2(0),AL2(0),AL2(0)
*
DT_E_09  DC    CL4'DTE ',AL1(FC_RTYP05)                "DT" COLUMN
         DC    AL2(MDLDT10L),AL2(MDLDT10P)
         DC    AL4(MDLDT10),AL4(MDLDT10R)
         DC    AL2(FCSUBDEC),AL2(0),AL2(0)
*
         DC    CL4'DTE ',AL1(FC_RTYP05)                "DT" COLUMN
         DC    AL2(MDLDT25L),AL2(MDLDT25P)
         DC    AL4(MDLDT25),AL4(MDLDT25R)
         DC    AL2(0),AL2(0),AL2(0)
*
DT_E_10  DC    CL4'DTE ',AL1(FC_RTYP05)                "DT" COLUMN
         DC    AL2(MDLDT11L),AL2(MDLDT11P)
         DC    AL4(MDLDT11),AL4(MDLDT11R)
         DC    AL2(FCSUBDEC),AL2(0),AL2(0)
*
         DC    CL4'DTE ',AL1(FC_RTYP05)                "DT" COLUMN
         DC    AL2(MDLDT25L),AL2(MDLDT25P)
         DC    AL4(MDLDT25),AL4(MDLDT25R)
         DC    AL2(0),AL2(0),AL2(0)
*
DT_E_11  DC    CL4'DTE ',AL1(FC_RTYP05)                "DT" COLUMN
         DC    AL2(MDLDT12L),AL2(MDLDT12P)
         DC    AL4(MDLDT12),AL4(MDLDT12R)
         DC    AL2(FCSUBcom),AL2(0),AL2(0)
*
         DC    CL4'DTE ',AL1(FC_RTYP05)                "DT" COLUMN
         DC    AL2(MDLDT02L),AL2(MDLDT02P)
         DC    AL4(MDLDT02),AL4(MDLDT02R)
         DC    AL2(0),AL2(0),AL2(0)
*
DT_E_12  DC    CL4'DTE ',AL1(FC_RTYP05)                "DT" COLUMN
         DC    AL2(MDLDT13L),AL2(MDLDT13P)
         DC    AL4(MDLDT13),AL4(MDLDT13R)
         DC    AL2(FCSUBCOM),AL2(0),AL2(0)
*
         DC    CL4'DTE ',AL1(FC_RTYP05)                "DT" COLUMN
         DC    AL2(MDLDT02L),AL2(MDLDT02P)
         DC    AL4(MDLDT02),AL4(MDLDT02R)
         DC    AL2(0),AL2(0),AL2(0)
*
DT_E_13  DC    CL4'DTE ',AL1(FC_RTYP05)                "DT" COLUMN
         DC    AL2(MDLDT14L),AL2(MDLDT14P)
         DC    AL4(MDLDT14),AL4(MDLDT14R)
         DC    AL2(0),AL2(0),AL2(0)
*
           DC  CL4'DTE ',AL1(FC_RTYP05)                "DT" COLUMN
         DC    AL2(MDLDT14_b8L),AL2(MDLDT14_b8P)
         DC    AL4(MDLDT14_b8),AL4(MDLDT14_b8R)
         DC    AL2(FCSUBB8),AL2(0),AL2(0)
*
DT_E_14  DC    CL4'DTE ',AL1(FC_RTYP05)                "DT" COLUMN
         DC    AL2(MDLDT15L),AL2(MDLDT15P)
         DC    AL4(MDLDT15),AL4(MDLDT15R)
         DC    AL2(0),AL2(0),AL2(0)
*
            DC CL4'DTE ',AL1(FC_RTYP05)                "DT" COLUMN
         DC    AL2(MDLDt15_b8L),AL2(MDLDt15_b8P)
         DC    AL4(MDLDt15_b8),AL4(MDLDt15_b8R)
         DC    AL2(0),AL2(0),AL2(0)
*
DT_E_15  DC    CL4'DTE ',AL1(FC_RTYP05)                "DT" COLUMN
         DC    AL2(MDLDT16L),AL2(MDLDT16P)
         DC    AL4(MDLDT16),AL4(MDLDT16R)
         DC    AL2(FCSUBBSN),AL2(0),AL2(0)
*
           DC  CL4'DTE ',AL1(FC_RTYP05)                "DT" COLUMN
         DC    AL2(MDLDT16_b8L),AL2(MDLDT16_b8P)
         DC    AL4(MDLDT16_b8),AL4(MDLDT16_b8R)
         DC    AL2(FCSUBb8),AL2(0),AL2(0)
*
DT_E_15A DC    CL4'DTE ',AL1(FC_RTYP05)                "DT" COLUMN
         DC    AL2(MDLDT51L),AL2(MDLDT51P)
         DC    AL4(MDLDT51),AL4(MDLDT51R)
         DC    AL2(FCSUBSTU),AL2(0),AL2(0)
*
*  this next entry is special - see code in LTBLMDLS
*  case 10 for selection
*
            DC    CL4'DTE ',AL1(FC_RTYP05)                "DT" COLUMN
         DC    AL2(MDLDT51_b8L),AL2(MDLDT51_b8P)
         DC    AL4(MDLDT51_b8),AL4(MDLDT51_b8R)
         DC    AL2(FCSUBb8),AL2(0),AL2(0)
*
DT_E_16  DC    CL4'DTE ',AL1(FC_RTYP05)                "DT" COLUMN
         DC    AL2(MDLDT17L),AL2(MDLDT17P)
         DC    AL4(MDLDT17),AL4(MDLDT17R)
         DC    AL2(FCSUBBUN),AL2(0),AL2(0)
*
           DC    CL4'DTE ',AL1(FC_RTYP05)                "DT" COLUMN
         DC    AL2(MDLDT52_b8L),AL2(MDLDT52_b8P)
         DC    AL4(MDLDT52_b8),AL4(MDLDT52_b8R)
         DC    AL2(FCSUBb8),AL2(0),AL2(0)
*
DT_E_16a DC    CL4'DTE ',AL1(FC_RTYP05)                "DT" COLUMN
         DC    AL2(MDLDT52L),AL2(MDLDT52P)
         DC    AL4(MDLDT52),AL4(MDLDT52R)
         DC    AL2(FCSUBUTS),AL2(0),AL2(0)
*
            DC    CL4'DTE ',AL1(FC_RTYP05)                "DT" COLUMN
         DC    AL2(MDLDT52_b8L),AL2(MDLDT52_b8P)
         DC    AL4(MDLDT52_b8),AL4(MDLDT52_b8R)
         DC    AL2(FCSUBb8),AL2(0),AL2(0)
*
DT_E_17  DC    CL4'DTE ',AL1(FC_RTYP05)                "DT" COLUMN
         DC    AL2(MDLDT18L),AL2(MDLDT18P)
         DC    AL4(MDLDT18),AL4(MDLDT18R)
         DC    AL2(0),AL2(0),AL2(0)
*
           DC  CL4'DTE ',AL1(FC_RTYP05)                "DT" COLUMN
         DC    AL2(MDLDT18_b8L),AL2(MDLDT18_b8P)
         DC    AL4(MDLDT18_b8),AL4(MDLDT18_b8R)
         DC    AL2(FCSUBb8),AL2(0),AL2(0)
*
DT_E_17a DC    CL4'DTE ',AL1(FC_RTYP05)                "DT" COLUMN
         DC    AL2(MDLDT53L),AL2(MDLDT53P)
         DC    AL4(MDLDT53),AL4(MDLDT53R)
         DC    AL2(FCSUBStu),AL2(0),AL2(0)
*
*  this next entry is special - see code in LTBLMDLS
*  case 10 for selection
*
            DC    CL4'DTE ',AL1(FC_RTYP05)                "DT" COLUMN
         DC    AL2(MDLDT53_b8L),AL2(MDLDT53_b8P)
         DC    AL4(MDLDT53_b8),AL4(MDLDT53_b8R)
         DC    AL2(FCSUBb8),AL2(0),AL2(0)
*
DT_E_18  DC    CL4'DTE ',AL1(FC_RTYP05)                "DT" COLUMN
         DC    AL2(MDLDT19L),AL2(MDLDT19P)
         DC    AL4(MDLDT19),AL4(MDLDT19R)
         DC    AL2(FCSUBbun),AL2(0),AL2(0)
*
           DC    CL4'DTE ',AL1(FC_RTYP05)                "DT" COLUMN
         DC    AL2(MDLDT19_b8L),AL2(MDLDT19_b8P)
         DC    AL4(MDLDT19_b8),AL4(MDLDT19_B8R)
         DC    AL2(FCSUBb8),AL2(0),AL2(0)
*
DT_E_18a DC    CL4'DTE ',AL1(FC_RTYP05)                "DT" COLUMN
         DC    AL2(MDLDT54L),AL2(MDLDT54P)
         DC    AL4(MDLDT54),AL4(MDLDT54R)
         DC    AL2(FCSUButs),AL2(0),AL2(0)
*
*  this next entry is special - see code in LTBLMDLS
*  case 10 for selection
*
           DC    CL4'DTE ',AL1(FC_RTYP05)                "DT" COLUMN
         DC    AL2(MDLDT54_b8L),AL2(MDLDT54_b8P)
         DC    AL4(MDLDT54_b8),AL4(MDLDT54_B8R)
         DC    AL2(FCSUBb8),AL2(0),AL2(0)
*
DT_E_19  DC    CL4'DTE ',AL1(FC_RTYP05)                "DT" COLUMN
         DC    AL2(MDLDT20L),AL2(MDLDT20P)
         DC    AL4(MDLDT20),AL4(MDLDT20R)
         DC    AL2(FCSUBBUN),AL2(0),AL2(0)
*
           DC    CL4'DTE ',AL1(FC_RTYP05)              "DT" COLUMN
         DC    AL2(MDLDT22_b8L),AL2(MDLDT22_b8P)
         DC    AL4(MDLDT22_b8),AL4(MDLDT22_b8R)
         DC    AL2(fcsubbun),AL2(0),al2(1)
*
           DC    CL4'DTE ',AL1(FC_RTYP05)              "DT" COLUMN
         DC    AL2(MDLDT22_8bL),AL2(MDLDT22_8bP)
         DC    AL4(MDLDT22_8b),AL4(MDLDT22_8bR)
         DC    AL2(fcsubbun),AL2(0),al2(1)
*
           DC    CL4'DTE ',AL1(FC_RTYP05)              "DT" COLUMN
         DC    AL2(MDLDT22_88L),AL2(MDLDT22_88P)
         DC    AL4(MDLDT22_88),AL4(MDLDT22_88R)
         DC    AL2(fcsubbun),AL2(0),al2(1)
*
DT_E_20  DC    CL4'DTE ',AL1(FC_RTYP05)                "DT" COLUMN
         DC    AL2(MDLDT21L),AL2(MDLDT21P)
         DC    AL4(MDLDT21),AL4(MDLDT21R)
         DC    AL2(FCSUBBSN),AL2(0),AL2(0)
*
           DC  CL4'DTE ',AL1(FC_RTYP05)                "DT" COLUMN
         DC    AL2(MDLDT21_b8L),AL2(MDLDT21_b8P)
         DC    AL4(MDLDT21_b8),AL4(MDLDT21_b8R)
         DC    AL2(fcsubbsn),AL2(0),al2(1)
*
           DC  CL4'DTE ',AL1(FC_RTYP05)                "DT" COLUMN
         DC    AL2(MDLDT21_8bL),AL2(MDLDT21_8bP)
         DC    AL4(MDLDT21_8b),AL4(MDLDT21_8bR)
         DC    AL2(fcsubbsn),AL2(0),al2(1)
*
           DC  CL4'DTE ',AL1(FC_RTYP05)                "DT" COLUMN
         DC    AL2(MDLDT21_88L),AL2(MDLDT21_88P)
         DC    AL4(MDLDT21_88),AL4(MDLDT21_88R)
         DC    AL2(fcsubbsn),AL2(0),al2(1)
*
DT_E_21  DC    CL4'DTE ',AL1(FC_RTYP05)                "DT" COLUMN
         DC    AL2(MDLDT22L),AL2(MDLDT22P)
         DC    AL4(MDLDT22),AL4(MDLDT22R)
         DC    AL2(FCSUBSTU),AL2(0),AL2(0)
*
*  this next entry is special - see code in LTBLMDLS
*  case 10 for selection
*
           DC    CL4'DTE ',AL1(FC_RTYP05)              "DT" COLUMN
         DC    AL2(MDLDT22_b8L),AL2(MDLDT22_b8P)
         DC    AL4(MDLDT22_b8),AL4(MDLDT22_b8R)
         DC    AL2(fcsubstu),AL2(0),al2(1)
*
           DC    CL4'DTE ',AL1(FC_RTYP05)              "DT" COLUMN
         DC    AL2(MDLDT22_8bL),AL2(MDLDT22_8bP)
         DC    AL4(MDLDT22_8b),AL4(MDLDT22_8bR)
         DC    AL2(fcsubstu),AL2(0),al2(1)
*
           DC    CL4'DTE ',AL1(FC_RTYP05)              "DT" COLUMN
         DC    AL2(MDLDT22_88L),AL2(MDLDT22_88P)
         DC    AL4(MDLDT22_88),AL4(MDLDT22_88R)
         DC    AL2(fcsubstu),AL2(0),al2(1)
*
DT_E_22  DC    CL4'DTE ',AL1(FC_RTYP05)                "DT" COLUMN
         DC    AL2(MDLDT23L),AL2(MDLDT23P)
         DC    AL4(MDLDT23),AL4(MDLDT23R)
         DC    AL2(FCSUBUTS),AL2(0),AL2(0)
*
*  this next entry is special - see code in LTBLMDLS
*  case 11 for selection
*
           DC    CL4'DTE ',AL1(FC_RTYP05)              "DT" COLUMN
         DC    AL2(MDLDT22_b8L),AL2(MDLDT22_b8P)
         DC    AL4(MDLDT22_b8),AL4(MDLDT22_b8R)
         DC    AL2(fcsubuts),AL2(0),al2(1)
*
           DC    CL4'DTE ',AL1(FC_RTYP05)              "DT" COLUMN
         DC    AL2(MDLDT22_8bL),AL2(MDLDT22_8bP)
         DC    AL4(MDLDT22_8b),AL4(MDLDT22_8bR)
         DC    AL2(fcsubuts),AL2(0),al2(1)
*
           DC    CL4'DTE ',AL1(FC_RTYP05)              "DT" COLUMN
         DC    AL2(MDLDT22_88L),AL2(MDLDT22_88P)
         DC    AL4(MDLDT22_88),AL4(MDLDT22_88R)
         DC    AL2(fcsubuts),AL2(0),al2(1)
                         EJECT
***********************************************************************
*        "DT" DATA AREA  -  ACCUMULATOR                               *
***********************************************************************
*
DT_A_01  DC    CL4'DTA ',AL1(FC_RTYP12)                "DT" COLUMN
         DC    AL2(MDLDT39L),AL2(MDLDT39P)
         DC    AL4(MDLDT39),AL4(MDLDT39R)
         DC    AL2(0),AL2(0),AL2(0)
*
         DC    CL4'DTA ',AL1(FC_RTYP12)                "DT" COLUMN
         DC    AL2(MDLDT39L),AL2(MDLDT39P)
         DC    AL4(MDLDT39),AL4(MDLDT39R)
         DC    AL2(0),AL2(0),AL2(0)
*
         DC    CL4'DTA ',AL1(FC_RTYP12)                "DT" COLUMN
         DC    AL2(MDLDT39L),AL2(MDLDT39P)
         DC    AL4(MDLDT39),AL4(MDLDT39R)
         DC    AL2(0),AL2(0),AL2(0)
*
         DC    CL4'DTA ',AL1(FC_RTYP12)                "DT" COLUMN
         DC    AL2(MDLDT39L),AL2(MDLDT39P)
         DC    AL4(MDLDT39),AL4(MDLDT39R)
         DC    AL2(0),AL2(0),AL2(0)
*
DT_A_02  DC    CL4'DTA ',AL1(FC_RTYP12)                "DT" COLUMN
         DC    AL2(MDLDT27L),AL2(MDLDT27P)
         DC    AL4(MDLDT27),AL4(MDLDT27R)
         DC    AL2(0),AL2(0),AL2(0)
*
DT_A_02f DC    CL4'DTA ',AL1(FC_RTYP12)                "DT" float input
         DC    AL2(MDLDT27fL),AL2(MDLDT27fP)
         DC    AL4(MDLDT27f),AL4(MDLDT27fR)
         DC    AL2(0),AL2(0),AL2(0)
*
DT_A_03  DC    CL4'DTA ',AL1(FC_RTYP12)                "DT" COLUMN
         DC    AL2(MDLDT28L),AL2(MDLDT28P)
         DC    AL4(MDLDT28),AL4(MDLDT28R)
         DC    AL2(0),AL2(0),AL2(0)
*
DT_A_04  DC    CL4'DTA ',AL1(FC_RTYP12)                "DT" COLUMN
         DC    AL2(MDLDT29L),AL2(MDLDT29P)
         DC    AL4(MDLDT29),AL4(MDLDT29R)
         DC    AL2(0),AL2(0),AL2(0)
*
DT_A_05  DC    CL4'DTA ',AL1(FC_RTYP12)                "DT" COLUMN
         DC    AL2(MDLDT30L),AL2(MDLDT30P)
         DC    AL4(MDLDT30),AL4(MDLDT30R)
         DC    AL2(0),AL2(0),AL2(0)
*
DT_A_06  DC    CL4'DTA ',AL1(FC_RTYP12)                "DT" COLUMN
         DC    AL2(MDLDT31L),AL2(MDLDT31P)
         DC    AL4(MDLDT31),AL4(MDLDT31R)
         DC    AL2(0),AL2(0),AL2(0)
*
            DC CL4'DTA ',AL1(FC_RTYP12)                "DT" COLUMN
         DC    AL2(MDLDT31_b8L),AL2(MDLDT31_b8P)
         DC    AL4(MDLDT31_b8),AL4(MDLDT31_b8R)
         DC    AL2(FCSUBb8),AL2(0),AL2(0)
*
DT_A_07  DC    CL4'DTA ',AL1(FC_RTYP12)                "DT" COLUMN
         DC    AL2(MDLDT32L),AL2(MDLDT32P)
         DC    AL4(MDLDT32),AL4(MDLDT32R)
         DC    AL2(0),AL2(0),AL2(0)
            DC CL4'DTA ',AL1(FC_RTYP12)                "DT" COLUMN
         DC    AL2(MDLDT31_b8L),AL2(MDLDT31_b8P)
         DC    AL4(MDLDT31_b8),AL4(MDLDT31_b8R)
         DC    AL2(FCSUBb8),AL2(0),AL2(0)
*
*
DT_A_08  DC    CL4'DTA ',AL1(FC_RTYP12)                "DT" COLUMN
         DC    AL2(MDLDT33L),AL2(MDLDT33P)
         DC    AL4(MDLDT33),AL4(MDLDT33R)
         DC    AL2(0),AL2(0),AL2(0)
            DC CL4'DTA ',AL1(FC_RTYP12)                "DT" COLUMN
         DC    AL2(MDLDT33_b8L),AL2(MDLDT33_b8P)
         DC    AL4(MDLDT33_b8),AL4(MDLDT33_b8R)
         DC    AL2(FCSUBb8),AL2(0),AL2(0)
                         EJECT
***********************************************************************
*        "CT" EXTRACT DATA AREA  -  CONSTANT                          *
***********************************************************************
CT_C_01  DC    CL4'CTC ',AL1(FC_RTYP04)                "CT" COLUMN
         DC    AL2(MDLCT06L),AL2(MDLCT06P)
         DC    AL4(MDLCT06),AL4(MDLCT06R)
         DC    AL2(0),AL2(0),AL2(0)
*
***********************************************************************
*        "CT" EXTRACT DATA AREA  -  GENERIC                           *
***********************************************************************
CT_E_01  DC    CL4'CTE ',AL1(FC_RTYP04)                "CT" COLUMN
         DC    AL2(MDLCT00L),AL2(MDLCT00P)
         DC    AL4(MDLCT00),AL4(MDLCT00R)
         DC    AL2(0),AL2(0),AL2(0)
         DC    CL4'CTE ',AL1(FC_RTYP04)                "CT" COLUMN
         DC    AL2(MDLCT00L),AL2(MDLCT00P)
         DC    AL4(MDLCT00),AL4(MDLCT00R)
         DC    AL2(0),AL2(0),AL2(0)
*
***********************************************************************
*        "CT" EXTRACT DATA AREA  -  PACKED                            *
***********************************************************************
CT_E_02  DC    CL4'CTE ',AL1(FC_RTYP04)                "CT" COLUMN
         DC    AL2(MDLCT02L),AL2(MDLCT02P)
         DC    AL4(MDLCT02),AL4(MDLCT02R)
         DC    AL2(0),AL2(0),AL2(0)
*
***********************************************************************
*        "CT" EXTRACT DATA AREA  -  NUMERIC                           *
***********************************************************************
CT_E_03  DC    CL4'CTE ',AL1(FC_RTYP04)                "CT" COLUMN
         DC    AL2(MDLCT03L),AL2(MDLCT03P)
         DC    AL4(MDLCT03),AL4(MDLCT03R)
         DC    AL2(0),AL2(0),AL2(0)
*
***********************************************************************
*        "CT" EXTRACT DATA AREA  -  BINARY - UNSIGNED                 *
***********************************************************************
CT_E_04  DC    CL4'CTE ',AL1(FC_RTYP04)                "CT" COLUMN
         DC    AL2(MDLCT04L),AL2(MDLCT04P)
         DC    AL4(MDLCT04),AL4(MDLCT04R)
         DC    AL2(0),AL2(0),AL2(0)
*
***********************************************************************
*        "CT" EXTRACT DATA AREA  -  BIN8   - SIGNED                   *
***********************************************************************
         DC    CL4'CTE ',AL1(FC_RTYP04)                "CT" COLUMN
         DC    AL2(MDLCT05_b8L),AL2(MDLCT05_b8P)
         DC    AL4(MDLCT05_b8),AL4(MDLCT05_b8R)
         DC    AL2(FCSUBb8),AL2(0),AL2(0)
*
***********************************************************************
*        "CT" EXTRACT DATA AREA  -  BINARY - SIGNED                   *
***********************************************************************
CT_E_05  DC    CL4'CTE ',AL1(FC_RTYP04)                "CT" COLUMN
         DC    AL2(MDLCT05L),AL2(MDLCT05P)
         DC    AL4(MDLCT05),AL4(MDLCT05R)
         DC    AL2(0),AL2(0),AL2(0)
*
***********************************************************************
*        "CT" EXTRACT DATA AREA  -  BIN8   - SIGNED                   *
***********************************************************************
         DC    CL4'CTE ',AL1(FC_RTYP04)                "CT" COLUMN
         DC    AL2(MDLCT05_b8L),AL2(MDLCT05_b8P)
         DC    AL4(MDLCT05_b8),AL4(MDLCT05_b8R)
         DC    AL2(FCSUBb8),AL2(0),AL2(0)
*
*******************************************************************@02I
*        "CT" EXTRACT DATA AREA  -  ACCUMULATOR now type 12        @02I
*******************************************************************@02I
CT_A_02  DC    CL4'CTA ',AL1(FC_RTYP12)                "CT" COLUMN @02I
         DC    AL2(MDLCT10L),AL2(MDLCT10P)                         @02I
         DC    AL4(MDLCT10),AL4(MDLCT10R)                          @02I
         DC    AL2(0),AL2(0),AL2(0)                                @02I
*                                                                  @02I
GVBFUNCT DC    AL02((*-GVBFUNTB)/FCENTLEN)
                        EJECT
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*                                                                     *
*  1. INITIALIZE USER   EXIT     INTERFACE   AREA                     *
*  2. INITIALIZE COMMON LANGUAGE ENVIRONMENT IF   SPECIFIED           *
*                                                                     *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*
* NOTE:  this routine is entered in AMODE 31
*
*
         sysstate amode64=NO
EXITINIT ds    0h
         lgr   R10,R14            SAVE   RETURN    ADDRESS
*
         LHI   R0,LEINTLEN+8
         GETMAIN R,LV=(0)
         MVC   0(8,R1),LEYEBALL   INITIALIZE  "EYEBALL"
         LA    R2,8(,R1)
         USING LEINTER,R2
*
         ST    R2,CEEWADDR        SAVE EXIT WORK AREA ADDRESS
*
         XC    LEINTER(LEINTLEN),LEINTER    ZERO EXIT WORK   AREA
*
***********************************************************************
* 1. LOAD THE "LANGUAGE ENVIRONMENT" INTERFACE ROUTINE (IF REQUESTED) *
* 2. INITIALIZE "LE" ENVIRONMENT FOR EACH  THREAD/TASK                *
***********************************************************************
*
         OC    CEEPIPI,CEEPIPI    "LE" RUNTIME INTERFACE LOADED ???
         JNZ   EXIT0100           YES - BYPASS LOADING   AGAIN
*
         LOAD  EP=CEEPIPI
         ST    R0,CEEPIPI
*
EXIT0100 MVC   LECEEADR,CEEPIPI
         XC    LETOKEN,LETOKEN
         XC    LESUBADR(8),LESUBADR
*
         LA    R0,PIPICALL        BUILD SUBROUTINE CALL PARAMETER LIST
         ST    R0,LEFUNCA
         LA    R0,LESUBADR
         ST    R0,LESUBRA
         LA    R0,LETOKEN
         ST    R0,LETOKNA
         LA    R0,LEPARMP
         ST    R0,LEPARMA
         lay   R0,PARM_AREA
         ST    R0,LEPARMP
         LA    R0,LERTNC
         ST    R0,LERTNCA
         LA    R0,LEREASON
         ST    R0,LEREASA
         LA    R0,LEFDBK
         ST    R0,LEFDBKA
         OC    LEFDBKA,MODE31
*
         LA    R0,PIPIINIT        BUILD INITIALIZATION PARAMETER  LIST
         sty   R0,GENPARM1
         LA    R0,PIPIPTR
         sty   R0,GENPARM2
         LA    R0,SVCSPTR
         sty   R0,GENPARM3
         LA    R0,PIPIRTIM
         sty   R0,GENPARM4
         LA    R0,LETOKEN
         sty   R0,GENPARM5
         oiy   GENPARM5,x'80'
*
         lay   R1,GENPARM1        CALL  COBOL  INITIALIZATION  FUNCTION
         L     R15,CEEPIPI
         BASR  R14,R15
         cijne R15,0,initerr      UNSUCCESSFUL ???
*
         LA    R0,PIPISEQ         BUILD START  SEQUENCE PARAMETER LIST
         sty   R0,GENPARM1
         LA    R0,LETOKEN
         sty   R0,GENPARM2
         oiy   GENPARM2,x'80'
*
         lay   R1,GENPARM1        CALL  COBOL  START SEQUENCE  FUNCTION
         L     R15,CEEPIPI
         BASR  R14,R15
         cije  R15,0,exitexit     UNSUCCESSFUL ???
*
INITERR  LHI   R14,COBOL_ENV_FAIL Error message
         XC    MSGS2PTR,MSGS2PTR  No additional parms
         J     ERRMSG#
*
EXITEXIT bsm   0,r10              RETURN
                        SPACE 3
static   loctr ,
PIPISEQ  DC    F'07'
PIPIINIT DC    F'09'
PIPICALL DC    F'10'
PIPIPTR  DC    A(PIPIPTBL)
SVCSPTR  DC    A(0)
LEYEBALL DC    CL8'GENCEEWA'      INTERFACE   AREA      "EYEBALL"
*
PIPIPTBL CEEXPIT
         CEEXPITY ,0
         CEEXPITS
                        SPACE 3
PIPIRTIM DC    CL25'RPTOPTS(OFF),RPTSTG(OFF),'
         DC    CL10'TRAP(OFF),'
         DC    CL35'ALL31(ON),ANYHEAP(16K,8K,ANY,FREE),'
         DC    CL22'BELOWHEAP(2K,2K,FREE),'
         DC    CL34'HEAP(32K,100K,ANY,KEEP,4K,4K),'
         DC    CL45'LIBSTACK(2K,2K,FREE),STACK(16K,16K,ANY,KEEP),'
         DC    CL16'NONONIPTSTACK(),'
         DC    CL27'STORAGE(NONE,NONE,NONE,2K),'
         DC    CL27'THREADHEAP(8K,32K,ANY,KEEP)'
RTIMEPAD EQU   (256-(*-PIPIRTIM))
         DC    (RTIMEPAD)CL1' '
*
code     loctr ,
         DROP  R2
         sysstate amode64=YES
                        EJECT
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*                                                                     *
*        P I C K   N E X T   E V E N T   F I L E                      *
*                                                                     *
*                                                                     *
*        R1  - TARGET THREAD WORK AREA                                *
*        R10 - RETURN ADDRESS                                         *
*                                                                     *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         USING LOGICTBL,R8
*
PICKEVNT llgt  R14,THRDMAIN         LOAD MAIN THREAD WORK AREA ADDRESS
*
         LH    R0,THRDTYP-THRDAREA(,R1)  LOAD THREAD TYPE
*
PICKTAPE LA    R15,LTNXTAPE-THRDAREA(,R14)    ASSUME TAPE
         CHI   R0,TAPEDEV                     TAPE THREAD ???
         JNE   PICKDISK                       NO  -   TRY DISK
*
         ltgf  R8,0(,R15)                     ANY TAPES LEFT ???
         JP    PICKSWAP                       YES -  PROCESS IT
*
         LA    R15,LTNXDISK-THRDAREA(,R14)    ANY DISKS LEFT ???
         ltgf  R8,0(,R15)
         JP    PICKSWAP                       YES -  PROCESS IT
         J     PICKEXIT                       NO  -  THREAD DONE
*
PICKDISK LA    R15,LTNXDISK-THRDAREA(,R14)    ASSUME DISK
         CHI   R0,DISKDEV                     DISK THREAD ???
         JNE   PICKOTHR                       NO  - USE OTHER
*
         ltgf  R8,0(,R15)                     ANY DISKS LEFT ???
         JP    PICKSWAP                       YES -  PROCESS IT
         J     PICKEXIT                       NO  -  THREAD DONE
*
PICKOTHR LA    R15,LTNXOTHR-THRDAREA(,R14)    ANY OTHERS ???
         ltgf  R8,0(,R15)
         JP    PICKSWAP                       YES - ASSIGN THIS "ES"
*
         LA    R15,LTNXDISK-THRDAREA(,R14)    ANY DISKS LEFT ???
         ltgf  R8,0(,R15)
         JP    PICKSWAP                       YES -  PROCESS IT
         J     PICKEXIT                       NO  -  THREAD DONE
*
PICKSWAP llgt  R0,LTNEXTES                    UPDATE NEXT "ES" POINTER
         CS    R8,R0,0(R15)
         JNE   PICKEVNT
*
         XC    LTNEXTES,LTNEXTES              RESET  NEXT "ES" POINTER
*
***********************************************************************
*  ADD THIS "ES" SET TO LIST OF SETS PROCESSED IN THIS THREAD         *
***********************************************************************
         ltgf  R14,THRDEXEC-THRDAREA(,R1)     ANY FILES ALREADY PICKED
         JP    PICKEXEC
         ST    R8,THRDEXEC-THRDAREA(,R1)
         J     PICKEXIT
*
PICKEXEC lgr   R15,R14
         ltgf  R14,LTNEXTES-LOGICTBL(,R14)
         JP    PICKEXEC
         ST    R8,LTNEXTES-LOGICTBL(,R15)
*
PICKEXIT BR    R10
                        EJECT
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*                                                                     *
*   D Y N A M I C A L L Y   A L L O C A T E   E V E N T   F I L E     *
*                                                                     *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*
         USING LOGICTBL,R8
*
DYNALLOC ds    0h
         push  using
         using savf4sa,savesubr
*
         stg   R14,SAVF4SAG64RS14 SAVE  RETURN ADDRESS
*
         CLC   EVNTSUBR,SPACES    READ  EXIT   SPECIFIED ???
         JNE   DYNAEXIT           YES - BYPASS DYNAMIC  ALLOCATION
*
***********************************************************************
*  SCAN "TIOT" TO DETERMINE IF DDNAME EXPLICITLY INCLUDED IN JCL      *
***********************************************************************
         LA    R14,DBLWORK
         XC    WKREENT,WKREENT    SET THE EXTRACT LIST  AREA
         EXTRACT (R14),'S',FIELDS=TIOT,MF=(E,WKREENT)
         llgt  R14,DBLWORK        LOAD TIOT  ADDRESS
         aghi  R14,24             LOAD ADDRESS OF FIRST DDNAME
         xgr   R15,R15            CLEAR LENGTH REGISTER
DYNATIOT CLC   4(8,R14),GPDDNAME  MATCHING  DDNAME  ???
         JE    DYNAEXIT           YES - RETURN  (DDNAME IS IN JCL)
*
         IC    R15,0(R14)         LOAD  ENTRY LENGTH
         agr   R14,R15            ADVANCE  TO NEXT    DDNAME
         ICM   R1,B'1111',0(R14)  IS  LENGTH  OF NEXT ENTRY ZERO ???
         JNZ   DYNATIOT           NO  - LOOP  THROUGH TIOT
                        SPACE 3
***********************************************************************
*  INITIALIZE "GVBUR35" DYNAMIC ALLOCATION WORK AREA                  *
***********************************************************************
         LAY   R9,DYNAAREA        DYNAMIC  ALLOCATION PARAMETERS
         USING M35SVC99,R9
*
         LA    R0,M35SVC99        CLEAR   "UR35" PARM AREA
         LA    R1,M35S99LN
         sgr   R14,r14
         sgr   R15,r15
         MVCL  R0,R14
*
         MVC   M35DDNAM,GPDDNAME  USE EVENT FILE ID AS DDNAME
*
***********************************************************************
*  SEPARATE RELATIVE GDG FROM DSNAME IF PRESENT                       *
***********************************************************************
         LHI   R0,L'LTDSNAME      LOAD MAXIMUM LENGTH OF DSNAME
         LA    R14,LTDSNAME+L'LTDSNAME   POINT TO LAST BYTE OF NAME
DYNALOOP BCTR  R14,0              BACKUP TO PREVIOUS BYTE
         CLI   0(R14),C' '        TRAILING BLANK  ???
         JNE   DYNAGDG            NO  - END FOUND
         BRCT  R0,DYNALOOP        YES - CONTINUE BACKSCAN FOR END
*
         J     DYNAEXIT           RETURN - DSNAME NOT AVAILABLE
*
DYNAGDG  CLI   0(R14),C')'        GENERATION SPECIFIED ???
         JNE   DYNAGDG6           NO  - BYPASS SCAN FOR LEFT PAREN
*
         lgr   R15,R14            SAVE  ")" ADDRESS
         CHI   R0,4               CHECK LENGTH  AGAINST  MINIMUM
         JL    DYNAEXIT
*
DYNAGDG2 bctgr R14,0              BACKUP TO PREVIOUS BYTE
         CLI   0(R14),C'('        LEFT  PARENTHESIS  ???
         JE    DYNAGDG4           YES - BEGINNING FOUND
         BRCT  R0,DYNAGDG2        LOOP
*
         J     DYNAEXIT           RETURN - DSNAME NOT AVAILABLE
*
DYNAGDG4 sgr   R15,R14            COMPUTE  LENGTH (+1)
         aghi  R15,-1             EXCLUDE "("
         JNP   DYNAEXIT
         BCTR  R15,0              DECREMENT FOR "EX"
         EX    R15,DYNAGMVC       MOVE    RELATIVE GENERATION
*
         bctgr R14,0              EXCLUDE "("
*
***********************************************************************
*  INSERT LEADING AND TRAILING QUOTES AROUND COPIED NAME              *
***********************************************************************
DYNAGDG6 LA    R0,LTDSNAME        COMPUTE DSNAME LENGTH (-1)
         sgr   R14,R0
         MVI   M35DSNAM,C''''     LEADING  QUOTE
         EX    R14,DYNADMVC       COPY    DSNAME
         LA    R3,M35DSNAM+1+1(R14)
         MVI   0(R3),C''''        TRAILING QUOTE
*
***********************************************************************
*  REPLACE DSNAME SYMBOLIC VARIABLES WITH ACTUAL VALUES               *
***********************************************************************
         LA    R2,M35DSNAM+1      LOAD STARTING SCAN ADDRESS
DYNAAMPR CLI   0(R2),C'$'         SYMBOLIC  VARIABLE ???
         JNE   DYNASCAN           NO - ADVANCE  TO NEXT CHARACTER
*
         llgt  R4,gpenvva         LOAD ENVIRONMENT VARIABLE  LIST ADDR
         USING ENVVTBL,R4
DYNANEXT cgijnh R4,0,dynascan     END-OF-LIST    ???                   +
                                  YES - VARIABLE NAME NOT ON LIST
*
         lgh   R1,ENVVNLEN        LOAD  VARIABLE NAME LENGTH
         EX    R1,DYNAENVV        MATCHING  NAME  ???
         JE    DYNASYMB           YES - SUBSTITUTE VALUE FOR SYMB
         llgt  R4,ENVVNEXT        ADVANCE TO  NEXT SYMBOL ON LIST
         J     DYNANEXT           LOOP
*
static   loctr ,
DYNAENVV CLC   ENVVNAME(0),0(R2)  * * * *  E X E C U T E D  * * * *
DYNAMVAL MVC   0(0,R2),ENVVVALU   * * * *  E X E C U T E D  * * * *
code     loctr ,
*
DYNASYMB lgh   R0,ENVVVLEN        COMPUTE SYMBOL VS VALUE LENGTH DIFF
         sgr   R0,R1
         JE    DYNASUBS           SAME   LENGTHS -  SUBSTITUTE  VALUE
         JP    DYNASHFT           SHIFT RIGHT IF VALUE  LONGER
*
***********************************************************************
*  SHIFT REMAINDER OF DSNAME LEFT TO FOLLOW SYMBOLIC VALUE            *
***********************************************************************
         LCgr  R0,R0              COMPLEMENT SHIFT DIST(CONVERT TO POS)
         LA    R1,1(R2,R1)        COMPUTE SOURCE  ADDRESS
         lgr   R14,R1             COMPUTE TARGET  ADDRESS
         sgr   R14,R0
*
         LA    R15,1(,R3)         COMPUTE SHIFT   LENGTH
         sgr   R15,R1
*
DYNALEFT MVC   0(1,R14),0(R1)
         LA    R14,1(,R14)
         LA    R1,1(,R1)
         BRCT  R15,DYNALEFT
*
***********************************************************************
*  CLEAR OUT TAIL OF DSNAME AFTER LEFT SHIFT                          *
***********************************************************************
DYNASPAC MVI   0(R3),C' '
         bctgr R3,0
         BRCT  R0,DYNASPAC
         J     DYNASUBS
*
***********************************************************************
*  SHIFT REMAINDER OF DSNAME RIGHT TO MAKE ROOM FOR SYMBOLIC VALUE    *
***********************************************************************
DYNASHFT lgr   R15,R3             COMPUTE  SHIFT  LENGTH
         sgr   R15,R2
         sgr   R15,R1             EXCLUDE  NAME
*
         lgr   R1,R3              SOURCE ADDRESS (LEFT -> RIGHT)
         agr   R3,R0              ADJUST TRAILING QUOTE  ADDRESS
         lgr   R14,R3             TARGET ADDRESS
*
DYNARGHT MVC   0(1,R14),0(R1)
         bctgr R14,0
         bctgr R1,0
         BRCT  R15,DYNARGHT
*
***********************************************************************
*  INSERT SYMBOLIC VALUE INTO DSNAME                                  *
***********************************************************************
DYNASUBS lgh   R1,ENVVVLEN        LOAD    VALUE  LENGTH (-1)
         EX    R1,DYNAMVAL        REPLACE SYMBOL WITH  VALUE
         LA    R2,0(R2,R1)        ADVANCE BEYOND VALUE
*
***********************************************************************
*  CONTINUE SCANNING DSNAME FOR MORE SYMBOLICS                        *
***********************************************************************
DYNASCAN LA    R2,1(,R2)          ADVANCE TO  NEXT DSN CHARACTER
         cgr   R2,R3              END-OF-NAME ???
         JL    DYNAAMPR           NO  -  CONTINUE SCAN
*
         DROP  R4
*
***********************************************************************
*  INDICATE DISP=SHR,FREE=CLOSE                                       *
***********************************************************************
         MVC   M35STATS,SHR       STATUS DISPOSITION
         MVI   M35CLOSE,C'Y'      DEALLOCATE AT CLOSE
         MVI   M35FCODE,C'1'      INDICATE ALLOCATION
         CLC   LTVOLSER,SPACES    VOLUME   SPECIFIC  ALLOCATION
         JE    *+10
         MVC   M35VLSER,LTVOLSER
*
***********************************************************************
*  DYNAMICALLY ALLOCATE EVENT FILE                                    *
***********************************************************************
         LA    R1,M35SVC99        --> CALLING STRUCTURE
         sty   R1,GENPARM1
         oiy   GENPARM1,X'80'
         lay   R1,GENPARM1
*
         llgf  R15,GVBUR35        GO DO THE ALLOCATION
         bassm R14,R15
*
         LTR   r15,r15
         BZ    DYNAEXIT
*
         CVD   R15,dblwork
         OI    dblwork+L'dblwork-1,X'0F'
         UNPK  dblwork2(3),dblwork
*
         GVBMSG LOG,MSGNO=DYNALLOC_UR35_FAIL,SUBNO=3,                  +
               GENENV=GENENV,                                          +
               SUB1=(PGMNAME,L'PGMNAME),                               +
               SUB2=(M35DSNAM,l'M35DSNAM),                             +
               SUB3=(dblwork2,3),                                      +
               MSGBUFFER=(PRNTBUFF,L'PRNTBUFF),                        +
               MF=(E,MSG_AREA)
*
DYNAEXIT lg    R14,SAVF4SAG64RS14 RESTORE RETURN ADDRESS
         br    R14              RETURN (SWITCH TO 31-BIT MODE)
*
static   loctr ,
DYNADMVC MVC   M35DSNAM+1(0),LTDSNAME * *  E X E C U T E D
DYNAGMVC MVC   M35MEMBR(0),1(R14)   * * *  E X E C U T E D
code     loctr ,
*
         pop   using
         DROP  R8
                        EJECT
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*                                                                     *
*        W R I T E   T O K E N   R E C O R D  -  W I T H   E X I T    *
*                                                                     *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*
         using litp_hdr+524288,r2
         USING LOGICTBL,R5
         USING EXTREC,R7
         USING COLEXTR,R8
*
WRTTKN   lgf   R9,LTWRLUBO        LOAD  LOOK-UP  BUFFER ADDRESS
         llgt  r9,0(r9,r2)                                         pgc
         USING LKUPBUFR,R9
*
         lgf   R3,LTWREXTO        POINT TO WRITE ANCHOR
         agr   R3,R2
         USING LTWRAREA,R3
*
         lgr   R14,R8             SAVE  CURRENT  COLUMN ADDRESS
         sgr   R8,R7              COMPUTE ACTUAL RECORD  LENGTH
         STH   R8,EXRECLEN        SET  LENGTH IN "RDW"
*
         lgr   r8,r7
         agf   r8,ltwr_offset_ct  point to first CT column
*
         sthh  r12,exncol
         sgr   R14,R8             COMPUTE LENGTH  OF COLUMN DATA
         jz    wrttbypd
         SRDL  R14,32
         LHI   R0,COLDATAL        COMPUTE NUMBER  OF COLUMNS
         DR    R14,R0
         STH   R15,EXNCOL
*
wrttbypd ds    0h
         MVC   EXVIEW#,LTWRVIEW   COPY FLAGGED VIEW ID
*
         llgt  R1,LTLogNV         COPY SORTLEN,TITLLEN,DATALEN
         MVC   EXSORTLN(6),LTSORTLN-LOGICTBL(R1)
*
         XC    RETNCODE,RETNCODE  ZERO WRITE PGM RETURN CODE
*
         llgf  R15,LTWRADDR       LOAD WRITE PGM EXIT   ADDR
         ltgr  r15,r15            Test value
         jz    wrttnew            None:                           pgc1
*
         LA    R0,LTWRPARM        POINT  TO WRITE    PARAMETERS
         sty   R0,GPSTARTA
         lgf   R1,LTWREXTO        POINT  TO WRITE    ANCHOR
         agr   R1,R2
r1wr     using ltwrarea,r1
         LA    R0,r1wr.LTWRWORK
         drop  r1wr
         sty   R0,GPWORKA
         stg   R7,RETNPTR         SET RETURN POINTER
         lay   R1,PARM_AREA
         bassm R14,R15            CALL USER   EXIT
*
         if    (oc,gp_error_reason,gp_error_reason,nz)
           bras  r9,errwtoa       issue "wto" if non-zero reason code
           lgf   r9,ltwrlubo      RESTORE FILE CONT AREA ADDR
           llgt  r9,0(r9,r2)
         endif
*
*
         L     R15,RETNCODE       LOAD RETURN CODE
         ST    R15,LBLSTRC        SAVE RETURN CODE FOR LOOP CHECKING
         sty   r15,lplurtnc         and save in literal pool
         lg    R7,RETNPTR         LOAD RETURN POINTER
*
         CHI   R15,8              USE    THIS RECORD  ???
         JL    WRTTNEW            YES -  PROCESS
         JH    *+14               NO  -  ERROR
         xc    lblstcnt,lblstcnt  BYPASS WRITE
         J     WRTTXIT
*
         CHI   R15,12             DISABLE VIEW ???
         JNE   ABORTEX            NO  -   ABEND
*
         llgt  R1,LTlogNV         LOAD logictbl NV address
         MVI   LTSTATUS-LOGICTBL(R1),C'W'  YES - INDICATE ERROR
         LARL  R14,WEXITMSG                SET INDICATIVE DATA
         MVC   ERRDATA(L'WEXITMSG),0(R14)
         BRAS  R9,DISABREQ                 DISABLE THIS REQUEST
         lgf   R9,LTWRLUBO                 RESTORE LOOK-UP BUFFER ADDR
         agr   R9,R2
         J     WRTTXIT
                        SPACE 3
WRTTNEW  LA    R4,LBDATA          LOAD   TARGET ADDRESS FOR NEW RECORD
         lgh   R15,0(,R7)         LOAD   RECORD LENGTH
*
*??WRTX  LA    R1,EXTREC          MOVE   THIS EXTRACT RECORD TO BUFFER
         LA    R1,EXSRTKEY        MOVE THIS EXTRACT RECORD TO BUFFER
         llgt  r14,ltlognv        Load  NV logic table entry
         lgh   r14,ltsortln-logictbl(,r14)  Get sort key length
         agr   r1,r14
*
         LA    R15,255(,R15)      ROUND UP TO  256 MULTIPLE
         lgr   R0,R15             LENGTH OF RECORD TO MOVE
         SRL   R0,8
         J     WRTTXEND
WRTTXMLP MVC   0(256,R4),0(R1)
         LA    R1,256(,R1)
         LA    R4,256(,R4)
WRTTXEND BRCT  R0,WRTTXMLP
         EX    R15,WRTEXMVC       MOVE RECORD FROM DATA SPACE
*
                        SPACE 3
WRTTCNT  agsi  LTWRCNTO,bin1      INCREMENT  RECORD COUNT
*
         llgt  r1,ltwr200a-logictbl(,r5)   get RETK logic pointer  @05I
         llgt  R1,VDP0200b_file_reader-VDP0200b_file_record(,r1)   @05I
         lgf   r15,ltreindx-logictbl(,r1)  Get index for RETK    pgc100
         mghi  r15,8                       Make it a word        pgc101
         aghi  r15,litphdrl                Allow for litpool hdr pgc100
         llgt  r14,lp_base_litp            Get base literal pool pgc100
         sty   r9,4-524288(r15,r14)      Save lkup bufr for RETK pgc101
         lgf   r15,0-524288(r15,r14)       Get offset to litpool pgc100
         agr   r15,r14                     Point at it           pgc100
         lgf   r14,ltfilcnt-logictbl(,r1)  Get ltfilcnt litp off.pgc100
         agr   r15,r14                     Point at it           pgc100
         agsi  0(r15),bin1                 Increment count         @05I
         mvc   lblstcnt,0(r15)          update last evnt rec number@05C
*
         clc   LTWRCNTO,LTWRLMT            EXTRACT RECORD LIMIT REACHED
         JNH   WRTTDEQ                     NO  - CONTINUE
*
         llgt  R1,LTlogNV                  LOAD  REPORT   BEG ROW  ADDR
         MVI   LTSTATUS-LOGICTBL(R1),C'L'  YES - INDICATE LIMIT REACHED
         LARL  R14,LIMITMSG                SET INDICATIVE DATA
         MVC   ERRDATA(L'LIMITMSG),0(R14)
         BRAS  R9,DISABREQ                 DISABLE THIS REQUEST
                        SPACE 3
WRTTDEQ  llgt  R7,GPEXTRA         RESTORE ORIGINAL EXTRACT RECORD ADDR
*
WRTTXIT  br    R10              RETURN (SWITCH TO 31-BIT MODE)
*
         drop  r3
         DROP  R5                 "LOGICTBL"     DSECT
         DROP  R7                 EXTRACT RECORD DSECT
         DROP  R8                 "CT"    COLUMN DSECT
         DROP  R9                 LOOK-UP BUFFER CONTROL  ELEMENT
                        EJECT
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*                                                                     *
*        W R I T E   S U M M A R Y   E X T R A C T   R E C O R D      *
*                                                                     *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*
         USING LOGICTBL,R5
         USING EXTREC,R7
         USING COLEXTR,R8
*
WRTSUM   lgf   R9,LTWREXTA        LOAD EXTRACT FILE CONTROL ELEMENT ADR
         USING EXTFILE,R9
*
         LLGTR R13,R13
         lgr   R14,R8             SAVE CURRENT COLUMN ADDRESS
*
         sgr   R8,R7              COMPUTE ACTUAL  RECORD  LENGTH
         if CH,R8,lt,EXTMINLN     Is length too short?
           lgh R8,EXTMINLN        NO  -   USE  MINIMUM
         endif
         STH   R8,EXRECLEN        SET  LENGTH  IN "RDW"
*
         lgr   r8,r7
         agf   r8,ltwr_offset_ct  point to first CT column
*
         sthh  r12,exncol
         sgr   R14,R8             LOAD    LENGTH  OF COLUMN DATA
         jz    wrtsbypd
         SRDL  R14,32
         LHI   R0,COLDATAL        COMPUTE NUMBER  OF COLUMNS
         DR    R14,R0
         STH   R15,EXNCOL
                        EJECT
wrtsbypd ds    0h
         MVC   EXVIEW#,LTWRVIEW   COPY FLAGGED VIEW ID
*
         llgt  R1,LTLOGNV         COPY SORTLEN,TITLLEN,DATALEN
         MVC   EXSORTLN(6),LTSORTLN-LOGICTBL(R1)
*
***********************************************************************
*  MERGE EXTRACT RECORD INTO SUMMARY STACK                            *
***********************************************************************
         lgf   R3,LTWREXTO        LOAD  SUM  AREA POINTER ADDRESS
         agr   R3,R2
         USING LTWRAREA,R3
*
         if ltgf,R8,LTWRSUMA,np   not allocated yet?
*
***********************************************************************
*  SWITCH TO "TCB" MODE IF ZIIP ENABLED                               *
***********************************************************************
           if (ltgf,r15,workazip,nz),and,  zIIP function available?    +
               (cli,thread_mode,eq,C'S') and we are in SRB mode
             la  r1,TCB_switch      Switch to TCB mode
             bassm r14,r15          Call zIIP module
           endif
*
***********************************************************************
*  FIRST TIME CALLED - INITIALIZATION                                 *
***********************************************************************
           LHI R0,SUMLEN+l'sumaeyeb LOAD SUM WORK AREA SIZE + EYEBALL
           AHI R0,EXTRECL         ADD  EXTRACT RECORD WORK AREA SIZE
           GETMAIN RU,LV=(0),LOC=(ANY)
           MVC 0(l'sumaeyeb,R1),SUMAEYEB
           AHI R1,l'sumaeyeb
           ST  R1,LTWRSUMA        SAVE  WORK AREA ADDRESS (POINTER)
*
           lgr r8,r1              We will use this reg as our base
           lgr R0,R1              ZERO  WORK AREA
           LA  R1,SUMLEN
           Sgr R14,R14
           SR  R15,R15
           MVCL R0,R14
*
           USING SUMAREA,R8
extsumsa   using savf4sa,r8
           using savf4sa,thrdarea
           STMG r14,r12,extsumsa.savf4sag64rs14 SAVE "MR95" REGISTERS

           STg R8,savf4sanext     FORWARD  POINTER IN OLD RSA
           STg R13,extsumsa.savf4saprev SET BACKWARD POINTER IN NEW RSA
*
           lgr R11,R3             r3 is destroyed by WRTSINIT so save
           BRAS R10,WRTSINIT      INITIALIZE  SUM   AREA
           lgr R3,R11 and restore
*
*        LA    R15,SUMLEN-1(,R8)
*          ly  r2,SNAPDCBA
*        SNAP  DCB=(r2),PDATA=(REGS),ID=105,STORAGE=((R8),(R15))
*
*        OPEN  (HASHDCB,(OUTPUT)),MODE=31
*
***********************************************************************
*  SWITCH TO "SRB" MODE IF ZIIP ENABLED                               *
***********************************************************************
           if (ltgf,r15,workazip,nz),and,  zIIP function available?    +
               (cli,thread_mode,eq,C'P') and we are in tcb mode
             la  r1,SRB_switch      Switch to srb mode
             bassm r14,r15          Call zIIP module
           endif
         else
***********************************************************************
*  SUBSEQUENT CALLS (AFTER FIRST TIME)                                *
***********************************************************************
           STMG r14,r12,extsumsa.savf4sag64rs14 SAVE "MR95" REGISTERS
*
*        LR    R15,R8
*        AHI   R15,SUMLEN-1
*          ly  r2,SNAPDCBA
*        SNAP  DCB=(r2),PDATA=(REGS),ID=110,STORAGE=((R8),(R15))
*
         endif
***********************************************************************
*  CHECK HASH TABLE FOR MATCHING KEY                                  *
***********************************************************************
         agsi  LTWRCNTI,bin1      INCREMENT INPUT RECORD COUNT
*
         DROP  R3
*
         LA    R0,8               ASSUME  SAME SORT  KEY (SKIP  RECORD)
         ST    R0,SUMRTNC
*
hashkey  la    r14,exsrtkey       load extract  record  key  address
         lgh   r15,exsortln
*
         sgr   r3,r3              zero work registers
         sgr   r2,r2
*
hashloop cksm  r3,r14             Compute Checksum
         jnz   hashloop
*
         d     r2,prime+4
*
         sllg  R2,r2,3            CONVERT SUBSCRIPT  TO SLOT ADDRESS
         AG    R2,HASHBEG
         STG   R2,ANCRCURR        SAVE SLOT ADDRESS
         LGR   R3,R2
*
         USING STACKENT,R2
         ltg   R2,0(,R3)          LOAD CURRENT OWNER
         JZ    WRTSNOTF           BRANCH IF  UNUSED (NO KEY MATCH)
*
*          ly  r2,SNAPDCBA
*        SNAP  DCB=(r2),PDATA=(REGS),ID=111
*        SGR   R5,R5              ZERO   SYNONYM  CHAIN LEN
*
WRTSYNLP LA    R14,STKRDW         MATCHING   SORT   KEY ???
         LGH   R15,EXSORTLN-EXTREC(,R14)
         LA    R14,EXSRTKEY-EXTREC(,R14)
         LGH   R0,EXSORTLN
         if CGRj,R15,eq,R0

           LA  R1,EXSRTKEY        LOAD  NEW   KEY ADDRESS
           LA  R15,255(,R15)      ROUND UP TO 256 MULTIPLE
           SRLG R0,R15,8          AND COPY NO OF MULTIPLES TO R0
           J   WRTSCLCE
WRTSCLCL   CLC 0(256,R14),0(R1)
           JNE WRTSYNXT
           LA  R14,256(,R14)
           LA  R1,256(,R1)
WRTSCLCE   BRCTG R0,WRTSCLCL
           EX  R15,SORTCLC        MOVE RECORD FROM DATA SPACE
           JE  FOUND              YES - SUM  COLUMNS
         endif

WRTSYNXT LGR   R14,R2             SAVE  PREVIOUS     ELEMENT    ADDR
         ltg   R2,STKSYNXT        START AT BEGINNING OF SYNONYM CHAIN
         JP    WRTSYNLP
*
         LG    R2,STAKCURR        ASSIGN STACK ELEMENT TO EXTRACT REC
*
         ltg   R0,STKNEXT         UPDATE POINTER  TO NEXT AVAILABLE
         JP    *+10
         LG    R0,SUMTEMP
         STG   R0,STAKCURR
*
         STG   R3,STKHASHA        SAVE   SLOT ADDRESS
         STG   R2,STKSYNXT-STACKENT(,R14) ADD TO SYNONYM CHAIN
         STG   R14,STKSYPRV
         J     WRTSTACK
         EJECT
***********************************************************************
*  SORT KEY NOT IN HASH TABLE  -  ADD TO STACK AND HASH TABLE         *
***********************************************************************
WRTSNOTF LG    R2,STAKCURR        ASSIGN STACK ELEMENT TO EXTRACT REC
*
         if ltg,R0,STKNEXT,np     UPDATE POINTER  TO NEXT AVAILABLE
           LG  R0,SUMTEMP
         endif
         STG   R0,STAKCURR
*
         STG   R2,0(,R3)          SAVE ELEMENT ADDRESS IN HASH  TABLE
         STG   R3,STKHASHA        SAVE    SLOT ADDRESS
         XC    STKSYPRV,STKSYPRV  NO  SYNONYMS (PREV)
         XC    STKSYNXT,STKSYNXT  NO  SYNONYMS (NEXT)
*
*        LGH   R9,EXRECLEN
*        AGR   R9,R7
*        BCTGR R9,0
*          ly  r2,SNAPDCBA
*        SNAP  DCB=(r2),PDATA=(REGS),ID=112,STORAGE=((R7),(R9))
         EJECT
***********************************************************************
*  SAVE CURRENT EXTRACT RECORD IN AVAILABLE ELEMENT                   *
***********************************************************************
WRTSTACK LA    R1,EXTREC          COPY EXTRACT/HEADER TO STACK
         LA    R14,STKRDW         COPY EXTRACT REC (EXCLUDE "CT" COLS)
         LGH   R15,STKLENG        ASSUME  NOT HEADER RECORD
*
         LA    R15,255(,R15)      ROUND UP TO  256 MULTIPLE
         SRLG  R0,R15,8           and copy no of multiples to r0
         J     WRTSSEND
WRTSSMLP MVC   0(256,R14),0(R1)
         LA    R1,256(,R1)
         LA    R14,256(,R14)
WRTSSEND BRCTG R0,WRTSSMLP
         EX    R15,MVCR14R1       MOVE RECORD FROM DATA SPACE
*
         XC    STKMAXC,STKMAXC    INITIALIZE  COUNT (NOT -1 ANYMORE)
*
         LG    R1,STKACUM         LOAD ADDRESS OF ACCUMULATORS
         LGH   R0,EXNCOL          LOAD NO.  OF COLUMNS IN EXTRACT REC
         if cgij,r0,gt,0          ANY  COLUMNS IN THIS RECORD   ???

           LGH R6,EXSORTLN        POINT  TO FIRST COLUMN
           LA  R6,EXSRTKEY(R6)
           LGH R15,EXTITLLN
           AGR R6,R15
           LGH R15,EXDATALN
           AGR R6,R15
           USING COLEXTR,R6
*
           do from=(r0)           LOAD     COLUMN NUMBER
             LGH R15,COLNO        LOAD     COLUMN NUMBER
             if CH,R15,gt,STKMAXC LARGER   COLUMN NUMBER  THAN PREVIOUS
               STH R15,STKMAXC
             endif
             SH R15,SUMMINC       COMPUTE  OFFSET TO INDICATED COLUMN
             LA R14,L'COLDATA
             MLGR R14,R14
*
             AGR R15,R1                 ADD  BASE  TO OFFSET
             MVC 0(L'COLDATA,R15),COLDATA ADD VALUE TO CORRECT COLUMN
*
             LA R6,COLDATAL(,R6)  ADVANCE  TO NEXT COLUMN  OFFSET
           enddo ,                LOOP THROUGH ALL COLUMNS IN EXTRACT
*
*          LA  R14,L'COLDATA
*          LGH R15,STKMAXC
*          MLGR R14,R14
*          AG  R15,STKACUM
*          BCTGR R15,0
*          ly  r2,SNAPDCBA
*          SNAP DCB=(r2),PDATA=(REGS),ID=115,STORAGE=((R2),(R15))
         endif
***********************************************************************
*  EXCHANGE TEMPORARY ELEMENT FOR BOTTOM ELEMENT                      *
***********************************************************************
         CG    R2,SUMTEMP         WAS TEMPORARY ELEMENT USED ???
         JNE   WRTSSUMX           NO  -  STACK NOT FULL YET (RET)
*
*        LA    R15,SUMLEN-1(,R8)
*          ly  r2,SNAPDCBA
*        SNAP  DCB=(r2),PDATA=(REGS),ID=130,STORAGE=((R8),(R15))
*
*        LG    R9,STAKBEG
*        LG    R15,STAKEND
*        BCTGR R15,0
*          ly  r2,SNAPDCBA
*        SNAP  DCB=(r2),ID=131,STORAGE=((R9),(R15))
*
         LGR   R14,R2             SAVE PREVIOUS TEMPORARY  ELEMENT
*
         LG    R2,STAKBOT         REMOVE BOTTOM ELEMENT FROM STACK
         STG   R2,SUMTEMP
         STG   R2,STAKCURR
*
         if ltg,R1,STKPREV,np
           LGR R1,R14             YES - PREVIOUS TEMPORARY IS NOW BOT
         endif
         STG   R1,STAKBOT
         XC    STKNEXT-STACKENT(8,R1),STKNEXT-STACKENT(R1)
*
         LG    R1,STAKTOP         ADD  PREVIOUS TEMPORARY TO STACK TOP
         STG   R14,STAKTOP
         if cgrj,r1,ne,r2         PREVIOUS TOP not= PREVIOUS BOTTOM ???
           STG R14,STKPREV-STACKENT(,R1)
           STG R1,STKNEXT-STACKENT(,R14)
         endif
         XC    STKPREV-STACKENT(8,R14),STKPREV-STACKENT(R14)
*
*  R2 --> PREVIOUS BOTTOM ELEMENT WHICH MUST BE WRITTEN (STOLEN ENTRY)
         LG    R1,STKSYNXT        REMOVE THIS ELEMENT FROM SYN  CHAIN
         ltg   R14,STKSYPRV
         JNP   FIRSTSYN
         STG   R1,STKSYNXT-STACKENT(,R14)
         if LTGR,R1,R1,p
           STG  R14,STKSYPRV-STACKENT(,R1)
         endif
         J     RSETCHAI
*
FIRSTSYN LG    R14,STKHASHA
         STG   R1,0(,R14)
         if cgij,R1,gt,0
           XC  STKSYPRV-STACKENT(8,R1),STKSYPRV-STACKENT(R1)
         endif

RSETCHAI XC    STKPREV,STKPREV
         XC    STKNEXT,STKNEXT
         XC    STKHASHA,STKHASHA
         XC    STKSYPRV,STKSYPRV
         XC    STKSYNXT,STKSYNXT
         EJECT
***********************************************************************
*  WRITE OUT CONTENTS OF STACK ELEMENT (R2 --> ELEMENT)               *
***********************************************************************
         LA    R1,STKRDW
         LA    R7,SUMEXTR         POINT TO EXTRACT RECORD WORK AREA
         LA    R14,EXTREC
         LGH   R15,STKLENG
*
         LA    R15,255(,R15)      ROUND UP TO  256 MULTIPLE
         SRLG  R0,R15,8           No of 256 blocks into r0
         J     WRTSOEND
WRTSOMLP MVC   0(256,R14),0(R1)
         LA    R1,256(,R1)
         LA    R14,256(,R14)
WRTSOEND BRCTG R0,WRTSOMLP
         EX    R15,MVCR14R1       MOVE RECORD FROM DATA SPACE
*
         SGR   R1,R1              ASSUME NO VARIABLE OR NON-ZERO COLS
         LGH   R0,SUMMAXC         LOAD   MAXIMUM NO. OF COLUMNS  USED
         cgijnh r0,0,bldrdw       ANY    USED ???
*
         SH    R0,SUMMINC         COMPUTE NUM OF "CT" COLUMNS
         aghi  R0,1
*
         LGH   R6,EXSORTLN        POINT  TO OUTPUT   AREA
         ah    R6,EXTITLLN
         ah    R6,EXDATALN
         LA    R6,EXSRTKEY(R6)    POINT  TO OUTPUT   AREA
         USING COLEXTR,R6
*
         LG    R14,STKACUM        POINT  TO SUMMARY TOTALS
*
         if LTgf,R15,extvdpa,p         is it avialable?
*
           lgf R15,VDP0200b_ALLOC_FILE_TYPE-VDP0200b_FILE_RECORD(,R15)
           CHI R15,PIPEDEV
           je  *+12
           CHI R15,TOKENDEV
           jne  COPYCOL#
*
           LGH R15,SUMMINC        INITIALIZE COLUMN NUMBER
COPYFIXD   STH R15,COLNO                 SAVE COLUMN  NUMBER
           MVC COLDATA,0(R14)            COPY TOTALS  TO BUFR
           MVC 0(L'COLDATA,R14),ZACCUM ZERO ACCUMULATOR
           LA R1,1(,R1)                  INCREMENT NON-ZERO   COUNT
           LA R6,COLDATAL(,R6)           ADVANCE   TO NEXT    COLUMN
           LA R14,L'COLDATA(,R14)        ADVANCE   TO NEXT    COLUMN
           LA R15,1(,R15)                INCREMENT    COLUMN  NUMBER
           jctg    R0,COPYFIXD    LOOP   THROUGH  ALL COLUMNS
*
         else
COPYCOL#   LGH R15,SUMMINC        INITIALIZE COLUMN NUMBER
COPYCOMP   CLC 0(L'COLDATA,R14),ZACCUM   ZERO VALUE   ???
           je  COPYZERO                  YES - SKIP   COLUMN
           STH R15,COLNO                 SAVE COLUMN  NUMBER
           MVC COLDATA,0(R14)            COPY TOTALS  TO BUFR
           MVC 0(L'COLDATA,R14),ZACCUM   ZERO ACCUMULATOR
           LA  R1,1(,R1)                 INCREMENT NON-ZERO   COUNT
           LA  R6,COLDATAL(,R6)          ADVANCE   TO NEXT    COLUMN
COPYZERO   LA  R14,L'COLDATA(,R14)       ADVANCE   TO NEXT    COLUMN
           LA  R15,1(,R15)               INCREMENT    COLUMN  NUMBER
           jctg  R0,COPYCOMP      LOOP   THROUGH  ALL COLUMNS
         endif
*
BLDRDW   STH   R1,EXNCOL          SAVE    NON-ZERO    COLUMN   COUNT
         LGHI  R0,COLDATAL        COMPUTE LENGTH OF   VARIABLE COLUMNS
         MLGR  R0,R0
         ah    R1,EXSORTLN        COMPUTE TOTAL  RECORD LENGTH
         ah    R1,EXTITLLN
         ah    R1,EXDATALN
         AGHI  R1,EXSRTKEY-EXTREC
         STH   R1,EXRECLEN
*
         MVC   STKMAXC,HEXFF      RESET  MAXIMUM (UNUSED)
*
         XC    SUMRTNC,SUMRTNC    WRITE OUT  SUMMARY RECORD
         J     WRTSSUMX
         EJECT
***********************************************************************
*  MOVE FOUND ELEMENT TO TOP OF STACK (MOST RECENTLY USED POSITION)   *
***********************************************************************
FOUND    ltg   R1,STKPREV         LOAD PREVIOUS ELEMENT ADDRESS
         JNP   WRTSACUM           YES - NO  RELOCATION  NECESSARY
         LG    R14,STKNEXT        LOAD  NEXT   ELEMENT  ADDRESS
         STG   R14,STKNEXT-STACKENT(,R1)
         if cgij,R14,le,0
           STg R1,STAKBOT         store here if not positive
         else
           STg R1,STKPREV-STACKENT(,R14)  here if positive
         endif
*
         LG    R1,STAKTOP
         STG   R2,STAKTOP
         STG   R2,STKPREV-STACKENT(,R1)
         STG   R1,STKNEXT
         XC    STKPREV,STKPREV
*
*        LA    R14,L'COLDATA
*        LGH   R15,STKMAXC
*        MLGR  R14,R14
*        AG    R15,STKACUM
*        BCTGR R15,0
*          ly  r2,SNAPDCBA
*        SNAP  DCB=(r2),PDATA=(REGS),ID=120,STORAGE=((R2),(R15))
*        LA    R15,SUMLEN-1(,R8)
*        SNAP  DCB=(r2),PDATA=(REGS),ID=121,STORAGE=((R8),(R15))
*
WRTSACUM LG    R1,STKACUM         LOAD ADDRESS OF ACCUMULATORS
         LGH   R0,EXNCOL          LOAD NO. OF  COLUMNS IN RECORD
         cgijnh r0,0,wrtssumx     ANY COLUMNS  IN THIS    RECORD ???   +
                                  NO - BYPASS  SUMMARIZATION
*
         LGH   R6,EXSORTLN        POINT TO  FIRST COLUMN
         ah    R6,EXTITLLN
         ah    R6,EXDATALN
         LA    R6,EXSRTKEY(R6)
         USING COLEXTR,R6
*
WRTSSUML LGH   R15,COLNO          LOAD     COLUMN NUMBER
         CH    R15,STKMAXC        LARGER   COLUMN NUMBER  THAN PREVIOUS
         JNH   *+8
         STH   R15,STKMAXC
*
         BCTGR R15,0              COMPUTE  OFFSET TO INDICATED COLUMN
*
         LG    R14,SUMSUBOP       COMPUTE  SUBTOTAL  OPTION CODE ADDR
         AGR   R14,R15
         SGR   R5,R5              LOAD     SUBTOTAL  OPTION
         IC    R5,0(,R14)
*
         AHI   R15,1              COMPUTE  OFFSET TO INDICATED COLUMN
         SH    R15,SUMMINC
         LA    R14,L'COLDATA
         MLGR  R14,R14
         AGR   R15,R1             ADD BASE TO COLUMN OFFSET
*
         CHI   R5,SUBTOT          CHECK    SUBTOTAL  OPTIONS
         JE    WRTSSUMC
         CHI   R5,DETCALC
         JE    WRTSSUMC
         CHI   R5,BRKCALC
         JE    WRTSSUMC
         CHI   R5,RECALC
         JE    WRTSSUMC
*
         CHI   R5,MAX
         JE    WRTSSUMC
         CHI   R5,DETMAX
         JNE   WRTSMIN
         CP    0(L'COLDATA,R15),COLDATA COMPARE PREVIOUS VS NEW VALUE
         JNL   WRTSNXTC
         J     WRTSCPYC
*
WRTSMIN  CHI   R5,MIN
         JE    WRTSSUMC
         CHI   R5,DETMIN
         JNE   WRTSLAST
         CP    0(L'COLDATA,R15),COLDATA COMPARE PREVIOUS VS NEW VALUE
         JNH   WRTSNXTC
         J     WRTSCPYC
*
WRTSLAST CHI   R5,LAST
         JE    WRTSCPYC
*
         CHI   R5,NOSUBTOT
         JNE   WRTSNXTC
*
WRTSCPYC MVC   0(L'COLDATA,R15),COLDATA COPY VALUE TO CORRECT  COLUMN
         J     WRTSNXTC
*
WRTSSUMC AP    0(L'COLDATA,R15),COLDATA ADD  VALUE TO CORRECT  COLUMN
*
WRTSNXTC LA    R6,COLDATAL(,R6)   ADVANCE  TO NEXT COLUMN  OFFSET
         BRCTG R0,WRTSSUML        LOOP THROUGH ALL COLUMNS IN EXTRACT
         SPACE 3
WRTSSUMX LGF   R15,SUMRTNC        LOAD    RETURN    CODE
*
         lg    r14,extsumsa.savf4sag64rs14
         LMG   R0,R12,extsumsa.savf4sag64rs0
*
*        LGH   R15,STKMAXC        LOAD    COLUMN  NUMBER
*        LA    R14,L'COLDATA
*        MLGR  R14,R14
*        LG    R9,STKACUM
*        LA    R10,0(R9,R15)
*          ly  r2,SNAPDCBA
*        SNAP  DCB=(r2),PDATA=(REGS),ID=110,STORAGE=((R9),(R10))
*        LGF   R15,SUMRTNC
*
*
         CHI   R15,8              SKIP  THIS  RECORD  ???
         JE    WRTSXIT            YES - BYPASS WRITE
         LA    R7,SUMEXTR         POINT TO EXTRACT RECORD WORK AR
*
         DROP  R2
         DROP  R6
         DROP  R8
*
         XC    RETNCODE,RETNCODE  ZERO WRITE PGM RETURN CODE
*
         llgf  R15,LTWRADDR       get the address
         ltgr  R15,r15            USER EXIT SPECIFIED   ???
         JZ    WRTSENQ            NO  - BYPASS CALL
*
         xc    gp_error_buffer_len,gp_error_buffer_len
         mvi   gp_error_buffer_len+3,(l'error_buffer) set max length
         xc    gp_error_reason,gp_error_reason        clear reason
WRTSCALL DS    0H
*
         LA    R0,LTWRPARM        POINT  TO WRITE    PARAMETERS
         sty   R0,GPSTARTA
         lgf   R1,LTWREXTO        POINT  TO WRITE    ANCHOR
         agr   R1,R2
         using ltwrarea,r1
         LA    R0,LTWRWORK
         drop  r1
         sty   R0,GPWORKA
         stg   R7,RETNPTR         SET RETURN POINTER
         lay   R1,PARM_AREA
         bassm R14,R15            CALL USER  EXIT
*
         if    (oc,gp_error_reason,gp_error_reason,nz)
           bras  r9,errwtoa       issue "wto" if non-zero reason code
           llgt  R9,LTWREXTA      RESTORE FILE CONT AREA ADDR
         endif
*
         lg    R7,RETNPTR         LOAD RETURN POINTER
         lgf   R15,RETNCODE       LOAD RETURN CODE
*
         CHI   R15,8              SKIP  THIS  RECORD  ???
         JE    WRTS05             YES - BYPASS WRITE
*
         CHI   R15,12             DISABLE  VIEW  ???
         JL    WRTSENQ            NO  - WRITE RECORD
         JNE   WRTSABOR
*
         llgt  R1,LTLOGNV         LOAD    VIEW  BEGINNING ROW    ADDR
         MVI   LTSTATUS-LOGICTBL(R1),C'W'  YES - INDICATE ERROR
         Larl  R14,WEXITmsg                SET INDICATIVE DATA
         MVC   ERRDATA(L'WEXITMSG),0(R14)
         BRAS  R9,DISABREQ                 DISABLE THIS REQUEST
         llgt  R9,LTWREXTA                 RESTORE FILE CONT AREA ADDR
         J     WRTSXIT
*
WRTSABOR MVC   ERRDATA(8),LTWRNAME
         B     ABORTEX            ABORT RUN          (16)
                        SPACE 3
WRTSENQ  LA    R1,WAITECB         LOAD THIS THREAD'S WAIT   ECB ADDRESS
         xgr   R14,R14            ZERO REGISTER (NOT IN-USE VALUE)
         ST    R14,0(,R1)         INITIALIZE   ECB
         LNR   R0,R1              NEGATIVE VERSION OF ECB ADDRESS
*
WRTSRTRY CS    R14,R0,EXTINUSE    TEST IN-USE FLAG ???
         JE    WRTSNEW            BRANCH  IF  ZERO (NOT IN-USE)
         ST    R14,4(,R1)         SAVE PREVIOUS VALUE IN LINKED LIST
         CS    R14,R1,EXTINUSE    MOVE THIS THREAD'S VALUE TO FLAG
         LHI   R14,0              RESET REGISTER BACK TO ZERO
         JNE   WRTSRTRY           TRY AGAIN IF FLAG CHANGED IN MEANTIME
*
           if  cli,thread_mode,eq,c'S'      and in srb mode
***********************************************************************
*    PAUSE "SRB"                                                      *
***********************************************************************
             push using
sa_map       using savf4sa,savesrb
             lmg r0,r1,srbpet1a    get current pointers
             stmg r0,r1,xfrsrbp3   save into parmlist
             lay R1,xfrsrbpl       CALL "IEAVPSE" - PAUSE
             stg r13,sa_map.SAVF4SAprev
             stg r2,savesrb   save r2 as ipk uses it
             la r13,savesrb
             xr r0,r0             clear r0
             ipk ,                save current key in r2
             spka 0(r0)            and flip to key 0
             pop using
           else
             push using
sa_map       using savf4sa,savetcb
             lmg r0,r1,tcbpet1a    get current pointers
             stmg r0,r1,xfrtcbp3   save into parmlist
             if (cli,localauth,eq,c'A')
               MODESET KEY=ZERO,MODE=SUP key zero needed now for the
*                                         pause element calls
             endif
             lay R1,xfrtcbpl      CALL "IEAVPSE" - PAUSE
             stg r13,sa_map.SAVF4SAprev
             la r13,savetcb
             pop using
           endif
           Llgt   R15,IEA4PSE
           BASR R14,R15
           if cij,r15,ne,0     If this fails, then end thread
             MVC DBLWORK,=CL8'IEA4PSE'
             ST  R15,DBLWORK2  Save return code
             j   PE_error      Write msg to log, and end thread
*            DC H'0'
           endif
sa_map     using savf4sa,thrdarea
           Lg  R13,sa_map.SAVF4SAprev
           drop sa_map
           if  cli,thread_mode,eq,c'S'      and in srb mode
             spka 0(r2)           restore the saved key
             lgf  r1,ovflmask       set bits 36 and 37           pgc120
             spm r1                 set overflow masks on pgc120
             lg r2,savesrb         restore r2
             lmg r0,r1,srbpet1a    get current pointers
             stg r1,srbpet1a          and flip to correct positions
             stg r0,srbpet2a
           else
             if (cli,localauth,eq,c'A')
               MODESET KEY=NZERO,MODE=PROB
             endif
             lmg r0,r1,tcbpet1a    get current pointers
             stg r1,tcbpet1a          and flip to correct positions
             stg r0,tcbpet2a
           endif
                        SPACE 3
WRTsNEW  do inf
           llgt R4,EXTRECAD        LOAD   TARGET ADDRESS FOR NEW RECORD
           lgh R15,EXRECLEN       LOAD   RECORD LENGTH
           if TM,EXTRECFM,X'40',z VARIABLE  OR  UNDEFINED ???
             lgh R15,EXTLRECL      NO  -   USE   FIXED  LENGTH
           endif
           lgr R0,R4              COMPUTE TRIAL END-OF-BUFFER  ADDRESS
           agr R0,R15
           doexit (cgf,R0,le,EXTEOBAD) If record fits, exit loop now
*
***********************************************************************
*  SWITCH TO "TCB" MODE IF ZIIP ENABLED                               *
***********************************************************************
           if (ltgf,r15,workazip,nz),and,  zIIP function available?    +
               (cli,thread_mode,eq,C'S') and we are in SRB mode
             la  r1,TCB_switch      Switch to TCB mode
             bassm r14,r15          Call zIIP module
           endif
*          here if record overflows buffer
*
           llgt R1,EXTDECBC       LOAD  CURRENT DECB PREFIX ADDRESS
           llgt R15,16(,R1)       LOAD   BUFFER ADDR FROM   DECB
           sgr  R4,R15            COMPUTE BLOCK LENGTH
           if TM,EXTRECFM,X'40',o     VARIABLE   OR UNDEFINED   ???
             STH R4,0(,R15)       BUILD   BLOCK DESCRIPTOR  WORD  (BDW)
           endif
           STH R4,10(,R1)         PLACE  LENGTH IN    DECB
*
           ltgf R15,EXTDCBA        DCB ALLOCATED ???
           JNP WRTSPIPE           NO  -   TREAT AS   DUMMY         @03C
*
           TM  48(R15),X'10'      EXTRACT FILE  STILL OPEN  ???
           JO  WRTSPUT            YES -  CONTINUE
           MVI 4(R1),X'7F'        NO  -  PRETEND  I/O COMPLETED
           llgt R1,EXTDECBC        LOAD  ADDRESS OF NEXT DECB PREFIX
           llgt R1,0(,R1)
           ST  R1,EXTDECBC        SAVE  ADDRESS OF NEXT DECB PREFIX
           j   WRTsnowt           and bypass the check (closed d/set)
*
WRTSPIPE   llgt R15,LTWR200A      LOAD VDP 200 RECORD ADDRESS      @03I
          ltgf R15,VDP0200b_FILE_READER-VDP0200b_FILE_RECORD(,R15) @03I
           JNZ WRTSPUT                                             @03I
*
           MVI 4(R1),X'7F'        NO  -  PRETEND  I/O COMPLETED
           J   WRTSSKIP
*
WRTSPUT    aghi R1,4              POINT TO DECB (FOLLOWING PREFIX)
           XC  0(4,R1),0(R1)      CLEAR ECB
           llgf R15,EXTPUT_6431   LOAD  WRITE  ROUTINE ADDRESS
           bassm R14,R15          WRITE PHYSICAL BLOCK (31-BIT MODE)
*
WRTSSKIP   llgt R1,EXTDECBC       LOAD  ADDRESS OF NEXT DECB PREFIX
           llgt R1,0(,R1)
           ST  R1,EXTDECBC        SAVE  ADDRESS OF NEXT DECB PREFIX
*
           AHI R1,4               POINT TO ECB
           llgf R15,extchk_6431   LOAD  CHECK  ROUTINE ADDRESS
           bassm R14,R15          WRITE PHYSICAL BLOCK (31-BIT MODE)
           llgt R1,EXTDECBC       RESTORE DECB PREFIX  ADDRESS
*
WRTSNOWT   llgt R15,16(,R1)       LOAD  BUFFER ADDRESS FROM DECB
           LA  R0,4(,R15)         SKIP  BDW
           TM  EXTRECFM,X'40'     VARIABLE  OR UNDEFINED    ???
           JO  *+8                YES - LEAVE  ROOM  FOR   "BDW"
           lgr R0,R15             NO  - START  AT BEGINNING
           ST  R0,EXTRECAD        INITIALIZE NEXT RECORD ADDRESS
*
           agh R15,EXTBLKSI
           ST  R15,EXTEOBAD
*
***********************************************************************
*    SWITCH TO "SRB" MODE IF ZIIP ENABLED                             *
***********************************************************************
           if (ltgf,r15,workazip,nz),and,  zIIP function available?    +
               (cli,thread_mode,eq,C'P') and we are in TCB mode
             la  r1,SRB_switch      Switch to SRB mode
             bassm r14,r15          Call zIIP module
           endif
*         if  cli,localziip,eq,c'Y',and,   switching allowed          +
*              cli,thread_mode,eq,c'P'      and in problem state (TCB)
*            LAY R14,WRTSNEW      CONTINUE WITH "WR_DT"
*            J SRBSWICH
*          else ,
*            J WRTSNEW
*          endif
         enddo
                        SPACE 3
WRTSCOPY ST    R0,EXTRECAD        UPDATE ADDRESS  FOR NEXT RECORD
*
         agsi  EXTCNT,bin1        INCREMENT   EXTRACT FILE RECORD COUNT
         agsi  thrd_extrrec_cnt,bin1    for thread total later
*
         lgr   R0,R15             ASSUME FIXED
         lg    r1,thrd_extrbyte_cnt  Get thread byte count
         agr   r1,r0                  add this record to total
         ag    r0,extbytec           Increment extract byte count
         stg   r0,extbytec             and save it
         stg   r1,thrd_extrbyte_cnt  and save thread byte count
*
         CH    R15,EXTLRECL
         JNH   WRTSSRC
*
         LHI   R14,RECORD_GT_LRECL INDICATE RECORD TOO LARGE
         MVC   ERRDATA(8),EXTDDNAM
         cvd   r15,dblwork
         OI    DBLWORK+L'DBLWORK-1,X'0F'
         UNPK  ERRDATA+10(6),DBLWORK
         XC    MSGS2PTR,MSGS2PTR  No additional parms
         st    r14,dblwork        Save msgid to use as flag later  pgc2
         j     wrtsdeq            Before stopping this make sure   pgc2
*
WRTSSRC  LA    R1,EXTREC          MOVE   THIS EXTRACT RECORD TO BUFFER
         TM    EXTRECFM,X'40'     VARIABLE OR UNDEFINED  ???
         JO    *+8                YES - INCLUDE "RDW"
         LA    R1,EXTREC+4        NO  - IGNORE  "RDW"
*
         LA    R15,255(,R15)      ROUND UP TO  256 MULTIPLE
         SRLg  R0,r15,8
         J     WRTSEND
WRTSMVLP MVC   0(256,R4),0(R1)
         LA    R1,256(,R1)
         LA    R4,256(,R4)
WRTSEND  BRCT  R0,WRTSMVLP
         EX    R15,WRTEXMVC       MOVE RECORD FROM DATA SPACE
                        SPACE 3
WRTSCNT  lgf   R3,LTWREXTO        LOAD  SUM  AREA POINTER ADDRESS
         agr   R3,R2
         USING LTWRAREA,R3
*
         agsi  LTWRCNTO,bin1      INCREMENT RECORD COUNT
*
         clc   LTWRCNTO,LTWRLMT            EXTRACT RECORD LIMIT REACHED
         JNH   WRTSDEQ                     NO  - CONTINUE
*
         llgt  R1,LTLOGNV                  LOAD  REPORT   BEG ROW  ADDR
         MVI   LTSTATUS-LOGICTBL(R1),C'L'  YES - INDICATE LIMIT REACHED
         Larl  R14,LIMITmsg                SET INDICATIVE DATA
         MVC   ERRDATA(L'LIMITMSG),0(R14)
         BRAS  R9,DISABREQ                 DISABLE THIS REQUEST
         llgt  R9,LTWREXTA                 RESTORE FILE CONT AREA ADDR
                        SPACE 3
WRTSDEQ  lgf   R1,EXTINUSE        LOAD IN-USE FLAG  VALUE
WRTSPOST ltgfr R1,R1              ANY  THREAD BESIDE THIS ONE WAITING
         JNP   WRTSRSET           NO  -  EXIT
*
         llgf  r15,4(,r1)         Load ptr to next thread's ecb    pgc2
         cs    r1,r15,extinuse    Next thread's ecb addr to flag   pgc2
         jne   wrtspost           Retry unlock if changed          pgc2
*                                                                  pgc2
*        Need to check if we are ending this thread, if not then   pgc2
*        carry on as normal. Otherwise we need to check if this    pgc2
*        thread is now the last in queue ie the 2nd last in queue  pgc2
*        points to the complement of the WAITECB for this thread.  pgc2
*        In this case the 2nd last thread is now the end of queue. pgc2
*                                                                  pgc2
         l     r14,dblwork       See if we flagged RECORD_GT_LRECL pgc2
         chi   r14,RECORD_GT_LRECL Was there an LRECL error?       pgc2
         jne   wrtspost_10        N: then carry on as normal       pgc2
         lgr   r15,r1                                              pgc2
wrtspost_02 ds 0h                                                  pgc2
         ltgf  r14,4(,r15)        Get next on queue                pgc2
         jnp   wrtspost_07        Here if negative                 pgc2
wrtspost_03 ds 0h                                                  pgc2
         ltgf  r0,4(,R14)         Get next on queue                pgc2
         jnp   wrtspost_05        Here if negative                 pgc2
         lgr   r15,r14            Point at 2nd and start there     pgc2
         lgr   r14,r0             Point at 2nd and start there     pgc2
         j     wrtspost_03        and try again                    pgc2
wrtspost_05 ds 0h                                                  pgc2
         lngr  r0,r14             Get negative of ECB              pgc2
         st    r0,4(,r15)         Save this as last in previous    pgc2
         j     wrtspost_10        Carry on and post next on queue  pgc2
wrtspost_07 ds 0h                                                  pgc2
         lngr  r0,r15             Get negative of ECB              pgc2
         cs    r15,r0,extinuse    Make the flag negative           pgc2
         jne   wrtspost_02                                         pgc2
*                                                                  pgc2
wrtspost_10 ds 0h                                                  pgc2
*
           la  r14,thread_mode-waitecb(,r1) point at flag
*          locate the appropiate pause element token
*          and then set up to release that PE
           if  cli,0(r14),eq,c'S'    this test is to make sure that    +
                                     the waiting element is an SRB
             lg r0,srbpet1a-waitecb(,r1) shift r1 to correct address
           else
             lg r0,tcbpet1a-waitecb(,r1) get the tcb pe pointer
           endif
           xgr r1,r1               clear the release code address
           if cli,thread_mode,eq,c'S'  then an SRB active
             push using
sa_map       using savf4sa,savesrb
             stmg r0,r1,xfrsrbp3  save in parm
             lay r1,xfrsrbpl  release srb which will clean up
             stg r13,sa_map.SAVF4SAprev
             stg r2,savesrb   save r2 as ipk uses it
             la r13,savesrb
             xr r0,r0             clear r0
             ipk ,                save current key in r2
             spka 0(r0)            and flip to key 0
             pop using
           else
             push using
sa_map       using savf4sa,savetcb
             stmg r0,r1,xfrtcbp3  save in parm
             if (cli,localauth,eq,c'A')
               MODESET KEY=ZERO,MODE=SUP key zero needed now for the
*                                         pause element calls
             endif
             lay r1,xfrtcbpl
             stg r13,sa_map.SAVF4SAprev
             la r13,savetcb
             pop using
           endif
           llgt r15,iea4rls      and finish
           basr r14,r15
sa_map     using savf4sa,thrdarea
           lg  R13,sa_map.SAVF4SAprev
           drop sa_map
           if cij,r15,ne,0    if this fails, then end thread
             MVC DBLWORK,=CL8'IEA4RLS'
             ST  R15,DBLWORK2  Save return code
             j   PE_error      Write msg to log, and end thread
*            DC H'0'
           endif
           if cli,thread_mode,eq,c'S'  then an SRB active
             spka 0(r2)           restore the saved key
             lg r2,savesrb         restore r2
             lgf  r1,ovflmask       set bits 36 and 37           pgc120
             spm r1                 set overflow masks on pgc120
           else
             if (cli,localauth,eq,c'A')
               MODESET KEY=NZERO,MODE=PROB
             endif
           endif
         J     WRTS05             INCREMENT  VIEW'S  EXTRACT COUNT
*
WRTSRSET XR    R0,R0              RESET FLAG BACK TO NO  ONE WAITING
         CS    R1,R0,EXTINUSE
         JNE   WRTSPOST           RETRY UNLOCK IF CHANGED IN MEANTIME
                        SPACE 3
wrts05   ds    0h                                                  pgc2
         l     r14,dblwork        Get possible RECORD_GT_LRECL pgc2
         chi   r14,RECORD_GT_LRECL Was there an LRECL error?       pgc2
         jne   wrts07             n: then carry on                 pgc2
         xc    dblwork(4),dblwork clear msg                        pgc2
         j     errmsg#            quit                             pgc2
wrts07   ds    0h                                                  pgc2
         llgt  R7,GPEXTRA         RESTORE ORIGINAL EXTRACT RECORD ADDR
         CLC   RETNCODE,F4        WRITE SUBROUTINE SPECIFIED "RECALL"
         JNE   WRTSXIT            NO  - CHECK CACHE RETURN CODE
         llgf  R15,LTWRADDR       LOAD  SUBROUTINE ADDRESS
         J     WRTSCALL           RECALL WRITE  SUBROUTINE
*
WRTSXIT  ds    0h                 RETURN (SWITCH TO 31-BIT MODE)
         lgr   r8,r7
         agf   r8,ltwr_offset_ct  point to first CT column
         BR    R10
*
         DROP  R3
                        EJECT
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*                                                                     *
*        I N I T I A L I Z E   S U M M A R Y   W O R K A R E A        *
*                                                                     *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*
         USING SUMAREA,R8
extsumsa using savf4sa,sumarea
*
WRTSINIT DS    0h
         llgt  R3,LTLOGNV         LOAD "NV" logictbl entry
r3logic  using logictbl,r3
*
         llgt  R0,r3logic.LTSUBOPT        COPY SUBTOTAL OPTIONS ADDR
         STG   R0,SUMSUBOP
*
         LGF   R2,LTWRSUMC        LOAD  STACK COUNT
         drop  r5
         STG   R2,SCALE
         SLLG  R2,R2,2            MULTIPLY BY 4  (#HASH TABLE SLOTS)
         STG   R2,PRIME
         SLLG  R2,R2,3            MULTIPLY BY 8  (DOUBLEWORDS)
*
         LGH   R1,r3logic.LTMINCOL LOAD MINIMUM COLUMN NO
         STH   R1,SUMMINC
         LGH   R0,r3logic.LTMAXCOL LOAD MAXIMUM COLUMN NO
         STH   R0,SUMMAXC
         SGR   R0,R1
         AGHI  R0,1
         LGHI  R1,L'COLDATA
         MLGR  R0,R0              COMPUTE "CT"  AREA  SIZE
*
         LGHI  R15,EXSRTKEY-EXTREC+L'HDRDATA+STACKLEN COMPUTE  MIN LEN
         ah    R15,EXSORTLN
*
         lgh   R0,EXSORTLN
         aghi  R0,EXSRTKEY-EXTREC       ADD "CT"  AREA   OFFSET
         ah    R0,EXTITLLN
         ah    R0,EXDATALN
         AGHI  R0,STACKLEN              ADD STACK PREFIX LENGTH
         AGR   R0,R1                    ADD "CT"  LENGTH
*
         if CGRj,R0,lt,R15         less than minimum ?
           LGR R0,R15             NO  - USE MINIMUM
         endif

         STY   R0,ELEMSIZE
*
         LG    R1,SCALE
         AGHI  R1,1               ADD  +1 FOR   TEMPORARY  SAVE  ELEM
         MLGR  R0,R0              COMPUTE STACK SIZE
         LGR   R3,R1              SAVE    STACK SIZE
*
         lay   R1,TRAC64B
         MVC   PRNTrdw(L'TRAC64B),0(R1)
*
         LGR   R4,R2
         AGR   R4,R3
         AG    R4,MEGROUND
         SRLG  R4,R4,20
*
         CVD   R4,DBLWORK
         OI    DBLWORK+L'DBLWORK-1,X'0F'
         UNPK  PRNTrdw+37(9),DBLWORK
         MVC   ERRDATA(9),PRNTRDW+37 Save for error message
         XC    MSGS2PTR,MSGS2PTR  No additional parms
*
         STG   R4,DBLWORK
*
         lghi  R14,EPA_LIMIT    LIMIT GETMAIN TO 20GB
         cghi  R4,20000
         JLH   ERRMSG#
*
         llgt  R14,THRDMAIN
         agf   R4,EXTSUM64-THRDAREA(,R14)
         ST    R4,EXTSUM64-THRDAREA(,R14)
*
         if TM,WORKFLAG1,MSGLVL_DEBUG,o  Check the message level
           ENQ (GENEVA,LOGNAME,E,,STEP),RNL=NO
           logit
           DEQ (GENEVA,LOGNAME,,STEP),RNL=NO
         endif
*
         IARV64 REQUEST=GETSTOR,SEGMENTS=DBLWORK,ORIGIN=HASHBEG,       X
               FPROT=NO,SVCDUMPRGN=YES,USERTKN=NO_USERTKN,             X
               MF=(E,GETMAIN,COMPLETE)
*
         SAM64                    SWITCH   TO 64-BIT  MODE
*
         LG    R0,HASHBEG         ZERO HASH AREA
         agr   R0,R2              LOAD HASH AREA SIZE
*              Iarv64 clears the storage area to zeroes
*
         STG   R0,STAKBEG         SAVE BEGINNING      ADDRESS
         STG   R0,STAKTOP         SET  FIRST  ELEMENT ADDRESS
         STG   R0,STAKCURR        SET  CURR   ELEMENT
         LGR   R1,R0              LOAD STACK  ADDRESS
         AGR   R1,R3
         STG   R1,STAKEND         SAVE ENDING         ADDRESS
         SGF   R1,ELEMSIZE
         STG   R1,SUMTEMP         SET  TEMPORARY      ELEMENT
         SGF   R1,ELEMSIZE
         STG   R1,STAKBOT         SET  LAST   ELEMENT ADDRESS
*
*        Clearing not required as IARV64 will have done this
*
*        LA    R9,WORKLEN-1(,R13)
*          ly  r2,SNAPDCBA
*        SNAP  DCB=(r2),PDATA=(REGS),ID=100,STORAGE=((R13),(R9))
*
         BRAS  R9,INITSTAK        INITIALIZE STACK
*
*        LG    R2,STAKTOP
*        LG    R9,SUMTEMP
*        AGF   R9,ELEMSIZE
*        BCTGR R9,0
*          ly  r3,SNAPDCBA
*        SNAP  DCB=(r3),PDATA=(REGS),ID=101,STORAGE=((R2),(R9))
*
         BR    R10                RETURN
         drop  r3logic
                        SPACE 5
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*                                                                     *
*        Z E R O   S U M M A R Y   C O L U M N S                      *
*                                                                     *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
INITSTAK LG    R2,STAKTOP         FIRST     STACK  ELEMENT
         USING STACKENT,R2
         SGR   R14,R14            PREVIOUS  STACK  ELEMENT (TOP = ZERO)
*
         LGHI  R15,EXSRTKEY-EXTREC COMPUTE OFFSET  TO "CT" ACCUMULATORS
         ah    R15,EXSORTLN
         ah    R15,EXTITLLN
         ah    R15,EXDATALN
*
         do until=(cgij,r2,le,0)
           STG R14,STKPREV        SET    PREVIOUS  POINTER
           LGR R14,R2             UPDATE PREVIOUS  POINTER
           STH R15,STKLENG
           LA  R1,STACKLEN(R2,R15)   SET ACCUMULATOR  ADDRESS
           STG R1,STKACUM
           MVC STKMAXC,HEXFF      INDICATE UNUSED  ELEMENT
*
           do until=(cgf,r0,gt,elemsize)
             MVC 0(L'COLDATA,R1),ZACCUM
             LA R1,L'COLDATA(,R1)
             LA R0,L'COLDATA(,R1)
             SGR R0,R2
           enddo

           AGF R2,ELEMSIZE        LOAD   ADDRESS   OF NEXT ELEMENT
           if CG,R2,gt,SUMTEMP
             SGR R2,R2
           endif
           STG R2,STKNEXT-STACKENT(,R14)
         enddo
*
         LG    R2,STAKBOT         REMOVE TEMP ELEMENT FROM STACK
         XC    STKNEXT,STKNEXT
*
         BR    R9
*
         DROP  R2
*
         DROP  R8                 SUBTOTAL DATA "DSECT"
         DROP  R9                 EXTRACT  FILE  CONTROL  ELEMENT
                        EJECT
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*                                                                     *
* "WRTHDR" - WRITE A REPORT HEADER RECORD TO THE APPROPRIATE          *
*            REPORT EXTRACT FILE.                                     *
*                                                                     *
* REGISTER USAGE:                                                     *
*                                                                     *
*        R14 - RETURN   ADDRESS                                       *
*        R8  - CURRENT  LOGIC   TABLE  ROW    ADDRESS ("NV")          *
*        R5  - CURRENT  LOGIC   TABLE  ROW    ADDRESS ("WR")          *
*        R3  - EXTRACT  FILE    CONTROL       AREA                    *
*        R1  - DCB      ADDRESS                                       *
*                                                                     *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*
         drop  r13
         using (thrdarea,thrdend),r13 Tell assembler to map the area
         using savf4sa,savesubr
         using genenv,env_area
         using genparm,parm_area
         using genfile,file_area
         USING MSGLIST,MSG_AREA
WRTHDR   ds    0h
*
         stg   R14,SAVF4SAG64RS14 SAVE  RETURN ADDRESS
*
         LAY   R10,WKREENT        INITIALIZE   TOKEN STACK POINTER
*
         llgt  R8,THRDES          LOAD  LOGIC  TABLE  "ES"  ROW  ADDR
         USING LOGICTBL,R8
         llgt  r2,lteslpad        load the literal pool address
*        this routine can be driven by the dcb eof code - all
*        registers will be those at open time - so make sure r2 is ok
         llgt  R8,LTFRSTNV        LOAD  FIRST  VIEW    ADDRESS
*
         ltgf  R5,LTFRSTWR               ANY   WRITES  ???
         JNP   WRTHNVNX                  NO -  ADVANCE TO  NEXT  "NV"

wrlogic  using logictbl,r5
WRTHTKLP do inf
           doexit CLC,wrlogic.LTFUNC,ne,WR_TX,and, not a token ?? so   +
               CLC,wrlogic.LTFUNC,ne,WR_TK      not a token ?? so      +
                                              BYPASS STACK
*
***********************************************************************
*  PUSH PREVIOUS NV(R8), WR(R5) ONTO STACK                            *
***********************************************************************
           ST  R8,0(,R10)
           ST  R5,4(,R10)
           LA  R10,4+4(,R10)
*
***********************************************************************
*  ADVANCE TO NEXT TOKEN "ET/ES" LEVEL                                *
***********************************************************************
           llgt r1,wrlogic.ltwr200a   .VDP200 output partition
           llgt r1,VDP0200b_file_reader-VDP0200b_file_record(,R1)
tk_re      USING LOGICTBL,R1
           llgt R1,tk_re.LTREES
           DROP tk_re
re_es      USING LOGICTBL,R1
           llgt r8,re_es.LTFRSTNV  LOAD  FIRST   VIEW  ADDRESS
           DROP re_es
*
           ltgf R5,LTFRSTWR        LOAD  FIRST   "WR"  ADDR
           JNP WRTHNVNX           NO -  ADVANCE  TO   NEXT  "NV"
         enddo
*
wrthwrlp clc   wrlogic.ltfunc,wr_tk      is it a write to token?
         je    wrthwrnx                  then split
         clc   wrlogic.ltfunc,wr_tx
         je    wrthwrnx
                        SPACE 3
         XC    SUMRTNC,SUMRTNC    CLEAR RETURN CODE
*
         llgt  r2,thrdes                 Get the "ES" for this thread
nves     using logictbl,r2               and map it
         llgt  r2,nves.lteslpad          load the literal pool address
         agfi  r2,f512k                  lit pool base is in middle
         drop  nves
         ltgf  r15,ltviewre              Get RE for this view    pgc100
         jz    wrthwrnx            jump here for the case where
*                                  this is a reference job and
*                                  there is no RE for the REH/RTH
*                                  WRDT
         lgf   r15,ltreindx-logictbl(,r15) Get it index          pgc100
         mghi  r15,8                     make it into word       pgc101
         aghi  r15,litphdrl              allow for litp header   pgc100
         agf   r2,0-524288(r15,r2)       Get offset of real litp pgc100
         llgt  R9,wrlogic.LTWREXTA       LOAD EXTRACT FILE CONTROL ADDR
         USING EXTFILE,R9
*
*
         tm    extflag,extfmtph          Is it a format phase write
         jno   WRTHHDR                   N: try neext WR**
*                                        After making sure the header
*                                        record is built -- as this
*                                        is needed for any WRITE exits.
*
         lgf   r3,wrlogic.ltwrexto       Load write extract area offset
         agr   r3,r2                     add literal pool base
         using ltwrarea,r3
*
***********************************************************************
*  FLUSH SUMMARY STACK IF ANY                                         *
***********************************************************************

         ltgf  r1,ltwrsuma        load sum area pointer address
         JNP   WRTHHDR            NO  - BYPASS ALLOCATION
         USING SUMAREA,R1
*
         LG    R4,STAKTOP         INITIALIZE CURRENT STACK POSITION
         STG   R4,STAKCURR
*
***********************************************************************
*  FLUSH STACK (LAST EXTRACT/HEADER RECORD RECEIVED)                  *
***********************************************************************
WRTHFLUS LGF   R0,SUMRTNC         LOAD  PREVIOUS RETURN CODE
         XC    SUMRTNC,SUMRTNC    RESET CURRENT  RETURN CODE
         cghi  R0,8               END-OF-STACK   ???
         JE    WRTHHDR
*
         LG    R4,STAKCURR        LOAD  CURRENT  STACK POSITION
         USING STACKENT,R4
*
         CG    R4,STAKBOT         LAST  ELEMENT  IN    STACK  ???
         JE    WRTHLST            YES - RETURN   HEADER
*
         LGH   R0,STKMAXC         ELEMENT USED   ???
         cgijnl R0,0,wrthadv       YES - RETURN   IT
*
         LG    R4,STKNEXT
         STG   R4,STAKCURR
         J     WRTHFLUS
*
***********************************************************************
*  FLUSH LAST ENTRY IN STACK                                          *
***********************************************************************
WRTHLST  LGH   R0,STKMAXC         BOTTOM ELEMENT USED ???
         cgijl r0,0,wrthhdr       NO  - WRITE  HEADER RECORD
*
         MVC   SUMRTNC,F8
*
         J     WRTHOUTP
*
***********************************************************************
*  SAVE ADDRESS OF NEXT ENTRY IN STACK                                *
***********************************************************************
WRTHADV  LG    R0,STKNEXT         LOAD  ELEMENT  IN   STACK
         STG   R0,STAKCURR
*
         MVC   SUMRTNC,F4         LOOP   UNTIL   LAST STACK ENTRY
*
         DROP  R1
                        EJECT
***********************************************************************
*  WRITE OUT CONTENTS OF STACK ELEMENT (R4 --> ELEMENT)               *
***********************************************************************
WRTHOUTP LA    R1,STKRDW
         LA    R14,EXTREC
         LGH   R15,STKLENG
*
         LA    R15,255(,R15)      ROUND UP TO  256 MULTIPLE
         SRLG  R0,R15,8           No of 256-byte chunks
         J     WRTHOEND
WRTHOMLP MVC   0(256,R14),0(R1)
         LA    R1,256(,R1)
         LA    R14,256(,R14)
WRTHOEND BRCTG R0,WRTHOMLP
         EX    R15,MVCR14R1       MOVE RECORD FROM CACHE
*
         SGR   R1,R1              ASSUME NO VARIABLE OR NON-ZERO COLS
         LGH   R0,LTMAXCOL        LOAD   MAXIMUM NO. OF COLUMNS  USED
         cgijnh r0,0,wrthrdw      ANY    USED ???
*
         lgh   R14,LTMINCOL        COMPUTE NUM OF "CT" COLUMNS
         sgr   R0,r14             COMPUTE NUM OF "CT" COLUMNS
         aghi  R0,1
*
         MVC   STKMAXC,HEXFF      RESET  MAXIMUM (UNUSED)
*
         LGH   R6,EXSORTLN        POINT  TO OUTPUT   AREA
         ah    R6,EXTITLLN
         ah    R6,EXDATALN
         LA    R6,EXSRTKEY(R6)
         USING COLEXTR,R6
*
         LG    R14,STKACUM        POINT  TO SUMMARY TOTALS
*
         ltgf  R15,EXTVDPA        VDP  RECORD AVAILABLE ???
         jnp   WRTHCOL#           NO - BYPASS PIPE TEST
*
         lgf   R15,VDP0200b_ALLOC_FILE_TYPE-VDP0200b_FILE_RECORD(,R15)
         CHI   R15,PIPEDEV
         je    *+12
         CHI   R15,TOKENDEV
         jne   WRTHCOL#
*
         LGH   R15,LTMINCOL       INITIALIZE COLUMN NUMBER
WRTHFIXD STH   R15,COLNO                 SAVE COLUMN  NUMBER
         MVC   COLDATA,0(R14)            COPY TOTALS  TO BUFR
         MVC   0(L'COLDATA,R14),ZACCUM   ZERO ACCUMULATOR
         LA    R1,1(,R1)                 INCREMENT NON-ZERO   COUNT
         LA    R6,COLDATAL(,R6)          ADVANCE   TO NEXT    COLUMN
         LA    R14,L'COLDATA(,R14)       ADVANCE   TO NEXT    COLUMN
         LA    R15,1(,R15)               INCREMENT    COLUMN  NUMBER
         jctg  R0,WRTHFIXD        LOOP   THROUGH  ALL COLUMNS
*
         j     WRTHRDW
*
WRTHCOL# LGH   R15,LTMINCOL       INITIALIZE COLUMN NUMBER
WRTHCOMP CLC   0(L'COLDATA,R14),ZACCUM   ZERO VALUE   ???
         JE    WRTHZERO                  YES - SKIP   COLUMN
         STH   R15,COLNO                 SAVE COLUMN  NUMBER
         MVC   COLDATA,0(R14)            COPY TOTALS  TO BUFR
         MVC   0(L'COLDATA,R14),ZACCUM   ZERO ACCUMULATOR
         LA    R1,1(,R1)                 INCREMENT NON-ZERO   COUNT
         LA    R6,COLDATAL(,R6)          ADVANCE   TO NEXT    COLUMN
WRTHZERO LA    R14,L'COLDATA(,R14)       ADVANCE   TO NEXT    COLUMN
         LA    R15,1(,R15)               INCREMENT    COLUMN  NUMBER
         jctg  R0,WRTHCOMP        LOOP   THROUGH  ALL COLUMNS
*
WRTHRDW  STH   R1,EXNCOL          SAVE    NON-ZERO    COLUMN   COUNT
         LA    R0,COLDATAL        COMPUTE LENGTH OF   VARIABLE COLUMNS
         MLGR  R0,R0
         ah    R1,EXSORTLN        COMPUTE TOTAL  RECORD LENGTH
         ah    R1,EXTITLLN
         ah    R1,EXDATALN
         LA    R1,EXSRTKEY-EXTREC(,R1)
         STH   R1,EXRECLEN
*
         JAS   R14,WRTHWAIT
*
         LGF   R1,LTWRSUMA
         L     R0,SUMRTNC
         CHI   R0,4
         JNE   WRTHHDR            NO  - WRITE    HEADER
*
         J     WRTHFLUS           YES - CONTINUE FLUSHING CACHE
*
         DROP  R4
         DROP  R6
                        EJECT
***********************************************************************
*  BUILD STANDARD VIEW HEADER RECORD                                  *
***********************************************************************
WRTHHDR  DS    0H
         JAS   R14,WRTHBLDH      BUILD  STANDARD EXTRACT HEADER RECORD
         JAS   R14,WRTHWAIT      WAIT FOR AVAILABLE OUTPUT BUFFER
*
WRTHWRNX ltgf  R5,wrlogic.LTWRNEXT
         JP    WRTHTKLP
*
WRTHNVNX ltgf  R8,LTNEXTNV
         JNP   WRTHTKNX
*
         ltgf  R5,LTFRSTWR        ANY   WRITES ???
         JNP   WRTHNVNX           NO  - ADVANCE TO  NEXT  "NV"
         J     WRTHTKLP
*
WRTHTKNX LAY   R0,WKREENT
         if cgrj,r10,ne,R0
*
***********************************************************************
*  POP THE PREVIOUS NV(R8), WR(R5) OFF THE STACK                      *
***********************************************************************
           aghi R10,-4-4
           llgt R8,0(,R10)
           llgt R5,4(,R10)
           J   WRTHWRLP
         endif
*
         lg    R14,SAVF4SAG64RS14 RESTORE RETURN ADDRESS
         br    R14
                        EJECT
***********************************************************************
*  BUILD STANDARD VIEW HEADER RECORD                                  *
***********************************************************************
WRTHBLDH DS    0H
         stg   R14,WRTHDR_R14       Need to save return address
*
         L     R0,wrlogic.LTWRVIEW
         nill  R0,x'fffe'         CLEAR  FLAG
         ST    R0,EXVIEW#
*
*        R8 is currently the logic table NV pointer so extract the
*        USERID from there
         MVC   HDUSERID,LTUSERID  USER   ID
*
*        The event DDname is in logic table RE - so find that first
         llgt  r14,thrdes         Get current ES
event_es using logictbl,r14
         llgt  r14,event_es.ltfrstre
ReadLT   using logictbl,r14
         MVC   HDEVNTNM,Readlt.LTDDNAME  EVENT  FILE   DDNAME
         drop  readlt,event_es
*
         MVI   HDOVRIND,C'N'      SET LIMIT EXCEEDED IND = 'N'
         CLI   LTSTATUS,C'L'      REPORT DISABLED DUE TO LIMIT ???
         JNE   *+8                NO  - LEAVE STATUS  = 'N'
         MVI   HDOVRIND,C'Y'      YES - SET   STATUS  = 'Y'
*
         lg    r0,wrlogic.LTWRLMT PASS LIMIT IN HDR
         cvdg  r0,dblwork2
         mvc   hdlimit,dblwork3+2
*
         MVI   HD0C7IND,C'N'      SET 0C7 ABEND OCCURRED = 'N'
         CLI   LTSTATUS,C'7'      REPORT DISABLED DUE TO 0C7 ???
         JNE   *+8                NO  - LEAVE STATUS  = 'N'
         MVI   HD0C7IND,C'Y'      YES - SET   STATUS  = 'Y'
*
*pgczap  ZAP   HDRECCNT,LTWRCNTO  EXTRACT COUNT
*pgcap   AP    HDRECCNT,P001      INCLUDE HEADER IN COUNT
         lg    r0,ltwrcnto        Extract count
         aghi  r0,1               Include header in cout
         cvdg  r0,dblwork2        conver to decimal
         mvc   hdreccnt,dblwork3+2 and save in header record
*
         MVI   HDSATIND,C'Y'      SET   VIEW  SATISFIED INDICATOR = 'Y'
         CLI   LTSTATUS,C'M'      MASK  ERROR ???
         JE    WRTHDR10           YES - LEAVE STATUS  = 'Y'
         CLI   LTSTATUS,C'B'      BAD   DATA  ???
         JE    WRTHDR10           YES - LEAVE STATUS  = 'Y'
         CLI   LTSTATUS,C' '      VIEW  SATISFIED ???
         JE    *+8                YES - LEAVE STATUS  = 'Y'
         MVI   HDSATIND,C'N'      NO  - SET   STATUS  = 'N' (7,L,W)
*
WRTHDR10 LA    R14,EXSRTKEY       LOAD   SORT KEY   ADDRESS
         LH    R15,LTSORTLN       LOAD   SORT KEY   LENGTH
         STH   R15,EXSORTLN
         XR    R0,R0              ZERO   SORT KEY
         XR    R1,R1
         MVCL  R14,R0
*
         MVC   0(L'HDRDATA,R14),HDRDATA
         LHI   R14,L'HDRDATA      EXTRACT    DATA   LENGTH
         LCR   R14,R14
         STH   R14,EXDATALN
*
         LH    R15,EXSORTLN       COMPUTE TOTAL RECORD LENGTH
         LA    R14,L'HDRREC+L'HDRDATA(,R15)
         CH    R14,EXTMINLN       DOES LENGTH EXCEED MINIMUM ???
         JNL   *+8                NO -  USE  MINIMUM
         LH    R14,EXTMINLN       YES - USE  ACTUAL
         STH   R14,EXRECLEN       SET  LENGTH  IN "RDW"
*
         XC    EXNCOL,EXNCOL      COLUMN   COUNT
*
         XC    EXTITLLN,EXTITLLN  SORT KEY TITLE LENGTH
*
         lg    R14,WRTHDR_R14     Get return address
         BR    R14
                        EJECT
***********************************************************************
*  COPY EXTRACT RECORD TO OUTPUT BUFFER (WAIT FOR AVAILABILITY)       *
***********************************************************************
WRTHWAIT DS    0H
         stg   R14,WRTHDR_R14     Need to save return address
         XC    RETNCODE,RETNCODE  ZERO WRITE PGM RETURN CODE
*
         LA    R1,WAITECB         LOAD THIS THREAD'S WAIT   ECB ADDRESS
         XR    R14,R14            ZERO REGISTER (NOT IN-USE VALUE)
         ST    R14,0(,R1)         INITIALIZE   ECB
         LNR   R0,R1              NEGATIVE VERSION OF ECB ADDRESS
*
WRTHRTRY CS    R14,R0,EXTINUSE    TEST IN-USE FLAG ???
         JE    WRTHPGMX           BRANCH  IF  ZERO (NOT IN-USE)
         ST    R14,4(,R1)         SAVE PREVIOUS VALUE IN LINKED LIST
         CS    R14,R1,EXTINUSE    MOVE THIS THREAD'S VALUE TO FLAG
         LHI   R14,0              RESET REGISTER BACK TO ZERO
         JNE   WRTHRTRY           TRY AGAIN IF FLAG CHANGED IN MEANTIME
         if    cli,thread_mode,eq,c'S'      and in srb mode
***********************************************************************
*  PAUSE "SRB"                                                        *
***********************************************************************
           push using
srb_sa     using savf4sa,savesrb
           lmg r0,r1,srbpet1a      get current pointers
           stmg r0,r1,xfrsrbp3     save into parmlist
           lay R1,xfrsrbpl         CALL "IEAVPSE" - PAUSE
           stg r13,srb_sa.SAVF4SAPREV
           stg r2,savesrb     save r2 as ipk uses it
           la r13,savesrb
           xr r0,r0               clear r0
           ipk ,                  save current key in r2
           spka 0(r0)              and flip to key 0
           pop using
         else
           push using
tcb_sa     using savf4sa,savetcb
           lmg r0,r1,tcbpet1a      get current pointers
           stmg r0,r1,xfrtcbp3     save into parmlist
           if (cli,localauth,eq,c'A')
             MODESET KEY=ZERO,MODE=SUP key zero needed now for the
*                                         pause element calls
           endif
           lay R1,xfrtcbpl         CALL "IEAVPSE" - PAUSE
           stg r13,tcb_sa.SAVF4SAPREV
           la r13,savetcb
           pop using
         endif
         llgt  R15,IEA4PSE
         BASR R14,R15
         if cij,r15,ne,0      if this fails, then end thread
           MVC DBLWORK,=CL8'IEA4PSE'
           ST   R15,DBLWORK2  Save return code
           j    PE_error      Write msg to log, and end thread
*          DC H'0'
         endif
sa_map   using savf4sa,thrdarea
         lg    R13,sa_map.SAVF4SAPREV
         drop  sa_map
         if    cli,thread_mode,eq,c'S'      and in srb mode
           spka 0(r2)             restore the saved key
           lgf    r1,ovflmask       set bits 36 and 37           pgc120
           spm r1                   set overflow masks on pgc120
           lg r2,savesrb           restore r2
           lmg r0,r1,srbpet1a      get current pointers
           stg r1,srbpet1a            and flip to correct positions
           stg r0,srbpet2a
         else
           if (cli,localauth,eq,c'A')
             MODESET KEY=NZERO,MODE=PROB
           endif
           lmg r0,r1,tcbpet1a      get current pointers
           stg r1,tcbpet1a            and flip to correct positions
           stg r0,tcbpet2a
         endif
                        SPACE 3
*
WRTHPGMX Llgf  R15,LTWRADDR-LOGICTBL(,R5) get the address
         LTgr  R15,r15                    USER  EXIT SPECIFIED ???
         JNZ   WRTHCALL                   YES - CALL EXIT
*
         lgh   R14,EXDATALN               WRITING  HEADER RECORD ???
         LTR   R14,R14
         JNM   WRTHDROK                   NO - ALWAYS WRITE
*
         CLC   WR_XT,LTFUNC-LOGICTBL(R5)  WRXT and WRSU get header rec
         JE    WRTHPGMY
         CLC   WR_SU,LTFUNC-LOGICTBL(R5)  WRXT and WRSU get header rec
         JE    WRTHPGMY
         J     WRTHDEQ                    Others don't
*
WRTHPGMY EQU   *
         ltgf  R14,LTWR200A-LOGICTBL(,R5) V4  "VDP"  AVAILABLE ???
         JNP   WRTHSTDX                   NO - USE   V3 CRITERIA
*
         USING VDP0200b_FILE_RECORD,R14
         L     R0,VDP0200b_ALLOC_FILE_TYPE
         CHI   R0,STDEXTR                 STANDARD EXTRACT FILE ???
         JE    WRTHDROK                   YES - WRITE  STANDARD HEADER
         J     WRTHDEQ                    NO  - BYPASS STANDARD HEADER
         DROP  R14
*
WRTHSTDX LH    R0,LTWREXT#-LOGICTBL(,R5) STANDARD  EXTRACT FILE ???
         CH    R0,MAXSTDF#
         JH    WRTHDEQ                   NO - BYPASS WRITE
         CLC   EXTDDNAM(L'EXTR),EXTR     STANDARD  EXTRACT FILE ???
         JNE   WRTHDEQ                   NO - BYPASS WRITE
         J     WRTHDROK
*
WRTHCALL LA    R0,wrlogic.LTWRPARM       POINT TO WRITE PARAMETERS
         sty   R0,GPSTARTA
         lgf   R1,wrlogic.LTWREXTO       POINT TO WRITE EXIT ANCHOR
         agr   R1,R2
r1_ltwr  using ltwrarea,r1
         LA    R0,r1_ltwr.LTWRWORK
         sty   R0,GPWORKA
         xc    gp_error_buffer_len,gp_error_buffer_len
         mvi   gp_error_buffer_len+3,(l'error_buffer) set max length
         xc    gp_error_reason,gp_error_reason        clear reason
         stg   R7,RETNPTR         SET RETURN POINTER
         lay   R1,PARM_AREA
         bassm R14,R15            CALL USER EXIT
*
         if    (oc,gp_error_reason,gp_error_reason,nz)
           bras  r9,errwtoa       issue "wto" if non-zero reason code
         endif
*
         lg    R7,RETNPTR         LOAD RETURN POINTER
         lgf   R15,RETNCODE       LOAD RETURN CODE
*
         CHI   R15,4              WRITE RECORD ???
         JH    WRTHDEQ            NO  - BYPASS WRITE
                        SPACE 3
WRTHDROK do inf
           Ltgf R0,EXTRECAD        LOAD  TARGET ADDRESS  FOR NEW RECORD
           JNP WRTHDEQ
*
           lgh R15,EXRECLEN       LOAD  RECORD  LENGTH
           if TM,EXTRECFM,X'40',z VARIABLE  OR  UNDEFINED ???
             lgh R15,EXTLRECL      NO  -   USE   FIXED  LENGTH
           endif
           lgr R14,R0             COMPUTE TRIAL END-OF-BUFFER  ADDRESS
           agr R14,R15
           doexit (cgf,R14,le,EXTEOBAD) If record fits, exit loop now
*
*          here if record overflows buffer
*          calculate length and update buffer with correct length
*          place buffer into output q, wake up any one waiting
*          and get the next buffer
*
           llgt R1,EXTDECBC        LOAD  CURRENT DECB PREFIX ADDRESS
           llgt R15,16(,R1)        LOAD   BUFFER ADDR FROM   DECB
           sgr R0,R15             COMPUTE BLOCK LENGTH
           if TM,EXTRECFM,X'40',o     VARIABLE   OR UNDEFINED   ???
             STH R0,0(,R15)       BUILD   BLOCK DESCRIPTOR  WORD  (BDW)
           endif
           STH R0,10(,R1)         PLACE  LENGTH IN    DECB
*
           ltgf R15,EXTDCBA        DCB ALLOCATED ???
           JNP WRTHPIPE           NO  -   TREAT AS   DUMMY
*
           TM  48(R15),X'10'      EXTRACT FILE  STILL OPEN  ???
           JO  WRTHPUT            YES -  CONTINUE
           MVI 4(R1),X'7F'        NO  -  PRETEND  I/O COMPLETED
           llgt R1,EXTDECBC        LOAD  ADDRESS OF NEXT DECB PREFIX
           llgt R1,0(,R1)
           ST  R1,EXTDECBC        SAVE  ADDRESS OF NEXT DECB PREFIX
           j   WRThnowt           and bypass the check (closed d/set)
*
WRTHPIPE   llgt R15,wrlogic.LTWR200A  200 RECORD ADDRESS
           USING VDP0200b_file_record,r15
           Ltgf R15,VDP0200b_FILE_READER
           drop r15
           Jnz WRTHPUT            YES -  PIPE NOT OPENED
*
           MVI 4(R1),X'7F'        NO  -  PRETEND  I/O COMPLETED
           J   WRTHSKIP
*
WRTHPUT    aghi R1,4              POINT TO DECB
           XC  0(4,R1),0(R1)      CLEAR ECB
           llgf R15,EXTPUT_6431   LOAD  WRITE   ROUTINE ADDRESS
           bassm R14,R15          WRITE PHYSICAL BLOCK (31-BIT MODE)
*
WRTHSKIP   llgt R1,EXTDECBC        LOAD  ADDRESS OF NEXT DECB PREFIX
           llgt R1,0(,R1)
           ST  R1,EXTDECBC        SAVE  ADDRESS OF NEXT DECB PREFIX
*
           aghi R1,4               POINT TO ECB
           llgf R15,extchk_6431    LOAD  CHECK   ROUTINE ADDRESS
           bassm R14,R15          WRITE PHYSICAL BLOCK (31-BIT MODE)
           llgt R1,EXTDECBC        RESTORE DECB PREFIX  ADDRESS
*
WRTHNOWT   llgt R15,16(,R1)        LOAD  BUFFER ADDRESS FROM DECB
           LA  R0,4(,R15)         SKIP  BDW
           TM  EXTRECFM,X'40'     VARIABLE  OR UNDEFINED    ???
           JO  *+8                YES - LEAVE  ROOM  FOR   "BDW"
           lgr R0,R15             NO  - START  AT BEGINNING
           ST  R0,EXTRECAD        INITIALIZE NEXT RECORD ADDRESS
*
           agh R15,EXTBLKSI
           ST  R15,EXTEOBAD
*
           J   WRTHDROK
                          SPACE 3
WRTHCOPY   ST  R14,EXTRECAD       UPDATE ADDRESS  FOR NEXT RECORD
         enddo
         ST    R14,EXTRECAD       UPDATE ADDRESS  FOR NEXT RECORD
*
         lgr   R14,R15            ASSUME FIXED
         lg    r1,thrd_extrbyte_cnt  Get thread byte count
         agr   r1,R14                 add this record to total
         ag    R14,extbytec          Increment extract byte count
         stg   R14,extbytec            and save it
         stg   r1,thrd_extrbyte_cnt  and save thread byte count
*
         CH    R15,EXTLRECL
         JNH   WRTHSRC
*
         LHI   R14,RECORD_GT_LRECL INDICATE RECORD TOO LARGE
         MVC   ERRDATA(8),EXTDDNAM
         cvd   r15,dblwork
         OI    DBLWORK+L'DBLWORK-1,X'0F'
         UNPK  ERRDATA+10(6),DBLWORK
         XC    MSGS2PTR,MSGS2PTR  No additional parms
         st    r14,dblwork        Save msgid to use as flag later  pgc2
         j     wrthdeq            Before stopping this make sure   pgc2
*                                 we release the next on queue     pgc2
*
WRTHSRC  LA    R14,EXTREC         MOVE   THIS HEADER  RECORD TO BUFFER
         TM    EXTRECFM,X'40'     VARIABLE OR UNDEFINED  ???
         JO    *+8                YES - INCLUDE "RDW"
         LA    R14,EXTREC+4       NO  - IGNORE  "RDW"
         LR    R1,R15
         MVCL  R0,R14
*
         agsi  EXTCNT,bin1        INCREMENT   EXTRACT FILE RECORD COUNT
         agsi  LTWRCNTO,bin1      VIEW EXTRACT  CNT
         agsi  thrd_extrrec_cnt,bin1    for thread total later
*
         CLC   RETNCODE,F4        WRITE SUBROUTINE  SPECIFIED "RECALL"
         JNE   WRTHDEQ            NO  - RETURN
*
         llgt  R7,GPEXTRA         RESTORE ORIGINAL EXTRACT REC   ADDR
         llgf  R15,wrlogic.LTWRADDR LOAD  WRITE  PGM EXIT  ADDR
         B     WRTHCALL           RECALL  WRITE SUBROUTINE
*
WRTHDEQ  llgt  R7,GPEXTRA         RESTORE ORIGINAL EXTRACT REC   ADDR
                        SPACE 3
         lgf   R1,EXTINUSE        LOAD IN-USE FLAG  VALUE
WRTHPOST ltgfr R1,R1              ANY  THREAD BESIDE THIS ONE WAITING
         JNP   WRTHRSET           NO  -  EXIT
*
         llgf  r15,4(,r1)         Load ptr to next thread's ecb    pgc2
         cs    r1,r15,extinuse    Next thread's ecb addr to flag   pgc2
         jne   wrthpost           Retry unlock if changed          pgc2
*                                                                  pgc2
*        Need to check if we are ending this thread, if not then   pgc2
*        carry on as normal. Otherwise we need to check if this    pgc2
*        thread is now the last in queue ie the 2nd last in queue  pgc2
*        points to the complement of the WAITECB for this thread.  pgc2
*        In this case the 2nd last thread is now the end of queue. pgc2
*                                                                  pgc2
         l     r14,dblwork        See if we flagged RECORD_GT_LRECL
         chi   r14,RECORD_GT_LRECL Was there an LRECL error?       pgc2
         jne   wrthpost_10        N: then carry on as normal       pgc2
         lgr   r15,r1                                              pgc2
wrthpost_02 ds 0h                                                  pgc2
         ltgf  r14,4(,r15)        Get next on queue                pgc2
         jnp   wrthpost_07        Here if negative                 pgc2
wrthpost_03 ds 0h                                                  pgc2
         ltgf  r0,4(,R14)         Get next on queue                pgc2
         jnp   wrthpost_05        Here if negative                 pgc2
         lgr   r15,r14            Point at 2nd and start there     pgc2
         lgr   r14,r0             Point at 2nd and start there     pgc2
         j     wrthpost_03        and try again                    pgc2
wrthpost_05 ds 0h                                                  pgc2
         lngr  r0,r14             Get negative of ECB              pgc2
         st    r0,4(,r15)         Save this as last in previous    pgc2
         j     wrthpost_10        Carry on and post next on queue  pgc2
wrthpost_07 ds 0h                                                  pgc2
         lngr  r0,r15             Get negative of ECB              pgc2
         cs    r15,r0,extinuse    Make the flag negative           pgc2
         jne   wrthpost_02                                         pgc2
*                                                                  pgc2
wrthpost_10 ds 0h                                                  pgc2
*
         la    r14,thread_mode-waitecb(,r1) point at flag
*        locate the appropiate pause element token
*        and then set up to release that PE
         if    cli,0(r14),eq,c'S'    this test is to make sure that    +
                                   the waiting element is an SRB
           lg   r0,srbpet1a-waitecb(,r1) shift r1 to correct address
         else
           lg   r0,tcbpet1a-waitecb(,r1) get the tcb pe pointer
         endif
         xr r1,r1                 clear the release code address
         if cli,thread_mode,eq,c'S'    then an SRB active
           push using
srb_sa     using savf4sa,savesrb
           stmg r0,r1,xfrsrbp3    save in parm
           lay r1,xfrsrbpl    release srb which will clean up
           stg r13,srb_sa.SAVF4SAPREV
           stg r2,savesrb     save r2 as ipk uses it
           la r13,savesrb
           xr r0,r0               clear r0
           ipk ,                  save current key in r2
           spka 0(r0)              and flip to key 0
           pop using
         else
           push using
tcb_sa        using savf4sa,savetcb
           stmg r0,r1,xfrtcbp3    save in parm
           if (cli,localauth,eq,c'A')
             MODESET KEY=ZERO,MODE=SUP key zero needed now for the
*                                       pause element calls
           endif
           lay   r1,xfrtcbpl
           stg r13,tcb_sa.SAVF4SAPREV
           la r13,savetcb
           pop using
         endif
         llgt r15,iea4rls        and finish
         basr r14,r15
sa_map   using savf4sa,thrdarea
         lg    R13,sa_map.SAVF4SAPREV
         drop  sa_map
         if cij,r15,ne,0      if this fails, then end thread
           MVC  DBLWORK,=CL8'IEA4RLS'
           ST   R15,DBLWORK2  Save return code
           j    PE_error      Write msg to log, and end thread
           DC H'0'
         endif
         if cli,thread_mode,eq,c'S'    then an SRB active
           spka 0(r2)             restore the saved key
           lg r2,savesrb           restore r2
           lgf    r1,ovflmask       set bits 36 and 37           pgc120
           spm r1                   set overflow masks on pgc120
         else
           if (cli,localauth,eq,c'A')
             MODESET KEY=NZERO,MODE=PROB
           endif
         endif
         J     WRTHRTN            INCREMENT  VIEW'S  EXTRACT COUNT
*
WRTHRSET XR    R0,R0              RESET FLAG BACK TO NO  ONE WAITING
         CS    R1,R0,EXTINUSE
         JNE   WRTHPOST           RETRY UNLOCK IF CHANGED IN MEANTIME
*
wrthrtn  ds    0h                                                  pgc2
         l     r14,dblwork        Get possible RECORD_GT_LRECL
         chi   r14,RECORD_GT_LRECL Was there an LRECL error?       pgc2
         jne   wrth07             n: then carry on                 pgc2
         xc    dblwork(4),dblwork clear msg                        pgc2
         j     errmsg#            quit                             pgc2
wrth07   ds    0h                                                  pgc2
         lg    R14,WRTHDR_R14     Get return address
         BR    R14
*
         DROP  r1_ltwr
         DROP  R3
         DROP  R7
         DROP  R8
         DROP  R9
         drop  wrlogic
                        EJECT
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*                                                                     *
*        L O O K - U P / W R I T E   E X I T   "CL"   P H A S E       *
*                                                                     *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         using (thrdarea,thrdend),r13 Tell assembler to map the area
         using savf4sa,savesubr
         using genenv,env_area
         using genparm,parm_area
         using genfile,file_area
*
***********************************************************************
*  PROCESS "ES" SET                                                   *
***********************************************************************
*
CLPHASE  ltgr  R13,R13            ANY   MORE THREADS ???
         JNP   CLEXIT             NO  - DONE CALLING EXITS
*
***********************************************************************
*  RESET THREAD WORK AREA VARIABLES                                   *
***********************************************************************
         MVC   gpphase,CL         INDICATE  CLOSE PHASE
*
         MVC   LKUPKEY,SPACES     INITIALIZE LOOK-UP  KEY   WORK  AREA
*
         MVC   GPDDNAME,SPACES
         MVC   EVNTSUBR,SPACES
         XC    EVNTREAD,EVNTREAD
*
         llgt  R0,GPEXTRA         ZERO EXTRACT RECORD AREA
         LHI   R1,EXTRECL
         XR    R14,R14
         XR    R15,R15
         MVCL  R0,R14
*
***********************************************************************
*  POINT TO FIRST "ES" SET EXECUTED BY THREAD                         *
***********************************************************************
         llgt  R8,THRDEXEC        LOAD  FIRST "ES"  SET ADDRESS
*
CLESLOOP ltgr  R8,R8
         JNP   CLEXIT
*
         llgt  r2,lteslpad-logictbl(,r8) load the literal pool address
         using litp_hdr+524288,r2
         agfi  r2,f512k             lit pool base now in middle
***********************************************************************
*  CHECK IF THIS "ES" SET OF VIEWS HAS AN EVENT FILE                  *
***********************************************************************
         llgt  R1,LTFRSTRE-LOGICTBL(,R8) LOAD "RE"  ROW ADDRESS
         ST    R1,THRDRE
         ltgr  R1,R1              READ  EVENT AVAILABLE ???
         JNP   CLNVFRST           YES - INITIALIZE   DRIVER
*
***********************************************************************
*  POPULATE EVENT FILE FIELDS                                         *
***********************************************************************
         MVC   GPDDNAME,LTDDNAME-LOGICTBL(R1) EVENT FILE DDNAME
         MVC   EVNTSUBR,LTRENAME-LOGICTBL(R1) READ  SUBROUTINE  NAME
         MVC   EVNTREAD,LTREADDR-LOGICTBL(R1) READ  SUBROUTINE  ADDR
*
***********************************************************************
*  LOAD "NV" ROW ADDRESS                                              *
***********************************************************************
CLNVFRST llgt  R7,LTFRSTNV-LOGICTBL(,R8) LOAD FIRST "NV"  IN "ES" SET
*
CLNVLOOP ltgr  R7,R7              END-OF-NV   LIST  ???
         JNP   CLESNEXT
*
***********************************************************************
*  CALL LOOK-UP AND WRITE EXITS WITH CLOSE (CL) FUNCTION CODE         *
***********************************************************************
         llgt  R5,LTFRSTLU-LOGICTBL(,R7) FIRST "LU"  ROW  IN  "NV"
*
CLLULOOP ltgr  R5,R5
         JNP   CLWRFRST
*
         CLC   =c'LUEX',LTFUNC-LOGICTBL(R5)         EXIT SPECIFIED ???
         JNE   CLLUNEXT
*
         lgf   R14,LTLUBoff-LOGICTBL(,R5) POINT TO LOOK-UP BUFFER
         llgt  r14,0(r14,r2)              Get the address
         using  LKUPBUFR,r14
*
         TM    LBFLAGS,LBCLOSE            ALREADY  CLOSED  ???
         JO    CLLUNEXT                   YES - BYPASS    CALL
         OI    LBFLAGS,LBCLOSE
*
         lay   r15,PARM_AREA
         MVC   LBPARML(LBPRMLEN),0(r15)   COPY  TEMPLATE
*
         LA    R0,LBSTRTUP                START-UP PARAMETERS
         ST    R0,LBSTARTA
         ly    R0,GPEXTRA                 EXTRACT RECORD ADDRESS
         ST    R0,LBEXTRA
         LA    R0,LBSUBWRK                WORK AREA ANCHOR
         ST    R0,LBANCHA
         LA    R0,LBLSTRC                 RETURN CODE
         ST    R0,LBRTNCA
         LA    R0,LBLSTFND                RESULT POINTER
         ST    R0,LBRPTRA
         LA    R0,LBEVENTA
         ST    R0,LBRECA
*
         xc    gp_error_buffer_len,gp_error_buffer_len
         mvi   gp_error_buffer_len+3,(l'error_buffer) set max length
         xc    gp_error_reason,gp_error_reason        clear reason
         LA    R1,LBPARML            LOAD PARAMETER LIST ADDR
         llgf  R15,LBSUBADR          LOOK-UP   EXIT ADDRESS
         bassm R14,R15               CALL  EXIT WITH close OPTION
         lgf   R14,LTLUboff-LOGICTBL(,R5)    LOAD RETURN    CODE
         llgt  r14,0(r14,r2) Get the address
         L     R15,LBLSTRC
         sty   r15,lplurtnc         and save in literal pool
         drop  r14
         if    (oc,gp_error_reason,gp_error_reason,nz) is the          +
                                     code non zero ==> text
           l     r15,gp_error_buffer_len   get length of text
           sthy   r15,error_bufl            and save in prefix
           lay    r3,error_bufl
           WTO   TEXT=(3),MF=(E,WTOPARM)
           l     r15,gp_error_buffer_len get length of text
           ahi   r15,4
           sthy  r15,error_bufl
           ENQ   (GENEVA,LOGNAME,E,,STEP),RNL=NO
           logit msg=error_bufl
           DEQ   (GENEVA,LOGNAME,,STEP),RNL=NO
         endif
*
***********************************************************************
*  ADVANCE TO NEXT LOGIC TABLE "LU" FUNCTION WITHIN THIS "NV"         *
***********************************************************************
CLLUNEXT llgt  R5,LTLUNEXT-LOGICTBL(,R5)
         J     CLLULOOP
*
CLWRFRST llgt  R5,LTFRSTWR-LOGICTBL(,R7)  FIRST "WR" ROW IN "NV"
*
CLWRLOOP ltgr  R5,R5                      END-OF-WR LIST    ???
         JNP   CLNVNEXT
*
         CLC   wr,LTMAJFUN-LOGICTBL(R5)   EXIT SPECIFIED ???
         JNE   CLWRNEXT
*
         LA    R0,LTWRPARM-LOGICTBL(,R5)  POINT  TO WRITE   PARAMETERS
         sty   R0,GPSTARTA
         lgf   R1,LTWREXTO-LOGICTBL(,R5)  POINT  TO WRITE    ANCHOR
         agr   R1,R2
         using ltwrarea,r1
         LA    R0,LTWRWORK
         drop  r1
         sty   R0,GPWORKA
*
         xc    gp_error_buffer_len,gp_error_buffer_len
         mvi   gp_error_buffer_len+3,(l'error_buffer) set max length
         xc    gp_error_reason,gp_error_reason        clear reason
         lay   R1,PARM_AREA
         llgf  R15,LTWRADDR-LOGICTBL(,R5)    LOAD EXIT ADDRESS
         if ltgr,r15,r15,nz
           bassm R14,R15            CALL  EXIT WITH CLOSE   OPTION
         endif
         L     R15,RETNCODE
         if    (oc,gp_error_reason,gp_error_reason,nz)     is the      +
                                     code non zero ==> text
           l     r15,gp_error_buffer_len   get length of text
           sthy   r15,error_bufl            and save in prefix
           lay    r3,error_bufl
           WTO   TEXT=(3),MF=(E,WTOPARM)
           l     r15,gp_error_buffer_len get length of text
           ahi   r15,4
           sthy  r15,error_bufl
           ENQ   (GENEVA,LOGNAME,E,,STEP),RNL=NO
           logit msg=error_bufl
           DEQ   (GENEVA,LOGNAME,,STEP),RNL=NO
         endif
*
***********************************************************************
*  ADVANCE TO NEXT LOGIC TABLE "WR" FUNCTION WITHIN THIS "NV"         *
***********************************************************************
CLWRNEXT llgt  R5,LTWRNEXT-LOGICTBL(,R5)
         J     CLWRLOOP
*
***********************************************************************
*  ADVANCE TO NEXT "NV" WITHIN THIS "ES" SET                          *
***********************************************************************
CLNVNEXT llgt  R7,LTNEXTNV-LOGICTBL(,R7)  LOOP THROUGH LOGIC TABLE
         J     CLNVLOOP
*
***********************************************************************
*  ADVANCE TO NEXT "ES" SET WITHIN THIS THREAD                        *
***********************************************************************
CLESNEXT llgt  R8,LTNEXTES-LOGICTBL(,R8)  NEXT "ES"  SET   ADDRESS
         J     CLESLOOP
*
***********************************************************************
*  RETURN                                                             *
***********************************************************************
CLEXIT   BR    R10
                        EJECT
tsrcrept dsect          Temporary area, while ISRC is sorted
tsrcwudd ds    cl8
tsrcddn  ds    cl8
tsrcrcnt ds    fd
tsrcbcnt ds    fd
tsrcpfnm ds    cl48
tsrcftyp ds    cl21
tsrcthrd ds    cl3
tsrcrept_len equ *-tsrcrept

isrcrept dsect          Actual ISRC print lines
isrcthrd ds    cl3
isrcf1   ds    cl2
isrcwudd ds    cl8
isrcf1a  ds    cl3
isrcddn  ds    cl8
isrcf2   ds    cl1
isrcrcnt ds    cl18
isrcf3   ds    cl2
isrcPFnm ds    cl48
isrcf5   ds    cl2
isrcftyp ds    cl21
isrcf4   ds    cl1
isrcbcnt ds    cl20
isrcrept_len equ *-isrcrept

twrtrept dsect          Temporary area while owrt is sorted
twrtnext ds    a               next pointer
twrtoccn ds    f               number ooccurrences for this work-unit
twrtwudd ds    cl8             Work Unit DDname
twrtltrw ds    f               LT row
twrtfunc ds    cl4             Function code
twrtsddn ds    cl8             Source DDname
twrteddn ds    cl8             Output DDname
twrtwwc  ds    fd              Output rec count
twrtera  ds    fd              Write ops to ERA
twrtcolp ds    f               ERA collapse
twrtview ds    f               View id
twrtpct  ds    cl1             %
twrtthrd ds    cl3             Thread number
twrtwex  ds    cl8             Write exit name
twrtftyp ds    cl9             Output file type
         ds    xl3
twrtrept_len equ *-twrtrept

owrtrept dsect          Actual OWRT print lines
owrtthrd ds    cl3             Thread number
owrtf1   ds    cl2
owrtwudd ds    cl8             Work Unit DDname
owrtf2   ds    cl2
owrtltrw ds    cl8             LT row
owrtf2b  ds    cl2
owrtfunc ds    cl4             Function code
owrtf2c  ds    cl2
owrtsddn ds    cl8             Source DDname
owrtf2a  ds    cl2
owrtview ds    cl7             View id
owrtf3   ds    cl2
owrteddn ds    cl8             Output DDname
owrtf4   ds    cl1
owrtwwc  ds    cl18            Output rec count
owrtf5   ds    cl2
owrtchev ds    cl1             chevron
owrtf55  ds    cl2
owrtftyp ds    cl9             Output file type
owrtf5a  ds    cl2
owrtwex  ds    cl8             Write exit name
owrtf6   ds    cl2             filler
owrtera  ds    cl18            Write ops to ERA
owrtf7   ds    cl2 filler
owrtcolp ds    cl11            ERA collapse
owrtpct  ds    cl1             %
owrtrept_len equ *-owrtrept
*
* ~LKUP report mapping           in memory table for sorting
tkuprept   dsect
tkupddname ds   cl8               lookup work-unit
tkupsrce   ds   cl8               lookup source
tkuppath   ds   f                 path
tkupstep   ds   f                 step
tkupLFnd   ds   fd
tkupLNFnd  ds   fd
tkupwpath  ds   f
tkupLRID   ds   f
tkupLFID   ds   f
tkupExit   ds   cl8
tkupopt    ds   cl1
tkupSdate  ds   cl1
tkupEdate  ds   cl1
tkupthrd   ds   cl3
tkupklen   ds   xl2
tkuprept_len equ *-tkuprept
*
* ~LKUP report mapping           actual report lines
lkuprept dsect
lkupthrd ds    cl3
lkupf1   ds    cl2
lkupddname ds  cl8               lookup work-unit
lkupf1c  ds    cl3
lkupsrce ds    cl8               lookup source
lkupf1b  ds    cl1
lkuppath ds    cl8               path
lkupf2   ds    cl2
lkupstep ds    cl4               step
lkupf3   ds    cl1
lkupLFnd ds    cl18
lkupf4   ds    cl1
lkupLNFnd ds   cl18
lkupf5   ds    cl2
lkupfchv ds    0cl1
lkupLTot ds    cl18
lkupf6   ds    cl2
lkupwpath ds   cl7
lkupf9   ds    cl2
lkupLRID ds    cl7
lkupf7   ds    cl2
lkupLFID ds    cl7
lkipf14  ds    cl1
lkupklen ds    cl4
lkupf13  ds    cl2
lkupclear ds  0cl20
lkupSdate ds   cl1
lkupf12  ds    cl3
lkupEdate ds   cl1
lkupf8   ds    cl3
lkupExit ds    cl8
lkupf10  ds    cl3
lkupopt  ds    cl1
lkupf15  ds    cl2
lkuprept_len equ *-lkuprept

gvbmr95  csect
***********************************************************************
*                                                                     *
*        Prepare ~ISRC Report In Memory for Sorting                   *
*                                                                     *
***********************************************************************
isrc_prepare ds 0h
*
*      Obtain enough storage
*
         llgt  r1,workunit_cnt    work-unit count
         mghi  r1,l'tsrcwudd      multiplied by sorted work units
         llgt  r0,isrcrec_cnt     ISRC record count
         mghi  r0,tsrcrept_len    multiplied by length of sort area
         agr   r0,r1
         llgt  r1,owrtrec_cnt1    OWRT records (inc omitted views)
         mghi  r1,twrtrept_len    multiplied by length of sort area
         agr   r0,r1
         llgt  r1,lkuprec_cnt     LKUP records
         mghi  r1,tkuprept_len    multiplied by length of sort area
         agr   r0,r1
         llgt  R1,filecnt_real    and storage for OFIL report
         mghi  R1,pextrept_len
         agr   R0,R1
*
         aghi  r0,SAVF4SA_LEN*2   saveareas
         sty   r0,rpt_sort_area_len
         aghi  r0,l'sorteyeb
*
         GETMAIN RU,LV=(0),LOC=(ANY)
*
         mvc   0(l'sorteyeb,r1),sorteyeb
         aghi  r1,l'sorteyeb
         sty   r1,rpt_sort_area_ptr
*                                                 store registers
         stmg  R14,R12,SAVF4SAG64RS14-SAVF4SA(r1) apart from r0, r1
         stg   r13,SAVF4SAPREV-SAVF4SA(r1)
         mvc   SAVF4SAID-SAVF4SA(4,r1),=cl4'SAVF4SAID_VALUE'
*
         aghi  r1,SAVF4SA_LEN*2   18fd savearea comes after eyeball
         lgr   r3,r1              point past savearea
         lgr   R0,r1              ZERO  WORK AREA
         llgt  R1,rpt_sort_area_len
         aghi  r1,-SAVF4SA_LEN*2  savearea not cleared: only clear rest
         xgr   r14,r14
         xgr   r15,r15
         mvcl  r0,r14
*
         sty   r3,ofil_first      First ofil item
         llgt  R4,filecnt_real
         mghi  R4,pextrept_len
         agr   r3,r4
         sty   r3,workunit_first  First work-unit
         llgt  r4,workunit_cnt    Then work unit list
         mghi  r4,l'tsrcwudd
         agr   r3,r4
         sty   r3,isrc_first      Then isrc list
*
         lgr   r4,r3              Point to 1st isrc item
         ly    r3,workunit_first  Point to first work unit item
         using tsrcrept,r4
*
*      ISRC report --------------------------------------------
*
         llgt  R8,LTHDROWA
         USING LOGICTBL,R8
*
         xc    event_file_cnt,event_file_cnt  input file count
         xc    event_pipe_token_cnt,event_pipe_token_cnt
         xc    event_database_cnt,event_database_cnt
         xc    event_read_exit_cnt,event_read_exit_cnt
         xc    event_file_rec_cnt,event_file_rec_cnt
         xc    event_pitk_rec_cnt,event_pitk_rec_cnt
         xc    event_dbms_rec_cnt,event_dbms_rec_cnt
         xc    event_rexi_rec_cnt,event_rexi_rec_cnt
         xc    event_file_byt_cnt,event_file_byt_cnt
         xc    event_pitk_byt_cnt,event_pitk_byt_cnt
         xc    event_dbms_byt_cnt,event_dbms_byt_cnt
         xc    event_rexi_byt_cnt,event_rexi_byt_cnt
*

*
TH_WRK   USING (THRDAREA,thrdend),R8
         llgt  R8,THRDFRST        LOAD FIRST  THREAD WORK AREA ADDRESS
*
th_wrk_env using genenv,th_wrk.env_area
*
TH_ES    USING LOGICTBL,R7
isrc_p02 ltgf  R7,TH_WRK.THRDEXEC LOAD EXECUTED "ES" SET  ADDR
         JNP   isrc_p03
*
isrc_p01 ltgf  R2,TH_ES.LTFRSTRE
         JNP   isrc_p04
ES_RE    USING LOGICTBL,R2
*
         llgt  R14,th_es.lteslpad       Get lit pool for this ES   @05I
         agfi  r14,f512k
         st    r14,workarea             Save thread litp address
*
         lay   r15,-3(r8)                point to start of thread #
         mvc   tsrcthrd(3),0(r15)        move in thread number
*
*      Move in work unit ddname
         MVC   tsrcwudd,ES_RE.LTDDNAME
         MVC   0(l'tsrcwudd,r3),ES_RE.LTDDNAME
*
*        Move in source DDname
         MVC   tsrcddn,ES_RE.LTDDNAME
*
*      Move in File type and PF name
         llgt  r14,es_re.ltvdp200
         using VDP0200b_file_record,r14
         mvc   tsrcPFnm,VDP0200b_file   move PF name
         drop  r14
*
         mvc   tsrcftyp,spaces
         lgh   r15,es_re.ltfiltyp              get input  type
*
*      If disk or tape, add to source file count for ~EXEC stats
*      And record and byte counts for different file types
         if    (chi,r15,eq,STDEXTR),or,(chi,r15,eq,DISKDEV),or,        +
               (chi,r15,eq,TAPEDEV)
*
           LH  R0,ES_RE.LTACCMTH               LOAD  ACCESS METHOD ID
           if  (chi,R0,eq,DB2SQL),or,(chi,r0,eq,DB2VSAM)
             alsi event_database_cnt,1         DB2 via SQL or VSAM
             lg   r14,event_dbms_rec_cnt
             lg   r0,es_re.ltfilcnt
             agr  r14,r0
             stg  r14,event_dbms_rec_cnt
             msgf r0,es_re.ltrerecl
             ag   r0,event_dbms_byt_cnt
             stg  r0,event_dbms_byt_cnt
             lghi r15,6                        Index to type database
           else
             if (clc,ES_RE.LTRENAME,eq,spaces)
               alsi event_file_cnt,1           Disk file
               lg   r14,event_file_rec_cnt
               lg   r0,es_re.ltfilcnt
               agr  r14,r0
               stg  r14,event_file_rec_cnt
               msgf r0,es_re.ltrerecl
               ag   r0,event_file_byt_cnt
               stg  r0,event_file_byt_cnt
             else
               alsi event_read_exit_cnt,1      Read Exit
               lg   r14,event_rexi_rec_cnt
               lg   r0,es_re.ltfilcnt
               agr  r14,r0
               stg  r14,event_rexi_rec_cnt
               msgf r0,es_re.ltrerecl
               ag   r0,event_rexi_byt_cnt
               stg  r0,event_rexi_byt_cnt
               lghi r15,7                      Index to type read exit
             endif
           endif
         else
           if (chi,r15,eq,PIPEDEV)        (can't check for token here)
             alsi event_pipe_token_cnt,1       Pipe
             lg   r14,event_pitk_rec_cnt
             lg   r0,es_re.ltfilcnt
             agr  r14,r0
             stg  r14,event_pitk_rec_cnt
             msgf r0,es_re.ltrerecl
             ag   r0,event_pitk_byt_cnt
             stg  r0,event_pitk_byt_cnt
             if (clc,ES_RE.LTRENAME,ne,spaces)
               lghi r15,8                      Index to type pipe exit
             endif
           endif
         endif
*
*
         bctgr r15,r0
         mghi  r15,l'ftype1              get the correct index as the
*                                        are only 9 chars long.
         lay   r15,filetype(r15)
         mvc   tsrcftyp(l'ftype1),0(r15) Move in the file type
*      check and see if READ exit was used
         clc   es_re.ltrename,spaces     any exit?
         je    isrc_p05                  no
         mvc   tsrcftyp(6),=cl6'Exit: '
         mvc   tsrcftyp+6(l'ltrename),es_re.ltrename
isrc_p05 equ   *
*
*      Move in Record count
         mvc   tsrcrcnt,es_re.ltfilcnt        get event record count
*
*      Move in byte count
         lg    r1,es_re.ltfilcnt        Get event record count
         msgf  r1,es_re.ltrerecl
         stg   r1,tsrcbcnt
*
         aghi  r3,l'tsrcwudd            increement work-unit list
         aghi  r4,tsrcrept_len          increment isrc list
*
*      Now process any Tokens being used by this "RE**/ES" set
*
         if (ltgf,r2,es_re.ltnxrtkn,p)  Is there any token
           do until=(ltgf,r2,es_re.ltnxrtkn,np) Is there another token
             lgr   r14,r4
             aghi  r14,-tsrcrept_len token inherits some previous flds
             mvc   0(tsrcrept_len,r4),0(r14)
*
             llgt r14,workarea       Get thread litp address
             lgf r15,es_re.ltreindx  Get its index
             mghi r15,8               Get correct offset for litpool
             aghi r15,litphdrl        Allow for the header
             lgf r15,0-524288(r15,r14) Get lit pool offset value
             agr r14,r15             Point at correct lit pool
             lgf   R5,es_re.ltfilcnt Get ltfilcnt offs in litpl
             agr   r5,r14            Get adrress
*
*          Move in Token DDname
             MVC   tsrcddn,ES_RE.LTDDNAME
*
*          Move in Token File type an Token PF name
             llgt  r14,es_re.ltvdp200
             using VDP0200b_file_record,r14
             mvc   tsrcPFnm,VDP0200b_file   move PF name
             mvc   tsrcftyp,spaces
             lgh   r15,es_re.ltfiltyp          get output type
             bctgr r15,r0
             mghi  r15,l'oextftyp        get the correct index as the
*                                        are only 9 chars long, Exits
*                                        are a special case
             lay   r15,filetype(r15)
             mvc   tsrcftyp(l'oextftyp),0(r15) Move in file type
             mvc   tsrcftyp+6(l'ltrename),es_re.ltrename
*
*          Increment token count
             alsi event_pipe_token_cnt,1
*
*          Move in Record count
             mvc   tsrcrcnt,0(r5)          get event record count
             lg    r1,0(,r5)               again
             lg    r14,event_pitk_rec_cnt
             agr   r14,r1
             stg   r14,event_pitk_rec_cnt
*
*          Move in byte count
             msgf  r1,es_re.ltrerecl       multiply records by lrecl
             lg    r14,event_pitk_byt_cnt
             agr   r14,r1
             stg   r14,event_pitk_byt_cnt
             stg   r1,tsrcbcnt
*
             aghi  r4,tsrcrept_len
           enddo
         endif
*
isrc_p04 ds    0h
         ltgf  R7,TH_ES.LTNEXTES  LOAD  NEXT   "ES" SET IN THREAD
         JP    isrc_p01

isrc_p03 ds    0h
         ltgf  R8,TH_WRK.THRDNEXT ADVANCE TO  NEXT  THREAD
         JP    isrc_p02
*
*      now do the sorting of isrc report by work-unit and source dd
*
         sty   r4,owrt_first      first owrt for GVBMR95E
*
         ly    r3,isrc_first      First isrc item
         do until=(ltr,r0,r0,np)
           lgr   r4,r3            start address of isrc table
           llgt  r2,isrcrec_cnt   ISRC record count
           bctgr r2,0             minus-1
           xgr r0,r0              swaps flag off
           if (ltgr,r2,r2,p)
             do from=(r2)
               if (clc,tsrcwudd(16),gt,tsrcwudd+tsrcrept_len)
                 la  r0,1           yes, there was a swap
                 xc  tsrcrept_len(tsrcrept_len,r4),0(r4)
                 xc  0(tsrcrept_len,r4),tsrcrept_len(r4)
                 xc  tsrcrept_len(tsrcrept_len,r4),0(r4)
               endif
               aghi  r4,tsrcrept_len
             enddo
           endif
         enddo
*
*      now do the sorting of work-units by work-unit
*
         ly    r3,workunit_first  First work-unit
         do until=(ltr,r0,r0,np)
           lgr   r4,r3            start address of isrc table
           llgt  r2,workunit_cnt  work-unit count
           bctgr r2,0             minus-1
           xgr r0,r0              swaps flag off
           if (ltgr,r2,r2,p)
             do from=(r2)
               if (clc,0(8,r4),gt,8(r4))
                 la  r0,1           yes, there was a swap
                 xc  8(8,r4),0(r4)
                 xc  0(8,r4),8(r4)
                 xc  8(8,r4),0(r4)
               endif
               aghi  r4,8
             enddo
           endif
         enddo
*
         llgt  r1,rpt_sort_area_ptr start of area after eyeball
*                                                 restore registers
         lmg   R14,R12,SAVF4SAG64RS14-SAVF4SA(r1) apart from r0, r1
*
         br    R14              RETURN (SWITCH TO 31-BIT MODE)
*
         DROP  R4 tsrcrept
         DROP  ES_RE
         DROP  TH_ES
         DROP  TH_WRK
         DROP  R8
*
***********************************************************************
*                                                                     *
*        Prepare ~OWRT Report In Memory for Sorting                   *
*                                                                     *
***********************************************************************
owrt_prepare ds 0h
*
         llgt  r1,rpt_sort_area_ptr
*                                                 store registers
         stmg  R14,R12,SAVF4SAG64RS14-SAVF4SA(r1) apart from r1
         stg   r13,SAVF4SAPREV-SAVF4SA(r1)
         mvc   SAVF4SAID-SAVF4SA(4,r1),=cl4'SAVF4SAID_VALUE'
*
*      OWRT report ----------------------------------------
*
         llgt  R8,LTBEGIN         LOAD LOGIC  TABLE ADDRESS
         USING LOGICTBL,R8
*
         using twrtrept,r4
         llgt  r4,owrt_first
*
         lgf   R7,LTCOUNT         LOAD LOGIC  TABLE ENTRY COUNT
*
* Start by looking for ES in logic table (skip any token RK-ET)
*
         do from=(r7),label=outer_01
           do ,label=inner_01
             if CLC,LTFUNC,eq,es         Look for es records
*
               llgt  r2,lteslpad        get literal pool pointer
               using litp_hdr+524288,r2
               agfi  r2,f512k
ltre           using logictbl,r14           map the RE record
               doexit (ltgf,r14,ltfrstre,p),and,                       +
               (ltgf,r0,ltcodseg-logictbl(,r14),np)
*
*          Get the thread number from the work area used
*
               if ltgf,r15,ltthrdwk,p
                 aghi  r15,-8
                 mvc   twrtthrd,5(R15)
               else
                 MVC   twrtthrd,=cl3'001'   cater for odd case where
*                          work unit is token and not multi-threaded
               endif
*
*          Move in work unit ddname
               MVC   twrtwudd,ltre.LTDDNAME
*
*          Move in source file ddname
               if    ltgr,r14,r14,p
                 MVC twrtsddn,ltre.ltddname
               endif
*
*   Loop through all logictbl entries for this RE-ES
*
nvptr          using logictbl,r5
               llgt  r5,ltfrstnv        get the first nv pointer
               do  inf
*
                 llgt  r15,owrt_first   Addr of next slot in OWRT table
                 if (cr,r4,gt,r15)
                   lgr   r15,r4
                   aghi  r15,-twrtrept_len inherits some previous fld
                   if (nc,twrtwudd,twrtwudd,z)
                     mvc   twrtwudd,twrtwudd-twrtrept(r15)
                     mvc   twrtview,twrtview-twrtrept(r15)
                     mvc   twrtthrd,twrtthrd-twrtrept(r15)
                   endif
                   if (nc,twrtsddn,twrtsddn,z)
                     mvc   twrtsddn,twrtsddn-twrtrept(r15)
                   endif
                 endif
*
                 drop nvptr,ltre
*
wrxt               using logictbl,r5
                 if  clc,wrxt.ltmajfun,eq,wr  Is this a write?
                   MVC twrtview,wrxt.LTVIEW#  View number
                   mvc twrtltrw,wrxt.ltrowno       LT Row number
                   mvc twrtfunc,wrxt.ltmajfun
*
                   lgf r3,wrxt.ltwrexto       and add the offset
                   agr r3,r2
                   using ltwrarea,r3           and map via r3
*
                   mvc  twrtwwc,ltwrcnto
*
                   llgt R15,wrxt.LTWREXTA
                   if ltgf,r1,extvdpa-extfile(r15),p
             lgf r15,VDP0200b_ALLOC_FILE_TYPE-VDP0200B_FILE_RECORD(r1)
                     bctgr r15,0
                     mghi r15,l'owrtftyp      get the correct index
                     lay r15,filetype(r15)
                     mvc twrtftyp,0(r15)  Move in the file type
                   else
                     lay r15,filetype
                     mvc twrtftyp,0(r15)  Move in the file type
                   endif
*
                   if (clc,wrxt.ltfunc,eq,wr_tk),or,                   +
               (clc,wrxt.ltfunc,eq,wr_tx)
                     MVC twrteddn,wrxt.LTWRFILE
                   else ,
                     llgt R15,wrxt.LTWREXTA
                     MVC twrteddn,EXTDDNAM-EXTFILE(R15)
                   endif
*
                   MVC twrtwex(8),wrxt.LTWRNAME
*
* Write Ops to ERA
                   if  clc,wrxt.LTFUNC,eq,=cl4'WRSU' aggregation WRSU?
                     lg    r15,ltwrcnti
                     stg   r15,twrtera
* calculate % summ / in
                     if  (clc,ltwrcnto,lt,ltwrcnti)
                       sg    r15,twrtwwc          (input - output)
                       mghi  r15,100
                       lg    r0,twrtera
                     else
                       xgr   r0,r0
                     endif
                     if (cgij,r0,ne,0)
                       xgr   r14,r14
                       dlgr  r14,r0
                       mghi  r15,100
                       stg   r15,dblwork4  store the integer portion
                       lgr   r15,r14
                       mghi  r15,100
                       xgr   r14,r14       calculate 2 decimal places
                       dlgr  r14,r0
                       ag    r15,dblwork4
                     else
                       xgr   r15,r15
                     endif
                     st    r15,twrtcolp
                     if (cij,r0,ne,0)
                       mvi   twrtpct,c'%'
                     else
                       mvi   twrtpct,c' '
                     endif
                   endif
*
                   l    r0,twrtview
                   stg  r9,dblwork4
                   jasl r9,runv_check      Check if it's in runv parms
                   lg   r9,dblwork4  will become zero if not mentioned
*
                   if (ltgr,r0,r0,nz)
                     aghi  r4,twrtrept_len   need to keep track of.
                     asi   owrtrec_cnt,1
                   endif
*
                 endif
                 agh  R5,wrxt.ltrowlen     Next logictbl entry in this +
                                            RE-ES
                 doexit (clc,wrxt.ltfunc,eq,es),or,                    +
               (clc,wrxt.ltfunc,eq,et),or,                             +
               (clc,wrxt.ltfunc,eq,en)
               enddo
*
*  Now check for token views for the work unit - chained off ES entry
*
               if clc,wrxt.ltfunc,eq,es
                 stg r8,workarea           Save current register value
                 stg r2,workarea+8         Save thread litp address
tokre            using logictbl,r8         Map the RETK record
                 llgt r8,wrxt.ltfrstre       Get 1st "RE" again
                 do inf
                   doexit (ltgf,r8,tokre.ltnxrtkn,np) another token ?
*       address the literal pool for this token view instance
                   lg  r2,workarea+8       Get thread litp address
                   lgf r15,tokre.ltreindx  Get its index
                   mghi r15,8               Get correct offset litpool
                   aghi r15,litphdrl        Allow for the header
                   llgt r15,0-524288(r15,r2) Get lit pool offset value
                   agr r2,r15              Point at correct lit pool
                   llgt r5,tokre.ltrees     Get the "ES" for this "RE"
                   llgt r5,wrxt.ltfrstnv    Get 1st "NV" for the token
*
                   jasl r9,tokenrptdet      Get details for this token
*
                 enddo
                 drop tokre
                 lg r8,workarea           Retore register value
               endif
               drop  r2
*
             endif
           enddo
*
           agh   R8,ltrowlen        ADVANCE TO NEXT ROW (31-BIT ADDR)
         enddo
*
         sty   r4,lkup_first      first lkup
*
*      now do the sorting of owrt_report by work-unit and LT row
*
         using twrtrept,r4
         llgt  r3,owrt_first        first owrt detail line
         do until=(ltr,r0,r0,np)
           lgr   r4,r3            start address of owrt table
           llgt  r2,owrtrec_cnt   OWRT record count
           bctgr r2,0             minus-1
           xgr r0,r0              swaps flag off
           if (ltgr,r2,r2,p)
             do from=(r2)
               if (clc,twrtwudd(12),gt,twrtwudd+twrtrept_len) W-U+LTrow
                 la  r0,1           yes, there was a swap
                 xc  twrtrept_len(twrtrept_len,r4),0(r4)
                 xc  0(twrtrept_len,r4),twrtrept_len(r4)
                 xc  twrtrept_len(twrtrept_len,r4),0(r4)
               endif
               aghi  r4,twrtrept_len
             enddo
           endif
         enddo
*
         llgt  r1,rpt_sort_area_ptr start of area after eyeball
*                                                 restore registers
         lmg   R14,R12,SAVF4SAG64RS14-SAVF4SA(r1) apart from r1
*
         br    R14              RETURN (SWITCH TO 31-BIT MODE)

         drop  wrxt
         DROP  R4 twrtrept
         DROP  R8
*
********************************************************************
*                                                                     *
*        Get I/O details for a Token                                  *
*        R8 --> RETK                                                  *
*        R5 --> First NV for this RETK-ET                             *
*                                                                     *
********************************************************************
Tokenrptdet ds    0h                 LOAD  TEMPORARY BASE REGISTER
         using twrtrept,r4
tkre     using logictbl,r8

         MVC twrtsddn,tkre.ltddname
*
         do  inf
tknv       using logictbl,r5
           llgt  r15,owrt_first
           if (cr,r4,gt,r15)
             lgr   r15,r4
             aghi  r15,-twrtrept_len inherits some previous fld
             if (nc,twrtwudd,twrtwudd,z)
               mvc   twrtwudd,twrtwudd-twrtrept(r15)
               mvc   twrtview,twrtview-twrtrept(r15)
               mvc   twrtthrd,twrtthrd-twrtrept(r15)
             endif
             if (nc,twrtsddn,twrtsddn,z)
               mvc   twrtsddn,twrtsddn-twrtrept(r15)
             endif
           endif
*
tkwr       using logictbl,r5
           if  clc,tkwr.ltmajfun,eq,wr     Is this a write?
             lgf r3,tkwr.ltwrexto           add offset to write area
             agr r3,r2
             using ltwrarea,r3              and map via r3
*
             mvc twrtview,tkwr.ltview#      view number
*
             mvc twrtwwc,ltwrcnto
*
             mvc twrtltrw,tkwr.ltrowno      LT Row number
*
             mvc twrtfunc,tkwr.ltmajfun
*
             if (clc,tkwr.ltfunc,eq,wr_tk),or,                         +
               (clc,tkwr.ltfunc,eq,wr_tx)
               MVC twrteddn,tkwr.LTWRFILE

             else ,
               Llgt R15,tkwr.LTWREXTA
               MVC twrteddn,EXTDDNAM-EXTFILE(R15)

*             Copy file type
              if ltgf,r1,extvdpa-extfile(r15),p
              lgf r15,VDP0200B_ALLOC_FILE_TYPE-VDP0200B_FILE_RECORD(r1)
                 bctgr r15,r0
                 mghi r15,l'owrtftyp            get the correct index
                 lay r15,filetype(r15)
                 mvc twrtftyp,0(r15)        Move in the file type
               else
                 lay r15,filetype
                 mvc twrtftyp,0(r15)        Move in the file type
               endif
             endif

             MVC twrtwex(8),tkwr.LTWRNAME
*
* Write Ops to ERA
             if  clc,tkwr.LTFUNC,eq,=cl4'WRSU' aggregation WRSU?
               lg    r15,ltwrcnti
               stg   r15,twrtera
* calculate % summ / in
               if  (clc,ltwrcnto,lt,ltwrcnti)
                 sg    r15,twrtwwc          (input - output)
                 mghi  r15,100
                 lg    r0,twrtera
               else
                 xgr   r0,r0
               endif
               if (cgij,r0,ne,0)
                 xgr   r14,r14
                 dlgr  r14,r0
                 mghi  r15,100
                 stg   r15,dblwork4  store the integer portion
                 lgr   r15,r14
                 mghi  r15,100
                 xgr   r14,r14       calculate 2 decimal places
                 dlgr  r14,r0
                 ag    r15,dblwork4
               else
                 xgr   r15,r15
               endif
               st    r15,twrtcolp
               if (cij,r0,ne,0)
                 mvi   twrtpct,c'%'
               else
                 mvi   twrtpct,c' '
               endif
             endif
*
             l    r0,twrtview
             stg  r9,dblwork4
             jasl r9,runv_check      Check if it's in runv parms
             lg   r9,dblwork4
*
             if (ltgr,r0,r0,nz)
               aghi  r4,twrtrept_len   need to keep track of.
               asi   owrtrec_cnt,1
             endif
*
           endif
           agh  R5,tkwr.ltrowlen
           doexit (clc,tkwr.ltfunc,eq,et)
           drop tkwr
         enddo
*
         br   r9

         drop tkre
         DROP R4 tsrcrept

* *********************************************************************
*                                                                     *
*        Check Runv parameters                                        *
*                                                                     *
* *********************************************************************
runv_check ds 0h
         llgt  r1,rpt_sort_area_ptr
         aghi  r1,SAVF4SA_LEN     2nd saverea for report preparation
*                                                 store registers
         stmg  R14,R12,SAVF4SAG64RS14-SAVF4SA(r1) apart from r1
         llgt  r14,rpt_sort_area_ptr
         stg   r1,SAVF4SANEXT-SAVF4SA(r14)
         stg   r14,SAVF4SAPREV-SAVF4SA(r1)
         mvc   SAVF4SAID-SAVF4SA(4,r1),=cl4'SAVF4SAID_VALUE'
*
         llgt r14,runview_ptr
         do label=runv_testing
           if ltgr,r14,r14,nz      check that we have runview data
             using (runview_list,runv_length),r14 and map the data
             l r15,runv_count     get counter
             llgt r1,runv_first      and get first entry
             using runvent,r1     and map that
             do from=(r15),while=(ltr,r1,r1,nz)
               if cl,r0,eq,runvent_view
                 leave runv_testing  found - so print it
               elseif (h)
                 llgt r1,runvent_next
               elseif (l)
                 leave
               endif
             enddo
             drop r1,r14

*          here if the view no is NOT in runviews
*          so set the view no to zero to prevent printing
             xgr   r0,r0
             llgt  r1,rpt_sort_area_ptr
             aghi  r1,SAVF4SA_LEN     2nd saverea for report preparatio
             stg   r0,SAVF4SAG64RS0-SAVF4SA(r1)
           endif
         enddo

         llgt  r1,rpt_sort_area_ptr
         aghi  r1,SAVF4SA_LEN     2nd saverea for report preparation
         lmg   R14,R12,SAVF4SAG64RS14-SAVF4SA(r1) restore except r1
*
         br    R9
*
***********************************************************************
*                                                                     *
*        Prepare ~LKUP Report In Memory for Sorting                   *
*                                                                     *
***********************************************************************
lkup_prepare ds 0h
*
         llgt  r1,rpt_sort_area_ptr
*                                                 store registers
         stmg  R14,R12,SAVF4SAG64RS14-SAVF4SA(r1) apart from r1
         stg   r13,SAVF4SAPREV-SAVF4SA(r1)
         mvc   SAVF4SAID-SAVF4SA(4,r1),=cl4'SAVF4SAID_VALUE'
*
*      LKUP report ----------------------------------------
*
         xgr   r10,r10          lookup stat counter
*
         using tkuprept,r4
         llgt  r4,lkup_first
*
* - We loop through the threads, getting the pointer to the list of
* ES logic table entries that were processed by this thread.
* - Then we loop through all the ES entries for that thread.
* - The ES logic table entry has a pointer to the Lookup buffer area
* chain (LTLBADDR) so we loop through the lookup buffer areas LKUPBUFR
* for that ES entry, and gather the statistics.
* Notes: There are LKUPBUFR areas used by tokens in this list, so we
* must ignore these.
*
         llgt  R8,THRDFRST        LOAD FIRST THREAD WORK AREA ADDRESS
TH_WRK   USING (THRDAREA,thrdend),R8
         do until=(ltgf,r8,th_wrk.thrdnext,np) Loop thro all threads
*
th_es      USING LOGICTBL,R7
           if ltgf,r7,th_wrk.thrdexec,nz
             do until=(ltgf,r7,th_es.ltnextes,np) Loop thro all ES for
*              now loop through all the LKUPBUFR areas -- for ES sets
               if ltgf,r5,th_es.ltlbanch,nz
                 do until=(ltgf,r5,lbnext,np)
*
                   using lkupbufr,r5
                   if clc,LBFILEID,ne,TOKN Ignore token LBs
*
                     llgt  r15,lkup_first
                     if (cr,r4,gt,r15)
                       lgr   r15,r4
                       aghi  r15,-tkuprept_len inherits some previous
                       if (nc,tkupddname,tkupddname,z)
                         mvc   tkupddname,tkupddname-tkuprept(r15)
                         mvc   tkupthrd,tkupthrd-tkuprept(r15)
                       endif
                     endif
*
                     ahi r10,1
                     lay r15,-3(r8)        point to start of thread #
                     mvc tkupthrd(3),0(r15) move in thread number
*           DDNAME
                     l r15,th_es.LTFRSTRE  point to RE
th_re                using logictbl,r15
                     mvc tkupddname,th_re.ltddname
*           Source
                     mvc tkupsrce,th_re.ltddname
                     drop th_re
*           RUNTIME path ID
                     mvc tkuppath,LBPATHID
*           Workbench path ID
                     mvc tkupwpath,LBWEPATH                    d
*           STEP ID
                     if c,r5,eq,LBPARENT,or,oc,LBPARENT,LBPARENT,z
                       lgfi r6,1         Set step counter for this path
                     else
                       agfi r6,1         next step
                     endif
                     st  r6,tkupstep
*
*           Lookups found
                     mvc tkupLFnd,lbfndcnt
*           Lookups not found
                     mvc tkupLNFnd,lbnotcnt
*
*           LR ID
                     mvc tkuplrid,LBLRID
*           LF ID
                     mvc tkuplfid,LBFILEID
*           Key Len
                     lh  r0,LBKEYLEN
                     ah  r0,=h'1'               was -1 value
                     sth r0,tkupklen            now key length
*
*           Any LOOKUP User Exit?
                     if TM,LBFLAGS,LBSUBPGM,o
                       MVC tkupExit,LBSUBNAM
*           Optimizable
                       if tm,lbflags+1,lbexitopt,o  Exit optimizable?
                         mvi tkupopt,c'Y'
                       else
                         mvi tkupopt,c'N'
                       endif
                     else
                       MVC tkupExit,spaces
                       mvi tkupopt,c' '  Not relevant if no exit
                     endif
*           Effective dates used - start dates
                     if TM,LBFLAGS,LBEFFDAT,o
                       mvi tkupSdate,c'Y'
                     else
                       mvi tkupSdate,c'N'
                     endif
*           Effective dates used - end dates
                     if TM,LBFLAGS,LBEFFEND,o
                       mvi tkupEdate,c'Y'
                     else
                       mvi tkupEdate,c'N'
                     endif
*
                     aghi  r4,tkuprept_len
                   endif  , not TOKN (i.e. fake lookup buffer)
*
                 enddo  , ES lkup buffers
               endif
*
*   This next part involves addressing the literal pool that was in
*   effect and associated with the original RENX-ES and then finding
*   lookup buffer(s) that are stored somewhere in the literal pool
*   based upon the literal pool header index associated with each RETK.
*
*           Look for any tokens associated with ES set
th_retk        USING LOGICTBL,R15
               if ltgf,r15,th_es.ltesrtkq,p
*           Source
                 mvc tkupsrce,th_retk.ltddname

                 llgt  r2,th_es.lteslpad
                 agfi  r2,f512k

                 do until=(ltgf,r15,th_reet.ltesrtkq,np) for all rtkq's
                   lgf   r1,th_retk.ltreindx
                   mghi  r1,8
                   agf   r1,th_es.lteslpad
                   aghi  r1,litphdrl
                   llgt  r1,0(,r1)
                   lgf   r15,th_retk.ltrees
                   drop  th_retk
th_reet            using LOGICTBL,R15
                   lgf   r5,th_reet.ltlbanch
                   if    tm,th_reet.ltesflg1,ltlbanco,o ltlbanch offset ?
                     agr   r5,r2
                     llgt  r5,0(r1,r5)
*
* save address of ET entry so it can be used to get next retk in chain
*
                     stg   r15,workarea

                     if ltgr,r5,r5,nz
                       do until=(ltgf,r5,lbnext,np)
                         if clc,LBFILEID,ne,TOKN Ignore token LBs
*
                           llgt  r15,lkup_first
                           if (cr,r4,gt,r15)
                             lgr   r15,r4
                             aghi  r15,-tkuprept_len inherits previous
                             if (nc,tkupddname,tkupddname,z)
                               mvc tkupddname,tkupddname-tkuprept(r15)
                               mvc tkupthrd,tkupthrd-tkuprept(r15)
                             endif
                             if (nc,tkupsrce,tkupsrce,z) inherits srce
                               mvc tkupsrce,tkupsrce-tkuprept(r15)
                             endif
                           endif
*
*           RUNTIME path ID
                           mvc tkuppath,LBPATHID
*           Workbench path ID
                           mvc tkupwpath,LBWEPATH
*           STEP ID
                     if c,r5,eq,LBPARENT,or,oc,LBPARENT,LBPARENT,z
                             lgfi r6,1 Set step counter for this path
                           else
                             agfi r6,1 next step
                           endif
                           st  r6,tkupstep
*
*           Lookups found
                           mvc tkupLFnd,lbfndcnt
*           Lookups not found
                           mvc tkupLNFnd,lbnotcnt
*
*           LR ID
                           mvc tkuplrid,LBLRID
*           LF ID
                           mvc tkuplfid,LBFILEID
*           Key Len
                           lh  r0,LBKEYLEN
                           ah  r0,=h'1'               was -1 value
                           sth r0,tkupklen            now key length
*
*           Any LOOKUP User Exit?
                           if TM,LBFLAGS,LBSUBPGM,o
                             MVC tkupExit,LBSUBNAM
*           Optimizable
                             if tm,lbflags+1,lbexitopt,o  Opt?
                               mvi tkupopt,c'Y'
                             else
                               mvi tkupopt,c'N'
                             endif
                           else
                             MVC tkupExit,spaces
                             mvi tkupopt,c' ' Not relevant if no exit
                           endif
*           Effective dates used - start dates
                           if TM,LBFLAGS,LBEFFDAT,o
                             mvi tkupSdate,c'Y'
                           else
                             mvi tkupSdate,c'N'
                           endif
*           Effective dates used - end dates
                           if TM,LBFLAGS,LBEFFEND,o
                             mvi tkupEdate,c'Y'
                           else
                             mvi tkupEdate,c'N'
                           endif

                           aghi  r4,tkuprept_len

                         endif   , not TOKN (i.e. fake lookup buffer)

                       enddo , ET lkup buffers
                     endif
                     lg  r15,workarea
                   endif  , ltlbanch is an offset

                 enddo  , RETK areas in queue
                 drop  th_reet
               endif

             enddo
           endif
         enddo
*
*      now do the sorting of lkup_report by work-unit/source/LP/step
*
         using tkuprept,r4
         llgt  r3,lkup_first        first lkup detail line
         do until=(ltr,r0,r0,np)
           lgr   r4,r3            start address of lkup table
           llgt  r2,lkuprec_cnt   LKUP record count
           bctgr r2,0             minus-1
           xgr r0,r0              swaps flag off
           if (ltgr,r2,r2,p)
             do from=(r2)
               if (clc,tkupddname(24),gt,tkupddname+tkuprept_len)
                 la  r0,1           yes, there was a swap
                 xc  tkuprept_len(tkuprept_len,r4),0(r4)
                 xc  0(tkuprept_len,r4),tkuprept_len(r4)
                 xc  tkuprept_len(tkuprept_len,r4),0(r4)
               endif
               aghi  r4,tkuprept_len
             enddo
           endif
         enddo
*
         llgt  r1,rpt_sort_area_ptr start of area after eyeball
*                                                 restore registers
         lmg   R14,R12,SAVF4SAG64RS14-SAVF4SA(r1) apart from r1
*
         br    R14              RETURN (SWITCH TO 31-BIT MODE)
*
         drop r5
         drop TH_WRK
         drop TH_ES
*
***********************************************************************
*                                                                     *
*        Count Number of Work_units, ISRC, OWRT LKUP detail records   *
*                                                                     *
***********************************************************************
prep_sorts  ds 0h
         stmg  R14,R12,SAVEZIIP

*      Get count of isrc rows in isrc report---------------

         xgr   r0,r0              token counter
         xgr   r1,r1              work-unit counter
         llgt  R8,LTHDROWA
         USING LOGICTBL,R8

         llgt  R8,THRDFRST        LOAD FIRST THREAD WORK AREA ADDRESS
TH_WRK   USING (THRDAREA,thrdend),R8

th_wrk_env using genenv,th_wrk.env_area

isrc_s02 ds    0h
         ltgf  R7,TH_WRK.THRDEXEC LOAD EXECUTED "ES" SET  ADDR
         JNP   isrc_s03
TH_ES    USING LOGICTBL,R7

isrc_s01 ds    0h
         ltgf  R2,TH_ES.LTFRSTRE
         JNP   isrc_s04
ES_RE    USING LOGICTBL,R2

         aghi  r1,1                     count extract files

*      Now process any Tokens being used by this "RE**/ES" set
         do inf
           doexit (ltgf,r2,es_re.ltnxrtkn,np) Is there another token
           aghi  r0,1                   count token
         enddo

isrc_s04 ltgf  R7,TH_ES.LTNEXTES  LOAD  NEXT   "ES" SET IN THREAD
         JP    isrc_s01

isrc_s03 ltgf  R8,TH_WRK.THRDNEXT ADVANCE TO  NEXT  THREAD
         JP    isrc_s02

         agr   r0,r1
         sty   r0,isrcrec_cnt     ISRC record counter
         sty   r1,workunit_cnt    work-unit counter

         DROP  ES_RE
         DROP  TH_ES
         DROP  TH_WRK
         DROP  R8
*
*      Get count of owrt rows in report--------------------
*
         llgt  R8,LTHDROWA
         USING LOGICTBL,R8
*
         llgt  R8,LTBEGIN         LOAD LOGIC  TABLE ADDRESS
         USING LOGICTBL,R8
*
         xgr   r1,r1              work-unit counter
*
         lgf   R7,LTCOUNT         LOAD LOGIC  TABLE ENTRY COUNT
*
         do from=(r7),label=outer_02
           do ,label=inner_02
             if CLC,LTFUNC,eq,es         Look for es|et records
*
               llgt  r2,lteslpad        get literal pool pointer
               using litp_hdr+524288,r2
               agfi  r2,f512k
ltre           using logictbl,r14           map the RE record
               doexit (ltgf,r14,ltfrstre,p),and,                       +
               (ltgf,r0,ltcodseg-logictbl(,r14),np)
*
nvptr          using logictbl,r5
               llgt  r5,ltfrstnv        get the first nv pointer

               do  inf
wrxt             using logictbl,r5
                 if  clc,wrxt.ltmajfun,eq,wr  Is this a write?
                   aghi r1,1               count of owrt rows
                 endif
*
                 agh  R5,wrxt.ltrowlen
                 doexit (clc,wrxt.ltfunc,eq,es),or,                    +
               (clc,wrxt.ltfunc,eq,et),or,                             +
               (clc,wrxt.ltfunc,eq,en)
               enddo
*
               if clc,wrxt.ltfunc,eq,es
                 stg r8,workarea           Save current register value
                 stg r2,workarea+8         Save thread litp address
tokre            using logictbl,r8         Map the RE record
                 llgt r8,wrxt.ltfrstre       Get 1st "RE" again
                 do inf
                   doexit (ltgf,r8,tokre.ltnxrtkn,np) another token ?
                   lg  r2,workarea+8       Get thread litp address
                   lgf r15,tokre.ltreindx  Get its index
                   mghi r15,8               Get correct offset litpool
                   aghi r15,litphdrl        Allow for the header
                   llgt r15,0-524288(r15,r2) Get lit pool offset value
                   agr r2,r15              Point at correct lit pool
                   llgt r5,tokre.ltrees     Get the "ES" for this "RE"
                   llgt r5,wrxt.ltfrstnv    Get 1st "NV" for the token
*
*                  Get count of owrt rows for a Token
*
                   do  inf
tkwr                 using logictbl,r5
                     if  clc,tkwr.ltmajfun,eq,wr   Is this a write?
                       aghi  r1,1
                     endif
                     agh   R5,tkwr.ltrowlen
                     doexit (clc,tkwr.ltfunc,eq,et)
                     drop tkwr
                   enddo
*                  jasl r9,tokenrptcnt     Go do report for this token
                 enddo
                 drop tokre
                 lg r8,workarea           Retore register value
               endif
               drop  r2
*
             endif
           enddo
           agh   R8,ltrowlen        ADVANCE TO NEXT ROW (31-BIT ADDR)
         enddo
         drop  wrxt

         sty   r1,owrtrec_cnt1    OWRT records (inc omitted views)

         DROP  R8
*
*      Get count of lkup rows in report--------------------
*
         xr    r10,r10          lookup stat counter
*
* - We loop through the threads, getting the pointer to the list of
* ES logic table entries that were processed by this thread.
* - Then we loop through all the ES entries for that thread.
* - The ES logic table entry has a pointer to the Lookup buffer area
* chain (LTLBADDR) so we loop through the lookup buffer areas LKUPBUFR
* for that ES entry, and gather the statistics.
* Notes: There are LKUPBUFR areas used by tokens in this list, so we
* must ignore these.
*
         llgt  R8,THRDFRST        LOAD FIRST THREAD WORK AREA ADDRESS
TH_WRK   USING (THRDAREA,thrdend),R8
         do until=(ltgf,r8,th_wrk.thrdnext,np) Loop thro all threads
*
th_es      USING LOGICTBL,R7
           if ltgf,r7,th_wrk.thrdexec,nz
             do until=(ltgf,r7,th_es.ltnextes,np) Loop thro all ES for
*              now loop through all the LKUPBUFR areas -- for ES sets
               if ltgf,r5,th_es.ltlbanch,nz
                 do until=(ltgf,r5,lbnext,np)
*
                   using lkupbufr,r5
                   if clc,LBFILEID,ne,TOKN Ignore token LBs
                     ahi r10,1
                   endif  , not TOKN (i.e. fake lookup buffer)
*
                 enddo  , ES lkup buffers
               endif
*
*   This next part involves addressing the literal pool that was in
*   effect and associated with the original RENX-ES and then finding
*   lookup buffer(s) that are stored somewhere in the literal pool
*   based upon the literal pool header index associated with each RETK.
*
*           Look for any tokens associated with ES set
th_retk        USING LOGICTBL,R15
               if ltgf,r15,th_es.ltesrtkq,p

                 llgt  r2,th_es.lteslpad
                 agfi  r2,f512k

                 do until=(ltgf,r15,th_reet.ltesrtkq,np) for all rtkq's
                   lgf   r1,th_retk.ltreindx
                   mghi  r1,8
                   agf   r1,th_es.lteslpad
                   aghi  r1,litphdrl
                   llgt  r1,0(,r1)
                   lgf   r15,th_retk.ltrees
                   drop  th_retk
th_reet            using LOGICTBL,R15
                   lgf   r5,th_reet.ltlbanch
                   if    tm,th_reet.ltesflg1,ltlbanco,o ltlbanch offset ?
                     agr   r5,r2
                     llgt  r5,0(r1,r5)
*
* save address of ET entry so it can be used to get next retk in chain
*
                     stg   r15,workarea

                     if ltgr,r5,r5,nz
                       do until=(ltgf,r5,lbnext,np)

                         if clc,LBFILEID,ne,TOKN Ignore token LBs
                           ahi r10,1
                         endif   , not TOKN (i.e. fake lookup buffer)

                       enddo , ET lkup buffers
                     endif
                     lg  r15,workarea
                   endif  , ltlbanch is an offset

                 enddo  , RETK areas in queue
                 drop  th_reet
               endif

             enddo
           endif
         enddo

         sty   r10,lkuprec_cnt    OWRT records

         lmg   R14,R12,SAVEZIIP   RESTORE RETURN ADDRESS
         br    R14

         drop r5
         drop TH_WRK
         drop TH_ES

********************************************************************
*                                                                     *
*        Print ~ISRC Report                                           *
*                                                                     *
********************************************************************
isrc_report ds 0h
         llgt  r1,rpt_sort_area_ptr
*                                                 store registers
         stmg  R14,R12,SAVF4SAG64RS14-SAVF4SA(r1) apart from r1
         stg   r13,SAVF4SAPREV-SAVF4SA(r1)
         mvc   SAVF4SAID-SAVF4SA(4,r1),=cl4'SAVF4SAID_VALUE'
*
         llgt  R8,LTHDROWA
         USING LOGICTBL,R8
*
         rptit msg=vb_blankl
         if clc,namepgm,eq,=cl8'GVBMR95E'
           phead hd=isrc
         else
           phead hd=iref
         endif
         rptit msg=rptisrc_hd2   column heading 2
         rptit msg=rptisrc_hda   column heading a
         rptit msg=rptisrc_hd3   column underlining 1
*
*        DBLWORK will contain the total record count and
*        DBLWORK+8 will contain the total byte count
*
         xc    dblwork(16),dblwork
         llgt  r4,isrc_first
         llgt  r3,isrcrec_cnt
         using tsrcrept,r4
is1      using isrcrept,prntline
*
         mvc   prntline,spaces
*
         do from=(r3)
*
           mvc   is1.isrcthrd,tsrcthrd  move in thread number
*
           MVC   is1.isrcwudd,tsrcwudd  work unit name
           MVC   is1.isrcddn,tsrcddn    source ddname
           mvc   is1.isrcPFnm,tsrcpfnm  move PF name
           mvc   is1.isrcftyp,tsrcftyp  file type
*
*        Move in Record count
           lg    r1,tsrcrcnt             get event record count
           cvdg  r1,dblwork2             make it decimal
           ag    r1,dblwork              increment the total
           stg   r1,dblwork              and save it
           MVC   is1.isrcrcnt,bytemsk+2    Use last 18 bytes of bytemsk
           mvi   is1.isrcrcnt,c' '         make 1 char of mask blank
           ed    is1.isrcrcnt,dblwork3+1
*
*        Move in byte count
           lg    r1,tsrcbcnt              Get event record count
           cvdg  r1,dblwork2
           mvc   is1.isrcbcnt,bytemsk     format
           ed    is1.isrcbcnt,dblwork3     it
           ag    r1,dblwork+8
           stg   r1,dblwork+8
*
           rptit ,
           aghi  r4,tsrcrept_len
         enddo
*
*        Print Record totals and Byte totals
*
         rptit msg=rptisrc_hd4   column underlining 2
         mvc   is1.isrcthrd(isrcrept_len),spaces
         lay   r15,=cl14'Total         '
         mvc   is1.isrcthrd(14),0(r15)   Move in the file type
         mvi   is1.isrcthrd+79,c'>'
         MVC   is1.isrcrcnt,bytemsk+2    Use last 18 bytes of bytemsk
         mvi   is1.isrcrcnt,c' '         make 1 char of mask blank
         lg    r0,dblwork
         lg    r1,dblwork+8
         if clc,namepgm,eq,=cl8'GVBMR95R' Reference phase relevant only
           stg   r0,iref_rcnt
           stg   r1,iref_bcnt
         endif
         cvdg  r0,dblwork
         cvdg  r1,dblwork2
         ed    is1.isrcrcnt,dblwork+9
         mvc   is1.isrcbcnt,bytemsk     format
         ed    is1.isrcbcnt,dblwork3     it
         rptit ,
         rptit msg=rptisrc_hd5   column underlining 3
*
         llgt  r1,rpt_sort_area_ptr start of area after eyeball
*                                                 restore registers
         lmg   R14,R12,SAVF4SAG64RS14-SAVF4SA(r1) apart from r1
         br    R14              RETURN (SWITCH TO 31-BIT MODE)
*
         DROP  R8
         DROP  R4

* *********************************************************************
*                                                                     *
*        Print ~OWRT Report                                           *
*                                                                     *
* *********************************************************************
owrt_report ds 0h
         llgt  r1,rpt_sort_area_ptr
*                                                 store registers
         stmg  R14,R12,SAVF4SAG64RS14-SAVF4SA(r1) apart from r1
         stg   r13,SAVF4SAPREV-SAVF4SA(r1)
         mvc   SAVF4SAID-SAVF4SA(4,r1),=cl4'SAVF4SAID_VALUE'
*
         rptit msg=vb_blankl
*
         phead hd=owrt
         rptit msg=rptowrt_hd1   column heading 1
         rptit msg=rptowrt_hd2   column heading 2
         rptit msg=rptowrt_hd3   column underlining 1
*
ow1      using owrtrept,prntline
         mvc   ow1.owrtrept(owrtrept_len),spaces
         llgt  r4,owrt_first
         llgt  r3,owrtrec_cnt
         using twrtrept,r4
*
         do from=(r3)
           mvc   ow1.owrtthrd,twrtthrd
           MVC   ow1.owrtwudd,twrtwudd
           MVC   ow1.owrtsddn,twrtsddn
*
           l     r0,twrtview
           cvd   r0,dblwork
           mvc dblwork2,nummask
           ed  dblwork2,dblwork+4        Move in the view id
           mvc ow1.owrtview,dblwork2+1
*
           l     r0,twrtltrw             LT Row number
           cvd   r0,dblwork
           mvc   ow1.owrtltrw,tracemsk+4
           mvi   ow1.owrtltrw,c' '       1st mask char blank
           ed    ow1.owrtltrw,dblwork+4
*
           mvc   ow1.owrtfunc,twrtfunc   function
*
           lg    r0,twrtwwc
           cvdg  r0,dblwork2
           mvc   ow1.owrtwwc,COUNTMSK_18
           ed    ow1.owrtwwc,dblwork3+1  VIEW  EXTRACT COUNT
*
           mvi   ow1.owrtchev,c'>'       chevron
*
           mvc   ow1.owrtftyp,twrtftyp   Move in the file type
           mvc   ow1.owrteddn,twrteddn
*
           mvc   ow1.owrtwex,twrtwex
*
           if   (clc,twrtfunc,eq,=cl4'WRSU')
             lg    r0,twrtera              ERA bytes
             cvdg  r0,dblwork2
             mvc   ow1.owrtera,COUNTMSK_18
             ed    ow1.owrtera,dblwork3+1  VIEW  EXTRACT COUNT
             if (lt,r15,twrtcolp,p)
               cvd   r15,dblwork
               mvc   ow1.owrtcolp,pctmsk+1
               mvi   ow1.owrtcolp,C' '
               ed    ow1.owrtcolp,dblwork+3
               mvc   ow1.owrtpct,twrtpct
             endif
           else
             mvc   ow1.owrtera(32),spaces
           endif
*
           lhi     r1,owrtrept_len+l'prntrdw
           sth     r1,prntrdwh
*
           rptit ,
*
           aghi    r4,twrtrept_len
         enddo
*
         llgt  r1,rpt_sort_area_ptr start of area after eyeball
*                                                 restore registers
         lmg   R14,R12,SAVF4SAG64RS14-SAVF4SA(r1) apart from r1
         br    R14              RETURN (SWITCH TO 31-BIT MODE)

         drop  r4
*
* *********************************************************************
*                                                                     *
*        Print ~LKUP report                                           *
*                                                                     *
* *********************************************************************
lkup_report ds 0h
         llgt  r1,rpt_sort_area_ptr
*                                                 store registers
         stmg  R14,R12,SAVF4SAG64RS14-SAVF4SA(r1) apart from r1
         stg   r13,SAVF4SAPREV-SAVF4SA(r1)
         mvc   SAVF4SAID-SAVF4SA(4,r1),=cl4'SAVF4SAID_VALUE'
*
         rptit msg=vb_blankl
         phead hd=lkup
         xgr   r10,r10          lookup stat counter
         xc    grand_total_lkups,grand_total_lkups
*
         llgt  r4,lkup_first
         llgt  r3,lkuprec_cnt
         using tkuprept,r4
*
         if (ltr,r3,r3,p)
           rptit msg=rptlkup_hd0 column heading 0
           rptit msg=rptlkup_hd1 column heading 1
           rptit msg=rptlkup_hd2 column underlining 1
           mvc prntline(lkuprept_len),SPACES
*
           do from=(r3)
lu1          using lkuprept,prntline
             mvc lu1.lkupthrd,tkupthrd      thread id
             mvc lu1.lkupddname,tkupddname  work unit (ddname)
             mvc lu1.lkupsrce,tkupsrce      source (ddname)
*
*           RUNTIME path ID
             l   r15,tkuppath
             cvd r15,dblwork
             mvc lu1.lkuppath,nummask
             ed  lu1.lkuppath,dblwork+4 Move in the path id
*
*           Workbench path ID
             l   r15,tkupwpath
             cvd r15,dblwork
             mvc dblwork2,nummask
             ed  dblwork2,dblwork+4     Move in WE path id
             mvc lu1.lkupwpath,dblwork2+1
*
*           STEP ID
             l   r15,tkupstep
             cvd r15,dblwork
             mvc lu1.lkupstep,nummask+4
             mvi lu1.lkupstep,c' '
             ed  lu1.lkupstep,dblwork+6 Move in the step no
*
*           Lookups found
             mvc  lu1.lkupLFnd,bytemsk+2
             mvi  lu1.lkupLFnd,c' '
             lg   r15,tkupLFnd
             cvdg r15,dblwork2
             ed   lu1.lkupLFnd,dblwork3+1
*
*           Lookups not found
             mvc  lu1.lkupLNFnd,bytemsk+2
             mvi  lu1.lkupLNFnd,c' '
             lg   r0,tkupLNFnd
             cvdg r0,dblwork2
             ed   lu1.lkupLNFnd,dblwork3+1
*
*           Total lookups
             mvc  lu1.lkupLTot,bytemsk+2
             mvi  lu1.lkupLTot,c' '
             agr  r15,r0
             cvdg r15,dblwork2
             ed   lu1.lkupLTot,dblwork3+1
             mvi  lu1.lkupfchv,c'>'
*
*           Running total lookups attempted across views
             lg   r0,grand_total_lkups
             agr  r0,r15
             stg  r0,grand_total_lkups
*
*           LR ID
             l   r15,tkuplrid
             cvd r15,dblwork
             mvc dblwork2,nummask
             ed  dblwork2,dblwork+4     Move in the Lr Id
             mvc lu1.lkuplrid,dblwork2+1
*
*           LF ID
             l   r15,tkuplfid
             cvd r15,dblwork
             mvc dblwork2,nummask
             ed  dblwork2,dblwork+4     Move in the Lf ID
             mvc lu1.lkuplfid,dblwork2+1
*
*           Key Length
             lhy R0,tkupklen
             cvd r0,dblwork
             mvc lu1.lkupklen,=x'40202120'
             ed  lu1.lkupklen,dblwork+6
*
             mvc lu1.lkupclear,spaces
*
*           Any LOOKUP User Exit?
             MVC lu1.lkupExit,tkupExit
*
*           Optimizable
             mvc lu1.lkupopt,tkupopt
*
*           Effective dates used - start dates
             mvc lu1.lkupSdate,tkupSdate
*
*           Effective dates used - end dates
             mvc lu1.lkupEdate,tkupEdate
*
             rptit ,

             aghi  r4,tkuprept_len
             aghi  r10,1

           enddo
         endif

         if cij,R10,eq,0      Have we printed anything?
           rptit msg=nonemsg  No
         endif
*
         llgt  r1,rpt_sort_area_ptr start of area after eyeball
*                                                 restore registers
         lmg   R14,R12,SAVF4SAG64RS14-SAVF4SA(r1) apart from r1
         br    r14              Return
*
         drop  r4
*
         push  using
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*                                                                     *
*        DAYS/MONTHS/YEARS BETWEEN  (CONSTANT VS CONSTANT)            *
*                                                                     *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*
         using (thrdarea,thrdend),r13 Tell assembler to map the area
         USING LOGICTBL,R5
         using litp_hdr+524288,r2
static   loctr ,
fnccsub_indirect jlu fnccsub
code     loctr ,
*
***********************************************************************
*  CONVERT FIRST NORMALIZED CONSTANT DATE                             *
***********************************************************************
FNCCSUB  LA    R14,LTCOLMSK       LOAD CONSTANT   DATE ADDRESS
         agh   R14,LTMSKLEN
         stg   R14,SAVALADR
*
         LA    R1,WORKAREA+0      LOAD TARGET     DATE ADDRESS
         ST    R1,DL96TGTA        SAVE TARGET  ADDRESS
*
         LHI   R0,8               LOAD NORMALIZED DATE LENGTH
         STH   R0,SAVALLEN
         STH   R0,DL96LEN

         if CLC,LTRELOPR,NE,DM,and,  Not DAYS IN MONTH ??              +
               CLI,LTRELOPR,eq,C'D'  but is DAYS BETWEEN ???

           MVI SAOUTCON+1,CYDDD   JULIAN   DATE  CODE
           LHI R0,7               OUTPUT LENGTH = 7
           STH R0,DL96LEN

         endif

         MVI   SAVALFMT+1,FC_NUM       FIELD    FORMAT   CODE
         MVI   SAVALCON+1,CYMD         FIELD    CONTENT  CODE
         mvhhi SAVALDEC,0         SET  NO.   OF DECIMALS
         mvhhi SAVALRND,0         SET  ROUNDING FACTOR
         MVI   SAVALSGN,C'N'      SET  SIGN     INDICATOR
*
         XC    SAMSKADR,SAMSKADR  ZERO TARGET   MASK  ADDRESS
         XC    SAMSKLEN,SAMSKLEN  ZERO TARGET   MASK  LENGTH
*
         MVI   SAOUTFMT+1,FC_NUM  SET  NUMERIC  FORMAT   CODE
         MVHHI SAOUTDEC,0         ZERO NO. OF   DECIMALS
         MVHHI SAOUTRND,0         ZERO ROUNDING FACTOR
         MVI   SAOUTSGN,C'N'      SET  EDITED   SIGN     IND
*
         BRAS  R9,DATEDL96        CONVERT DATE TO JULIAN/GREG (NUMERIC)
*
         CLC   LTRELOPR,DM        DAYS IN MONTH ???
         JE    BETW_050
*
***********************************************************************
*  CONVERT SECOND NORMALIZED CONSTANT DATE                            *
***********************************************************************
         lgh   R14,LTMSKLEN
         ah    R14,LTV1LEN
         LA    R14,LTCOLMSK(r14)  LOAD CONSTANT   DATE ADDRESS
         stg   R14,SAVALADR
*
         LA    R1,WORKAREA+8      LOAD TARGET     DATE ADDRESS
         ST    R1,DL96TGTA        SAVE TARGET  ADDRESS
*
         BRAS  R9,DATEDL96        CONVERT DATE TO JULIAN/GREG (NUMERIC)
*

         select CLI,LTRELOPR,eq   Test ltrelopr
         when  C'D'               DAYS  FUNCTION ???

           BRAS R9,BETWDAYS

         when  C'M'               MONTHS BETWEEN ???

           BRAS R9,BETWMONS

         othrwise ,

           BRAS R9,BETWYRS

         endsel

         J     BETW_020           BRANCH TO "BETWEEN" COMMON LOGIC

         DROP  R2
         DROP  R5
         DROP  R13
                        EJECT
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*                                                                     *
*        DAYS/MONTHS/YEARS BETWEEN  (EVENT VS NORMALIZED CONSTANT)    *
*                                    EVENT is one of E/L/P/X          *
*                                                                     *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*
         using (thrdarea,thrdend),r13 Tell assembler to map the area
         USING LOGICTBL,R5
         using litp_hdr+524288,r2
*
static   loctr ,
fnxcsub_indirect jlu fnxcsub
fncxsub_indirect jlu fnxcsub
code     loctr ,
FNxCSUB  ds    0h                 R14 loaded by model code
         LA    R1,WORKAREA+0      LOAD  TARGET DATE    ADDRESS
*
         BRAS  R9,DATECONV        CONVERT DATE TO JULIAN/GREG (NUMERIC)
*
         CLC   LTRELOPR,DM        DAYS IN MONTH ???
         JE    BETW_050
*
***********************************************************************
*  CONVERT NORMALIZED CONSTANT DATE                                   *
***********************************************************************
         lgh   R14,LTMSKLEN
         ah    R14,LTV1LEN
         LA    R14,LTCOLMSK(r14)  LOAD CONSTANT   DATE ADDRESS
         stg   R14,SAVALADR
*
         LA    R1,WORKAREA+8      LOAD TARGET     DATE ADDRESS
         ST    R1,DL96TGTA        SAVE TARGET  ADDRESS
*
         LHI   R0,8               LOAD NORMALIZED DATE LENGTH
         STH   R0,SAVALLEN
*
         MVI   SAVALFMT+1,FC_NUM       FIELD    FORMAT   CODE
         MVI   SAVALCON+1,CYMD         FIELD    CONTENT  CODE
         MVHHI SAVALDEC,0         SET  NO.   OF DECIMALS
         MVHHI SAVALRND,0         SET  ROUNDING FACTOR
         MVI   SAVALSGN,C'N'      SET  SIGN     INDICATOR
*
         XC    SAMSKADR,SAMSKADR  ZERO TARGET   MASK  ADDRESS
         XC    SAMSKLEN,SAMSKLEN  ZERO TARGET   MASK  LENGTH
*
         MVI   SAOUTFMT+1,FC_NUM  SET  NUMERIC  FORMAT   CODE
         MVHHI SAOUTDEC,0         ZERO NO. OF   DECIMALS
         MVHHI SAOUTRND,0         ZERO ROUNDING FACTOR
         MVI   SAOUTSGN,C'N'      SET  EDITED   SIGN     IND
*
         J     BETWCOMN           BRANCH TO "BETWEEN" COMMON LOGIC
*
         DROP  R2
         DROP  R5
         DROP  R13
                        EJECT
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*                                                                     *
*        DAYS/MONTHS/YEARS BETWEEN  (EVENT VS EVENT)                  *
*                                                                     *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*
         using (thrdarea,thrdend),r13 Tell assembler to map the area
         USING LOGICTBL,R5
         using litp_hdr+524288,r2
*
***********************************************************************
*  CONVERT EVENT RECORD DATE-1 TO JULIAN/GREGORIAN                    *
***********************************************************************
static   loctr ,
fnxxsub_indirect jlu fnxxsub
code     loctr ,
FNxxSUB  ds    0h                 R14 already loaded
         stg   r15,registers      and save r15
         LA    R1,WORKAREA+0      LOAD  TARGET DATE   ADDRESS
*
         BRAS  R9,DATECONV        CONVERT DATE TO JULIAN/GREG (NUMERIC)
*
***********************************************************************
*  CONVERT EVENT RECORD DATE-2 TO JULIAN/GREGORIAN                    *
***********************************************************************
         lg    R14,registers      R15 saved earlier
         LA    R1,WORKAREA+8      LOAD  TARGET DATE   ADDRESS
         ST    R1,DL96TGTA        SAVE  TARGET ADDRESS
*
         J     BETWVAL2
*
         DROP  R2
         DROP  R5
         DROP  R13
                        EJECT
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*                                                                     *
*        DAYS/MONTHS/YEARS BETWEEN  (EVENT VS LOOK-UP)                *
*                                                                     *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*

         using (thrdarea,thrdend),r13 Tell assembler to map the area
         USING LOGICTBL,R5
         USING LKUPBUFR,R3
         using litp_hdr+524288,r2

BETWVAL2 ds    0h                 R14 already loaded
         stg   R14,SAVALADR
*
         LH    R0,LTCOLLEN        LOAD   FIELD LENGTH   (-1)
         AHI   R0,1               RESTORE TRUE FIELD    LENGTH
         STH   R0,SAVALLEN
*
         MVC   SAVALFMT,LTCOLFMT  COPY  FIELD    FORMAT    CODE
         MVC   SAVALCON,LTCOLCON  COPY  FIELD    CONTENT   CODE
         MVC   SAVALDEC+1(1),LTCOLDEC  COPY NO.   OF DECIMALS
         MVC   SAVALRND+1(1),LTCOLRND  COPY ROUNDING FACTOR
         MVC   SAVALSGN,LTCOLSGN  COPY  SIGN     INDICATOR
*
         XC    SAMSKADR,SAMSKADR  ZERO  FIELD    MASK   ADDRESS
         XC    SAMSKLEN,SAMSKLEN  ZERO  FIELD    MASK   LENGTH
*
         MVI   SAOUTFMT+1,FC_NUM  SET  NUMERIC  FORMAT    CODE
         MVHHI SAOUTDEC,0         ZERO  NO. OF   DECIMALS
         MVHHI SAOUTRND,0         ZERO  ROUNDING FACTOR
         MVI   SAOUTSGN,C'Y'      SET   EDITED   SIGN  IND
*
BETWCOMN CLI   LTRELOPR,C'D'      DAYS  FUNCTION ???
         JNE   BETW_010           NO  - CONVERT  TO GREGORIAN
*
***********************************************************************
*  CONVERT TO JULIAN                                                  *
***********************************************************************
         MVI   SAOUTCON+1,CYDDD   SET JULIAN DATE CODE CCYYDDD
         LHI   R0,7               OUTPUT LENGTH = 7
         STH   R0,DL96LEN
*
         BRAS  R9,DATEDL96        CALL "GVBDL96"
         BRAS  R9,BETWDAYS
         J     BETW_020
*
***********************************************************************
*  CONVERT TO GREGORIAN                                               *
***********************************************************************
BETW_010 MVI   SAOUTCON+1,CYMD    SET GREGORIAN DATE CODE CCYYMMDD
         LHI   R0,8               OUTPUT LENGTH  = 8
         STH   R0,DL96LEN
*
         BRAS  R9,DATEDL96        CALL "GVBDL96"
*
         CLI   LTRELOPR,C'M'      MONTHS BETWEEN ???
         JNE   *+12
         BRAS  R9,BETWMONS
         J     BETW_020
*
         BRAS  R9,BETWYRS
*
***********************************************************************
*  NEGATE DAYS/MONTHS/YEARS BETWEEN DEPENDING ON ORIGINAL EXPRESSION  *
***********************************************************************
*
BETW_020 CLI   LTRELOPR+1,C'N'
         JNE   *+6
         LCR   R15,R15
*
         cxftr fp0,0,r15,0        convert 32 bit to extended DFP
         qaxtr fp4,fp0,fp9,0      Qantise to no of dps required
         std   fp4,0(0,r4)
         std   fp6,8(0,r4)
*
         BR    R10
*
***********************************************************************
*  DAYS IN MONTH                                                      *
***********************************************************************
BETW_050 PACK  DBLWORK,WORKAREA+0+4(2)
         CVB   R14,DBLWORK        CONVERT MONTH TO BINARY
*
         SR    R15,R15            LOAD  DAYS IN MONTH
         ICY   R15,DIMTBL(R14)
*
         CHI   R14,2              FEBRUARY ???
         JNE   BETW_052           NO  - BYPASS  LEAP YEAR CHECK
*
         PACK  DBLWORK,WORKAREA+0+0(4)
         CVB   R0,DBLWORK         CONVERT CCYY  TO BINARY
*
         lr    r14,r0             save the conversion
* the algorithm is
* if year mod 400 = 0 then it is a leap year
*    else if  year mod 100 ^= 0
*         and year mod 4    = 0 then it is a leap year
*                          else it is NOT a leap year
         SRDL  R0,32
         D     R0,F400            divide by 400
         if cij,R0,eq,0           No REMAINDER ???
           ahi   r15,1              then it is a leap year
         else
           lr   r0,r14            reload r0
           SRDL R0,32
           D   R0,F100            divide by 100
           if  cij,R0,ne,0        REMAINDER ??? (if the division by 100+
                      has a zero remainder, then it is not a leap year)
             lr r0,r14            reload r0
             SRDL R0,32
             D R0,F4              divide by 4
             if cij,R0,eq,0       No REMAINDER ???
               ahi r15,1            then it is a leap year
             endif
           endif
         endif

*
BETW_052 ds    0h
         cxftr fp0,0,r15,0        convert 32 bit to extended DFP
         qaxtr fp4,fp0,fp9,0      Qantise to no of dps required
         std   fp4,0(0,r4)
         std   fp6,8(0,r4)
*
         BR    R10
*
         DROP  R2
         DROP  R5
         DROP  R13
                        EJECT
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*                                                                     *
*  COMMON LOGIC TO CONVERT DATES TO JULIAN FORMAT                     *
*                                                                     *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         using (thrdarea,thrdend),r13 Tell assembler to map the area
         using genparm,parm_area
         USING LOGICTBL,R5
*
DATECONV ST    R1,DL96TGTA        SAVE TARGET  ADDRESS
*
         stg   R14,SAVALADR
*
         LH    R0,LTFLDLEN        LOAD   FIELD LENGTH   (-1)
         AHI   R0,1               RESTORE TRUE FIELD    LENGTH
         STH   R0,SAVALLEN
*
         MVC   SAVALFMT,LTFLDFMT  COPY  FIELD    FORMAT    CODE
         MVC   SAVALCON,LTFLDCON  COPY  FIELD    CONTENT   CODE
         MVC   SAVALDEC+1(1),LTNDEC   COPY  NO.   OF DECIMALS
         MVC   SAVALRND+1(1),LTRNDFAC COPY  ROUNDING FACTOR
         MVC   SAVALSGN,LTSIGN    COPY  SIGN     INDICATOR
*
         XC    SAMSKADR,SAMSKADR  ZERO  FIELD    MASK   ADDRESS
         XC    SAMSKLEN,SAMSKLEN  ZERO  FIELD    MASK   LENGTH
*
         MVI   SAOUTFMT+1,FC_NUM   SET  NUMERIC  FORMAT    CODE
         MVHHI SAOUTDEC,0         ZERO  NO. OF   DECIMALS
         MVHHI SAOUTRND,0         ZERO  ROUNDING FACTOR
         MVI   SAOUTSGN,C'Y'      SET   EDITED   SIGN  IND
*
         CLI   LTRELOPR,C'D'      DAYS  BETWEEN  ???
         JNE   DATE_010
*
         MVI   SAOUTCON+1,CYDDD   JULIAN DATE CODE CCYYDDD
         LHI   R0,7               OUTPUT LENGTH = 7
         STH   R0,DL96LEN
         J     DATEDL96
*
DATE_010 MVI   SAOUTCON+1,CYMD    GREGORIAN DATE CODE CCYYMMDD
         LHI   R0,8               OUTPUT LENGTH = 8
         STH   R0,DL96LEN
*
***********************************************************************
*  CALL "GVBDL96"                                                     *
***********************************************************************
DATEDL96 llgf  R15,GVBDL96a       LOAD "GVBDL96"  ADDRESS
         oill  r15,x'0001'        set amode 64 in link address
         LA    R1,DL96LIST        POINT R1   AT PARAMETER LIST
         bassm R14,R15            CALL "GVBDL96" - FORMAT DATA
*
         ltr   r15,r15
         bzr   r9
*
         CLI   SAFMTERR,x'02'     FIELD  OVERFLOW (TRUNCATION) ???
         BRE   CALL96O
         LA    R0,B               Indicate bad data
         BRU   CALL96B
*
*        BR    R9
*
         DROP  R5
         DROP  R13
                        EJECT
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*                                                                     *
*  COMMON LOGIC TO COMPUTE DAYS BETWEEN TWO JULIAN DATES              *
*                                                                     *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         using (thrdarea,thrdend),r13 Tell assembler to map the area
         using genparm,parm_area
*
BETWDAYS LA    R0,WORKAREA+0      BUILD PARAMETER LIST
         sty   R0,GENPARM1
         LA    R0,WORKAREA+8
         sty   R0,GENPARM2
         LA    R0,DBLWORK
         sty   R0,GENPARM3
*
         lay   R1,GENPARM1        CALL  "GVBDAYS"
         llgf  R15,GVBDAYS
         bassm R14,R15
         L     R15,DBLWORK
*
         BR    R9
*
         DROP  R13
                        EJECT
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*                                                                     *
*  COMMON LOGIC TO COMPUTE MONTHS BETWEEN TWO GREGORIAN DATES         *
*                                                                     *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         using (thrdarea,thrdend),r13 Tell assembler to map the area
*
BETWMONS ds    0h
         if CLC,WORKAREA+0+0(8),lt,WORKAREA+8+0 DATE1 < DATE2 ???
*
           PACK DBLWORK,WORKAREA+0(4)       CCYY(DATE1)
           PACK DBLWORK3,WORKAREA+8(4)      CCYY(DATE2)
           SP  DBLWORK3,DBLWORK
           CVB R15,DBLWORK3
*
           if CLC,WORKAREA+0+4(4),gt,WORKAREA+8+4 is date1 later in    +
                                     year than date2 ?
             ahi R15,-1
           endif
*
           LHI R14,12
           MR  R14,R14
*
           PACK DBLWORK,WORKAREA+0+4(2)     MM(DATE1)
           PACK DBLWORK3,WORKAREA+8+4(2)    MM(DATE2)
*
           if SP,DBLWORK3,DBLWORK,m    MM2-MM1 and if negative
             ap dblwork3,=p'12'        add 12 to make it positive
           endif
           CVB R0,DBLWORK3
*
           AR  R15,R0
*
         else  ,
           PACK DBLWORK,WORKAREA+8(4)       CCYY(DATE2)
           PACK DBLWORK3,WORKAREA+0(4)      CCYY(DATE1)
           SP  DBLWORK3,DBLWORK
           CVB R15,DBLWORK3
*
           if CLC,WORKAREA+8+4(4),gt,WORKAREA+0+4 is date2 later in    +
                                     year than date1 ?
             ahi R15,-1
           endif
*
           LHI R14,12
           MR  R14,R14
*
           PACK DBLWORK,WORKAREA+8+4(2)       MM(DATE2)
           PACK DBLWORK3,WORKAREA+0+4(2)      MM(DATE1)
*
           if SP,DBLWORK3,DBLWORK,m    MM1-MM2 and if negative
             ap dblwork3,=p'12'        add 12 to make it positive
           endif
           CVB R0,DBLWORK3
*
           AR  R15,R0
           LCR R15,R15
*
         endif
         BR    R9
*
         DROP  R13
                        EJECT
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*                                                                     *
*  COMMON LOGIC TO COMPUTE YEARS BETWEEN TWO GREGORIAN DATES          *
*                                                                     *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         using (thrdarea,thrdend),r13 Tell assembler to map the area
*
BETWYRS  CLC   WORKAREA+0+0(8),WORKAREA+8+0 DATE1 < DATE2 ???
         JH    BETWYR_5
*
         PACK  DBLWORK,WORKAREA+0(4)        CCYY(DATE1)
         PACK  DBLWORK3,WORKAREA+8(4)       CCYY(DATE2)
         SP    DBLWORK3,DBLWORK
         CVB   R15,DBLWORK3
*
         BR    R9
*
BETWYR_5 PACK  DBLWORK,WORKAREA+8(4)        CCYY(DATE2)
         PACK  DBLWORK3,WORKAREA+0(4)       CCYY(DATE1)
         SP    DBLWORK3,DBLWORK
         CVB   R15,DBLWORK3
*
         LCR   R15,R15
*
         BR    R9
*
         pop   using
                        EJECT
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*                                                                     *
*        C L O S E   T H E   F I L E S  (EVENT, LOOK-UP, EXTRACT)     *
*                                                                     *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*
CLOSFILE ds    0h                 LOAD  TEMPORARY BASE REGISTER
*
sub_sav  using savf4sa,savesubr
         stg   R14,sub_sav.SAVF4SAG64RS14 SAVE  RETURN    ADDRESS
*
         llgt  R6,GPEXTRA
         USING EXTREC,R6

         MVC   WKREENT(8),OPENPARM     INITIALIZE OPEN/CLOSE PARM AREA
*
         llgt  R3,THRDFRST        POINT TO  FIRST THREAD
         DROP  R13
         using (thrdarea,thrdend),r3  Tell assembler to map the area
         using genfile,file_area
mainthrd using (thrdarea,thrdend),r13
         USING MSGLIST,mainthrd.MSG_AREA
*
CLOSEVNT ltgr  R3,R3              LAST  THREAD ???
         JNP   CLOSLEND           YES - end
*
         ap    mainthrd.switches,switches accumulate srb switch count

         llgt  R2,EVNTDCBA        LOAD  EVENT FILE DCB ADDRESS
         using ihadcb,r2
         if tm,dcboflgs,dcbofopn,o            Is it open?
           if ltgf,r1,evntpgfs,nz    anything page fixed?
             llgt r15,evntpgfe        get end address
             PGSER R,FREE,A=(1),EA=(15) unfix pages
             xc evntpgfs,evntpgfs signal no more page fix
             xc evntpgfe,evntpgfe signal no more page fix
           endif
           MVC WKREENT(8),OPENPARM
           sysstate amode64=NO
           sam31
           CLOSE ((R2)),MODE=31,MF=(E,WKREENT)
           sam64
           sysstate amode64=YES
         endif
         drop  r2
*
         ltgf  R8,THRDRE          LOAD "RE" ROW ADDRESS
         USING LOGICTBL,R8
         JNP   CLOSENXT
*
         LH    R0,LTHDROPT
         CHI   R0,VERHDR          VERIFY HEADER CONTROL TOTAL ??
         JNE   CLOSENXT           NO  -  BYPASS CHECK
*
         lghi  R14,HDR_REC_COUNT_MISMATCH ASSUME COUNTS DON'T MATCH
         MVC   mainthrd.ERRDATA(8),GPDDNAME INDICATE  FILE
         XC    MSGS2PTR,MSGS2PTR  No additional parms
         clc   GPRECCNT,LTCTLCNT   COMPARE COUNTS ???
         Jlne  ERRMSG#            ISSUE ERROR MESSAGE
*
CLOSENXT llgt  R3,THRDNEXT        LOOP THROUGH ALL THREADS
         J     CLOSEVNT
*
         DROP  R3
         DROP  R8
         drop  mainthrd
                        SPACE 3
         using (thrdarea,thrdend),r13 Tell assembler to map the area
         USING MSGLIST,MSG_AREA
         using genenv,env_area
         using saver,savesubr
*
CLOSLEND ds    0h                 ANY MORE LOOK-UP BUFFERS   ???
*
                        EJECT
***********************************************************************
*  "BUBBLE SORT" EXTRACT FILE TABLE ENTRIES INTO "DDNAME" SEQUENCE    *
*               (EXCLUDING STANDARD EXTRACT FILES AT BEGINNING)       *
***********************************************************************
         ltgf  R5,EXTFILEA        LOAD   FIRST EXTRACT FILE TABLE ENTRY
         JNP   CLOSBILL
*
         lgf   R0,filecnt_real    COMPUTE LAST ENTRY   ADDRESS
         BCTR  R0,0
         lghi  R1,EXTFILEL
         MR    R0,R0
         LA    R15,0(R5,R1)
*
         lgh   R0,MAXSTDF#        SKIP  OVER STANDARD  EXTRACT FILES
         lghi  R1,EXTFILEL
         MR    R0,R0
         LA    R14,0(R5,R1)       FIRST NON-STANDARD   ENTRY

         do while=(cgrj,r5,lt,r15) More entries to process?
*
           if cgrj,r5,ge,r14      standard extract ??
*
             LA R1,EXTFILEL(,R5)  COMPARE CURRENT AND  NEXT ENTRY
*
             do until=(cgrj,r1,gt,r15)
               doexit ltgf,R3,EXTPRINT-EXTFILE(,R5),np

               if ltgf,R9,EXTPRINT-EXTFILE(,R1),p,and,                 +
               CLC,EXTDDNAM-EXTFILE(L'EXTDDNAM,R3),gt,extDDNAM-EXTFILE(+
               R9)
                 ST R9,EXTPRINT-EXTFILE(,R5) SWAP PRINT SEQUENCE
                 ST R3,EXTPRINT-EXTFILE(,R1)
               endif
               aghi R1,EXTFILEL
             enddo
           endif
           aghi R5,EXTFILEL       ADVANCE CURRENT ENTRY
         enddo
                        SPACE 3
***********************************************************************
*  CLOSE EXTRACT FILE                                                 *
***********************************************************************
*
         lghi  R7,1               LOAD  INITIAL EXTRACT FILE SUBSCRIPT
*
         ltgf  R5,EXTFILEA        START PRINTING WITH LOWEST "DDNAME"
         JNP   CLOSBILL
*
CLOSEXTL ltgf  R3,EXTPRINT-EXTFILE(,R5) START WITH FIRST EXTRACT SLOT
         USING EXTFILE,R3
         JNP   CLOSXNXT
*
         SR    R0,R0              ASSUME   NO VDP  FILE TYPE
         ltgf  R1,EXTVDPA         VDP  RECORD AVAILABLE ???
         JNP   *+16               NO - BYPASS PIPE TEST
         L     R0,VDP0200b_ALLOC_FILE_TYPE-VDP0200b_FILE_RECORD(,R1)
         CHI   R0,PIPEDEV
         JE    CLOSX200
*
         ltgf  R2,EXTDCBA         LOAD  EXTRACT  FILE DCB ADDRESS
         USING IHADCB,R2
         JNP   CLOSX010
*
         TM    48(R2),X'10'       EXTRACT  FILE  OPEN   ???
         JO    CLOSX100           YES - FLUSH BUFFERS
*
         tm    extflag,extfmtph   Going to format phase?
         jo    closx015           Y:
         j     closxnxt           N:
CLOSX010 ds    0h
         tm    extflag,extfmtph   Going to format phase?
         jno   closxnxt           N:
*
         LA    R0,EXTRDCBL        LOAD DCB  LENGTH
         GETMAIN R,LV=(0),LOC=BELOW    GET  MEMORY  FOR DCB
         ST    R1,EXTDCBA         SAVE DCB ADDRESS IN  CONTROL ELEMENT
         lgr   R2,R1
         USING IHADCB,R2
*
         Larl  R14,EXTRfile            COPY  DCB
         MVC   0(EXTRDCBL,R2),0(R14)
         LA    R14,EXTRDCBE-EXTRFILE(,R2)
         ST    R14,DCBDCBE
*
         MVC   DCBDDNAM,EXTDDNAM
*
CLOSX015 ds    0h
         sysstate amode64=NO
         sam31
         OPEN  ((R2),OUTPUT),MODE=31,MF=(E,WKREENT)   EMPTY OUTPUT FILE
         CLOSE ((R2),FREE),MODE=31,MF=(E,WKREENT)
*           the FREE above refers to volume release

         STORAGE OBTAIN,          get some storage for DCB             +
               LENGTH=sortfilel,                                       +
               LOC=BELOW,         must be below for the DCB            +
               COND=NO            Unconditional
*        STORAGE returns a valid 64-bit address
         lgr   r2,r1                     copy for later
*
         larl  R14,sortfile              COPY MODEL   DCB
         using ihadcb,r2
         MVC   ihadcb(sortfilel),0(R14)
         LA    R0,sortdcbe-sortfile(,R2) SET DCBE   ADDRESS IN  DCB
         sty   R0,DCBDCBE

         MVC   DCBDDNAM(4),SORTVERB     SORT CONTROL DDNAME
         MVC   DCBDDNAM+4(4),EXTDDNAM+4

         OPEN  ((R2),(OUTPUT)),MODE=31,MF=(E,WKREENT)
         if tm,dcboflgs,dcbofopn,o            Is it open?
*
           LR  R1,R2              WRITE SORT CONTROL RECORD (DUMMY)
           LA  R0,SORTCTRL
           put (1),(0)
*
           CLOSE ((R2),FREE),MODE=31,MF=(E,WKREENT)
*
         endif
         STORAGE RELEASE,         Release the DCB storage              +
               LENGTH=sortfilel,                                       +
               ADDR=(r2),                                              +
               COND=NO            Unconditional
         sysstate amode64=YES
         sam64
         J     CLOSXNXT
                        SPACE 3
CLOSX100 ds    0h
         if ltgf,r0,thread_fail,nz    failing thread?
*
           sam31
           sysstate amode64=NO
           CLOSE ((R2)),MODE=31,MF=(E,WKREENT) YES - DON'T TRY ANY I/O
           sysstate amode64=YES
           sam64
         else
*
           LA  R1,WAITECB
           XR  R14,R14            ZERO REGISTER (NOT IN-USE VALUE)
           ST  R14,0(,R1)         INITIALIZE   ECB
           LNR R0,R1              NEGATIVE VERSION OF ECB ADDRESS
*
CLOSX110   CS  R14,R0,EXTINUSE    TEST IN-USE FLAG ???
           JE  CLOSX115           BRANCH  IF  ZERO (NOT IN-USE)
           ST  R14,4(,R1)         SAVE PREVIOUS VALUE IN LINKED LIST
           CS  R14,R1,EXTINUSE    MOVE THIS THREAD'S VALUE TO FLAG
           LHI R14,0              RESET REGISTER BACK TO ZERO
           JNE CLOSX110           TRY AGAIN IF FLAG CHANGED IN MEANTIME
*
           if  cli,thread_mode,eq,c'S'      and in srb mode
***********************************************************************
*    PAUSE "SRB"                                                      *
***********************************************************************
             push using
             drop r13
             using (thrdarea,thrdend),r13 Tell assembler to map area
sa_map       using savf4sa,savesrb
             lmg r0,r1,srbpet1a    get current pointers
             stmg r0,r1,xfrsrbp3   save into parmlist
             lay R1,xfrsrbpl       CALL "IEAVPSE" - PAUSE
             stg r13,sa_map.SAVF4SAprev
             stg r2,savesrb   save r2 as ipk uses it
             la r13,savesrb
             xr r0,r0             clear r0
             ipk ,                save current key in r2
             spka 0(r0)            and flip to key 0
             pop using
           else
             push using
             drop r13
             using (thrdarea,thrdend),r13 Tell assembler to map area
sa_map       using savf4sa,savetcb
             lmg r0,r1,tcbpet1a    get current pointers
             stmg r0,r1,xfrtcbp3   save into parmlist
             if (cli,localauth,eq,c'A')
               MODESET KEY=ZERO,MODE=SUP key zero needed now for the   +
                                          pause element calls
             endif
             lay R1,xfrtcbpl       CALL "IEAVPSE" - PAUSE
             stg r13,sa_map.SAVF4SAprev
             la r13,savetcb
             pop using
           endif
           llgt R15,IEA4PSE
           BASR R14,R15
           if cij,r15,ne,0    if this fails, then end thread
             MVC DBLWORK,=CL8'IEA4PSE'
             ST R15,DBLWORK2  Save return code
             j  PE_error      Write msg to log, and end thread
*            DC H'0'
           endif
sa_map     using savf4sa,thrdarea
           lg  R13,sa_map.SAVF4SAprev
           drop sa_map
           if  cli,thread_mode,eq,c'S'      and in srb mode
             spka 0(r2)           restore the saved key
             lgf  r1,ovflmask       set bits 36 and 37           pgc120
             spm r1                 set overflow masks on pgc120
             lg r2,savesrb         restore r2
             lmg r0,r1,srbpet1a    get current pointers
             stg r1,srbpet1a         and flip to correct positions
             stg r0,srbpet2a
           else
             if (cli,localauth,eq,c'A')
               MODESET KEY=NZERO,MODE=PROB
             endif
             lmg r0,r1,tcbpet1a    get current pointers
             stg r1,tcbpet1a          and flip to correct positions
             stg r0,tcbpet2a
           endif
                          SPACE 3
*
CLOSX115   ds   0h
           tm  extflag,extfmtph   Is this going to format phase
           jno closx130           N: then bypass control record write
           STH R7,CTFILENO
           BRAS R9,WRTCTRL        YES - WRITE  STANDARD CONTROL  RECORD
*
CLOSX130   llgt R1,EXTDECBC       LOAD  CURRENT  DECB PREFIX ADDRESS
           lgr R4,R1              SAVE  STARTING DECB PREFIX ADDRESS
           llgt R0,EXTRECAD       LOAD    TARGET ADDRESS FOR NEW RECORD
           llgt R14,16(,R1)       LOAD    BUFFER ADDR FROM   DECB
           sgr  R0,R14            COMPUTE  BLOCK LENGTH
           cghi R0,4
           JNH CLOSX150           BRANCH IF BLOCK EMPTY
*
           STH R0,10(,R1)         PLACE  LENGTH IN    DECB
           TM  DCBRECFM,X'40'     VARIABLE/UNDEFINED    ???
           JNO CLOSX135           NO  -  MUST  BE FIXED
           STH R0,0(,R14)         BUILD  BDW
           J   CLOSX140
CLOSX135   TM  EXTRECFM,X'10'     BLOCKED RECORDS ???
           JNO CLOSX140           NO  - DON'T  CHANGE  SIZE
           STH R0,DCBBLKSI        PLACE LENGTH IN DCB
CLOSX140   aghi R1,4               POINT TO DECB(FOLLOWS PREFIX)
           XC  0(4,R1),0(R1)      CLEAR  ECB
           lr  r9,r3              copy the extfile address
           llgf R15,EXTPUT_6431   LOAD  WRITE   SUBROUTINE ADDRESS
           bassm R14,R15          WRITE PHYSICAL BLOCK (31-BIT MODE)
           llgt R1,EXTDECBC        RESTORE  DECB  PREFIX ADDRESS
*
CLOSX150   llgt R1,0(,R1)          LOAD NEXT DECB PREFIX ADDRESS
           ST  R1,EXTDECBC        SAVE  ADDRESS OF NEXT DECB PREFIX
*
           aghi R1,4               POINT TO ECB
           lr  r9,r3              copy the extfile address
           llgf R15,extchk_6431   LOAD  CHECK   SUBROUTINE ADDRESS
           bassm R14,R15          WRITE PHYSICAL  BLOCK
           llgt R1,EXTDECBC        RESTORE DECB PREFIX  ADDRESS
*
CLOSX155   cgr R1,R4              LOOPED AROUND WHOLE RING ???
           JNE CLOSX150           NO - CONTINUE AROUND
*
           llgt r14,execdadr
           using execdata,r14
           if CLI,execpagf,eq,c'Y'    was page fixing on?
             modeset mode=SUP
             lgh   r14,extblksi       load physical blocksize
             aghi  r14,7              round to next doubleword
             srlg  r14,r14,3
             sllg  r14,r14,3
             lgh   r15,extbufno       compute  buffer pool size
             mr    r14,r14
             lgr   r4,r15
             llgt  r1,extdecbf        get 1st DECB
             llgt  r1,16(,r1)         get address of 1st buffer
             agr   r4,r1              end address
             aghi  r4,-1              last byte
             PGSER R,FREE,A=(1),EA=(4)
             modeset mode=PROB
           endif
           drop r14
           sam31
           sysstate amode64=NO
           CLOSE ((R2)),MODE=31,MF=(E,WKREENT) CLOSE EXTRACT  FILE
           sysstate amode64=YES
           sam64
           DROP R2
                          SPACE 3
           llgf R1,EXTINUSE       LOAD IN-USE FLAG   VALUE
CLOSX160   cijnh r1,0,closx165 no more THREAD BESIDE THIS ONE WAITING
*
           llgf R0,4(,R1)         LOAD POINTER TO NEXT THREAD'S  ECB
           CS  R1,R0,EXTINUSE     MOVE NEXT THREAD'S ECB ADDR TO FLAG
           JNE CLOSX160           RETRY UNLOCK IF CHANGED IN MEANTIME
*
           la  r14,thread_mode-waitecb(,r1) point at flag
*          locate the appropiate pause element token
*          and then set up to release that PE
           if  cli,0(r14),eq,c'S'    this test is to make sure that    +
                                     the waiting element is an SRB
             lg r0,srbpet1a-waitecb(,r1) shift r1 to correct address
           else
             lg r0,tcbpet1a-waitecb(,r1) get the tcb pe pointer
           endif
           xr r1,r1               clear the release code address
           if cli,thread_mode,eq,c'S'  then an SRB active
             push using
             drop r13
             using (thrdarea,thrdend),r13 Tell assembler to map area
sa_map       using savf4sa,savesrb
             stmg r0,r1,xfrsrbp3  save in parm
             lay r1,xfrsrbpl  release srb which will clean up
             stg r13,sa_map.SAVF4SAprev
             stg r2,savesrb   save r2 as ipk uses it
             la r13,savesrb
             xr r0,r0             clear r0
             ipk ,                save current key in r2
             spka 0(r0)            and flip to key 0
             pop using
           else
             push using
             drop r13
             using (thrdarea,thrdend),r13 Tell assembler to map area
sa_map       using savf4sa,savetcb
             stmg r0,r1,xfrtcbp3  save in parm
             if (cli,localauth,eq,c'A')
               MODESET KEY=ZERO,MODE=SUP key zero needed now for the
*                                         pause element calls
             endif
             lay r1,xfrtcbpl
             stg r13,sa_map.SAVF4SAprev
             la r13,savetcb
             pop using
           endif
           llgt r15,iea4rls      and finish
           basr r14,r15
sa_map     using savf4sa,thrdarea
           lg  R13,sa_map.SAVF4SAprev
           drop sa_map
           if cij,r15,ne,0    if this fails, then end thread
             MVC DBLWORK,=CL8'IEA4RLS'
             ST R15,DBLWORK2  Save return code
             j  PE_error      Write msg to log, and end thread
*            DC H'0'
           endif
           if cli,thread_mode,eq,c'S'  then an SRB active
             spka 0(r2)           restore the saved key
             lg r2,savesrb         restore r2
             lgf  r1,ovflmask       set bits 36 and 37           pgc120
             spm r1                 set overflow masks on pgc120
           else
             if (cli,localauth,eq,c'A')
               MODESET KEY=NZERO,MODE=PROB
             endif
           endif
           J   CLOSX170           INCREMENT  VIEW'S  EXTRACT COUNT
*
CLOSX165   XR  R0,R0              RESET FLAG BACK TO NO  ONE WAITING
           CS  R1,R0,EXTINUSE
           JNE CLOSX160           RETRY UNLOCK IF CHANGED IN MEANTIME
                          SPACE 3
CLOSX170   ds   0h
           tm  extflag,extfmtph   Is this going to format phase
           jno closx200           N: then bypass sort field write
*
CLOSX180   LH  R15,EXTMINLN       LOAD MINIMUM RECORD   LENGTH
           LA  R1,EXVIEW#-EXTREC      SUBTRACT PREFIX   LENGTH
           SR  R15,R1
           CVD R15,DBLWORK        CONVERT SORT FIELD LENGTH TO DECIMAL
           UNPK SORTKEYL,DBLWORK
           OI  SORTKEYL+L'SORTKEYL-1,X'F0'

           STORAGE OBTAIN,        get some storage for DCB             +
               LENGTH=sortfilel,                                       +
               LOC=BELOW,         must be below for the DCB            +
               COND=NO            Unconditional
*          STORAGE returns a valid 64-bit address
           lgr r2,r1                     copy for later
*
           larl R14,sortfile             COPY MODEL   DCB
           using ihadcb,r2
           MVC ihadcb(sortfilel),0(R14)
           LA  R0,sortdcbe-sortfile(,R2) SET DCBE   ADDRESS IN  DCB
           sty R0,DCBDCBE

           MVC DCBDDNAM(4),SORTVERB     SORT CONTROL DDNAME
           MVC DCBDDNAM+4(4),EXTDDNAM+4
           MVC ERRDATA(8),DCBDDNAM
           XC  MSGS2PTR,MSGS2PTR  No additional parms

           sysstate amode64=NO
           sam31
*
           OPEN ((R2),(OUTPUT)),MODE=31,MF=(E,WKREENT)
           if tm,dcboflgs,dcbofopn,z      open failed?
             sam64                      , issue warning msg
             sysstate amode64=YES
             GVBMSG LOG,MSGNO=OPEN_SORT_FAIL,SUBNO=2,GENENV=GENENV,    +
               SUB1=(PGMNAME,L'PGMNAME),                               +
               SUB2=(ERRDATA,8),                                       +
               MF=(E,MSG_AREA)
* set warning return code
               LHI R15,4        warning return code
               if cl,r15,gt,overall_return_code   greatest RC so far?
                 st r15,overall_return_code       save for end
               endif
*
           else
            sysstate amode64=NO
*
            LR R1,R2               WRITE SORT CONTROL RECORD (DUMMY)
            LA R0,SORTCTRL
            put (1),(0)
*
            CLOSE ((R2),FREE),MODE=31,MF=(E,WKREENT)
*
           endif
*
           STORAGE RELEASE,       Release the DCB storage              +
               LENGTH=sortfilel,                                       +
               ADDR=(r2),                                              +
               COND=NO            Unconditional

           sam64
           sysstate amode64=YES

         endif
CLOSX200 ds    0h
*
         MVC   BLDDNAME,EXTDDNAM
         MVC   BLRECTYP,C03
         STH   R7,BLSRTFN
*
*pgczap  ZAP   BLSRTBYT,EXTBYTEC
         lg    r0,extbytec
         cvdg  r0,dblwork2
         ZAP   BLSRTBYT,dblwork3
         XC    BLSRTFLR,BLSRTFLR

CLOSXNXT aghi  R5,EXTFILEL        ADVANCE   CONTROL AREA ADDRESS
         aghi  R7,1               INCREMENT EXTRACT FILE NUMBER
         cgf   R7,filecnt_real
         JNH   CLOSEXTL

CLOSBILL ds    0h
         llgt  R14,EXECDADR       LOAD PARAMETER DATA  ADDRESS
         USING EXECDATA,R14
         if    (CLI,EXECSNAP,EQ,C'Y') Snap on - so dcb opened
           sysstate amode64=NO
           sam31
           ly    r2,snapdcba
           CLOSE ((r2)),MODE=31     then we have to close it
           sam64
           sysstate amode64=YES
         endif
         DROP  R14
         llgt  R14,EXECDADR       LOAD PARAMETER DATA  ADDRESS
         USING EXECDATA,R14
         if    (CLI,EXECTRAC,EQ,C'Y') trace on - so dcb opened
           llgt R2,TRACDCBA
           sysstate amode64=NO
           sam31
           CLOSE ((2)),MODE=31  then we have to close it
           sam64
           sysstate amode64=YES
         endif
         DROP  R14

sub_sav  using savf4sa,savesubr
         lg    R14,sub_sav.SAVF4SAG64RS14 RESTORE RETURN ADDRESS
         br    r14              RETURN (SWITCH TO 31-BIT MODE)
*
         DROP  R3,R6
*
* Report line layouts
*
*---------------------------------------
* ~OFIL - Output summary by extract file
*---------------------------------------
oext_total dsect
oext_totcnt  ds pl7
oext_totbyte ds pl8
*
oextrept dsect
oextfx   ds    cl14
oextf0   ds    cl2
oextddn  ds    cl8
oextf1   ds    cl1
oextrcnt ds    cl18
oextf2   ds    cl2
oextPFnm ds    cl48
oextf4   ds    cl2
oextftyp ds    cl09
oextf3   ds    cl13
oextbcnt ds    cl21
oextrept_len equ *-oextrept
*
pextrept dsect
pextfx   ds    cl14
pextf0   ds    cl2
pextddn  ds    cl8
pextf1   ds    cl1
pextrcnt ds    cl18
pextf2   ds    cl2
pextPFnm ds    cl48
pextf4   ds    cl2
pextftyp ds    cl09
pextf3   ds    cl13
pextbcnt ds    cl21
pextrept_len equ *-pextrept
*
*MEM - Memory mapping
memsrept dsect
memsdesc ds    cl33              Memory area description
memsf1   ds    cl1
memsbbar ds    cl15              Below bar storage
memsf2   ds    cl1
memsabar ds    cl20              IREF Record count
memsrept_len equ *-memsrept
*
thrdrept dsect
thrdnbr  ds    cl6
thrdf1   ds    cl1
thrdsrc  ds    cl20
thrdf2   ds    cl1
thrderc  ds    cl20
thrdf3   ds    cl30
thrdmore ds    cl1
thrdf4   ds    cl2
thrdsbc  ds    cl20
thrdf5   ds    cl1
thrdebc  ds    cl20
thrdrept_len equ *-thrdrept
*
thrd_total dsect
thrd_totscnt  ds pl8
thrd_totsbyte ds pl8
thrd_totecnt  ds pl8
thrd_totebyte ds pl8
*
execrept dsect
execdesc ds    cl29              exec summary line description
execnum  ds    cl20              numeric value
execrept_len equ *-execrept

gvbmr95  csect
* *********************************************************************
*                                                                     *
*        Print the ~OFIL report                                       *
*                                                                     *
* *********************************************************************
*
ofil_report ds 0h
         stg   r14,Final_reports_save   Save the return address
*
*--------------------------------------
* OEXT - Output summary by extract file
*--------------------------------------
         lay   r6,pgmwork            pgmwork used to develop totals
         using oext_total,r6
         zap   oext_totcnt,p000      initialize totals
         zap   oext_totbyte,p000
*
         xc    extr_file_cnt,extr_file_cnt
         xc    extr_pipe_token_cnt,extr_pipe_token_cnt
         xc    extr_rec_disk_cnt,extr_rec_disk_cnt
         xc    extr_rec_pitk_cnt,extr_rec_pitk_cnt
         xc    extr_byt_disk_cnt,extr_byt_disk_cnt
         xc    extr_byt_pitk_cnt,extr_byt_pitk_cnt

         rptit msg=vb_blankl
         phead hd=oext
         rptit msg=rptoext_hd0  column heading 0
         rptit msg=rptoext_hd1  column heading 1
         rptit msg=rptoext_hd2  column underlining 1
*
         llgt  r5,extfilea       Get start of extract ctrl blks
         using extfile,r5
*
         ly    r1,ofil_first     first ofil entry
*
         lgr   R3,R1
         lgr   R4,R1
o2       USING pextrept,R1
         lgf   r2,filecnt_real   number of extract files
oextloop ds    0h
         xc    o2.pextrept(pextrept_len),o2.pextrept zero area
         mvc   o2.pextf0,spaces
         mvc   o2.pextf1,spaces
         mvc   o2.pextf2,spaces
         mvc   o2.pextf4,spaces
         mvc   o2.pextf3,spaces
         if ltgf,r14,extvdpa,p
           using VDP0200b_file_record,r14
           mvc o2.pextpfnm,VDP0200b_file    move PF name
           lgf r15,VDP0200b_ALLOC_FILE_TYPE get output type
           if (chi,r15,eq,PIPEDEV),or,(chi,r15,eq,TOKENDEV)
             lhi  r14,1                   indicate pipe or token
           else
             lhi  r14,0                   indicate disk
           endif
           bctgr r15,r0
           mghi r15,l'oextftyp            get the correct index
           lay r15,filetype(r15)
           mvc o2.pextftyp,0(r15)        Move in the file type
         else
           lay r15,filetype
           mvc o2.pextftyp,0(r15)        Move in the file type
           lay r15,=cl48'Extract File'
           mvc o2.pextPFnm,0(r15)
           mvc o2.pextPFnm+13(4),extddnam+4
           lhi r14,0                      indicate disk
         endif
         mvc   o2.pextfx,=cl14'------------->'
         mvc   o2.pextddn,extddnam  Move in DDname
*
*        Move in record count
         mvc   o2.pextrcnt,bytemsk+2
         mvi   o2.pextrcnt,c' '
         lg    r15,extcnt
         cvdg  r15,dblwork2
         ed    o2.pextrcnt,dblwork3+1
         ap    oext_totcnt,dblwork3   record count total
         if (chi,r14,eq,0)
           alsi  extr_file_cnt,1
           ag    r15,extr_rec_disk_cnt
           stg   r15,extr_rec_disk_cnt
         else
           alsi  extr_pipe_token_cnt,1
           ag    r15,extr_rec_pitk_cnt
           stg   r15,extr_rec_pitk_cnt
         endif
*
*        Move in byte count
         mvc   o2.pextbcnt,bytemsk
         mvi   o2.pextbcnt,c' '
         lg    r15,extbytec
         cvdg  r15,dblwork2
         ed    o2.pextbcnt,dblwork3
         ap    oext_totbyte,dblwork3  byte count total
         if (chi,r14,eq,0)
           ag    r15,extr_byt_disk_cnt
           stg   r15,extr_byt_disk_cnt
         else
           ag    r15,extr_byt_pitk_cnt
           stg   r15,extr_byt_pitk_cnt
         endif
*
         aghi  r5,extfilel       Next extract file entry
         lgr   r3,r1             set end of the table
         aghi  r1,pextrept_len   get next table entry
         jct   r2,oextloop
*
* Sort the OFIL table on ddname
*
         llgtr r14,r4             set to table first entry address
current  using pextrept,r14
         llgtr R15,R3             load OFIL table end entry address
*
outerlp  do inf
           doexit (cgr,r14,gt,r15)
           lay   r1,current.pextrept+pextrept_len
next       using pextrept,r1
*
innerlp    do inf
             doexit (cgr,r1,gt,r15)
             if (clc,current.pextddn,gt,next.pextddn)
               xc  next.pextrept(pextrept_len),current.pextrept
               xc  current.pextrept(pextrept_len),next.pextrept
               xc  next.pextrept(pextrept_len),current.pextrept
             endif
             aghi  r1,pextrept_len
           enddo
           aghi    r14,pextrept_len
         enddo
*
o3       using pextrept,prntline  print sorted table
         lgf  r2,filecnt_real
o4       using pextrept,r4    set OFIL table first entry address
oextlpa  ds    0h
         mvc   o3.pextrept(pextrept_len),o4.pextrept
         rptit ,
         aghi  r4,pextrept_len
         jct   r2,oextlpa
*
o1       using oextrept,prntline    Print Totals

         rptit msg=rptoext_hd3      column underlining 2
         mvc   prntline(oextrept_len),spaces
         lay   r15,=cl9'Total'
         mvc   o1.oextfx,=cl14'------------->'
         mvc   o1.oextddn,0(r15)        Move in total line
         mvc   o1.oextrcnt,bytemsk+2
         mvi   o1.oextrcnt,c' '
         ed    o1.oextrcnt,oext_totcnt
         mvc   o1.oextbcnt,bytemsk
         ed    o1.oextbcnt,oext_totbyte
         mvi   o1.oextpfnm+34,c'>'
         rptit ,
         rptit msg=rptoext_hd4   column underlining 3
         drop  o1,o2,o3,o4,r5,r6

         lg    r14,Final_reports_save   Get saved return address
         br    r14              Return


* *********************************************************************
*                                                                     *
*        Print the final report which consist of the following:       *
*                                                                     *
*        1) ~MEMS MR95 memory usage summary (in bytes)                *
*        2) ~CPUT zIIP CPU stats                                      *
*        3) ~EXEC Execution summary - totals                          *
*                                                                     *
* *********************************************************************
*
Final_reports ds 0h
         stg   r14,Final_reports_save   Save the return address
*
*--------------------------------------------
* MEMS - MR95 memory usage summary (in bytes)
*--------------------------------------------

         if clc,namepgm,eq,=cl8'GVBMR95E'    E for extract phase
           rptit msg=vb_blankl
m1         using memsrept,prntline
           phead hd=mems
           rptit msg=rptmems_hd1   column heading 1
           rptit msg=rptmems_hd2   column heading 2
           rptit msg=rptmems_hd3   column underlining 1
           mvc   m1.memsf1,spaces
           mvc   m1.memsf2,spaces
           mvc   m1.memsabar,spaces
           xgr   r3,r3             zero below bar total
           xgr   r4,r4             zero above bar total
*
*       Generated machine code line
           lay   r15,mems_desc01
           mvc   m1.memsdesc,0(r15)
           mvc   m1.memsbbar,countmsk
           llgt  r1,codeend        Get end of generated code
           sgf   r1,codebeg         subtract start address
           cvd   r1,dblwork        convert length to decimal
           ed    m1.memsbbar,dblwork+2
           agr   r3,r1             add to total
           rptit ,
*
*       Logic table line
           lay   r15,mems_desc02
           mvc   m1.memsdesc,0(r15)
           mvc   m1.memsbbar,countmsk
           llgt  r1,ltenrowa      Get end of logic table
           sgf   r1,ltbegin         subtract start address
           aghi  r1,8               logic table eyecatcher
           cvd   r1,dblwork        convert length to decimal
           ed    m1.memsbbar,dblwork+2
           agr   r3,r1             add to total
           rptit ,
*
*       VDP data line
           lay   r15,mems_desc03
           mvc   m1.memsdesc,0(r15)
           mvc   m1.memsbbar,countmsk
           llgt  r1,vdpsize       Get end of logic table
           cvd   r1,dblwork        convert length to decimal
           ed    m1.memsbbar,dblwork+2
           agr   r3,r1             add to total
           rptit ,
*
*       Literal pools line
           lay   r15,mems_desc04
           mvc   m1.memsdesc,0(r15)
           mvc   m1.memsbbar,countmsk
           lgf   r1,litpool_sz    Get literal pool size
           aghi  r1,8+nvcodeln
           cvd   r1,dblwork        convert length to decimal
           ed    m1.memsbbar,dblwork+2
           agr   r3,r1             add to total
           rptit ,
*
*       Ref work file I/O buffers line
*
*       All    file I/O buffers line
           lay   r15,mems_desc07
           mvc   m1.memsdesc,0(r15)
           mvc   m1.memsbbar,countmsk
           lgf   r1,read_buffer_hwm  Get size of read I/O buffers
           agf   r1,write_buffer_tot Add size of write I/O buffers
           cvd   r1,dblwork          convert length to decimal
           ed    m1.memsbbar,dblwork+2
           agr   r3,r1               add to total
           rptit ,
*
*       Reference tables line
           lay   r15,mems_desc09
           mvc   m1.memsdesc,0(r15)
           mvc   m1.memsbbar,spaces
           mvc   m1.memsabar,bytemsk
           lgf   r1,refpools_real  Size of reference table area in MBs
           sllg  r1,r1,20           make it bytes
           cvdg  r1,dblwork2       convert length to decimal
           ed    m1.memsabar,dblwork3
           agr   r4,r1             add to total
           rptit ,
*
*       Extract-Phase Aggregation buffers line
           lay   r15,mems_desc10
           mvc   m1.memsdesc,0(r15)
           mvc   m1.memsabar,bytemsk
           lgf   r1,extsum64      Get end of logic table
           sll   r1,20
           cvdg  r1,dblwork2       convert length to decimal
           ed    m1.memsabar,dblwork3
           agr   r4,r1             add to total
           rptit ,
*
*       Totals line
           rptit msg=rptmems_hd4   column underlining 2

           lay   r15,=cl8'Total'
           mvc   m1.memsdesc(8),0(r15)

           mvc   m1.memsbbar,countmsk
           mvc   m1.memsabar,bytemsk
           cvd   r3,dblwork        convert total above bar to decimal
           ed    m1.memsbbar,dblwork+2
           cvdg  r4,dblwork2       convert total above bar to decimal
           ed    m1.memsabar,dblwork3
           rptit ,
           rptit msg=rptmems_hd5   column underlining 3

           drop  m1
         endif
*
         using thrd_total,r6     Get # of source files
         lay   r6,pgmwork
t2       using thrdarea,r5
         lgf   r5,thrdfrst       Get 1st thread work area
         zap   thrd_totscnt,p000
         zap   thrd_totsbyte,p000
         zap   thrd_totecnt,p000
         zap   thrd_totebyte,p000
*
         do until=(ltgf,r5,t2.thrdnext,np)   get all the threads
           lg  r14,t2.thrd_evntrec_cnt
           cvd r14,dblwork
           ap  thrd_totscnt,dblwork
           lg  r14,t2.thrd_evntbyte_cnt
           cvd r14,dblwork
           ap  thrd_totsbyte,dblwork
           lg  r14,t2.thrd_extrrec_cnt
           cvd r14,dblwork
           ap  thrd_totecnt,dblwork
           lg  r14,t2.thrd_extrbyte_cnt
           cvd r14,dblwork
           ap  thrd_totebyte,dblwork
         enddo
         drop t2
*
*-------------------------------------------------------------------
* CPUT - zIIP CPU Statistics and GP CPU statistics if APF authorized
*-------------------------------------------------------------------

         if   (cli,localauth,eq,c'A')
           rptit msg=vb_blankl
           phead hd=zcpu

           llgt R2,CTRLDCBA       get dcb address
           lay r3,ziiptime        and the stckvalues from the enclave
           lay r4,ziiponcptime
           lay r5,enc_cputime

           lay r1,callparm_list   address remote copy

           call gvburztm,         Call the Ziip formatter              +
               ((2),(3),(4),(5)), passing these addresses              +
               plist4=YES,        make them 4 byte addresses           +
               linkinst=bassm,    using bassm as the link instruction  +
               MF=(E,(1))         Execute form

           rptit msg=vb_blankl
           lay  R14,TOT15         PRINT GRAND TOTAL switch count
           MVC prntline(l'tot15),0(R14)

           MVC prntline+l'tot15(l'tot15_a),COUNTMSK
           ED  prntline+l'tot15(l'tot15_a),switches
           lhi   r1,l'tot15+l'tot15_a+l'prntrdw
           sth   r1,prntrdwh
           rptit ,
         endif
*
*-------------------------
* EXEC - Execution Summary
*-------------------------

         rptit msg=vb_blankl
e1       using execrept,prntline
         phead hd=exec
*        mvc   e1.execf1,=c'  '
         lhi   r1,execrept_len+l'prntrdw
         sth   r1,prntrdwh
*
*       SAFR views processed
         lay   r15,exec_desc01
         mvc   e1.execdesc,0(r15)
         mvc   e1.execnum(5),spaces
         mvc   e1.execnum+5(l'countmsk),countmsk
         ly    r1,processed_view_cnt  number of processed views
         cvd   r1,dblwork        convert length to decimal
         ed    e1.execnum+5(l'countmsk),dblwork+2
         rptit ,
*
*       Parallel threads executed
         lay   r15,exec_desc02
         mvc   e1.execdesc,0(r15)
         llgt  r14,execdadr       load parameter data   address
         using execdata,r14
         if cli,execsngl,eq,c'1',or,cli,execsngl,eq,c'a'
           lhi r1,1              yes - only one    executed
         else
           lhy r1,thrdcnt          no - then multiple threads
         endif
         drop  r14
         mvc   e1.execnum(5),spaces
         mvc   e1.execnum+5(l'countmsk),countmsk
         cvd   r1,dblwork        convert length to decimal
         ed    e1.execnum+5(l'countmsk),dblwork+2
         rptit ,
*
*       Lookups performed
         if clc,namepgm,eq,=cl8'GVBMR95E'
           lay   r15,exec_desc03
           mvc   e1.execdesc,0(r15)
           mvc   e1.execnum,=cl2'  '
           mvc   e1.execnum+2,bytemsk+2
           mvi   e1.execnum+2,c' '
           lg    r1,grand_total_lkups
           cvdg  r1,dblwork2
           ed    e1.execnum+2,dblwork3+1
           rptit ,
         endif
*
* The elapse time convertion assumes that it is < 24 hours
*
*       Elapsed time (HHHH:MM:SS)
*
         lg    R2,begtime
         lg    R3,endtime
         SGR   R3,R2                 Work out elapsed time
         STG   R3,begtime            Save elapsed time
*
         sysstate amode64=NO
         sam31
         STCKCONV STCKVAL=begtime,CONVVAL=workarea,TIMETYPE=DEC,       +
               DATETYPE=YYYYDDD,MF=(E,stckconveform)
         sam64
         sysstate amode64=YES
         MVC   workarea+4(4),workarea     .Make it date
         LHI   R2,4095                    .X'0FFF'
         ST    R2,workarea                .init the "to" area
         NC    workarea(4),workarea+8     .and the date, remove year
         IC    R3,workarea+4              .save 1st byte of time
         MVI   workarea+4,X'0F'           .make date packed decimal
         SP    workarea(5),P010           .decrement 10 (really 1)
         STC   R3,workarea+4              .restore 1st byte of time
*
         lhi   r1,execrept_len+l'prntrdw
         sth   r1,prntrdwh
         lay   r15,exec_desc13
         mvc   e1.execdesc,0(r15)
         MVC   e1.execnum+5(L'PATTERN3),PATTERN3
         ED    e1.execnum+5(L'PATTERN3),workarea+4
         rptit ,
*
*       Elapsed time
*
         sysstate amode64=NO
         sam31
         STCKCONV STCKVAL=begtime,CONVVAL=workarea,TIMETYPE=BIN,       +
               DATETYPE=YYYYDDD,MF=(E,stckconveform)
         sam64
         sysstate amode64=YES
*
         lay   r15,exec_desc12
         mvc   e1.execdesc,0(r15)
*
         l     r0,workarea
         CVD   R0,dblwork
         MVC   e1.execnum+5,PATTERN4
         ED    e1.execnum+5,DBLWORK+2
         rptit ,

         rptit msg=vb_blankl
         rptit msg=vb_blankl

*
*       Further breakdown of exec statistics for GVBMR95E (IN)
         if clc,namepgm,eq,=cl8'GVBMR95E'
*
*       External files read (disk/tape/database)
           lhi   r1,execrept_len+l'prntrdw
           sth   r1,prntrdwh
           lay   r15,exec_desc04A
           mvc   e1.execdesc,0(r15)
           mvc   e1.execnum(5),spaces
           mvc   e1.execnum+5(l'countmsk),countmsk
           ly    r2,event_file_cnt
           ay    r2,event_database_cnt
           cvd   r2,dblwork
           ed    e1.execnum+5(l'countmsk),dblwork+2
           rptit ,
*
*       External records read (disk/tape/database)
           lay   r15,exec_desc05A
           mvc   e1.execdesc,0(r15)
           lg    r2,event_file_rec_cnt
           ag    r2,event_dbms_rec_cnt
           cvdg  r2,dblwork2
           mvc   e1.execnum,bytemsk
           ed    e1.execnum,dblwork3
           rptit ,
*
*       External bytes read (disk/tape/database)
           lay   r15,exec_desc06A
           mvc   e1.execdesc,0(r15)
           lg    r2,event_file_byt_cnt
           ag    r2,event_dbms_byt_cnt
           cvdg  r2,dblwork2
           mvc   e1.execnum,bytemsk
           ed    e1.execnum,dblwork3
           rptit ,

           rptit msg=vb_blankl
*
*       Pipe/Token files read
           lhi   r1,execrept_len+l'prntrdw
           sth   r1,prntrdwh
           lay   r15,exec_desc04B
           mvc   e1.execdesc,0(r15)
           mvc   e1.execnum(5),spaces
           mvc   e1.execnum+5(l'countmsk),countmsk
           ly    r2,event_pipe_token_cnt
           cvd   r2,dblwork
           ed    e1.execnum+5(l'countmsk),dblwork+2
           rptit ,
*
*       Pipe/Token records read
           lay   r15,exec_desc05B
           mvc   e1.execdesc,0(r15)
           lg    r2,event_pitk_rec_cnt
           cvdg  r2,dblwork2
           mvc   e1.execnum,bytemsk
           ed    e1.execnum,dblwork3
           rptit ,
*
*       Pipe/Token bytes read
           lay   r15,exec_desc06B
           mvc   e1.execdesc,0(r15)
           lg    r2,event_pitk_byt_cnt
           cvdg  r2,dblwork2
           mvc   e1.execnum,bytemsk
           ed    e1.execnum,dblwork3
           rptit ,

           rptit msg=vb_blankl
*
*       Read Exit files read
           lhi   r1,execrept_len+l'prntrdw
           sth   r1,prntrdwh
           lay   r15,exec_desc04C
           mvc   e1.execdesc,0(r15)
           mvc   e1.execnum(5),spaces
           mvc   e1.execnum+5(l'countmsk),countmsk
           ly    r2,event_read_exit_cnt
           cvd   r2,dblwork
           ed    e1.execnum+5(l'countmsk),dblwork+2
           rptit ,
*
*       Read Exit records read
           lay   r15,exec_desc05C
           mvc   e1.execdesc,0(r15)
           lg    r2,event_rexi_rec_cnt
           cvdg  r2,dblwork2
           mvc   e1.execnum,bytemsk
           ed    e1.execnum,dblwork3
           rptit ,
*
*       Read Exit bytes read
           lay   r15,exec_desc06C
           mvc   e1.execdesc,0(r15)
           lg    r2,event_rexi_byt_cnt
           cvdg  r2,dblwork2
           mvc   e1.execnum,bytemsk
           ed    e1.execnum,dblwork3
           rptit ,

           rptit msg=vb_blankl
         endif
*
*       Total source files read
         lhi   r1,execrept_len+l'prntrdw
         sth   r1,prntrdwh
         if clc,namepgm,eq,=cl8'GVBMR95E'
           lay   r15,exec_desc04
         else
           lay   r15,exec_desc14
         endif
         mvc   e1.execdesc,0(r15)
         mvc   e1.execnum(5),spaces
         mvc   e1.execnum+5(l'countmsk),countmsk
         ly    r2,event_file_cnt
         ay    r2,event_pipe_token_cnt
         ay    r2,event_database_cnt
         ay    r2,event_read_exit_cnt
         cvd   r2,dblwork
         ed    e1.execnum+5(l'countmsk),dblwork+2
         rptit ,
*
*       Total source records read
         using thrd_total,r6
         lay   r6,pgmwork
         if clc,namepgm,eq,=cl8'GVBMR95E'
           lay   r15,exec_desc05
           mvc   e1.execdesc,0(r15)
           lg    r2,event_file_rec_cnt
           ag    r2,event_pitk_rec_cnt
           ag    r2,event_rexi_rec_cnt
           cvdg  r2,dblwork2
           mvc   e1.execnum,bytemsk
           ed    e1.execnum,dblwork3
         else
           lay   r15,exec_desc15
           mvc   e1.execdesc,0(r15)
           mvc   e1.execnum,=cl2'  '
           mvc   e1.execnum+2,bytemsk+2
           mvi   e1.execnum+2,c' '
           lg    r0,iref_rcnt
           cvdg  r0,dblwork2
           ed    e1.execnum+2,dblwork3+1
         endif
         rptit ,
*
*       Total source bytes read
         if clc,namepgm,eq,=cl8'GVBMR95E'
           lay   r15,exec_desc06
           mvc   e1.execdesc,0(r15)
           lg    r2,event_file_byt_cnt
           ag    r2,event_pitk_byt_cnt
           ag    r2,event_rexi_byt_cnt
           cvdg  r2,dblwork2
           mvc   e1.execnum,bytemsk
           ed    e1.execnum,dblwork3
         else
           lay   r15,exec_desc16
           mvc   e1.execdesc,0(r15)
           mvc   e1.execnum,=cl2'  '
           mvc   e1.execnum+2,bytemsk+2
           mvi   e1.execnum+2,c' '
           lg    r0,iref_bcnt
           cvdg  r0,dblwork2
           ed    e1.execnum+2,dblwork3+1
         endif
         rptit ,

         rptit msg=vb_blankl
         rptit msg=vb_blankl
*
*       Further breakdown of exec statistics for GVBMR95E (OUT)
         if clc,namepgm,eq,=cl8'GVBMR95E'
*       Extract files written (Disk)
           lhi   r1,execrept_len+l'prntrdw
           sth   r1,prntrdwh
           lay   r15,exec_desc07A
           mvc   e1.execdesc,0(r15)
           mvc   e1.execnum(5),spaces
           mvc   e1.execnum+5(l'countmsk),countmsk
           ly    r1,extr_file_cnt
           cvd   r1,dblwork        convert length to decimal
           ed    e1.execnum+5(l'countmsk),dblwork+2
           rptit ,
*
*       Extract records written (Disk)
           lay   r15,exec_desc08A
           mvc   e1.execdesc,0(r15)
           lg    r2,extr_rec_disk_cnt
           cvdg  r2,dblwork2
           mvc   e1.execnum,bytemsk
           ed    e1.execnum,dblwork3
           rptit ,
*
*       Extract bytes written (Disk)
           lay   r15,exec_desc09A
           mvc   e1.execdesc,0(r15)
           lg    r2,extr_byt_disk_cnt
           cvdg  r2,dblwork2
           mvc   e1.execnum,bytemsk
           ed    e1.execnum,dblwork3
           rptit ,
*
           rptit msg=vb_blankl
*
*       Extract files written (Pipes and Tokens)
           lhi   r1,execrept_len+l'prntrdw
           sth   r1,prntrdwh
           lay   r15,exec_desc07B
           mvc   e1.execdesc,0(r15)
           mvc   e1.execnum(5),spaces
           mvc   e1.execnum+5(l'countmsk),countmsk
           ly    r1,extr_pipe_token_cnt
           cvd   r1,dblwork        convert length to decimal
           ed    e1.execnum+5(l'countmsk),dblwork+2
           rptit ,
*
*       Extract records written (Pipes and Tokens)
           lay   r15,exec_desc08B
           mvc   e1.execdesc,0(r15)
           lg    r2,extr_rec_pitk_cnt
           cvdg  r2,dblwork2
           mvc   e1.execnum,bytemsk
           ed    e1.execnum,dblwork3
           rptit ,
*
*       Extract bytes written (Pipes and Tokens)
           lay   r15,exec_desc09B
           mvc   e1.execdesc,0(r15)
           lg    r2,extr_byt_pitk_cnt
           cvdg  r2,dblwork2
           mvc   e1.execnum,bytemsk
           ed    e1.execnum,dblwork3
           rptit ,
*
           rptit msg=vb_blankl
*
*       Extract files written (Total)
           lhi   r1,execrept_len+l'prntrdw
           sth   r1,prntrdwh
           lay   r15,exec_desc07
           mvc   e1.execdesc,0(r15)
           mvc   e1.execnum(5),spaces
           mvc   e1.execnum+5(l'countmsk),countmsk
           ly    r1,extr_file_cnt
           ay    r1,extr_pipe_token_cnt
           cvd   r1,dblwork        convert length to decimal
           ed    e1.execnum+5(l'countmsk),dblwork+2
           rptit ,
*
*       Extract records written (Total)
           lay   r15,exec_desc08
           mvc   e1.execdesc,0(r15)
           lg    r2,extr_rec_disk_cnt
           ag    r2,extr_rec_pitk_cnt
           cvdg  r2,dblwork2
           mvc   e1.execnum,bytemsk
           ed    e1.execnum,dblwork3
           rptit ,
*
*       Extract bytes written (Total)
           lay   r15,exec_desc09
           mvc   e1.execdesc,0(r15)
           lg    r2,extr_byt_disk_cnt
           ag    r2,extr_byt_pitk_cnt
           cvdg  r2,dblwork2
           mvc   e1.execnum,bytemsk
           ed    e1.execnum,dblwork3
           rptit ,
         else
*
*       MR95R version of total*******
*       Extract files written (Total)
           lhi   r1,execrept_len+l'prntrdw
           sth   r1,prntrdwh
           lay   r15,exec_desc07
           mvc   e1.execdesc,0(r15)
           mvc   e1.execnum(5),spaces
           mvc   e1.execnum+5(l'countmsk),countmsk
           ly    r1,filecnt_real   Get number of views
           cvd   r1,dblwork        convert length to decimal
           ed    e1.execnum+5(l'countmsk),dblwork+2
           rptit ,
*
*       Extract records written (Total)
           lay   r15,exec_desc08
           mvc   e1.execdesc,0(r15)
           mvc   e1.execnum,bytemsk
           ed    e1.execnum,thrd_totecnt
           rptit ,
*
*       Extract bytes written (Total)
           lay   r15,exec_desc09
           mvc   e1.execdesc,0(r15)
           mvc   e1.execnum,bytemsk
           ed    e1.execnum,thrd_totebyte
           rptit ,
         endif

         rptit msg=vb_blankl

         rptit msg=vb_blankl
         rptit msg=vb_blankl
         drop  e1
         drop  r6
*
**      free storage used for sorting reports
*
         ly    r0,rpt_sort_area_len
         aghi  r0,l'sorteyeb
         ly    r1,rpt_sort_area_ptr
*
         FREEMAIN RC,LV=(0),A=(1) free
*
         lg    r14,Final_reports_save   Get saved return address
         br    r14              Return
*
static   loctr ,
*              PIC          H H : M M : S S . T T
PATTERN3 DC    XL15'4040404021207A20207A20204B2020'
*              PIC    S S S , S S S , S S S . T T
PATTERN4 DC    XL15'402020206B2020206B2021204B2020'
*
* RTC21059 Table to sort and store OFIL data before printing
*
code     loctr ,

********************************************************************
*                                                                     *
*        Close User Exits (if assembler ones)                         *
*                                                                     *
********************************************************************
term_uexits ds 0h
         stmg  R14,R12,SAVEZIIP                   store registers
*
         llgt  R8,LTBEGIN         LOAD LOGIC  TABLE ADDRESS
         USING LOGICTBL,R8
*
         lgf   R7,LTCOUNT         LOAD LOGIC  TABLE ENTRY COUNT
*
         do from=(r7)
           if CLC,LTFUNC(2),eq,WR_EX
*
* CALL EXIT INIT function for ASM exits only
*
             LT    R15,LTWRADDR       USER EXIT SPECIFIED ?
             JZ    exittex            no, go
             cli   LTWRPGM_TYPE+3,LTWRPGM_TYPE_ASM Assembler?
             jne   exittex
*
             using genenv,env_area
             using genparm,parm_area
             using genfile,file_area
*
             MVC   gpphase,TE        INDICATE "term"  PHASE
             MVC   ERRDATA(8),LTWRNAME SAVE EXIT NAME
*
             LA    R0,LTWRPARM       POINT TO WRITE PARAMETERS
             STY   R0,GPSTARTA
*            LA    R0,LTWRWORK       LOAD EXIT WRITE ANCHOR
*            STY   R0,GPWORKA          but this in in literal pool
*
             mvc   gp_error_buffer_len,=a(l'error_buffer) max len
             xc    gp_error_reason,gp_error_reason   clear reason
*
             LAy   1,PARM_AREA
             BASSM R14,R15          CALL EXIT WITH TERM OPTION
*
             if (oc,gp_error_reason,gp_error_reason,nz) success?
               l r15,gp_error_buffer_len get length of text
               sthy r15,error_bufl        and save in prefix
               lay r9,error_bufl
               WTO TEXT=(9),MF=(E,WTOPARM)
               l r15,gp_error_buffer_len get length of text
               ahi  r15,4
               sthy r15,error_bufl
               logit msg=error_bufl
             endif
*
             L     R15,RETNCODE
             lghi  R14,EXIT_ABORT
             chi   r15,8              higher than 8 is bad
             bh    errmsg#
*
           endif
exittex    equ   *
           agh   R8,ltrowlen        ADVANCE TO NEXT ROW (31-BIT ADDR)
         enddo
*
         lmg   R14,R12,SAVEZIIP                   restore registers
         br    R14
*
         DROP  R8 LOGICTBL
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*                                                                     *
* "WRTCTRL" - WRITE A CONTROL RECORD TO THE APPROPRIATE REPORT        *
*             EXTRACT FILE.                                           *
*                                                                     *
* REGISTER USAGE:                                                     *
*                                                                     *
*        R9  - RETURN   ADDRESS                                       *
*        R8  - "HD"     LOGIC   TABLE  ROW    ADDRESS                 *
*        R4  - Save R9 while R9 is being used as a pointer            *
*        R3  - EXTRACT  FILE  CONTROL  AREA   ADDRESS                 *
*        R1  - DCB      ADDRESS                                       *
*                                                                     *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*
         USING EXTFILE,R3
         USING EXTREC,R6
*
WRTCTRL  XC    CTVIEW#,CTVIEW#    SET  VIEW  NO. TO LOW VALUES
*
         XC    CTSORTLN,CTSORTLN  SORT KEY       LENGTH
         XC    CTTITLLN,CTTITLLN  SORT KEY TITLE LENGTH
         LHI   R15,21             CONTROL  DATA  LENGTH
         STH   R15,CTDATALN
         XC    CTNCOL,CTNCOL      COLUMN   COUNT
*
         llgt  R8,LTHDROWA
         USING LOGICTBL,R8
         MVC   CTFINPDT,LTFINPDT  FISCAL  PERIOD   DATE
         MVC   CTPROCDT,LTPROCDT
         MVC   CTPROCTM,LTPROCTM  PROCESSED TIME
         DROP  R8
*
         agsi  EXTCNT,bin1        INCREMENT RECORD COUNT
         agsi  thrd_extrrec_cnt,bin1    for thread total later
         lg    r15,extcnt
         cvdg  r15,dblwork2
         ZAP   CTRECCNT,dblwork3
*
         LHI   R0,L'CTLREC        LOAD LENGTH  OF CONTROL RECORD
         CH    R0,EXTMINLN        DOES LENGTH EXCEED MINIMUM ???
         JNL   *+8                NO -  USE  MINIMUM
         LH    R0,EXTMINLN        YES - USE  ACTUAL
         STH   R0,CTRECLEN        SET  LENGTH  IN "RDW"
*
WRTctlok do inf
           ltgf R0,EXTRECAD       LOAD  TARGET ADDRESS  FOR NEW RECORD
           JNP WRTCTLEX
           LH  R15,ctRECLEN       LOAD   RECORD LENGTH
           if TM,EXTRECFM,X'40',z VARIABLE  OR  UNDEFINED ???
             lgh R15,EXTLRECL     NO  -   USE   FIXED  LENGTH
           endif
           lgr R14,r0             COMPUTE TRIAL END-OF-BUFFER  ADDRESS
           agr R14,r15
           doexit (cgf,R14,le,EXTEOBAD) If record fits, exit loop now
*
*          here if record overflows buffer
*
           llgt R1,EXTDECBC       LOAD  CURRENT DECB PREFIX ADDRESS
           llgt R14,16(,R1)       LOAD   BUFFER ADDR FROM   DECB
           sgr R0,R14             COMPUTE BLOCK LENGTH
           TM  EXTRECFM,X'40'     VARIABLE  OR  UNDEFINED   ???
           JNO *+8                NO  -  BYPASS "BDW"
           STH R0,0(,R14)         BUILD  BLOCK  DESCRIPTOR WORD (BDW)
           STH R0,10(,R1)         PLACE  LENGTH IN    DECB
*
WRTCPUT    aghi R1,4              POINT TO DECB
           XC  0(4,R1),0(R1)      CLEAR ECB
           LGR  R4,R9             Save R9 while R9 is retasked
           LR   R9,R3             Setup R9 as pointer
           llgf R15,EXTPUT_6431   LOAD  WRITE   ROUTINE ADDRESS
           bassm R14,R15          WRITE PHYSICAL BLOCK (31-BIT MODE)
           LGR  R9,R4             Restore R9 to the return address
*
WRTCSKIP   llgt R1,EXTDECBC       LOAD  ADDRESS OF NEXT DECB PREFIX
           llgt R1,0(,R1)
           ST  R1,EXTDECBC        SAVE  ADDRESS OF NEXT DECB PREFIX
*
           aghi R1,4              POINT TO ECB
           LGR  R4,R9             Save R9 while R9 is retasked
           LR   R9,R3             Setup R9 as pointer
           llgf R15,extchk_6431   LOAD  CHECK   ROUTINE ADDRESS
           bassm R14,R15          WAIT  FOR I/O TO      COMPLETE
           LGR  R9,R4             Restore R9 to the return address
           llgt R1,EXTDECBC       RESTORE DECB PREFIX   ADDRESS
*
CTNOWAIT   llgt R15,16(,R1)       LOAD  BUFFER ADDRESS  FROM DECB
           LA  R0,4(,R15)         SKIP  BDW
           TM  EXTRECFM,X'40'     VARIABLE  OR UNDEFINED    ???
           JO  *+8                YES - LEAVE  ROOM  FOR   "BDW"
           lgr R0,R15             NO  - START  AT BEGINNING
           ST  R0,EXTRECAD        INITIALIZE NEXT RECORD ADDRESS
*
           agh R15,EXTBLKSI
           ST  R15,EXTEOBAD
         enddo
                        SPACE 3
WRTCTLMV ST    R14,EXTRECAD       UPDATE ADDRESS  FOR NEXT RECORD
*
         lg    r1,thrd_extrbyte_cnt  Get thread byte count
         agr   r1,r15                 add this byte to total
         stg   r1,thrd_extrbyte_cnt  and save thread byte count
         lg    r1,extbytec           Increment extract byte count
         agr   r1,r15                 add this byte to total
         stg   r1,extbytec             and save it
*
         LA    R14,CTLREC         MOVE   THIS CONTROL RECORD TO BUFFER
         TM    EXTRECFM,X'40'     VARIABLE OR UNDEFINED  ???
         JO    *+8                YES - INCLUDE "RDW"
         LA    R14,CTLREC+4       NO  - IGNORE  "RDW"
         LR    R1,R15
         MVCL  R0,R14
*
WRTCTLEX BR    R9                 EXIT  SUBROUTINE
*
static   loctr ,
*
SORTCTRL DS   0CL80               SORT CONTROL CARD
         DC    CL01' '
SORTVERB DC    CL05'SORT '
         DC    CL12' FIELDS=(13,'
SORTKEYL DC    CL04'0004'
         DC    CL58',CH,A)'
code     loctr ,
*
         DROP  R3
         DROP  R6
*
static   loctr ,
TRACMOVE MVC   PRNTLINE+(TRACEDAT-TRACEMSG)(0),0(R14)  * * EXECUTED * *
TRACMVV2 MVC   PRNTLINE+(TRACEV2-TRACEMSG)(0),0(R14)   * * EXECUTED * *
FLDFMT   DC    C'  X A N P S B I C M E F G 1314151617181920'
code     loctr ,
*
         DROP  R13
                        EJECT
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*                                                                     *
*  P A S S   T W O   T H R O U G H   T H E   L O G I C   T A B L E    *
*                                                                     *
*    1.  INSERT OPERAND OFFSETS INTO INSTRUCTIONS                     *
*    2.  ADJUST LITERAL POOL OFFSETS AFTER THEY'RE COPIED TO CODE SEG *
*    3.  INSERT TRUE/FALSE OFFSETS INTO INSTRUCTIONS                  *
*                                                                     *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*
         using (thrdarea,thrdend),r13 Tell assembler to map the area
         using savf4sa,savesubr   and the savearea map as well
*
PASS2    stg   R14,SAVF4SAG64RS14 SAVE RETURN ADDRESS
*
         llgt  R8,LTBEGIN         LOAD LOGIC TABLE ADDRESS
         USING LOGICTBL,R8
*
P2LOOP   llgt  R3,LTCODSEG        LOAD  CODE SEGMENT ADDR FOR THIS ROW
*
P2CHKFUN CLC   LTFUNC,NV          "NV"  ROW  ???
         JE    P2FUNNV            YES - NO TRACE BRANCH INSTR
*
         CLC   LTFUNC,ES          "ES"  ROW  ???
         JE    P2FUNES            YES - BRANCH
*
         CLC   LTMAJFUN,=c'HD'    "HD"  SET  ???
         JE    P2FUNCTB           YES - NO TRACE BRANCH INSTR
*
         CLC   LTMAJFUN,=C'RE'    "RE"  SET  ???
         JE    P2FUNCTB           YES - NO TRACE BRANCH INSTR
*
         CLC   LTMAJFUN,NV        "NV"  SET  ???
         JE    P2FUNCTB           YES - NO TRACE BRANCH INSTR
*
         CLC   LTMAJFUN,ES        "ES"  SET  ???
         JE    P2FUNCTB           YES - NO TRACE BRANCH INSTR
*
         CLC   LTFUNC,ET          "ET"  ROW  ???
         JE    P2FUNCTB           YES - BRANCH
*
         CLC   LTMAJFUN,EN        "EN"  ROW  ???
         JE    P2FUNCTB           YES - NO TRACE BRANCH INSTR
*
         llgt  R14,EXECDADR       TRACE OPTION  SPECIFIED ???
         push  using
         using execdata,r14
         do ,
           doexit (clc,=c'DIM',eq,ltfunc)
           if CLI,EXECTRAC,eq,C'Y' trace option on?
             pop using
             if CLI,VIEWTRAC,eq,C'Y' VIEW SPECIFIC TRACE OPTION ???
*
               doexit (ltgf,R14,ltlognv,np)   "NV" adr                 +
                       and get out if not ok
               doexit (ltgf,R0,LTPARMTB-LOGICTBL(,R14),np) test        +
                       ltparmtb and exit if not positive
*
             endif
             aghi R3,4            YES - ADVANCE OVER BRANCH INSTRUCTION
*
           endif
         enddo
*
         if TM,LTFLAGS,LTLKUPRE,o   LOOK-UP PREFIX CODE REQUIRED ???
           AHI R3,lkuppref_length ADVANCE CODE  BASE  REG BEYOND PREFIX
           if clc,=c'LL',eq,ltsubfun   xxLL function?
             AHI R3,lkuppref_length ADVANCE CODE BASE BEYOND 2nd prefix
           endif
         endif

         if cli,ltsubfun,eq,c'P',or,  Did we insert a loadprev?        +
               cli,ltsubfun+1,eq,c'P'    previous record address ?

           aghi R3,L'loadprev     ADVANCE over load instruction
         endif
         J     P2FUNCTB
loadprev ltg   r3,prevreca only here to give the length - never execute
*
P2FUNNV  llgt  R2,LTVIEWNV        ADVANCE CODE BASE POINTER
         USING NVPROLOG,R2
*
         llgt  r14,runview_ptr    get runviews data if any
         do label=runv_test
           if cgij,r14,ne,0         check that we have runview data
             using (runview_list,runv_length),r14 and map the data
             lgf r15,runv_count     get counter
             llgt r1,runv_first     and get first entry
             using runvent,r1       and map that
             do from=(r15),while=(cgij,r1,ne,0)
               if clc,nvviewid,eq,runvent_view
                 leave runv_test    found - so exit completly
               elseif (h)
                 llgt r1,runvent_next search view  higher than runview +
                                    so get the next entry
               elseif (l)
                 leave ,            search view is less than runview   +
               which means view is not in list so split
               endif
             enddo
*            here if the view no is NOT in runviews
*            so disable the view from running
             oi nvnop+1,x'f0'
             drop r14,r1
           endif
         enddo

         LHI   R0,EXSRTKEY-EXTREC COMPUTE OFFSET TO FIRST SUB-TOTAL
         AH    R0,LTSORTLN        ADD SORT    DATA  LENGTH
         AH    R0,LTTITLLN        ADD TITLE   KEY   LENGTH
         AH    R0,LTDATALN        ADD EXTRACT DATA  LENGTH
         STH   R0,NVLAYR8+2       INSERT    OFFSET  INTO "LA" INSTR
         NI    NVLAYR8+2,X'0F'
         OI    NVLAYR8+2,X'70'    FILL-IN   BASE    REGISTER
         SRL   R0,12
         STC   R0,NVLAYR8+4
*
         TM    NVNOP+1,X'F0'      VIEW  BEEN   DISABLED  ???
         JO    P2NEXT             YES - BYPASS ALL LOGIC TABLE ROWS
*
         J     P2FUNCTB
*
P2FUNES  ltgf  R0,LTFRSTRE        ANY   EVENT FILE  READ ???
         JP    P2FUNCTB
*
         using mdles,r3           Map using the model layout
         if clc,mdles,eq,mdles+l'mdles  are two words the same?
           MVC mdles,BRNCHEOF   yes - BRANCH  TO "EVNTEOF" WHEN DONE
           MVC mdles+l'mdles,BRNCHEOF
         else
*          here if it is not the mdles model so flip to mdlesrl
           using mdlesrl,r3
           mvc mdlesrl_exit,brncheof  and update the single evntprev
           drop r3
         endif
                        SPACE 3
P2FUNCTB llgt  R6,LTFUNTBL        LOAD ADDRESS  OF FUNCTION  TABLE
         USING FUNCTBL,R6
*
         TM    LTFLAGS,LTOMITGO   GOTO BRANCH   OMITTED ???
         JO    P2NEXT
*
         ltgf  R14,FCRELOCA       LOAD RELOCATION  TABLE ADDRESS
         JNP   P2NEXT
*
P2RELOLP CLI   0(R14),X'FF'       END-OF-TABLE  ???
         JE    P2NEXT             YES -  ADVANCE TO NEXT LOGIC ROW
*
         llgc  R1,1(,R14)         LOAD RELOCATION VALUE OFFSET
         agr   R1,R3              ADD  CODE  BASE TO    OFFSET
*
         llgc  R0,0(,R14)         LOAD RELOCATION VALUE TYPE CODE
         select cij,r0,eq         use select for ones of interest
           when 12                TRUE    BRANCH DISPLACEMENT
             if TM,LTFLAGS,LTOMITTB,z OPT true BRANCH not ommitted?
               BRAS R9,TRUEOFF
               ST R0,0(,R1)
             endif
           when 13                TRUE    BRANCH DISPLACEMENT
             BRAS R9,TRUEOFF
             ST R0,0(,R1)
           when 14                FALSE   BRANCH DISPLACEMENT
             if TM,LTFLAGS,LTOMITfB,z OPT false BRANCH not ommitted?
               BRAS R9,falseoff
               ST R0,0(,R1)
             endif
           when 15                FALSE   BRANCH DISPLACEMENT
             BRAS R9,FALSEOFF
             ST R0,0(,R1)
           when 29                TITLE   KEY    OFFSET
             llgt R9,LTlognv      LOAD  "NV"   ROW ADDRESS
             LA  R0,EXSRTKEY-EXTREC  COMPUTE TITLE AREA ADDRESS
             ah  R0,LTSORTLN-LOGICTBL(,R9) ADD SORT DATA LENGTH
             ah  R0,LTFLDPOS          ADD CURRENT COLUMN OFFSET
             STH R0,00(,R1)       INSERT OFFSET  INTO   "MVC"
             OI 00(R1),X'70'
*
         endsel

         aghi  R14,2              ADVANCE TO NEXT RELOCATION TBL ENTRY
         J     P2RELOLP           LOOP

P2NEXT   agh   R8,0(,R8)          ADVANCE TO NEXT ROW
         cgf   R8,LTENROWA
         JNH   P2LOOP
                        SPACE 3
         lg    R14,SAVF4SAG64RS14 RESTORE RETURN  ADDRESS
         br    R14              RETURN
*
         DROP  R6
                        EJECT
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*                                                                     *
* "TRUEOFF"  - CONVERTS  THE TRUE BRANCH ROW ADDRESS INTO THE         *
*              OFFSET OF THE CODE FOR THE TRUE  ROW                   *
*                                                                     *
* "FALSEOFF" - CONVERTS THE FALSE BRANCH ROW ADDRESS INTO THE         *
*              OFFSET OF THE CODE FOR THE FALSE ROW                   *
*                                                                     *
* REGISTER USAGE:                                                     *
*                                                                     *
*        R14 - RETURN  ADDRESS                                        *
*        R8  - CURRENT LOGIC    TABLE  ROW   ADDRESS                  *
*        R1  - OFFSET  OF FALSE BRANCH CODE                           *
*                                                                     *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*
         USING LOGICTBL,R8
*
TRUEOFF  llgt  R15,LTTRUE                LOAD TRUE  BRANCH  ROW ADDRESS
         J     FALSECOM                  YES - GOTO COMMON LOGIC
                        SPACE 3
FALSEOFF llgt  R15,LTFALSE               LOAD FALSE BRANCH  ROW ADDRESS
*
FALSECOM CLC   LTMAJFUN-LOGICTBL(,R15),NV NEXT  VIEW    ???
         JE    FALSENV                   YES - SPECIAL CASE
*
         CLC   LTMAJFUN-LOGICTBL(,R15),ES END-OF SET    ???
         JE    FALSENV                   YES - SPECIAL CASE
*
         llgt  R0,LTCODSEG-LOGICTBL(,R15)  LOAD  CODE SEGMENT ADDRESS  +
                        of target code
         sgr   R0,r1    subtract my current position (offset ptr)
         aghi  r0,+2    add two to offset to account for r1 posie      +
                   so this is relative to current position
         SRA   R0,1                        CONVERT TO HALFWORDS
         BR    R9                          RETURN (R0 = OFFSET)
         DROP  R2
*
falsenv  llgt  r15,ltviewnv              locate the nv code
         using nvprolog,r15
         llgt  r15,nvnxview              get address of next view
         drop  r15
         sgr   r15,r1
         aghi  r15,+2
         sra   r15,1
         lgr   r0,r15
*
         Br    r9                        RETURN SKIP "STH"
*
         DROP  R8
                        EJECT
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*                                                                     *
* "WRTXLEIN" - WRITE EXIT COMMON LANGUAGE INTERFACE STUB              *
*                                                                     *
*  REGISTER USAGE:                                                    *
*                                                                     *
*        R15 - ENTRY     POINT   ADDRESS                              *
*        R14 - RETURN    ADDRESS                                      *
*        R13 - THREAD    WORK    AREA    ADDRESS                      *
*        R1  - PARAMETER LIST    ADDRESS                              *
*                                                                     *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         using (thrdarea,thrdend),r13 Tell assembler to map the area
         USING LOGICTBL,R5
*
wrtxlein amode 31
WRTXLEIN llgt  R15,CEEWADDR       LOAD COMMON LANG INTERFACE AREA ADDR
         USING LEINTER,R15
*
         L     R0,LTWRENTP        LOAD TRUE  ENTRY POINT     ADDRESS
         ST    R0,LESUBADR
*
         ST    R1,LEPARMP         PASS TRUE  PARAMETER  LIST ADDRESS
         ST    R14,LERETADR       SAVE RETURN  ADDRESS
*
         LA    R1,LEPARM
         l     R15,LECEEADR       CALL COMMON LANG INTERFACE
         BASR  R14,R15
         DROP  R15
*
         llgt  R1,CEEWADDR        LOAD COMMON LANG INTERFACE AREA ADDR
         USING LEINTER,R1
*
         llgf  R14,LERETADR       LOAD RETURN ADDR
         lgf   R15,LERTNC         LOAD RETURN CODE
         bsm   0,r14            RETURN
*
         DROP  R1
         DROP  R5
            EJECT
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*                                                                     *
* "LKPXLEIN" - LOOK-UP EXIT COMMON LANGUAGE INTERFACE STUB            *
*                                                                     *
*  REGISTER USAGE:                                                    *
*                                                                     *
*        R15 - ENTRY     POINT   ADDRESS                              *
*        R14 - RETURN    ADDRESS                                      *
*        R13 - THREAD    WORK    AREA    ADDRESS                      *
*        R1  - PARAMETER LIST    ADDRESS                              *
*                                                                     *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*
lkpxlein amode 31
LKPXLEIN llgt  R15,CEEWADDR       LOAD COMMON LANG INTERFACE AREA ADDR
         USING LEINTER,R15
*
         l     R0,LBSUBENT-LBPARML(,R1) LOAD TRUE ENTRY POINT  ADDRESS
         ST    R0,LESUBADR              (BEYOND END OF PARAMETER LIST)
*
         ST    R1,LEPARMP         PASS TRUE  PARAMETER  LIST ADDRESS
         ST    R14,LERETADR       SAVE RETURN  ADDRESS
*
         LA    R1,LEPARM
         llgt  R15,LECEEADR       CALL COMMON LANG INTERFACE
         BASR  R14,R15
         DROP  R15
*
         llgt  R1,CEEWADDR        LOAD COMMON LANG INTERFACE AREA ADDR
         USING LEINTER,R1
*
         llgf  R14,LERETADR       LOAD RETURN ADDR
         lgf   R15,LERTNC         LOAD RETURN CODE
         bsm   0,r14            RETURN
*
         DROP  R1
                        EJECT
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*                                                                     *
*        P I P E D   O U T P U T   E N D - O F - F I L E              *
*                                                                     *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*
PIPEEOF  ds    0h
savesub  using savf4sa,savesubr
         stg   r14,savesub.SAVF4SAG64RS14 SAVE RETURN ADDRESS
*
*
         llgt  R8,THRDES          LOAD CURRENT "ES"  ROW ADDRESS
tk_es    USING LOGICTBL,R8
*
         LA    R4,tk_es.LTPIPELS  PIPE LIST   ADDRESS PRESENT
         bras  r9,pipeloop        Set Eof in all buffers
*                                                                pgc500
         if ltgf,r7,tk_es.ltesrtkq,p    Are there tokens?
tokn_re    using logictbl,r7                                     pgc500
           do until=(ltgf,r7,tokn_re.ltnxrtkn,np) all done?
             llgt r8,tokn_re.ltrees  Get "ET" for this "RETK"    pgc500
tokn_es      using logictbl,r8                                   pgc500
             la r4,tokn_es.ltpipels Is there a pipe list?        pgc500
             bras r9,pipeloop                                    pgc500
             drop tokn_es                                        pgc500
           enddo
           drop tokn_re                                          pgc500
         endif
*                                                                pgc500

         lg    r14,savesub.SAVF4SAG64RS14
         br    r14
         DROP  TK_es

PIPELOOP do while=(ltgf,r4,0(,r4),p) loop while we have a +ve pointer
           llgt R3,4(,R4)
           USING EXTFILE,R3
                          SPACE 3
           lgf R15,EXTPIPEP       PRIOR   EXECUTING/DONE   COUNT
           do until=(cs,r15,r14,eq,extpipep)
             LA R14,1(,R15)       INCREMENT  DONE   COUNT (RIGHT 1/2)
           enddo
*
           if CLC,EXTPIPED,ge,EXTPIPEP ALL THREAD'S FINISHED ???
*
             llgt R0,EXTRECAD     LOAD   TARGET ADDRESS FOR NEW RECORD
             llgt R1,EXTDECBC     LOAD  CURRENT DECB PREFIX ADDRESS
             llgt R14,16(,R1)     LOAD   BUFFER ADDR FROM   DECB
             sgr R0,R14           COMPUTE BLOCK LENGTH
             if TM,EXTRECFM,X'40',o    VARIABLE   OR UNDEFINED   ???
               if cgij,R0,le,8     just the BDW ??
                 sgr R0,R0         NO  -  BLOCK  IS  EMPTY
               endif
               STH R0,0(,R14)     BUILD  BLOCK  DESCRIPTOR  WORD (BDW)
             endif
             STH R0,10(,R1)       PLACE  LENGTH IN    DECB
             llilh r0,X'7000'     LOAD  COMPLETION    CODE
             if ltgf,R1,4+MAPWRTL-4(,R1),p RELATED READ PIPE DECB?
               xr R15,R15         ZERO  REGISTER
               if CS,R15,R0,ne,0(R1)    MARK  LAST   BUFFER
                 POST (1),(0)     "WAKE-UP" PIPE READ if cs fails
             endif
             else
               llgt R1,EXTDECBC   LOAD  CURRENT  DECB PREFIX ADDRESS
               MVI 4(R1),X'70'    FLAG  LAST    BLOCK
             endif
           endif
         enddo
         BR    R9
*
ZAPAREA  DC    512X'00'
*
         DROP  R3
                        EJECT
MACHCODE CSECT
MACHCODE RMODE 31
MACHCODE AMODE 31
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*                                                                     *
*           M O D E L   C O D E   S E G M E N T   T A B L E           *
*                                                                     *
*       (INCLUDES MACHINE CODE TEMPLATES AND RELOCATION TABLES)       *
*                                                                     *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*
*  NOTE: Must not use branch relative instructions for any external
*        jumps as code is relocated in the MACHCODE area
*
*
         using (thrdarea,thrdend),r13 Tell assembler to map the area
         using genenv,env_area
         using genparm,parm_area
         using genfile,file_area
         USING EXTREC,R7
         using litp_hdr+524288,r2
*
         ieabrcx DISABLE
MR95TRAC BAS   R10,TRACE          BRANCH  TO   TRACE ROUTINE
         entry call96at,call96al,call96ap,call96ax
call96at bas r10,CALL96AT_indirect CALL "GVBDL96"
call96al bas r10,CALL96Al_indirect CALL "GVBDL96"
call96ap bas r10,CALL96Ap_indirect CALL "GVBDL96"
call96ax bas r10,CALL96Ax_indirect CALL "GVBDL96"
         entry call96tr,call96lr,call96pr,call96xr
call96tr bas r10,CALL96tr_indirect CALL "GVBDL96"
call96lr bas r10,CALL96lr_indirect CALL "GVBDL96"
call96pr bas r10,CALL96pr_indirect CALL "GVBDL96"
call96xr bas r10,CALL96xr_indirect CALL "GVBDL96"
         entry call96t,call96l,call96p,call96x
call96t  bas r10,CALL96t_indirect CALL "GVBDL96"
call96l  bas r10,CALL96l_indirect CALL "GVBDL96"
call96p  bas r10,CALL96p_indirect CALL "GVBDL96"
call96x  bas r10,CALL96x_indirect CALL "GVBDL96"
***********************************************************************
*        NEW  VIEW  PREFIX                                            *
***********************************************************************
MR95NV   jlnop *                 "NOP" BRANCH INSTR(DISABLE VIEW)
         LAY   R8,EXTREC+0        INITIALIZE COLUMN DATA  POINTER
         BRAS  R14,MDLNVBEG       BRANCH AROUND HEADER (SET R14)
         using nvconst,r14
         DC    FL4'0'             VIEW    ID
         DC    AL4(0)             ADDRESS OF LOGIC TABLE ROW FOR "NV"
         DC    FL4'0'             LITERAL POOL  SIZE  THIS VIEW
         DC    AL4(0)             ADDRESS OF CODE FOR NEXT VIEW
MDLNVBEG MVC   gpview#,NVVIEWID
         lay   r15,lpvaddr
         mvc   0(l'lpvaddr,r15),nvlogtbl Copy nv logic table pointer
         la    r11,nvconst        get start of NV constants
         nop   trace              BRANCH TO  TRACE  ROUTINE (NOP)
*        this nop above must be replaced with MR95TRAC if reqd
* (CQ7768) this possible call to trace MUST follow the lpvaddr update
         LG    R6,RECADDR         Initialize Event Record Base Register
MDLNVL   EQU   *-MR95NV
         drop  r14
*        this model length MUST match the NVPROLOG dsect length
*        so we will just add this test to make sure
         ASSERT mdlnvl,eq,nvcodeln
*
*DLNVP   EQU   view_counters_length liTERAL POOL USAGE (EXCL FIELD LEN)
MDLNVP   EQU   0                    liTERAL POOL USAGE (EXCL FIELD LEN)
*
MDLNVR   DC   2XL1'FF'            END OF RELOCATION TABLE
                        EJECT
***********************************************************************
*        LOOK-UP - SEARCH MEMORY USING KEY                            *
***********************************************************************
MDLLUSM  llgt  R5,0(,R2)          LOAD   LOOKUP BUFFER ADDRESS
MDLLUSMX LLGT  R15,0(,R12)        ADDRESS SEARCH ROUTINE without hi bit
         BASR  R10,r15            SEARCH ROUTINE
MDLLUSMF jlu   *+l'*              "RECORD NOT FOUND" BRANCH (FALSE)
MDLLUSMT jlu   *+l'*              "RECORD     FOUND" BRANCH (OPTIONAL)
MDLLUSML EQU   *-MDLLUSM
*
MDLLUSMP EQU   4                  LITERAL POOL USAGE (EXCL FIELD LEN)
*
MDLLUSMR DC    AL1(CSLBAOFF),AL1(MDLLUSM+2-MDLLUSM)   LOOK-UP  BUFR
         DC    AL1(CSSRCHR),AL1(MDLLUSMX+2-MDLLUSM)  search routine
         DC    AL1(CSFALSEM),AL1(MDLLUSMF+2-MDLLUSM)  FALSE  BRANCH
         DC    AL1(CSTRUEO),AL1(MDLLUSMT+2-MDLLUSM)   TRUE   BRANCH
         DC   2XL1'FF'
*
***********************************************************************
*        LOOK-UP  -  CALL EXIT PROGRAM                                *
***********************************************************************
MDLLUEX  llgt  R5,0(,R2)                  LOAD LOOKUP  BUFFER  ADDRESS
         lay   r15,PARM_AREA
         MVC   LBPARML-LKUPBUFR(8,R5),0(r15)
         STG   R6,LBEVENTA-LKUPBUFR(,r5)  Save Event record addr in LB
         ST    R7,LBEXTRA-LKUPBUFR(,R5)   PASS EXTRACT RECORD  ADDR
         LA    R0,LKUPKEY                 PASS KEY     ADDRESS
         ST    R0,LBKEYA-LKUPBUFR(,R5)
*
         xc    gp_error_buffer_len,gp_error_buffer_len
         mvi   gp_error_buffer_len+3,(l'error_buffer) set max length
         xc    gp_error_reason,gp_error_reason        clear reason
         LA    R1,LBPARML-LKUPBUFR(,R5)   LOAD PARAMETER  LIST  ADDR
*
         llgf  R15,LBSUBADR-LKUPBUFR(,R5) LOAD SUBROUTINE ADDR
         BASsm R14,R15                    CALL SUBROUTINE
*
         if    (oc,gp_error_reason,gp_error_reason,nz)
           bas  r9,errwto         issue "wto" if non-zero reason code
         endif
*
         lt    R15,LBLSTRC-LKUPBUFR(,R5)  SUCCESSFUL  ???
         jnz   mdlluexe
*
         agsi  lbfndcnt-LKUPBUFR(r5),bin1     INCREMENT Found COUNT
*
         LH    R0,LBLKSTK#-LKUPBUFR(,R5)  SAVE STACK    COUNT
         ST    R0,gpjstpct
         lg    R15,LBLSTFND-LKUPBUFR(,R5) SAVE POINTER  IN STACK
         llgt  R14,gpjstka
MDLLUEXS AHI   R14,0
         MVC   0(4,R14),LBLRID-LKUPBUFR(R5)
         stg   R15,4(,R14)
MDLLUEXT jlu   *+l'*                 "Record found" branch true
*
MDLLUEXE DS    0h
         agsi  lbnotcnt-LKUPBUFR(r5),bin1     INCREMENT Not Found COUNT
         ltgf  R1,LBPARENT-LKUPBUFR(,R5)
         if    (p)
           MVC LBLSTFND-LKUPBUFR(L'LBLSTFND,R1),HEXFF
         endif
*
         CHI   R15,4
MDLLUEXF jle   *+l'*              "RECORD NOT FOUND" BRANCH (FALSE)
*
         CHI   R15,8              SKIP  EVENT RECORD (8)
         BE    EVNTPREV
*
MDLLUEXb llgt  r5,0(,r2)          Load logic table address
         using logictbl,r5
         llgt  r9,ltviewnv        load addr NV machcode
         CHI   R15,12
         if    (e)                If equal to 12
           b   DISABREQ_model    DON'T USE R9 (RETURN TO disabled view)
         endif
*
         MVC   ERRDATA(8),LBSUBNAM-LKUPBUFR(R5)
         B     ABORTEX_indirect   ABORT RUN          (16)
MDLLUEXL EQU   *-MDLLUEX
*
MDLLUEXP EQU   4                  LITERAL POOL USAGE (EXCL FIELD LEN)
*
MDLLUEXR DC    AL1(CSLBAOFF),AL1(MDLLUEX+2-MDLLUEX)   LOOK-UP  BUFR
         DC    AL1(CSLKPSTK),AL1(MDLLUEXS+2-MDLLUEX)  STACK  OFFSET
         DC    AL1(CStrueM),AL1(MDLLUEXT+2-MDLLUEX)  true   BRANCH
         DC    AL1(CSFALSEM),AL1(MDLLUEXF+2-MDLLUEX)  FALSE  BRANCH
         DC    AL1(CSLtroff),AL1(MDLLUEXb+2-MDLLUEX)  Logictbl off
         DC   2XL1'FF'
*
                        SPACE 3

***********************************************************************
*        GO TO                                                        *
***********************************************************************
MDLGOTO  jlu   *+l'*              BRANCH
MDLGOTOL EQU   *-MDLGOTO
*
MDLGOTOP EQU   0                  LITERAL POOL USAGE (EXCL FIELD LEN)
*
MDLGOTOR DC    AL1(CSTRUEO),AL1(MDLGOTO+02-MDLGOTO) BRANCH ROW    ADDR
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        CFCC                                                         *
***********************************************************************
MDLCFCC  jlu   *+l'*              BRANCH
MDLCFCCL EQU   *-MDLCFCC
*
MDLCFCCP EQU   0                  LITERAL POOL USAGE (EXCL FIELD LEN)
*
MDLCFCCR DC    AL1(CSFALSEO),AL1(MDLCFCC+02-MDLCFCC) BRANCH ROW  ADDR
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        WRITE EXTRACT RECORD  -  NO EXIT                             *
***********************************************************************
MDLWRXT  llgt  R5,0(,R2)          LOAD   LOGIC TBL ROW     ADDRESS
         BAS   R10,WRTEXT_Indirect BRANCH AND WRITE EXTRACT RECORD
*        BAS   R10,MULTOCC        PRINT  MULTIPLE OCCURRENCE LINES
MDLWRXTL EQU   *-MDLWRXT
*
MDLWRXTP EQU   4                  LITERAL POOL USAGE (EXCL FIELD LEN)
*
MDLWRXTR DC    AL1(CSLTROFF),AL1(MDLWRXT+02-MDLWRXT) LOGIC TBL ROW ADDR
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        WRITE SUMMARIZED EXTRACT RECORD                              *
***********************************************************************
MDLWRSU  llgt  R5,0(,R2)          LOAD   LOGIC TBL ROW     ADDRESS
         LAY   R15,WRTSUM         BRANCH AND WRITE EXTRACT RECORD
         BASR  R10,R15
MDLWRSUL EQU   *-MDLWRSU
*
MDLWRSUP EQU   4                  LITERAL POOL USAGE (EXCL FIELD LEN)
*
MDLWRSUR DC    AL1(CSLTROFF),AL1(MDLWRSU+02-MDLWRSU) LOGIC TBL ROW ADDR
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        WRITE DATA AREA       -  NO EXIT                             *
***********************************************************************
MDLWRDT  llgt  R5,0(,R2)          LOAD   LOGIC TBL ROW  ADDRESS
         BAS   R10,WRTDT_indirect BRANCH AND WRITE EXTRACT RECORD
MDLWRDTL EQU   *-MDLWRDT
*
MDLWRDTP EQU   4                  LITERAL POOL USAGE (EXCL FIELD LEN)
*
MDLWRDTR DC    AL1(CSLTROFF),AL1(MDLWRDT+02-MDLWRDT) LOGIC TBL ROW ADDR
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        WRITE TOKEN DATA AREA -  NO EXIT                             *
***********************************************************************
MDLWRTK  llgt  R5,0(,R2)                 LOAD LOgic table row addr
         llgt  r1,ltwr200a-logictbl(,r5) Get adddress            pgc100
         llgt  r1,VDP0200b_file_reader-VDP0200b_file_record(,r1) pgc100
         lgf   r15,ltreindx-logictbl(,r1)  Get index for RETK    pgc100
         mghi  r15,8                       Make it a word        pgc101
         aghi  r15,litphdrl                Allow for litpool hdr pgc100
         lgr   r0,r15                      Save offset for later pgc101
         llgt  r14,lp_base_litp            Get base literal pool pgc100
         llgt  r15,0-524288(r15,r14)       Get offset to litpool pgc100
         lgr   r3,r14                      save base litp        pgc101
         agr   r14,r15                     Point at it           pgc100
         lgf   r15,ltfilcnt-logictbl(,r1)  Get ltfilcnt litp off.pgc100
         agr   r14,r15                     Point at it           pgc100
         llgt  r1,ltwrexta-logictbl(,r5)   Point to EXTFILE
         using EXTFILE,R1
         lgf   r5,ltwrlubo-logictbl(,r5) get lkupbufr offset
         llgt  r5,0(r5,r2)               get the buffer itself
         lgr   r15,r0                    Get RETK offset inlitp  pgc101
         sty   r5,4-524288(r15,r3)       Save lkup bufr for RETK pgc101
         agsi  0(r14),bin1               Increment count           @05I
         mvc   lblstcnt-lkupbufr(l'lblstcnt,r5),0(r14) save rec no.@05I
         XC    LBLSTRC-LKUPBUFR(L'LBLSTRC,R5),LBLSTRC-LKUPBUFR(R5)
         LA    R14,EXSRTKEY-EXTREC(,R7)  LOAD EXTRACT RECORD ADDRESS
MDLWRTKA aghi  R14,0                     ADVANCE   TO DATA   AREA
         lgh   R15,LBRECLEN-LKUPBUFR(,R5)
         agsi  extcnt,bin1                 Increment records written
         lg    r0,extbytec
         agr   r0,r15
         stg   r0,extbytec
         DROP  R1 EXTFILE
         LA    R0,LBDATA-LKUPBUFR(,R5)
         lgr   R1,R15
         MVCL  R0,R14                     MOVE DATA AREA TO TOKEN
*
MDLWRTKB llgt  R5,0(,R2)                  LOAD LOGIC TBL ROW ADDR
         lgf   R14,LTWREXTO-LOGICTBL(,R5) LOAD "LTWRAREA" address
         agr   R14,R2
         agsi  LTWRCNTi-LTWRAREA(R14),bin1 INCREMENT COUNT
         agsi  LTWRCNTO-LTWRAREA(R14),bin1 INCREMENT COUNT
MDLWRTKC EQU   *
MDLWRTKL EQU   *-MDLWRTK
*
MDLWRTKP EQU   4+4                LITERAL POOL USAGE (EXCL FIELD LEN)
*
MDLWRTKR DC    AL1(CSLTROFF),AL1(MDLWRTK+02-MDLWRTK) LOGIC TBL ROW ADR
         DC    AL1(CSSRTLEN),AL1(MDLWRTKA+02-MDLWRTK) SORT  KEY LENGTH
         DC    AL1(CSLTROFF),AL1(MDLWRTKB+02-MDLWRTK) LOGIC TBL ROW ADR
         DC    AL1(CSCALLVW),AL1(MDLWRTKC+00-MDLWRTK) CALL VIEW CODE
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        WRITE TOKEN RECORD    -  EXIT                                *
***********************************************************************
MDLWRTX  llgt  R5,0(,R2)          LOAD LOGIC  TABLE  ROW ADDRESS
         LAY   R15,WRTTKN         BRANCH AND WRITE EXTRACT RECORD
         BASR  R10,R15
         chi   r15,8              did exit say ignore this record
         je    *+4+callview_dsect_l  Y: then bypass token code
MDLWRTXC EQU   *
MDLWRTXL EQU   *-MDLWRTX
*
MDLWRTXP EQU   4                  LITERAL POOL USAGE
*
MDLWRTXR DC    AL1(CSLTROFF),AL1(MDLWRTX+02-MDLWRTX) LOGIC TBL ROW ADDR
         DC    AL1(CSCALLVW),AL1(MDLWRTXC+00-MDLWRTX) CALL VIEW CODE
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        EVENT FILE END-OF-TOKEN-SET                                  *
***********************************************************************
MDLET    llgt  R5,0(,R2)          LOAD   LOGIC TBL ROW     ADDRESS pgc
baselp   using litp_hdr+524288,r15                                pgc99
         llgt  r15,lp_base_litp             base lit pool
         lgf   R0,baselp.Lplurtnc           Pick up last RC
         lgf   r14,ltesretn-logictbl(,r5)   Get offset in litpool pgc1
         llgt  r15,0(r14,r2)                Get return point      pgc1
         lgf   r14,ltespr11-logictbl(,r5)   Get offset in litpool pgc1
         llgt  r11,0(r14,r2)                Get previous r11      pgc1
         lgf   r14,lp_prev_litpo            prev litpl offset     pgc99
         lg    r6,lp_r6_save              Get old event rec addr
         llgt  r2,lp_base_litp              base literal pool     pgc99
         agr   r2,r14                Address of prev lit pool     pgc99
         CHI   R0,4                        RECALL(RC=4) ???
         drop  baselp                                             pgc99
         BNER  R15                         NO - RETURN NORMALLY
*
         aghi  R15,-CALLVIEW_dsect_l-MDLWRTXL                          +
                                     BACKUP TO TOKEN WRITER CALL
         BR    R15
MDLETL   EQU   *-MDLET
*
MDLETP   EQU   4                                                 pgc1
*
MDLETR   DC    AL1(CSLTROFF),AL1(MDLET+02-MDLET) LOG TBL ROW ADDRpgc1
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        EVENT FILE END-OF-SET - WITHOUT READ LIMIT                   *
***********************************************************************
MDLES    B     EVNTPREV           READ  NEXT EVENT RECORD
         B     EVNTPREV           READ  NEXT EVENT RECORD (DUPLICATE)
MDLESL   EQU   *-MDLES
MDLESP   EQU   0
MDLESR   DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        EVENT FILE END-OF-SET - WITH READ LIMIT                      *
***********************************************************************
MDLESRL  BC    0,0(,0)             NOP (4 BYTES OF FILLER)
MDLESRLA LAY   R14,0(,R2)
         clc   GPRECCNT,0(R14) READ LIMIT REACHED ???
         BNL   EVNTEOF_indirect   YES - TREAT AS END-OF-FILE
mdlesrl_exit B     EVNTPREV           READ  NEXT EVENT RECORD
MDLESRLL EQU   *-MDLESRL
*
MDLESRLP EQU   8                  LITERAL POOL USAGE (LIMIT PL8)
*
MDLESRLR DC    AL1(CSV1OFF),AL1(MDLESRLA+02-MDLESRL)   VALUE  1  OFF
         DC   2XL1'FF'            END OF RELOCATION TABLE
                        SPACE 3
***********************************************************************
*        END-OF-TABLE                                                 *
***********************************************************************
MDLEN    DC    XL4'FFFFFFFF'      END-OF-TABLE MARKER
MDLENL   EQU   *-MDLEN
MDLENP   EQU   0
MDLENR   DC   2XL1'FF'
                        EJECT
***********************************************************************
*        VARIABLE "SET"  -  CONSTANT (not DFP)                        *
***********************************************************************
MDLsC01  LAY   R14,0(,R2)         LOAD ACCUMULATOR ADDR (CHG'D TO "LY")
MDLsC01A LAY   R15,0(,R2)         LOAD CONSTANT    ADDR
MDLsC01V MVC   0(0,R14),0(R15)
MDLsC01L EQU   *-MDLsC01
*
MDLsC01P EQU   4                  LITERAL POOL USAGE (EXCL FIELD LEN)
*
MDLsC01R DC    AL1(CSACCOFF),AL1(MDLsC01+02-MDLsC01)  ACCUM  ADDR
         DC    AL1(CSACCVAL),AL1(MDLsC01A+02-MDLsC01) VALUE  OFFSET
         DC    AL1(CSACCLEN),AL1(MDLsC01V+01-MDLsC01) VALUE  LENGTH
         DC   2XL1'FF'
MDLsc01_b8 LAY R14,0(,R2)         LOAD ACCUMULATOR ADDR (CHG'D TO "LY")
MDLsc01_b8A LAY R15,0(,R2)        LOAD CONSTANT    ADDR
MDLsc01_b8V MVC 0(0,R14),0(R15)
MDLsc01_b8L EQU *-MDLsc01_b8
*
MDLsc01_b8P EQU 4                 LITERAL POOL USAGE (EXCL FIELD LEN)
*
MDLsc01_b8R DC AL1(CSACCOFF),AL1(MDLsc01_b8+02-MDLsc01_b8) ACCUM ADDR
         DC    AL1(CSACCVAL),AL1(MDLsc01_b8A+02-MDLsc01_b8) VALUE OFFS
         DC    AL1(CSACCLEN),AL1(MDLsc01_b8V+01-MDLsc01_b8) VALUE LEN
         DC   2XL1'FF'
***********************************************************************
*        VARIABLE "SET"  -  CONSTANT (DFP)                            *
***********************************************************************
MDLsC02  LAY   R14,0(,R2)         LOAD ACCUMULATOR ADDR (CHG'D TO "LY")
MDLsC02A LAY   R15,0(,R2)         LOAD CONSTANT    ADDR
MDLsC02V MVC   0(0,R14),0(R15)
         ld    fp0,0(0,r14)       need to load the FP registers as well
         ld    fp2,8(0,r14)
MDLsC02L EQU   *-MDLsC02
*
MDLsC02P EQU   4                  LITERAL POOL USAGE (EXCL FIELD LEN)
*
MDLsC02R DC    AL1(CSACCOFF),AL1(MDLsC02+02-MDLsC02)  ACCUM  ADDR
         DC    AL1(CSACCVAL),AL1(MDLsC02A+02-MDLsC02) VALUE  OFFSET
         DC    AL1(CSACCLEN),AL1(MDLsC02V+01-MDLsC02) VALUE  LENGTH
         DC   2XL1'FF'
                        EJECT
***********************************************************************
*        VARIABLE "ADD"  -  CONSTANT     (BINARY FULLWORD)            *
***********************************************************************
MDLAC03  LAY   R14,0(,R2)         LOAD ACCUMULATOR ADDR (CHG'D TO "LY")
         l     R0,0(,R14)
MDLAC03V AY    R0,0(,R2)
         ST    R0,0(,R14)
MDLAC03L EQU   *-MDLAC03
*
MDLAC03P EQU   4                  LITERAL POOL USAGE
*
MDLAC03R DC    AL1(CSACCOFF),AL1(MDLAC03+02-MDLAC03)  ACCUM  ADDR
         DC    AL1(CSACCVAL),AL1(MDLAC03V+02-MDLAC03) VALUE  OFFSET
         DC   2XL1'FF'
*
***********************************************************************
*        VARIABLE "ADD"  -  CONSTANT     (BINARY 8)                   *
***********************************************************************
MDLAC03_b8  LAY   R14,0(,R2)    LOAD ACCUMULATOR ADDR (CHG'D TO "LY")
            LG    R0,0(,R14)
MDLAC03_b8V AG    R0,0(,R2)
            STG   R0,0(,R14)
MDLAC03_b8L EQU   *-MDLAC03_b8
*
MDLAC03_b8p EQU   4                  LITERAL POOL USAGE
*
MDLAC03_b8R DC    AL1(CSACCOFF),AL1(MDLAC03_b8+02-MDLAC03_b8)  ACC ADR
            DC    AL1(CSACCVAL),AL1(MDLAC03_b8V+02-MDLAC03_b8) VAL OFF
            DC   2XL1'FF'
*
                        EJECT
***********************************************************************
*        VARIABLE "SUBTRACT"      (BINARY FULLWORD)                   *
***********************************************************************
MDLAC05  LAY   R14,0(,R2)         LOAD ACCUMULATOR ADDR (CHG'D TO "LY")
         L     R0,0(,R14)
MDLAC05V SY    R0,0(,R2)
         ST    R0,0(,R14)
MDLAC05L EQU   *-MDLAC05
*
MDLAC05P EQU   4                  LITERAL POOL USAGE
*
MDLAC05R DC    AL1(CSACCOFF),AL1(MDLAC05+02-MDLAC05)  ACCUM  ADDR
         DC    AL1(CSACCVAL),AL1(MDLAC05V+02-MDLAC05) VALUE  OFFSET
         DC   2XL1'FF'
*
***********************************************************************
*        VARIABLE "Subtract"             (BINARY 8)                   *
***********************************************************************
MDLAC05_b8  LAY   R14,0(,R2)    LOAD ACCUMULATOR ADDR (CHG'D TO "LY")
            LG    R0,0(,R14)
MDLAC05_b8V SG    R0,0(,R2)
            STG   R0,0(,R14)
MDLAC05_b8L EQU   *-MDLAC05_b8
*
MDLAC05_b8p EQU   4                  LITERAL POOL USAGE
*
MDLAC05_b8R DC    AL1(CSACCOFF),AL1(MDLAC05_b8+02-MDLAC05_b8)  ACC ADR
            DC    AL1(CSACCVAL),AL1(MDLAC05_b8V+02-MDLAC05_b8) VAL OFF
            DC   2XL1'FF'
*
                        EJECT
***********************************************************************
*        ADD  TO  ACCUM          (PACKED)                             *
***********************************************************************
MDLAC06  LAY   R14,0(,R2)         LOAD ACCUMULATOR ADDR (CHG'D TO "LY")
MDLAC06A LAY   R15,0(,0)          LOAD SOURCE  FLD ADDRESS
MDLAC06B ZAP   WORKAREA,0(0,R15) CONVERT SOURCE FIELD
         lmg   r0,r1,workarea
         cxstr fp1,r0
MDLAC06C lghi  r15,*-*           Create biased exponent
         iextr fp1,fp1,r15       and insert
mdlac06d ld    fp0,0(0,r14)
         ld    fp2,8(0,r14)
         axtr  fp0,fp0,fp1       Add
         std   fp0,0(0,r14)
         std   fp2,8(0,r14)
MDLAC06L EQU   *-MDLAC06
*
MDLAC06P EQU   4                  LITERAL POOL USAGE (EXCL FIELD LEN)
*
MDLAC06R DC    AL1(CSACCOF2),AL1(MDLAC06+02-MDLAC06)  ACCUM 2   OFFSET
         DC    AL1(CSTGTLOF),AL1(MDLAC06A+02-MDLAC06) TARGET    OFFSET
         DC    AL1(CSTGTLNR),AL1(MDLAC06B+01-MDLAC06) TARGET    LENGTH
         DC    AL1(CSdfpexp),AL1(MDLAC06C+02-MDLAC06) dfp exp
         DC    AL1(CSdfpopt),AL1(MDLAC06d-MDLAC06) optimise loads
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        ADD  TO  ACCUM          (NUMERIC)                            *
***********************************************************************
MDLAC07  LAY   R14,0(,R2)         LOAD ACCUMULATOR ADDR (CHG'D TO "LY")
MDLAC07A LAY   R15,0(,0)                 LOAD SOURCE  FLD ADDRESS
MDLAC07B PACK  WORKAREA,0(0,R15)  CONVERT SOURCE FIELD
         lmg   r0,r1,workarea
         cxstr fp1,r0
mdlac07c lghi  r15,*-*            Create biased exponent
         iextr fp1,fp1,r15          and insert
mdlac07d ld    fp0,0(0,r14)
         ld    fp2,8(0,r14)
         axtr  fp0,fp0,fp1       Add
         std   fp0,0(0,r14)
         std   fp2,8(0,r14)
MDLAC07L EQU   *-MDLAC07
*
MDLAC07P EQU   4                  LITERAL POOL USAGE (EXCL FIELD LEN)
*
MDLAC07R DC    AL1(CSACCOF2),AL1(MDLAC07+02-MDLAC07)  ACCUM 2   OFFSET
         DC    AL1(CSTGTLOF),AL1(MDLAC07A+02-MDLAC07) TARGET    OFFSET
         DC    AL1(CSTGTLNR),AL1(MDLAC07B+01-MDLAC07) TARGET    LENGTH
         DC    AL1(CSdfpexp),AL1(MDLAC07C+02-MDLAC07) SHIFT DEC PLACES
         DC    AL1(CSdfpopt),AL1(MDLAC07d-MDLAC07) optimise loads
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        ADD  TO  ACCUM          (BINARY)                             *
***********************************************************************
MDLAC08  LAY   R14,0(,R2)         LOAD ACCUMULATOR ADDR (CHG'D TO "LY")
         Xgr   R0,R0              LOAD BINARY NUMBER
MDLAC08S TMy   0(0),X'80'
         if (o)
           lghi r0,-1             fill with 1's
         endif
MDLAC08A ICMy  R0,B'0000',0(0)
         cxgtr fp1,r0             convert to extended DFP
mdlac08b lghi  r15,*-*            Create biased exponent
         iextr fp1,fp1,r15          and insert
mdlac08d ld    fp0,0(0,r14)
         ld    fp2,8(0,r14)
         axtr  fp0,fp0,fp1       Add
         std   fp0,0(0,r14)
         std   fp2,8(0,r14)
MDLAC08L EQU   *-MDLAC08
*
MDLAC08P EQU   4                  LITERAL POOL USAGE (EXCL FIELD LEN)
*
MDLAC08R DC    AL1(CSACCOF2),AL1(MDLAC08+02-MDLAC08)  ACCUM 2   OFFSET
         DC    AL1(CSTGTloF),AL1(MDLAC08S+02-MDLAC08) TARGET    OFFSET
         DC    AL1(CSBYTMSK),AL1(MDLAC08A+01-MDLAC08) ICM  BYTE MASK
         DC    AL1(CSTGTloF),AL1(MDLAC08A+02-MDLAC08) TARGET    OFFSET
         DC    AL1(CSdfpexp),AL1(MDLAC08B+02-MDLAC08) DFP EXP
         DC    AL1(CSdfpopt),AL1(MDLAC08d-MDLAC08) optimise loads
         DC   2XL1'FF'
***********************************************************************
*        ADD  TO  ACCUM          (BINARY unsigned)                    *
***********************************************************************
MDLac08u LAY   R14,0(,R2)         LOAD ACCUMULATOR ADDR (CHG'D TO "LY")
         Xgr   R0,R0              LOAD BINARY NUMBER
MDLac08uA ICMy R0,B'0000',0(0)
         cxgtr fp1,r0             convert to extended DFP
mdlac08ub lghi  r15,*-*            Create biased exponent
         iextr fp1,fp1,r15          and insert
mdlac08ud ld    fp0,0(0,r14)
         ld    fp2,8(0,r14)
         axtr  fp0,fp0,fp1       Add
         std   fp0,0(0,r14)
         std   fp2,8(0,r14)
MDLac08uL EQU  *-MDLac08u
*
MDLac08uP EQU  4                  LITERAL POOL USAGE (EXCL FIELD LEN)
*
MDLac08uR DC   AL1(CSACCOF2),AL1(MDLac08u+02-MDLac08u) ACCUM 2  OFFSET
         DC    AL1(CSBYTMSK),AL1(MDLac08uA+01-MDLac08u) ICM BYTE MASK
         DC    AL1(CSTGTloF),AL1(MDLac08uA+02-MDLac08u) TARGET  OFFSET
         DC    AL1(CSdfpexp),AL1(MDLac08uB+02-MDLac08u) DFP Exponent
         DC    AL1(CSdfpopt),AL1(MDLac08ud-MDLac08u) DFP optimise
         DC   2XL1'FF'
***********************************************************************
*        Add to accumlator   BINARY  SOURCE 8 byte                    *
***********************************************************************
MDLAC08_b8  LAY   R14,0(,R2)    LOAD ACCUMULATOR ADDR (CHG'D TO "LY")
MDLAC08_b8A LG    R0,0(,0)
         cxgtr fp1,r0             convert to extended DFP
mdlac08_b8c lghi  r15,*-*            Create biased exponent
         iextr fp1,fp1,r15          and insert
mdlac08_b8d ld    fp0,0(0,r14)
         ld    fp2,8(0,r14)
         axtr  fp0,fp0,fp1       Add
         std   fp0,0(0,r14)
         std   fp2,8(0,r14)
MDLAC08_b8L EQU   *-MDLAC08_b8
*
MDLAC08_b8P EQU   4             LITERAL POOL USAGE (EXCL FIELD LEN)
*
MDLAC08_B8R DC AL1(CSACCOF2),AL1(MDLAC08_b8+02-MDLAC08_b8) ACCUM  2 OFF
         DC   AL1(CSTGTlof),AL1(MDLAC08_b8A+02-MDLAC08_b8) TARGET OFF
         DC   AL1(CSdfpexp),AL1(MDLAC08_b8C+02-MDLAC08_b8) shift
         DC   AL1(CSdfpopt),AL1(MDLAC08_b8d-MDLAC08_b8) optimise loads
         DC   2XL1'FF'
                        EJECT
***********************************************************************
*        SUBTRACT FROM ACCUM     (PACKED)                             *
***********************************************************************
MDLAC09  LAY   R14,0(,R2)         LOAD ACCUMULATOR ADDR (CHG'D TO "LY")
MDLAC09A LAY   R15,0(,0)                 LOAD SOURCE  FLD ADDRESS
MDLAC09B ZAP   WORKAREA,0(0,R15)  CONVERT SOURCE FIELD
         lmg   r0,r1,workarea
         cxstr fp1,r0
MDLAC09C lghi  r15,*-*           Create biased exponent
         iextr fp1,fp1,r15       and insert
mdlac09d ld    fp0,0(0,r14)
         ld    fp2,8(0,r14)
         sxtr  fp0,fp0,fp1
         std   fp0,0(0,r14)
         std   fp2,8(0,r14)
MDLAC09L EQU   *-MDLAC09
*
MDLAC09P EQU   4                  LITERAL POOL USAGE (EXCL FIELD LEN)
*
MDLAC09R DC    AL1(CSACCOF2),AL1(MDLAC09+02-MDLAC09)  ACCUM ADR OFFSET
         DC    AL1(CSTGTLOF),AL1(MDLAC09A+02-MDLAC09) TARGET    OFFSET
         DC    AL1(CSTGTLNR),AL1(MDLAC09B+01-MDLAC09) TARGET    LENGTH
         DC    AL1(CSdfpexp),AL1(MDLAC09C+02-MDLAC09) dfp exp
         DC    AL1(CSdfpopt),AL1(MDLAC09d-MDLAC09) optimise loads
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        SUBTRACT FROM ACCUM     (NUMERIC)                            *
***********************************************************************
MDLAC10  LAY   R14,0(,R2)         LOAD ACCUMULATOR ADDR (CHG'D TO "LY")
MDLAC10A LAY   R15,0(,0)                 LOAD SOURCE  FLD ADDRESS
MDLAC10B PACK  WORKAREA,0(0,R15)  CONVERT SOURCE FIELD
         lmg   r0,r1,workarea
         cxstr fp1,r0
mdlac10c lghi  r15,*-*            Create biased exponent
         iextr fp1,fp1,r15          and insert
mdlac10d ld    fp0,0(0,r14)
         ld    fp2,8(0,r14)
         sxtr  fp0,fp0,fp1
         std   fp0,0(0,r14)
         std   fp2,8(0,r14)
MDLAC10L EQU   *-MDLAC10
*
MDLAC10P EQU   4                  LITERAL POOL USAGE (EXCL FIELD LEN)
*
MDLAC10R DC    AL1(CSACCOF2),AL1(MDLAC10+02-MDLAC10)  ACCUM ADR OFFSET
         DC    AL1(CSTGTLOF),AL1(MDLAC10A+02-MDLAC10) TARGET    OFFSET
         DC    AL1(CSTGTLNR),AL1(MDLAC10B+01-MDLAC10) TARGET    LENGTH
         DC    AL1(CSdfpexp),AL1(MDLAC10C+02-MDLAC10) SHIFT DEC PLACES
         DC    AL1(CSdfpopt),AL1(MDLAC10d-MDLAC10) optimise loads
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        SUBTRACT FROM ACCUM     (BINARY)                             *
***********************************************************************
MDLAC11  LAY   R14,0(,R2)         LOAD ACCUMULATOR ADDR (CHG'D TO "LY")
         xgr   R0,R0              LOAD BINARY NUMBER
MDLAC11S TMy   0(0),X'80'
         if (o)
           lghi r0,-1             fill with 1's
         endif
MDLAC11A ICMy  R0,B'0000',0(0)
         cxgtr fp1,r0             convert to extended DFP
mdlac11b lghi  r15,*-*            Create biased exponent
         iextr fp1,fp1,r15          and insert
mdlac11d ld    fp0,0(0,r14)
         ld    fp2,8(0,r14)
         sxtr  fp0,fp0,fp1
         std   fp0,0(0,r14)
         std   fp2,8(0,r14)
MDLAC11L EQU   *-MDLAC11
*
MDLAC11P EQU   4                  LITERAL POOL USAGE (EXCL FIELD LEN)
*
MDLAC11R DC    AL1(CSACCOF2),AL1(MDLAC11+02-MDLAC11)  ACCUM ADR OFFSET
         DC    AL1(CSTGTloF),AL1(MDLAC11S+02-MDLAC11) TARGET    OFFSET
         DC    AL1(CSBYTMSK),AL1(MDLAC11A+01-MDLAC11) ICM  BYTE MASK
         DC    AL1(CSTGTloF),AL1(MDLAC11A+02-MDLAC11) TARGET    OFFSET
         DC    AL1(CSdfpexp),AL1(MDLAC11B+02-MDLAC11) DFP EXP
         DC    AL1(CSdfpopt),AL1(MDLAC11d-MDLAC11) optimise loads
         DC   2XL1'FF'
***********************************************************************
*        SUBTRACT FROM ACCUM     (BINARY) unsigned input              *
***********************************************************************
MDLac11u LAY   R14,0(,R2)         LOAD ACCUMULATOR ADDR (CHG'D TO "LY")
         Xgr   R0,R0              LOAD BINARY NUMBER
MDLac11uA ICMy R0,B'0000',0(0)
         cxgtr fp1,r0             convert to extended DFP
mdlac11ub lghi  r15,*-*            Create biased exponent
         iextr fp1,fp1,r15          and insert
mdlac11ud ld    fp0,0(0,r14)
         ld    fp2,8(0,r14)
         sxtr  fp0,fp0,fp1
         std   fp0,0(0,r14)
         std   fp2,8(0,r14)
MDLac11uL EQU  *-MDLac11u
*
MDLac11uP EQU  4                  LITERAL POOL USAGE (EXCL FIELD LEN)
*
MDLac11uR DC   AL1(CSACCOF2),AL1(MDLac11u+02-MDLac11u) ACCUM ADR OFFSET
         DC    AL1(CSBYTMSK),AL1(MDLac11uA+01-MDLac11u) ICM BYTE MASK
         DC    AL1(CSTGTloF),AL1(MDLac11uA+02-MDLac11u) TARGET  OFFSET
         DC    AL1(CSdfpexp),AL1(MDLac11uB+02-MDLac11u) DFP Exponent
         DC    AL1(CSdfpopt),AL1(MDLac11ud-MDLac11u) DFP optimise
         DC   2XL1'FF'
***********************************************************************
*        Subtract to accumlator   BINARY  SOURCE 8 byte
***********************************************************************
MDLAC11_b8  LAY   R14,0(,R2)    LOAD ACCUMULATOR ADDR (CHG'D TO "LY")
MDLAC11_b8A LG    R0,0(,0)
         cxgtr fp1,r0             convert to extended DFP
mdlac11_b8c lghi  r15,*-*            Create biased exponent
         iextr fp1,fp1,r15          and insert
mdlac11_b8d ld    fp0,0(0,r14)
         ld    fp2,8(0,r14)
         sxtr  fp0,fp0,fp1
         std   fp0,0(0,r14)
         std   fp2,8(0,r14)
MDLAC11_b8L EQU   *-MDLAC11_b8
*
MDLAC11_b8P EQU   4             LITERAL POOL USAGE (EXCL FIELD LEN)
*
MDLAC11_B8R DC AL1(CSACCOF2),AL1(MDLAC11_b8+02-MDLAC11_b8) ACCUM  2 OFF
         DC   AL1(CSTGTlof),AL1(MDLAC11_b8A+02-MDLAC11_b8) TARGET OFF
         DC   AL1(CSdfpexp),AL1(MDLAC11_b8C+02-MDLAC11_b8) shift
         DC   AL1(CSdfpopt),AL1(MDLAC11_b8d-MDLAC11_b8) optimise loads
         DC   2XL1'FF'
                        EJECT
***********************************************************************
*        MULTIPLY ACCUM          (PACKED)                             *
***********************************************************************
MDLAC12  LAY   R14,0(,R2)         LOAD ACCUMULATOR ADDR (CHG'D TO "LY")
MDLAC12A LAY   R15,0(,0)                 LOAD SOURCE  FLD ADDRESS
MDLAC12B ZAP   WORKAREA,0(0,R15)  CONVERT SOURCE FIELD
         lmg   r0,r1,workarea
         cxstr fp1,r0
MDLAC12C lghi  r15,*-*           Create biased exponent
         iextr fp1,fp1,r15       and insert
mdlac12d ld    fp0,0(0,r14)
         ld    fp2,8(0,r14)
         mxtr  fp0,fp0,fp1
         std   fp0,0(0,r14)
         std   fp2,8(0,r14)
MDLAC12L EQU   *-MDLAC12
*
MDLAC12P EQU   4                  LITERAL POOL USAGE (EXCL FIELD LEN)
*
MDLAC12R DC    AL1(CSACCOF2),AL1(MDLAC12+02-MDLAC12) ACCUM ADR OFFSET
         DC    AL1(CSTGTLOF),AL1(MDLAC12A+02-MDLAC12) TARGET    OFFSET
         DC    AL1(CSTGTLNR),AL1(MDLAC12b+01-MDLAC12) TARGET    LENGTH
         DC    AL1(CSdfpexp),AL1(MDLAC12C+02-MDLAC12) dfp exp
         DC    AL1(CSdfpopt),AL1(MDLAC12d-MDLAC12) optimise loads
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        MULTIPLY ACCUM          (NUMERIC)                            *
***********************************************************************
MDLAC13  LAY   R14,0(,R2)         LOAD ACCUMULATOR ADDR (CHG'D TO "LY")
MDLAC13A LAY   R15,0(,0)                 LOAD SOURCE  FLD ADDRESS
MDLAC13B PACK  WORKAREA,0(0,R15)  CONVERT SOURCE FIELD
         lmg   r0,r1,workarea
         cxstr fp1,r0
MDLAC13C lghi  r15,*-*           Create biased exponent
         iextr fp1,fp1,r15       and insert
mdlac13d ld    fp0,0(0,r14)
         ld    fp2,8(0,r14)
         mxtr  fp0,fp0,fp1
         std   fp0,0(0,r14)
         std   fp2,8(0,r14)
MDLAC13L EQU   *-MDLAC13
*
MDLAC13P EQU   4                  LITERAL POOL USAGE (EXCL FIELD LEN)
*
MDLAC13R DC    AL1(CSACCOF2),AL1(MDLAC13+02-MDLAC13) ACCUM ADR OFFSET
         DC    AL1(CSTGTLOF),AL1(MDLAC13A+02-MDLAC13) TARGET    OFFSET
         DC    AL1(CSTGTLNR),AL1(MDLAC13b+01-MDLAC13) TARGET    LENGTH
         DC    AL1(CSdfpexp),AL1(MDLAC13C+02-MDLAC13) dfp exp
         DC    AL1(CSdfpopt),AL1(MDLAC13d-MDLAC13) optimise loads
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        MULTIPLY ACCUM          (BINARY)                             *
***********************************************************************
MDLAC14  LAY   R14,0(,R2)         LOAD ACCUMULATOR ADDR (CHG'D TO "LY")
         xgr   R0,R0              LOAD BINARY NUMBER
MDLAC14S TMy   0(0),X'80'
         if (o)
           lghi r0,-1             fill with 1's
         endif
MDLAC14A ICMy  R0,B'0000',0(0)
         cxgtr fp1,r0             convert to extended DFP
mdlac14b lghi  r15,*-*            Create biased exponent
         iextr fp1,fp1,r15          and insert
mdlac14d ld    fp0,0(0,r14)
         ld    fp2,8(0,r14)
         mxtr  fp0,fp0,fp1
         std   fp0,0(0,r14)
         std   fp2,8(0,r14)
MDLAC14L EQU   *-MDLAC14
*
MDLAC14P EQU   4                  LITERAL POOL USAGE (EXCL FIELD LEN)
*
MDLAC14R DC    AL1(CSACCOF2),AL1(MDLAC14+02-MDLAC14)  ACCUM ADR OFFSET
         DC    AL1(CSTGTloF),AL1(MDLAC14S+02-MDLAC14) TARGET    OFFSET
         DC    AL1(CSBYTMSK),AL1(MDLAC14A+01-MDLAC14) ICM  BYTE MASK
         DC    AL1(CSTGTloF),AL1(MDLAC14A+02-MDLAC14) TARGET    OFFSET
         DC    AL1(CSdfpexp),AL1(MDLAC14B+02-MDLAC14) DFP EXP
         DC    AL1(CSdfpopt),AL1(MDLAC14d-MDLAC14) optimise loads
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        MULTIPLY ACCUM          (BINARY unsigned input)              *
***********************************************************************
MDLac14u LAY   R14,0(,R2)         LOAD ACCUMULATOR ADDR (CHG'D TO "LY")
         Xgr   R0,R0              LOAD BINARY NUMBER
MDLac14uA ICMy R0,B'0000',0(0)
         cxgtr fp1,r0             convert to extended DFP
mdlac14ub lghi  r15,*-*            Create biased exponent
         iextr fp1,fp1,r15          and insert
mdlac14ud ld    fp0,0(0,r14)
         ld    fp2,8(0,r14)
         mxtr  fp0,fp0,fp1
         std   fp0,0(0,r14)
         std   fp2,8(0,r14)
MDLac14uL EQU  *-MDLac14u
*
MDLac14uP EQU  4                  LITERAL POOL USAGE (EXCL FIELD LEN)
*
MDLac14uR DC   AL1(CSACCOF2),AL1(MDLac14u+02-MDLac14u) ACCUM ADR OFFSET
         DC    AL1(CSBYTMSK),AL1(MDLac14uA+01-MDLac14u) ICM BYTE MASK
         DC    AL1(CSTGTloF),AL1(MDLac14uA+02-MDLac14u) TARGET  OFFSET
         DC    AL1(CSdfpexp),AL1(MDLac14uB+02-MDLac14u) DFP Exponent
         DC    AL1(CSdfpopt),AL1(MDLac14ud-MDLac14u) DFP optimise
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        MULTIPLY ACCUM          (BINARY 8 byte)                      *
***********************************************************************
MDLAC14_b8  LAY   R14,0(,R2)    LOAD ACCUMULATOR ADDR (CHG'D TO "LY")
MDLAC14_b8A LG    R0,0(,0)
         cxgtr fp1,r0             convert to extended DFP
mdlac14_b8c lghi  r15,*-*            Create biased exponent
         iextr fp1,fp1,r15          and insert
mdlac14_b8d ld    fp0,0(0,r14)
         ld    fp2,8(0,r14)
         mxtr  fp0,fp0,fp1
         std   fp0,0(0,r14)
         std   fp2,8(0,r14)
MDLAC14_b8L EQU   *-MDLAC14_b8
*
MDLAC14_b8P EQU   4             LITERAL POOL USAGE (EXCL FIELD LEN)
*
MDLAC14_B8R DC AL1(CSACCOF2),AL1(MDLAC14_b8+02-MDLAC14_b8) ACCUM  2 OFF
         DC   AL1(CSTGTlof),AL1(MDLAC14_b8A+02-MDLAC14_b8) TARGET OFF
         DC   AL1(CSdfpexp),AL1(MDLAC14_b8C+02-MDLAC14_b8) shift
         DC   AL1(CSdfpopt),AL1(MDLAC14_b8d-MDLAC14_b8) optimise loads
         DC   2XL1'FF'
                        EJECT
***********************************************************************
*        DIVIDE   ACCUM          (PACKED)                             *
***********************************************************************
mdlac15  LAY   R14,0(,R2)         LOAD ACCUMULATOR ADDR (CHG'D TO "LY")
mdlac15A LAY   R15,0(,0)                 LOAD SOURCE  FLD ADDRESS
mdlac15B ZAP   WORKAREA,0(0,R15)  CONVERT SOURCE FIELD
         lmg   r0,r1,workarea
         cxstr fp1,r0
mdlac15C lghi  r15,*-*           Create biased exponent
         iextr fp1,fp1,r15       and insert
mdlac15d ld    fp0,0(0,r14)
         ld    fp2,8(0,r14)
         dxtr  fp0,fp0,fp1       divide
         std   fp0,0(0,r14)
         std   fp2,8(0,r14)
mdlac15L EQU   *-mdlac15
*
mdlac15P EQU   4                  LITERAL POOL USAGE (EXCL FIELD LEN)
*
mdlac15R DC    AL1(CSACCOF2),AL1(mdlac15+02-mdlac15) ACCUM ADR OFFSET
         DC    AL1(CSTGTLOF),AL1(mdlac15A+02-mdlac15) TARGET    OFFSET
         DC    AL1(CSTGTLNR),AL1(mdlac15b+01-mdlac15) TARGET    LENGTH
         DC    AL1(CSdfpexp),AL1(mdlac15C+02-mdlac15) dfp exp
         DC    AL1(CSdfpopt),AL1(mdlac15d-mdlac15) optimise loads
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        DIVIDE   ACCUM          (NUMERIC)                            *
***********************************************************************
mdlac16  LAY   R14,0(,R2)         LOAD ACCUMULATOR ADDR (CHG'D TO "LY")
mdlac16A LAY   R15,0(,0)                 LOAD SOURCE  FLD ADDRESS
mdlac16B PACK  WORKAREA,0(0,R15)  CONVERT SOURCE FIELD
         lmg   r0,r1,workarea
         cxstr fp1,r0
mdlac16C lghi  r15,*-*           Create biased exponent
         iextr fp1,fp1,r15       and insert
mdlac16d ld    fp0,0(0,r14)
         ld    fp2,8(0,r14)
         dxtr  fp0,fp0,fp1       Divide
         std   fp0,0(0,r14)
         std   fp2,8(0,r14)
mdlac16L EQU   *-mdlac16
*
mdlac16P EQU   4                  LITERAL POOL USAGE (EXCL FIELD LEN)
*
mdlac16R DC    AL1(CSACCOF2),AL1(mdlac16+02-mdlac16) ACCUM ADR OFFSET
         DC    AL1(CSTGTLOF),AL1(mdlac16A+02-mdlac16) TARGET    OFFSET
         DC    AL1(CSTGTLNR),AL1(mdlac16b+01-mdlac16) TARGET    LENGTH
         DC    AL1(CSdfpexp),AL1(mdlac16C+02-mdlac16) dfp exp
         DC    AL1(CSdfpopt),AL1(mdlac16d-mdlac16) optimise loads
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        DIVIDE   ACCUM          (BINARY)                             *
***********************************************************************
mdlac17  LAY   R14,0(,R2)         LOAD ACCUMULATOR ADDR (CHG'D TO "LY")
         xgr   R0,R0              LOAD BINARY NUMBER
mdlac17S TMy   0(0),X'80'
         if (o)
           lghi r0,-1             fill with 1's
         endif
mdlac17A ICMy  R0,B'0000',0(0)
         cxgtr fp1,r0             convert to extended DFP
mdlac17b lghi  r15,*-*            Create biased exponent
         iextr fp1,fp1,r15          and insert
mdlac17d ld    fp0,0(0,r14)
         ld    fp2,8(0,r14)
         dxtr  fp0,fp0,fp1        Divide
         std   fp0,0(0,r14)
         std   fp2,8(0,r14)
mdlac17L EQU   *-mdlac17
*
mdlac17P EQU   4                  LITERAL POOL USAGE (EXCL FIELD LEN)
*
mdlac17R DC    AL1(CSACCOF2),AL1(mdlac17+02-mdlac17)  ACCUM ADR OFFSET
         DC    AL1(CSTGTloF),AL1(mdlac17S+02-mdlac17) TARGET    OFFSET
         DC    AL1(CSBYTMSK),AL1(mdlac17A+01-mdlac17) ICM  BYTE MASK
         DC    AL1(CSTGTloF),AL1(mdlac17A+02-mdlac17) TARGET    OFFSET
         DC    AL1(CSdfpexp),AL1(mdlac17B+02-mdlac17) DFP EXP
         DC    AL1(CSdfpopt),AL1(mdlac17d-mdlac17) optimise loads
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        DIVIDE   ACCUM          (BINARY unsigned input               *
***********************************************************************
mdlac17u LAY   R14,0(,R2)         LOAD ACCUMULATOR ADDR (CHG'D TO "LY")
         Xgr   R0,R0              LOAD BINARY NUMBER
mdlac17uA ICMy R0,B'0000',0(0)
         cxgtr fp1,r0             convert to extended DFP
mdlac17ub lghi  r15,*-*            Create biased exponent
         iextr fp1,fp1,r15          and insert
mdlac17ud ld    fp0,0(0,r14)
         ld    fp2,8(0,r14)
         dxtr  fp0,fp0,fp1       divide
         std   fp0,0(0,r14)
         std   fp2,8(0,r14)
mdlac17uL EQU  *-mdlac17u
*
mdlac17uP EQU  4                  LITERAL POOL USAGE (EXCL FIELD LEN)
*
mdlac17uR DC   AL1(CSACCOF2),AL1(mdlac17u+02-mdlac17u) ACCUM ADR OFFSET
         DC    AL1(CSBYTMSK),AL1(mdlac17uA+01-mdlac17u) ICM BYTE MASK
         DC    AL1(CSTGTloF),AL1(mdlac17uA+02-mdlac17u) TARGET  OFFSET
         DC    AL1(CSdfpexp),AL1(mdlac17uB+02-mdlac17u) DFP Exponent
         DC    AL1(CSdfpopt),AL1(mdlac17ud-mdlac17u) DFP optimise
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        Divide   ACCUM          (BINARY 8 byte)                      *
***********************************************************************
mdlac17_b8  LAY   R14,0(,R2)    LOAD ACCUMULATOR ADDR (CHG'D TO "LY")
mdlac17_b8A LG    R0,0(,0)
         cxgtr fp1,r0             convert to extended DFP
mdlac17_b8c lghi  r15,*-*            Create biased exponent
         iextr fp1,fp1,r15          and insert
mdlac17_b8d ld    fp0,0(0,r14)
         ld    fp2,8(0,r14)
         dxtr  fp0,fp0,fp1
         std   fp0,0(0,r14)
         std   fp2,8(0,r14)
mdlac17_b8L EQU   *-mdlac17_b8
*
mdlac17_b8P EQU   4             LITERAL POOL USAGE (EXCL FIELD LEN)
*
mdlac17_B8R DC AL1(CSACCOF2),AL1(mdlac17_b8+02-mdlac17_b8) ACCUM  2 OFF
         DC   AL1(CSTGTlof),AL1(mdlac17_b8A+02-mdlac17_b8) TARGET OFF
         DC   AL1(CSdfpexp),AL1(mdlac17_b8C+02-mdlac17_b8) shift
         DC   AL1(CSdfpopt),AL1(mdlac17_b8d-mdlac17_b8) optimise loads
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        SET ACCUMULATOR  -  GENERIC  -  EVENT                        *
***********************************************************************
MDLAC18  llgt  R5,0(0,R2)         LOAD   LOGIC TABLE  ROW   ADDRESS
MDLAC18a LAY   R1,0(,R2)          LOAD ACCUMULATOR ADDR (CHG'D TO "LY")
mdlac18b BAS   R10,*-*            CALL "GVBDL96"  (FORMAT  FIELD)
MDLAC18F jlu   *+l'*              FORMAT UNSUCCESSFUL BRANCH (FALSE)
MDLAC18T jlu   *+l'*              FORMAT   SUCCESSFUL BRANCH (TRUE )
MDLAC18L EQU   *-MDLAC18
*
MDLAC18P EQU   4                  LITERAL POOL USAGE (EXCL FIELD LEN)
*
MDLAC18R DC    AL1(CSLTROFF),AL1(MDLAC18+02-MDLAC18)  LOGIC TABLE ROW
         DC    AL1(CSACCOF2),AL1(MDLAC18A+02-MDLAC18) ACCUM    OFFSET
         DC    AL1(CSdl96call),AL1(MDLAC18b-MDLAC18)  MR96 BAS
         DC    AL1(CSFALSEM),AL1(MDLAC18F+02-MDLAC18) FALSE    BRANCH
         DC    AL1(CSTRUEO),AL1(MDLAC18T+02-MDLAC18)  TRUE     BRANCH
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        SET ACCUMULATOR  -  PACKED  SOURCE                           *
***********************************************************************
MDLAC19  LAY   R14,0(,R2)         LOAD ACCUMULATOR ADDR (CHG'D TO "LY")
MDLAC19A LAY   R15,0(,0)          LOAD SOURCE      ADDRESS
MDLAC19B ZAP   workarea,0(0,R15)
         lmg   r0,r1,workarea
         cxstr fp0,r0
mdlac19c lghi  r15,*-*            Create biased exponent
         iextr fp0,fp0,r15          and insert
         std   fp0,0(0,r14)        store first part
         std   fp2,8(0,r14)         and the second part
MDLAC19L EQU   *-MDLAC19
*
MDLAC19P EQU   4                  LITERAL POOL USAGE (EXCL FIELD LEN)
*
MDLAC19R DC    AL1(CSACCOF2),AL1(MDLAC19+02-MDLAC19)  ACCUM   2 OFFSET
         DC    AL1(CSTGTLOF),AL1(MDLAC19a+02-MDLAC19) TARGET    OFFSET
         DC    AL1(CSTGTLNR),AL1(MDLAC19B+01-MDLAC19) TARGET    LENGTH
         DC    AL1(CSDFPexp),AL1(MDLAC19C+02-MDLAC19) DFP EXP
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        SET ACCUMULATOR  -  NUMERIC SOURCE                           *
***********************************************************************
MDLAC20  LAY   R14,0(,R2)         LOAD ACCUMULATOR ADDR (CHG'D TO "LY")
MDLAC20A LAY   R15,0(,0)          LOAD SOURCE      ADDRESS
MDLAC20B PACK  workarea,0(0,R15)
         lmg   r0,r1,workarea
         cxstr fp0,r0
mdlac20c lghi  r15,*-*            Create biased exponent
         iextr fp0,fp0,r15          and insert
         std   fp0,0(0,r14)        store first part
         std   fp2,8(0,r14)         and the second part
MDLAC20L EQU   *-MDLAC20
*
MDLAC20P EQU   4                  LITERAL POOL USAGE (EXCL FIELD LEN)
*
MDLAC20R DC    AL1(CSACCOF2),AL1(MDLAC20+02-MDLAC20)  ACCUM   2 OFFSET
         DC    AL1(CSTGTLOF),AL1(MDLAC20A+02-MDLAC20) TARGET    OFFSET
         DC    AL1(CSTGTLNR),AL1(MDLAC20B+01-MDLAC20) TARGET    LENGTH
         DC    AL1(CSDFPexp),AL1(MDLAC20C+02-MDLAC20) DFP EXP
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        SET ACCUMULATOR  -  BINARY  SOURCE                           *
***********************************************************************
MDLAC21  LAY   R14,0(,R2)         LOAD ACCUMULATOR ADDR (CHG'D TO "LY")
         Xgr   R0,R0
MDLAC21S TMy   0(0),X'80'
         if (o)
           lghi r0,-1             fill with 1's
         endif
MDLAC21A ICMy  R0,B'0000',0(0)
         cxgtr fp0,r0             convert to extended DFP
mdlac21c lghi  r15,*-*            Create biased exponent
         iextr fp0,fp0,r15          and insert
         std   fp0,0(0,r14)        store first part
         std   fp2,8(0,r14)         and the second part
MDLAC21L EQU   *-MDLAC21
*
MDLAC21P EQU   4                  LITERAL POOL USAGE (EXCL FIELD LEN)
*
MDLAC21R DC    AL1(CSACCOF2),AL1(MDLAC21+02-MDLAC21)  ACCUM   2 OFFSET
         DC    AL1(CSTGTloF),AL1(MDLAC21S+02-MDLAC21) TARGET    OFFSET
         DC    AL1(CSBYTMSK),AL1(MDLAC21A+01-MDLAC21) ICM  BYTE MASK
         DC    AL1(CSTGTloF),AL1(MDLAC21A+02-MDLAC21) TARGET    OFFSET
         DC    AL1(CSDFPexp),AL1(MDLAC21C+02-MDLAC21) DFP EXP
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        SET ACCUMULATOR  -  BINARY  SOURCE unsigned                 *
***********************************************************************
MDLAC21u LAY   R14,0(,R2)         LOAD ACCUMULATOR ADDR (CHG'D TO "LY")
         Xgr   R0,R0
MDLAC21uA ICMy R0,B'0000',0(0)
         cxgtr fp0,r0             convert to DFP
mdlac21uc lghi  r15,*-*            Create biased exponent
         iextr fp0,fp0,r15          and insert
         std   fp0,0(0,r14)        store first part
         std   fp2,8(0,r14)         and the second part
MDLAC21uL EQU  *-MDLAC21u
*
MDLAC21uP EQU  4                  LITERAL POOL USAGE (EXCL FIELD LEN)
*
MDLAC21uR DC   AL1(CSACCOF2),AL1(MDLAC21u+02-MDLAC21u) ACCUM  2 OFFSET
         DC    AL1(CSBYTMSK),AL1(MDLAC21uA+01-MDLAC21u) ICM BYTE MASK
         DC    AL1(CSTGTloF),AL1(MDLAC21uA+02-MDLAC21u) TARGET  OFFSET
         DC    AL1(CSDFPEXP),AL1(MDLAC21uC+02-MDLAC21u) DFP exp
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        SET ACCUMULATOR  -  BINARY  SOURCE 8 byte                    *
***********************************************************************
MDLAC21_b8  LAY   R14,0(,R2)    LOAD ACCUMULATOR ADDR (CHG'D TO "LY")
MDLAC21_b8A LG    R0,0(0,0)
         cxgtr fp0,r0             convert to DFP
mdlac21_b8c lghi  r15,*-*            Create biased exponent
         iextr fp0,fp0,r15          and insert
         std   fp0,0(0,r14)        store first part
         std   fp2,8(0,r14)         and the second part
MDLAC21_b8L EQU   *-MDLAC21_b8
*
MDLAC21_b8P EQU   4             LITERAL POOL USAGE (EXCL FIELD LEN)
*
MDLAC21_B8R DC AL1(CSACCOF2),AL1(MDLAC21_b8+02-MDLAC21_b8) ACCUM  2 OFF
         DC   AL1(CSTGTlof),AL1(MDLAC21_b8A+02-MDLAC21_b8) TARGET OFF
         DC   AL1(CSDFPEXP),AL1(MDLAC21_b8C+02-MDLAC21_b8) DFP EXP
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        Subtract                  DFP number                         *
***********************************************************************
MDLAC22  LAY   R14,0(,R2)         LOAD ACCUMULATOR ADDR (CHG'D TO "LY")
MDLAC22V LAY   R15,0(,R2)
mdlac22d ld    fp0,0(0,r14)
         ld    fp2,8(0,r14)
         ld    fp4,0(0,r15)
         ld    fp6,8(0,r15)
         sxtr  fp0,fp0,fp4
         std   fp0,0(0,r14)
         std   fp2,8(0,r14)
MDLAC22L EQU   *-MDLAC22
*
MDLAC22P EQU   4                  LITERAL POOL USAGE
*
MDLAC22R DC    AL1(CSACCOFF),AL1(MDLAC22+02-MDLAC22)  ACCUM  ADDR
         DC    AL1(CSACCVAL),AL1(MDLAC22V+02-MDLAC22) VALUE  OFFSET
         DC    AL1(CSdfpopt),AL1(MDLAC22d-MDLAC22) dfp load optimise
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        Add constant              DFP number                         *
***********************************************************************
MDLAC23  LAY   R14,0(,R2)         LOAD ACCUMULATOR ADDR (CHG'D TO "LY")
MDLAC23V LAY   R15,0(,R2)
mdlac23d ld    fp0,0(0,r14)
         ld    fp2,8(0,r14)
         ld    fp4,0(0,r15)
         ld    fp6,8(0,r15)
         axtr  fp0,fp0,fp4
         std   fp0,0(0,r14)
         std   fp2,8(0,r14)
MDLAC23L EQU   *-MDLAC23
*
MDLAC23P EQU   4                  LITERAL POOL USAGE
*
MDLAC23R DC    AL1(CSACCOFF),AL1(MDLAC23+02-MDLAC23)  ACCUM  ADDR
         DC    AL1(CSACCVAL),AL1(MDLAC23V+02-MDLAC23) VALUE  OFFSET
         DC    AL1(CSdfpopt),AL1(MDLAC23d-MDLAC23) dfp load optimise
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        VARIABLE "ADD"           (GENEVA NUMBER)                     *
***********************************************************************
MDLAC24  LAY   R14,0(,R2)         LOAD ACCUMULATOR ADDR (CHG'D TO "LY")
MDLAC24V LAY   R15,0(,R2)
         AP    0(ACCUMLEN,R14),0(ACCUMLEN,R15)
MDLAC24L EQU   *-MDLAC24
*
MDLAC24P EQU   4                  LITERAL POOL USAGE
*
MDLAC24R DC    AL1(CSACCOFF),AL1(MDLAC24+02-MDLAC24)  ACCUM  ADDR
         DC    AL1(CSACCVAL),AL1(MDLAC24V+02-MDLAC24) VALUE  OFFSET
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        VARIABLE "SUBTRACT"      (GENEVA NUMBER)                     *
***********************************************************************
MDLAC25  LAY   R14,0(,R2)         LOAD ACCUMULATOR ADDR (CHG'D TO "LY")
MDLAC25V LAY   R15,0(,R2)
         SP    0(ACCUMLEN,R14),0(ACCUMLEN,R15)
MDLAC25L EQU   *-MDLAC25
*
MDLAC25P EQU   4                  LITERAL POOL USAGE
*
MDLAC25R DC    AL1(CSACCOFF),AL1(MDLAC25+02-MDLAC25)  ACCUM  ADDR
         DC    AL1(CSACCVAL),AL1(MDLAC25V+02-MDLAC25) VALUE  OFFSET
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        MULTIPLY ACCUM          (CONSTANT)                           *
***********************************************************************
MDLAC26  LAY   R14,0(,R2)         LOAD ACCUMULATOR ADDR (CHG'D TO "LY")
MDLAC26A LAY   R15,0(,R2)         LOAD CONSTANT    ADDRESS
mdlac26d ld    fp0,0(0,r14)
         ld    fp2,8(0,r14)
         ld    fp4,0(0,r15)
         ld    fp6,8(0,r15)
         mxtr  fp0,fp0,fp4
         std   fp0,0(0,r14)
         std   fp2,8(0,r14)
MDLAC26L EQU   *-MDLAC26
*
MDLAC26P EQU   4+4                LITERAL POOL USAGE (EXCL FIELD LEN)
*
MDLAC26R DC    AL1(CSACCOFF),AL1(MDLAC26+02-MDLAC26)  ACCUM ADR OFFSET
         DC    AL1(CSACCVAL),AL1(MDLAC26A+02-MDLAC26) CONSTANT  OFFSET
         DC    AL1(CSdfpopt),AL1(MDLAC26d-MDLAC26) dfp load optimise
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        DIVIDE   ACCUM          (CONSTANT)                           *
***********************************************************************
MDLAC27  LAY   R14,0(,R2)         LOAD ACCUMULATOR ADDR (CHG'D TO "LY")
MDLAC27A LAY   R15,0(,R2)         LOAD CONSTANT    ADDRESS
mdlac27d ld    fp0,0(0,r14)
         ld    fp2,8(0,r14)
         ld    fp4,0(0,r15)
         ld    fp6,8(0,r15)
         dxtr  fp0,fp0,fp4
         std   fp0,0(0,r14)
         std   fp2,8(0,r14)
MDLAC27L EQU   *-MDLAC27
*
MDLAC27P EQU   4+4                LITERAL POOL USAGE (EXCL FIELD LEN)
*
MDLAC27R DC    AL1(CSACCOFF),AL1(MDLAC27+02-MDLAC27) ACCUM ADR OFFSET
         DC    AL1(CSACCVAL),AL1(MDLAC27A+02-MDLAC27) CONSTANT OFFSET
         DC    AL1(CSdfpopt),AL1(MDLAC27d-MDLAC27) dfp load optimise
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        VARIABLE "SET"  -  ACCUMULATOR                               *
***********************************************************************
MDLAC28  LAY   R14,0(,R2)         LOAD ACCUMULATOR ADDR (CHG'D TO "LY")
MDLAC28A LAY   R15,0(,R2)         LOAD ACCUMULATOR ADDR (CHG'D TO "LY")
MDLAC28B MVC   0(0,R14),0(R15)
         ld    fp0,0(0,r14)       need to load the FP registers as well
         ld    fp2,8(0,r14)
MDLAC28L EQU   *-MDLAC28
*
MDLAC28P EQU   4+4                LITERAL POOL USAGE (EXCL FIELD LEN)
*
MDLAC28R DC    AL1(CSACCOFF),AL1(MDLAC28+02-MDLAC28)  ACCUM  ADDR - TGT
         DC    AL1(CSACCLEN),AL1(MDLAC28B+01-MDLAC28) ACCUM  LEN  - TGT
         DC    AL1(CSACCOF2),AL1(MDLAC28A+02-MDLAC28) ACCUM  ADDR - SRC
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        VARIABLE "ADD"           (ACCUMULATOR)                       *
***********************************************************************
MDLAC29  LAY   R14,0(,R2)         LOAD ACCUMULATOR ADDR (CHG'D TO "LY")
MDLAC29V LAY   R15,0(,R2)         LOAD ACCUMULATOR ADDR (CHG'D TO "LY")
mdlac29d ld    fp0,0(0,r14)
         ld    fp2,8(0,r14)
         ld    fp1,0(0,r15)
         ld    fp3,8(0,r15)
         axtr  fp0,fp0,fp1           Add, putting result in fp0/fp2
         std   fp0,0(0,r14)
         std   fp2,8(0,r14)
MDLAC29L EQU   *-MDLAC29
*
MDLAC29P EQU   4+4                LITERAL POOL USAGE
*
MDLAC29R DC    AL1(CSACCOFF),AL1(MDLAC29+02-MDLAC29)  ACCUM  ADDR - TGT
         DC    AL1(CSACCOF2),AL1(MDLAC29V+02-MDLAC29) ACCUM  ADDR - SRC
         DC    AL1(CSdfpopt),AL1(MDLAC29d-MDLAC29) dfp load optimise
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        VARIABLE "SUBTRACT"      (ACCUMULATOR)                       *
***********************************************************************
MDLAC30  LAY   R14,0(,R2)         LOAD ACCUMULATOR ADDR (CHG'D TO "LY")
MDLAC30V LAY   R15,0(,R2)         LOAD ACCUMULATOR ADDR (CHG'D TO "LY")
mdlac30d ld    fp0,0(0,r14)
         ld    fp2,8(0,r14)
         ld    fp1,0(0,r15)
         ld    fp3,8(0,r15)
         sxtr  fp0,fp0,fp1        Subtract, putting result in fp0/fp2
         std   fp0,0(0,r14)
         std   fp2,8(0,r14)
MDLAC30L EQU   *-MDLAC30
*
MDLAC30P EQU   4+4                LITERAL POOL USAGE
*
MDLAC30R DC    AL1(CSACCOFF),AL1(MDLAC30+02-MDLAC30)  ACCUM  ADDR - TGT
         DC    AL1(CSACCOF2),AL1(MDLAC30V+02-MDLAC30) ACCUM  ADDR - SRC
         DC    AL1(CSdfpopt),AL1(MDLAC30d-MDLAC30) dfp load optimise
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        MULTIPLY ACCUM          (ACCUMULATOR)                        *
***********************************************************************
MDLAC31  LAY   R14,0(,R2)         LOAD ACCUMULATOR ADDR (CHG'D TO "LY")
MDLAC31A LAY   R15,0(,R2)         LOAD CONSTANT    ADDRESS
mdlac31d ld    fp0,0(0,r14)
         ld    fp2,8(0,r14)
         ld    fp4,0(0,r15)
         ld    fp6,8(0,r15)
         mxtr  fp0,fp0,fp4
         std   fp0,0(0,r14)
         std   fp2,8(0,r14)
MDLAC31L EQU   *-MDLAC31
*
MDLAC31P EQU   4+4                LITERAL POOL USAGE (EXCL FIELD LEN)
*
MDLAC31R DC    AL1(CSACCOFF),AL1(MDLAC31+02-MDLAC31)  ACCUM ADR OFFSET
         DC    AL1(CSACCOF2),AL1(MDLAC31A+02-MDLAC31) CONSTANT  OFFSET
         DC    AL1(CSdfpopt),AL1(MDLAC31d-MDLAC31) dfp load optimise
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        DIVIDE   ACCUM          (ACCUMULATOR)                        *
***********************************************************************
MDLAC32  LAY   R14,0(,R2)         LOAD ACCUMULATOR ADDR (CHG'D TO "LY")
MDLAC32A LAY   R15,0(,R2)         LOAD CONSTANT    ADDRESS
mdlac32d ld    fp0,0(0,r14)
         ld    fp2,8(0,r14)
         ld    fp4,0(0,r15)
         ld    fp6,8(0,r15)
         dxtr  fp0,fp0,fp4
         std   fp0,0(0,r14)
         std   fp2,8(0,r14)
MDLAC32L EQU   *-MDLAC32
*
MDLAC32P EQU   4+4                LITERAL POOL USAGE (EXCL FIELD LEN)
*
MDLAC32R DC    AL1(CSACCOFF),AL1(MDLAC32+02-MDLAC32) ACCUM ADR OFFSET
         DC    AL1(CSACCOF2),AL1(MDLAC32A+02-MDLAC32) CONSTANT OFFSET
         DC    AL1(CSdfpopt),AL1(MDLAC32d-MDLAC32) dfp load optimise
         DC   2XL1'FF'
                        EJECT
***********************************************************************
*        ADD  TO  ACCUM          (PACKED sortable)                    *
***********************************************************************
MDLac43  LAY   R14,0(,R2)         LOAD ACCUMULATOR ADDR (CHG'D TO "LY")
MDLac43A LAY   R15,0(,0)          LOAD SOURCE  FLD ADDRESS
MDLac43b mvc   workar2(0),0(r15)  copy event field to workplace
         ic    r0,0(0,r15)        save first character into r0
         if tmll,r0,x'00f0',z     test to see if not ones
mdlac43c   xc workar2(0),hexff   flip all the bits
         endif
         ni    workar2,x'0f'      clean top nibble in workarea
MDLac43d mvo   WORKAREA,workar2(0)  CONVERT SOURCE FIELD
         ni workarea+l'workarea-1,x'f0'     clean the sign bits
         if tmll,r0,x'00f0',o     test to see if all ones
           oi workarea+l'workarea-1,x'0c'   and set sign to X'c'
         else
           oi workarea+l'workarea-1,x'0d'   and set sign to X'd'
         endif
         lmg   r0,r1,workarea
         cxstr fp1,r0
MDLAC43e lghi  r15,*-*           Create biased exponent
         iextr fp1,fp1,r15       and insert
mdlac43f ld    fp0,0(0,r14)
         ld    fp2,8(0,r14)
         axtr  fp0,fp0,fp1       Add
         std   fp0,0(0,r14)
         std   fp2,8(0,r14)
MDLac43L EQU   *-MDLac43
*
MDLac43P EQU   4                  LITERAL POOL USAGE (EXCL FIELD LEN)
*
MDLac43R DC    AL1(CSACCOF2),AL1(MDLac43+02-MDLac43)  ACCUM 2   OFFSET
         DC    AL1(CSTGTLOF),AL1(MDLac43A+02-MDLac43) TARGET    OFFSET
         DC    AL1(CSTGTLN),AL1(MDLac43b+01-MDLac43) TARGET    OFFSET
         DC    AL1(CSTGTLN),AL1(MDLac43c+01-MDLac43) TARGET    OFFSET
         DC    AL1(CSTGTLNR),AL1(MDLac43d+01-MDLac43) TARGET    LENGTH
         DC    AL1(CSdfpexp),AL1(MDLac43e+02-MDLac43) dfp exp
         DC    AL1(CSdfpopt),AL1(MDLAC43f-MDLAC43) optimise loads
         DC   2XL1'FF'
***********************************************************************
*        ADD  TO  ACCUM          (binary sortable)                    *
***********************************************************************
MDLac44  LAY   R14,0(,R2)         LOAD ACCUMULATOR ADDR (CHG'D TO "LY")
mdlac44la lay  r15,0(0,0)         get event field address
mdlac44m mvc   workarea(0),0(r15) move event field to workarea
         Xgr   R0,R0              LOAD BINARY NUMBER
         xi    workarea,x'80'      flip the top bit
         if tm,workarea,x'80',nz If negative ...
           lghi r0,-1             fill with 1's
         endif
MDLac44A ICMy  R0,B'0000',workarea
         cxgtr fp1,r0             convert to DFP
mdlac44b lghi  r15,*-*            Create biased exponent
         iextr fp1,fp1,r15          and insert
mdlac44d ld    fp0,0(0,r14)
         ld    fp2,8(0,r14)
         axtr  fp0,fp0,fp1       Add
         std   fp0,0(0,r14)
         std   fp2,8(0,r14)
MDLac44L EQU   *-MDLac44
*
MDLac44P EQU   4                  LITERAL POOL USAGE (EXCL FIELD LEN)
*
MDLac44R DC    AL1(CSACCOF2),AL1(MDLac44+02-MDLac44)  ACCUM 2   OFFSET
         DC    AL1(CStgtloF),AL1(MDLac44la+02-MDLac44) TARGET    OFFSET
         DC    AL1(CStgtln),AL1(MDLac44m+01-MDLac44)  length
         DC    AL1(CSBYTMSK),AL1(MDLac44A+01-MDLac44) ICM  BYTE MASK
         DC    AL1(CSdfpexp),AL1(MDLac44B+02-MDLac44) dfp exp
         DC    AL1(CSdfpopt),AL1(MDLAC44d-MDLAC44) optimise loads
         DC   2XL1'FF'
***********************************************************************
*        ADD  TO  ACCUM          (binary sortable - bin8)             *
***********************************************************************
MDLac44_b8 LAY R14,0(,R2)         LOAD ACCUMULATOR ADDR (CHG'D TO "LY")
mdlac44_b8la lay r15,0(0,0)       get event field address
mdlac44_b8m mvc workarea(0),0(r15) move event field to workarea
         xi    workarea,x'80'     flip the top bit
         LG    R0,workarea
         cxgtr fp1,r0             convert to extended DFP
mdlac44_b8b lghi  r15,*-*            Create biased exponent
         iextr fp1,fp1,r15          and insert
mdlac44_b8d ld    fp0,0(0,r14)
         ld    fp2,8(0,r14)
         axtr  fp0,fp0,fp1       Add
         std   fp0,0(0,r14)
         std   fp2,8(0,r14)
MDLac44_b8L EQU *-MDLac44_b8
*
MDLac44_b8P EQU 4                 LITERAL POOL USAGE (EXCL FIELD LEN)
*
MDLac44_b8R DC AL1(CSACCOF2),AL1(MDLac44_b8+02-MDLac44_b8) ACC 2 off
         DC    AL1(CStgtloF),AL1(MDLac44_b8la+02-MDLac44_b8) Tgrt off
         DC    AL1(CStgtln),AL1(MDLac44_b8m+01-MDLac44_b8) length
         DC    AL1(CSdfpexp),AL1(MDLac44_b8B+02-MDLac44_b8) dfp exp
         DC    AL1(CSdfpopt),AL1(MDLAC44_b8d-MDLAC44_b8) DFP load opt
         DC   2XL1'FF'
***********************************************************************
*        ADD  TO  ACCUM          (BCD - packed with no sign)          *
***********************************************************************
MDLac45  LAY   R14,0(,R2)         LOAD ACCUMULATOR ADDR (CHG'D TO "LY")
MDLac45A LAY   R15,0(,0)          LOAD SOURCE  FLD ADDRESS
MDLac45B mvo   WORKAREA,0(0,R15) CONVERT SOURCE FIELD
         oi workarea+l'workarea-1,x'0F'     and set sign to X'f'
         lmg   r0,r1,workarea
         cxstr fp1,r0
MDLAC45C lghi  r15,*-*           Create biased exponent
         iextr fp1,fp1,r15       and insert
mdlac45d ld    fp0,0(0,r14)
         ld    fp2,8(0,r14)
         axtr  fp0,fp0,fp1       Add
         std   fp0,0(0,r14)
         std   fp2,8(0,r14)
MDLac45L EQU   *-MDLac45
*
MDLac45P EQU   4                  LITERAL POOL USAGE (EXCL FIELD LEN)
*
MDLac45R DC    AL1(CSACCOF2),AL1(MDLac45+02-MDLac45)  ACCUM 2   OFFSET
         DC    AL1(CSTGTLOF),AL1(MDLac45A+02-MDLac45) TARGET    OFFSET
         DC    AL1(CSTGTLNR),AL1(MDLac45B+01-MDLac45) TARGET    LENGTH
         DC    AL1(CSdfpexp),AL1(MDLAC45C+02-MDLAC45) dfp exp
         DC    AL1(CSdfpopt),AL1(MDLAC45d-MDLAC45) optimise loads
         DC   2XL1'FF'
***********************************************************************
*        ADD  TO  ACCUM          (edit)                               *
***********************************************************************
MDLac46  llgt  R5,0(,R2)          load logic table row address
         LA    R1,WORKAREA
mdlac46c BAS   R10,*-*            CONVERT EDITED/MASKED  NUMERIC
MDLac46A jlu   *+l'*              FORMAT UNSUCCESSFUL BRANCH (FALSE)
*        do NOT use R14 here as it gets NOPed out
MDLac46b LAY   R1,0(,R2)         LOAD ACCUMULATOR ADDR (CHG'D TO "LY")
         ld    fp0,0(0,r1)        and load into fp regs
         ld    fp2,8(0,r1)
         ld    fp4,workarea
         ld    fp6,workarea+8
         axtr  fp0,fp0,fp4
         std   fp0,0(0,r1)
         std   fp2,8(0,r1)
MDLac46L EQU   *-MDLac46
*
MDLac46P EQU   4                  LITERAL POOL USAGE (EXCL FIELD LEN)
*
mdlac46r DC    AL1(CSltroff),AL1(MDLac46+02-MDLac46)  TARGET    OFFSET
         DC    AL1(CSdl96call),AL1(MDLAC46c-MDLAC46)  MR96 BAS
         DC    AL1(CSFALSEO),AL1(MDLac46A+2-MDLac46)  FALSE  BRANCH
         DC    AL1(CSACCOF2),AL1(MDLac46b+02-MDLac46) acc 2   OFFSET
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        subtract  from accum     (PACKED sortable)                   *
***********************************************************************
MDLac47  LAY   R14,0(,R2)         LOAD ACCUMULATOR ADDR (CHG'D TO "LY")
MDLac47A LAY   R15,0(,0)          LOAD SOURCE  FLD ADDRESS
MDLac47b mvc   workar2(0),0(r15)  copy event field to workplace
         ic    r0,0(0,r15)        save first character into r0
         if tmll,r0,x'00f0',z     test to see if not ones
mdlac47c   xc workar2(0),hexff   flip all the bits
         endif
         ni    workar2,x'0f'      clean top nibble in workarea
MDLac47d mvo   WORKAREA,workar2(0)  CONVERT SOURCE FIELD
         ni workarea+l'workarea-1,x'f0'   clean the sign bits
         if tmll,r0,x'00f0',o     test to see if all ones
           oi workarea+l'workarea-1,x'0c' and set sign to X'c'
         else
           oi workarea+l'workarea-1,x'0d' and set sign to X'd'
         endif
         lmg   r0,r1,workarea
         cxstr fp1,r0
MDLAC47e lghi  r15,*-*           Create biased exponent
         iextr fp1,fp1,r15       and insert
mdlac47f ld    fp0,0(0,r14)
         ld    fp2,8(0,r14)
         sxtr  fp0,fp0,fp1       Add
         std   fp0,0(0,r14)
         std   fp2,8(0,r14)
MDLac47L EQU   *-MDLac47
*
MDLac47P EQU   4                  LITERAL POOL USAGE (EXCL FIELD LEN)
*
MDLac47R DC    AL1(CSACCOF2),AL1(MDLac47+02-MDLac47)  ACCUM 2   OFFSET
         DC    AL1(CSTGTLOF),AL1(MDLac47A+02-MDLac47) TARGET    OFFSET
         DC    AL1(CSTGTLN),AL1(MDLac47b+01-MDLac47) TARGET    OFFSET
         DC    AL1(CSTGTLN),AL1(MDLac47c+01-MDLac47) TARGET    OFFSET
         DC    AL1(CSTGTLNR),AL1(MDLac47d+01-MDLac47) TARGET    LENGTH
         DC    AL1(CSdfpexp),AL1(MDLac47e+02-MDLac47) dfp exp
         DC    AL1(CSdfpopt),AL1(MDLAC47f-MDLAC47) optimise loads
         DC   2XL1'FF'
***********************************************************************
*        subtract  from accum    (binary sortable)                    *
***********************************************************************
MDLac48  LAY   R14,0(,R2)         LOAD ACCUMULATOR ADDR (CHG'D TO "LY")
mdlac48la lay  r15,0(0,0)         get event field address
mdlac48m mvc   workarea(0),0(r15) move event field to workarea
         Xgr   R0,R0              LOAD BINARY NUMBER
         xi    workarea,x'80'      flip the top bit
         if tm,workarea,x'80',nz If negative ...
           lghi r0,-1             fill with 1's
         endif
MDLac48A ICMy  R0,B'0000',workarea
         cxgtr fp1,r0             convert to DFP
mdlac48b lghi  r15,*-*            Create biased exponent
         iextr fp1,fp1,r15          and insert
mdlac48d ld    fp0,0(0,r14)
         ld    fp2,8(0,r14)
         sxtr  fp0,fp0,fp1       Add
         std   fp0,0(0,r14)
         std   fp2,8(0,r14)
MDLac48L EQU   *-MDLac48
*
MDLac48P EQU   4                  LITERAL POOL USAGE (EXCL FIELD LEN)
*
MDLac48R DC    AL1(CSACCOF2),AL1(MDLac48+02-MDLac48)  ACCUM 2   OFFSET
         DC    AL1(CStgtloF),AL1(MDLac48la+02-MDLac48) TARGET    OFFSET
         DC    AL1(CStgtln),AL1(MDLac48m+01-MDLac48)  length
         DC    AL1(CSBYTMSK),AL1(MDLac48A+01-MDLac48) ICM  BYTE MASK
         DC    AL1(CSdfpexp),AL1(MDLac48B+02-MDLac48) dfp exp
         DC    AL1(CSdfpopt),AL1(MDLAC48d-MDLAC48) optimise loads
         DC   2XL1'FF'
***********************************************************************
*        subtract  from accum    (binary sortable -bin8               *
***********************************************************************
MDLac48_b8 LAY R14,0(,R2)         LOAD ACCUMULATOR ADDR (CHG'D TO "LY")
mdlac48_b8la lay r15,0(0,0)       get event field address
mdlac48_b8m mvc workarea(0),0(r15) move event field to workarea
         xi    workarea,x'80'     flip the top bit
         LG    r0,workarea
         cxgtr fp1,r0             convert to extended DFP
mdlac48_b8b lghi  r15,*-*            Create biased exponent
         iextr fp1,fp1,r15          and insert
mdlac48_b8d ld    fp0,0(0,r14)
         ld    fp2,8(0,r14)
         sxtr  fp0,fp0,fp1       Add
         std   fp0,0(0,r14)
         std   fp2,8(0,r14)
MDLac48_b8L EQU *-MDLac48_b8
*
MDLac48_b8P EQU 4                 LITERAL POOL USAGE (EXCL FIELD LEN)
*
MDLac48_b8R DC AL1(CSACCOF2),AL1(MDLac48_b8+02-MDLac48_b8) ACC 2 off
         DC    AL1(CStgtloF),AL1(MDLac48_b8la+02-MDLac48_b8) Trgt off
         DC    AL1(CStgtln),AL1(MDLac48_b8m+01-MDLac48_b8) length
         DC    AL1(CSdfpexp),AL1(MDLac48_b8B+02-MDLac48_b8) dfp exp
         DC    AL1(CSdfpopt),AL1(MDLAC48_b8d-MDLAC48_b8) DFP load opt
         DC   2XL1'FF'
***********************************************************************
*        subtract from accum     (BCD - packed with no sign)          *
***********************************************************************
MDLac49  LAY   R14,0(,R2)         LOAD ACCUMULATOR ADDR (CHG'D TO "LY")
MDLac49A LAY   R15,0(,0)          LOAD SOURCE  FLD ADDRESS
MDLac49B mvo   WORKAREA,0(0,R15)  CONVERT SOURCE FIELD
         oi workarea+l'workarea-1,x'0F'   and set sign to X'f'
         lmg   r0,r1,workarea
         cxstr fp1,r0
MDLAC49C lghi  r15,*-*           Create biased exponent
         iextr fp1,fp1,r15       and insert
mdlac49d ld    fp0,0(0,r14)
         ld    fp2,8(0,r14)
         sxtr  fp0,fp0,fp1       Add
         std   fp0,0(0,r14)
         std   fp2,8(0,r14)
MDLac49L EQU   *-MDLac49
*
MDLac49P EQU   4                  LITERAL POOL USAGE (EXCL FIELD LEN)
*
MDLac49R DC    AL1(CSACCOF2),AL1(MDLac49+02-MDLac49)  ACCUM 2   OFFSET
         DC    AL1(CSTGTLOF),AL1(MDLac49A+02-MDLac49) TARGET    OFFSET
         DC    AL1(CSTGTLNR),AL1(MDLac49B+01-MDLac49) TARGET    LENGTH
         DC    AL1(CSdfpexp),AL1(MDLAC49C+02-MDLAC49) dfp exp
         DC    AL1(CSdfpopt),AL1(MDLAC49d-MDLAC49) optimise loads
         DC   2XL1'FF'
***********************************************************************
*        subtract from accum     (EDIT)                               *
***********************************************************************
MDLac50  llgt  R5,0(,R2)          load logic table row address
         LA    R1,WORKAREA
mdlac50c BAS   R10,*-*            CONVERT EDITED/MASKED  NUMERIC
MDLac50A jlu   *+l'*              FORMAT UNSUCCESSFUL BRANCH (FALSE)
*        do NOT use R14 here as it gets NOPed out
MDLac50b LAY   R1,0(,R2)          LOAD ACCUMULATOR ADDR (CHG'D TO "LY")
         ld    fp0,0(0,r1)        and load into fp regs
         ld    fp2,8(0,r1)
         ld    fp4,workarea
         ld    fp6,workarea+8
         sxtr  fp0,fp0,fp4
         std   fp0,0(0,r1)
         std   fp2,8(0,r1)
MDLac50L EQU   *-MDLac50
*
MDLac50P EQU   4                  LITERAL POOL USAGE (EXCL FIELD LEN)
*
mdlac50r DC    AL1(CSltroff),AL1(MDLac50+02-MDLac50)  TARGET    OFFSET
         DC    AL1(CSdl96call),AL1(MDLAC50c-MDLAC50)  MR96 BAS
         DC    AL1(CSFALSEO),AL1(MDLac50A+2-MDLac50)  FALSE  BRANCH
         DC    AL1(CSACCOF2),AL1(MDLac50b+02-MDLac50) acc 2   OFFSET
         DC   2XL1'FF'
***********************************************************************
*        Mulitply accum           (PACKED sortable)                   *
***********************************************************************
mdlac51  LAY   R14,0(,R2)         LOAD ACCUMULATOR ADDR (CHG'D TO "LY")
mdlac51A LAY   R15,0(,0)          LOAD SOURCE  FLD ADDRESS
mdlac51b mvc   workar2(0),0(r15)  copy event field to workplace
         ic    r0,0(0,r15)        save first character into r0
         if tmll,r0,x'00f0',z     test to see if not ones
mdlac51c   xc workar2(0),hexff   flip all the bits
         endif
         ni    workar2,x'0f'      clean top nibble in workarea
mdlac51d mvo   WORKAREA,workar2(0)  CONVERT SOURCE FIELD
         ni workarea+l'workarea-1,x'f0'   clean the sign bits
         if tmll,r0,x'00f0',o     test to see if all ones
           oi workarea+l'workarea-1,x'0c' and set sign to X'c'
         else
           oi workarea+l'workarea-1,x'0d' and set sign to X'd'
         endif
         lmg   r0,r1,workarea
         cxstr fp1,r0
mdlac51e lghi  r15,*-*           Create biased exponent
         iextr fp1,fp1,r15       and insert
mdlac51f ld    fp0,0(0,r14)
         ld    fp2,8(0,r14)
         mxtr  fp0,fp0,fp1       Add
         std   fp0,0(0,r14)
         std   fp2,8(0,r14)
mdlac51L EQU   *-mdlac51
*
mdlac51P EQU   4                  LITERAL POOL USAGE (EXCL FIELD LEN)
*
mdlac51R DC    AL1(CSACCOF2),AL1(mdlac51+02-mdlac51)  ACCUM 2   OFFSET
         DC    AL1(CSTGTLOF),AL1(mdlac51A+02-mdlac51) TARGET    OFFSET
         DC    AL1(CSTGTLN),AL1(mdlac51b+01-mdlac51) TARGET    OFFSET
         DC    AL1(CSTGTLN),AL1(mdlac51c+01-mdlac51) TARGET    OFFSET
         DC    AL1(CSTGTLNR),AL1(mdlac51d+01-mdlac51) TARGET    LENGTH
         DC    AL1(CSdfpexp),AL1(mdlac51e+02-mdlac51) dfp exp
         DC    AL1(CSdfpopt),AL1(mdlac51f-mdlac51) optimise loads
         DC   2XL1'FF'
***********************************************************************
*        multiply  accum    (binary sortable)                         *
***********************************************************************
mdlac52   LAY  r14,0(,R2)         LOAD ACCUMULATOR ADDR (CHG'D TO "LY")
mdlac52la lay  r15,0(0,0)         get event field address
mdlac52m mvc   workar2(0),0(r15) move event field to workarea
         xgr   R0,R0              fill with zeroes
         xi    workar2,x'80'      flip the top bit
         if tm,workar2,x'80',nz   If negative ...
           lghi r0,-1             fill with 1's
         endif
mdlac52A ICMy  R0,B'0000',workar2
         cxgtr fp1,r0             convert to DFP
mdlac52b lghi  r15,*-*            Create biased exponent
         iextr fp1,fp1,r15          and insert
mdlac52d ld    fp0,0(0,r14)
         ld    fp2,8(0,r14)
         mxtr  fp0,fp0,fp1
         std   fp0,0(0,r14)
         std   fp2,8(0,r14)
mdlac52L EQU   *-mdlac52
*
mdlac52P EQU   4                  LITERAL POOL USAGE (EXCL FIELD LEN)
*
mdlac52R DC    AL1(CSACCOF2),AL1(mdlac52+02-mdlac52) ACCUM 2 OFFSET
         DC    AL1(CStgtloF),AL1(mdlac52la+02-mdlac52) TARGET    OFFSET
         DC    AL1(CStgtln),AL1(mdlac52m+01-mdlac52)  length
         DC    AL1(CSBYTMSK),AL1(mdlac52A+01-mdlac52) ICM  BYTE MASK
         DC    AL1(CSdfpexp),AL1(mdlac52B+02-MDLac52) dfp exp
         DC    AL1(CSdfpopt),AL1(mdlac52d-mdlac52) optimise loads
         DC   2XL1'FF'
***********************************************************************
*        multiply  accum    (binary sortable bin 8)                   *
***********************************************************************
mdlac52_b8   LAY R14,0(,R2)       LOAD ACCUMULATOR ADDR (CHG'D TO "LY")
mdlac52_b8la lay r15,0(0,0)       get event field address
mdlac52_b8m mvc workar2(0),0(r15) move event field to workarea
         xi    workar2,x'80'      flip the top bit
         LG    r0,workar2
         cxgtr fp1,r0             convert to extended DFP
mdlac52_b8b lghi  r15,*-*            Create biased exponent
         iextr fp1,fp1,r15          and insert
mdlac52_b8d ld    fp0,0(0,r14)
         ld    fp2,8(0,r14)
         mxtr  fp0,fp0,fp1       Add
         std   fp0,0(0,r14)
         std   fp2,8(0,r14)
mdlac52_b8L EQU *-mdlac52_b8
*
mdlac52_b8P EQU 4                 LITERAL POOL USAGE (EXCL FIELD LEN)
*
mdlac52_b8R DC AL1(CSACCOF2),AL1(mdlac52_b8+02-mdlac52_b8) ACC 2 off
         DC    AL1(CStgtloF),AL1(mdlac52_b8la+02-mdlac52_b8) Trgt off
         DC    AL1(CStgtln),AL1(mdlac52_b8m+01-mdlac52_b8) length
         DC    AL1(CSdfpexp),AL1(mdlac52_b8B+02-mdlac52_b8) dfp exp
         DC    AL1(CSdfpopt),AL1(mdlac52_b8d-mdlac52_b8) DFP load opt
         DC   2XL1'FF'
***********************************************************************
*        mulitply accum          (BCD - packed with no sign)          *
***********************************************************************
mdlac53  LAY   R14,0(,R2)         LOAD ACCUMULATOR ADDR (CHG'D TO "LY")
mdlac53A LAY   R15,0(,0)          LOAD SOURCE  FLD ADDRESS
mdlac53B mvo   WORKAREA,0(0,R15) CONVERT SOURCE FIELD
         oi workarea+l'workarea-1,x'0F'     and set sign to X'f'
         lmg   r0,r1,workarea
         cxstr fp1,r0
mdlac53C lghi  r15,*-*           Create biased exponent
         iextr fp1,fp1,r15       and insert
mdlac53d ld    fp0,0(0,r14)
         ld    fp2,8(0,r14)
         mxtr  fp0,fp0,fp1       Add
         std   fp0,0(0,r14)
         std   fp2,8(0,r14)
mdlac53L EQU   *-mdlac53
*
mdlac53P EQU   4                  LITERAL POOL USAGE (EXCL FIELD LEN)
*
mdlac53R DC    AL1(CSACCOF2),AL1(mdlac53+02-mdlac53)  ACCUM 2   OFFSET
         DC    AL1(CSTGTLOF),AL1(mdlac53A+02-mdlac53) TARGET    OFFSET
         DC    AL1(CSTGTLNR),AL1(mdlac53B+01-mdlac53) TARGET    LENGTH
         DC    AL1(CSdfpexp),AL1(mdlac53C+02-mdlac53) dfp exp
         DC    AL1(CSdfpopt),AL1(mdlac53d-mdlac53) optimise loads
         DC   2XL1'FF'
***********************************************************************
*        multipley accum         (EDIT)                               *
***********************************************************************
mdlac54  llgt  R5,0(,R2)          load logic table row address
         LA    R1,WORKAREA
mdlac54c BAS   R10,*-*            CONVERT EDITED/MASKED  NUMERIC
mdlac54A jlu   *+l'*              FORMAT UNSUCCESSFUL BRANCH (FALSE)
*        do NOT use R14 here as it gets NOPed out
mdlac54b LAY   R1,0(,R2)         LOAD ACCUMULATOR ADDR (CHG'D TO "LY")
         ld    fp0,0(0,r1)        and load into fp regs
         ld    fp2,8(0,r1)
         ld    fp4,workarea
         ld    fp6,workarea+8
         mxtr  fp0,fp0,fp4
         std   fp0,0(0,r1)
         std   fp2,8(0,r1)
mdlac54L EQU   *-mdlac54
*
mdlac54P EQU   4                  LITERAL POOL USAGE (EXCL FIELD LEN)
*
mdlac54r DC    AL1(CSltroff),AL1(mdlac54+02-mdlac54)  TARGET    OFFSET
         DC    AL1(CSdl96call),AL1(mdlac54c-mdlac54)  MR96 BAS
         DC    AL1(CSFALSEO),AL1(mdlac54A+2-mdlac54)  FALSE  BRANCH
         DC    AL1(CSACCOF2),AL1(mdlac54b+02-mdlac54) acc 2   OFFSET
         DC   2XL1'FF'
***********************************************************************
*        divide   accum           (PACKED sortable)                   *
***********************************************************************
mdlac55  LAY   R14,0(,R2)         LOAD ACCUMULATOR ADDR (CHG'D TO "LY")
mdlac55a LAY   R15,0(,0)          LOAD SOURCE  FLD ADDRESS
mdlac55b mvc   workarea(0),0(r15)  copy event field to workplace
         ic    r0,0(0,r15)        save first character into r0
         if tmll,r0,x'00f0',z     test to see if not ones
mdlac55c   xc workarea(0),hexff   flip all the bits
         endif
         ni    workarea,x'0f'      clean top nibble in workarea
mdlac55d mvo   WORKAR2,workarea(0)  CONVERT SOURCE FIELD
         ni workar2+l'workar2-1,x'f0'     clean the sign bits
         if tmll,r0,x'00f0',o     test to see if all ones
           oi workar2+l'workar2-1,x'0c'   and set sign to X'c'
         else
           oi workar2+l'workar2-1,x'0d'   and set sign to X'd'
         endif
         lmg   r0,r1,workar2
         cxstr fp1,r0
MDLAC55e lghi  r15,*-*           Create biased exponent
         iextr fp1,fp1,r15       and insert
mdlac55f ld    fp0,0(0,r14)
         ld    fp2,8(0,r14)
         dxtr  fp0,fp0,fp1
         std   fp0,0(0,r14)
         std   fp2,8(0,r14)
mdlac55L EQU   *-mdlac55
*
mdlac55P EQU   4                  LITERAL POOL USAGE (EXCL FIELD LEN)
*
mdlac55R DC    AL1(CSACCOF2),AL1(mdlac55+02-mdlac55) ACCUM 2   OFFSET
         DC    AL1(CSTGTLOF),AL1(mdlac55a+02-mdlac55) TARGET    OFFSET
         DC    AL1(CSTGTLN),AL1(mdlac55b+01-mdlac55) TARGET    OFFSET
         DC    AL1(CSTGTLN),AL1(mdlac55c+01-mdlac55) TARGET    OFFSET
         DC    AL1(CSTGTLNR),AL1(mdlac55d+01-mdlac55) TARGET    LENGTH
         DC    AL1(CSdfpexp),AL1(MDLac55e+02-MDLac55) dfp exp
         DC    AL1(CSdfpopt),AL1(MDLAC55f-MDLAC55) optimise loads
         DC   2XL1'FF'
***********************************************************************
*        Divide    accum    (binary sortable)                         *
***********************************************************************
mdlac56   LAY  r14,0(,R2)         LOAD ACCUMULATOR ADDR (CHG'D TO "LY")
mdlac56la lay  r15,0(0,0)         get event field address
mdlac56m mvc   workar2(0),0(r15) move event field to workarea
         xgr   R0,R0              fill with zeroes
         xi    workar2,x'80'      flip the top bit
         if tm,workar2,x'80',nz   If negative ...
           lghi r0,-1             fill with 1's
         endif
mdlac56A ICMy  R0,B'0000',workar2
         cxgtr fp1,r0             convert to DFP
mdlac56b lghi  r15,*-*            Create biased exponent
         iextr fp1,fp1,r15          and insert
mdlac56d ld    fp0,0(0,r14)
         ld    fp2,8(0,r14)
         dxtr  fp0,fp0,fp1
         std   fp0,0(0,r14)
         std   fp2,8(0,r14)
mdlac56L EQU   *-mdlac56
*
mdlac56P EQU   4                  LITERAL POOL USAGE (EXCL FIELD LEN)
*
mdlac56R DC    AL1(CSACCOF2),AL1(mdlac56+02-mdlac56) ACCUM 2 OFFSET
         DC    AL1(CStgtloF),AL1(mdlac56la+02-mdlac56) TARGET    OFFSET
         DC    AL1(CStgtln),AL1(mdlac56m+01-mdlac56)  length
         DC    AL1(CSBYTMSK),AL1(mdlac56A+01-mdlac56) ICM  BYTE MASK
         DC    AL1(CSdfpexp),AL1(MDLac56B+02-MDLac56) dfp exp
         DC    AL1(CSdfpopt),AL1(MDLAC56d-MDLAC56) optimise loads
         DC   2XL1'FF'
***********************************************************************
*        divide    accum    (binary sortable bin 8)                   *
***********************************************************************
mdlac56_b8   LAY R14,0(,R2)       LOAD ACCUMULATOR ADDR (CHG'D TO "LY")
mdlac56_b8la lay r15,0(0,0)       get event field address
mdlac56_b8m mvc workar2(0),0(r15) move event field to workarea
         xi    workar2,x'80'      flip the top bit
         LG    r0,workar2
         cxgtr fp1,r0             convert to extended DFP
mdlac56_b8b lghi  r15,*-*            Create biased exponent
         iextr fp1,fp1,r15          and insert
mdlac56_b8d ld    fp0,0(0,r14)
         ld    fp2,8(0,r14)
         dxtr  fp0,fp0,fp1       Add
         std   fp0,0(0,r14)
         std   fp2,8(0,r14)
mdlac56_b8L EQU *-mdlac56_b8
*
mdlac56_b8P EQU 4                 LITERAL POOL USAGE (EXCL FIELD LEN)
*
mdlac56_b8R DC AL1(CSACCOF2),AL1(mdlac56_b8+02-mdlac56_b8) ACC 2 off
         DC    AL1(CStgtloF),AL1(mdlac56_b8la+02-mdlac56_b8) Trgt off
         DC    AL1(CStgtln),AL1(mdlac56_b8m+01-mdlac56_b8) length
         DC    AL1(CSdfpexp),AL1(MDLac56_b8B+02-MDLac56_b8) dfp exp
         DC    AL1(CSdfpopt),AL1(MDLAC56_b8d-MDLAC56_b8) DFP load opt
         DC   2XL1'FF'
***********************************************************************
*        Divide accum          (BCD - packed with no sign)          *
***********************************************************************
mdlac57  LAY   R14,0(,R2)         LOAD ACCUMULATOR ADDR (CHG'D TO "LY")
mdlac57A LAY   R15,0(,0)          LOAD SOURCE  FLD ADDRESS
mdlac57B mvo   WORKAREA,0(0,R15) CONVERT SOURCE FIELD
         oi workarea+l'workarea-1,x'0F'     and set sign to X'f'
         lmg   r0,r1,workarea
         cxstr fp1,r0
mdlac57C lghi  r15,*-*           Create biased exponent
         iextr fp1,fp1,r15       and insert
mdlac57d ld    fp0,0(0,r14)
         ld    fp2,8(0,r14)
         dxtr  fp0,fp0,fp1       Add
         std   fp0,0(0,r14)
         std   fp2,8(0,r14)
mdlac57L EQU   *-mdlac57
*
mdlac57P EQU   4                  LITERAL POOL USAGE (EXCL FIELD LEN)
*
mdlac57R DC    AL1(CSACCOF2),AL1(mdlac57+02-mdlac57)  ACCUM 2   OFFSET
         DC    AL1(CSTGTLOF),AL1(mdlac57A+02-mdlac57) TARGET    OFFSET
         DC    AL1(CSTGTLNR),AL1(mdlac57B+01-mdlac57) TARGET    LENGTH
         DC    AL1(CSdfpexp),AL1(mdlac57C+02-mdlac57) dfp exp
         DC    AL1(CSdfpopt),AL1(mdlac57d-mdlac57) optimise loads
         DC   2XL1'FF'
***********************************************************************
*        Divide    accum         (EDIT)                               *
***********************************************************************
mdlac58  llgt  R5,0(,R2)          load logic table row address
         LA    R1,WORKAREA
mdlac58c BAS   R10,*-*            CONVERT EDITED/MASKED  NUMERIC
mdlac58A jlu   *+l'*              FORMAT UNSUCCESSFUL BRANCH (FALSE)
*        do NOT use R14 here as it gets NOPed out
mdlac58b LAY   R1,0(,R2)         LOAD ACCUMULATOR ADDR (CHG'D TO "LY")
         ld    fp0,0(0,r1)        and load into fp regs
         ld    fp2,8(0,r1)
         ld    fp4,workarea
         ld    fp6,workarea+8
         dxtr  fp0,fp0,fp4
         std   fp0,0(0,r1)
         std   fp2,8(0,r1)
mdlac58L EQU   *-mdlac58
*
mdlac58P EQU   4                  LITERAL POOL USAGE (EXCL FIELD LEN)
*
mdlac58r DC    AL1(CSltroff),AL1(mdlac58+02-mdlac58)  TARGET    OFFSET
         DC    AL1(CSdl96call),AL1(mdlac58c-mdlac58)  MR96 BAS
         DC    AL1(CSFALSEO),AL1(mdlac58A+2-mdlac58)  FALSE  BRANCH
         DC    AL1(CSACCOF2),AL1(mdlac58b+02-mdlac58) acc 2   OFFSET
         DC   2XL1'FF'
                        EJECT
***********************************************************************
*        substring compare SFx to CONSTANT                            *
***********************************************************************
mdlsfxc  ly    r0,0(,r2)          load the counter
MDLsfxcB LAY   R14,0(,R2)         COMPARE CONSTANT (needle)
MDLsfxcLA LAY  R15,0(0,0)         get address (haystack)
         basr  r1,0
MDLsfxcA CLC   0(0,r15),0(R14)    COMPARE TWO  FIELDS
MDLsfxcT jle   *+l'*              BRANCH  TO   TRUE
         aghi  r15,1              move along one
         bctr  r0,r1              and repeat
MDLsfxcF jlu   *+l'*              BRANCH  TO   FALSE
MDLsfxcL EQU   *-MDLsfxc
*
MDLsfxcP EQU   0                  LITERAL POOL USAGE (EXCL FIELD LEN)
*
MDLsfxcR DC    AL1(CSsubctrxc),AL1(MDLsfxc+02-MDLsfxc)  loop counter
         DC    AL1(CSV1OFF),AL1(MDLsfxcb+02-MDLsfxc)  VALUE  1  OFF
         DC    AL1(CSv1len),AL1(MDLsfxcA+01-MDLsfxc)  compare   LEN
         DC    AL1(CSSRCloF),AL1(MDLsfxcLA+02-MDLsfxc) FIELD 1  OFF
         DC    AL1(CSTRUEm),AL1(MDLsfxcT+2-MDLsfxc)   TRUE   BRANCH
         DC    AL1(CSFALSEO),AL1(MDLsfxcF+2-MDLsfxc)  FALSE  BRANCH
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        substring compare SFC to x                                   *
***********************************************************************
mdlsfcx  ly    r0,0(,r2)          load the counter
MDLsfcxB LAY   R14,0(,R2)         COMPARE CONSTANT (haystack)
MDLsfcxLA LAY  R15,0(0,0)         get address      (needle)
         basr  r1,0
MDLsfcxA CLC   0(0,r14),0(R15)    COMPARE TWO  FIELDS
MDLsfcxT jle   *+l'*              BRANCH  TO   TRUE
         aghi  r14,1              move along one
         bctr  r0,r1              and repeat
MDLsfcxF jlu   *+l'*              BRANCH  TO   FALSE
MDLsfcxL EQU   *-MDLsfcx
*
MDLsfcxP EQU   0                  LITERAL POOL USAGE (EXCL FIELD LEN)
*
MDLsfcxR DC    AL1(CSsubctrcx),AL1(MDLsfcx+02-MDLsfcx)  loop counter
         DC    AL1(CSV1OFFr),AL1(MDLsfcxb+02-MDLsfcx)  VALUE  1  OFF
         DC    AL1(CSsrcLN),AL1(MDLsfcxA+01-MDLsfcx)  compare len
         DC    AL1(CSSRCloFr),AL1(MDLsfcxLA+02-MDLsfcx) FIELD 1  OFF
         DC    AL1(CSTRUEm),AL1(MDLsfcxT+2-MDLsfcx)   TRUE   BRANCH
         DC    AL1(CSFALSEO),AL1(MDLsfcxF+2-MDLsfcx)  FALSE  BRANCH
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        substring compare SFxx                                       *
***********************************************************************
mdlsfxx  ly    r0,0(,r2)          load the counter
MDLsfxxB LAY   R14,0(0,0)         get first operand (haystack)
MDLsfxxLA LAY  R15,0(0,0)         get second operand (needle)
         basr  r1,0
MDLsfxxA CLC   0(0,r14),0(R15)    COMPARE TWO  FIELDS
MDLsfxxT jle   *+l'*              BRANCH  TO   TRUEe
         aghi  r14,1              move along one
         bctr  r0,r1              and repeat
MDLsfxxF jlu   *+l'*              BRANCH  TO   FALSE
MDLsfxxL EQU   *-MDLsfxx
*
MDLsfxxP EQU   0                  LITERAL POOL USAGE (EXCL FIELD LEN)
*
MDLsfxxR DC    AL1(CSsubctr),AL1(MDLsfxx+02-MDLsfxx)  loop counter
         DC    AL1(CSsrclof),AL1(MDLsfxxb+02-MDLsfxx)  VALUE  1  OFF
         DC    AL1(CStgtLN),AL1(MDLsfxxA+01-MDLsfxx)  compare len
         DC    AL1(CStgtloF),AL1(MDLsfxxLA+02-MDLsfxx) FIELD 2  OFF
         DC    AL1(CSTRUEm),AL1(MDLsfxxT+2-MDLsfxx)   TRUE   BRANCH
         DC    AL1(CSFALSEO),AL1(MDLsfxxF+2-MDLsfxx)  FALSE  BRANCH
         DC   2XL1'FF'
                        eject
***********************************************************************
*        COMPARE FIELDS           (TWO CHARACTER CONSTANTS)           *
***********************************************************************
MDLCFC0  LAY   R14,0(,R2)         COMPARE TWO  FIELDS
MDLCFC0A LAY   R15,0(,R2)         COMPARE TWO  FIELDS
mdlcfc0d ld    fp0,0(0,r14)
         ld    fp2,8(0,r14)
         ld    fp4,0(0,r15)
         ld    fp6,8(0,r15)
         cxtr  fp0,fp4
MDLCFC0F jlu   *+l'*              BRANCH  TO   FALSE  IF NOT TRUE
MDLCFC0T jlu   *+l'*              BRANCH  TO   TRUE  (OPTIONAL)
MDLCFC0L EQU   *-MDLCFC0
*
MDLCFC0P EQU   0                  LITERAL POOL USAGE (EXCL FIELD LEN)
*
MDLCFC0R DC    AL1(CSV1OFF),AL1(MDLCFC0+02-MDLCFC0)   VALUE  1  OFF
         DC    AL1(CSV2OFF),AL1(MDLCFC0A+02-MDLCFC0)  VALUE  2  OFF
         DC    AL1(CSdfpopt),AL1(MDLcfc0d-MDLcfc0) dfp load optimise
         DC    AL1(CSRELOPR),AL1(MDLCFC0F+1-MDLCFC0)  RELATIONAL CC
         DC    AL1(CSFALSEO),AL1(MDLCFC0F+2-MDLCFC0)  FALSE  BRANCH
         DC    AL1(CSTRUEO),AL1(MDLCFC0T+2-MDLCFC0)   TRUE   BRANCH
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        COMPARE FIELD            (CHARACTER CONSTANT)                *
***********************************************************************
MDLCFC1  LAY   R14,0(,R2)         COMPARE CONSTANT
MDLCFCLA LAY   R15,0(0,0)         get address
MDLCFC1A CLC   0(0,r15),0(R14)    COMPARE TWO  FIELDS
MDLCFC1F jlu   *+l'*              BRANCH  TO   FALSE  IF NOT TRUE
MDLCFC1T jlu   *+l'*              BRANCH  TO   TRUE  (OPTIONAL)
MDLCFC1L EQU   *-MDLCFC1
*
MDLCFC1P EQU   0                  LITERAL POOL USAGE (EXCL FIELD LEN)
*
MDLCFC1R DC    AL1(CSV1OFF),AL1(MDLCFC1+02-MDLCFC1)   VALUE  1  OFF
         DC    AL1(CSSRCLN),AL1(MDLCFC1A+01-MDLCFC1)  FIELD  1  LEN
         DC    AL1(CSSRCloF),AL1(MDLCFCLA+02-MDLCFC1) FIELD  1  OFF
         DC    AL1(CSRELOPR),AL1(MDLCFC1F+1-MDLCFC1)  RELATIONAL CC
         DC    AL1(CSFALSEO),AL1(MDLCFC1F+2-MDLCFC1)  FALSE  BRANCH
         DC    AL1(CSTRUEO),AL1(MDLCFC1T+2-MDLCFC1)   TRUE   BRANCH
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        COMPARE FIELD            (PACKED    CONSTANT)                *
***********************************************************************
MDLCFC2  LAY   R14,0(,R2)         COMPARE CONSTANT
MDLCFC2_la LAY R15,0(0,0)         get address
MDLCFc2A ZAP   WORKAREA,0(0,r15)  CONVERT PACKED
         lmg   r0,r1,workarea
         cxstr fp1,r0
MDLcfc2b lghi  r15,*-*           Create biased exponent
         iextr fp1,fp1,r15       and insert
mdlcfc2d ld    fp0,0(0,r14)
         ld    fp2,8(0,r14)
         cxtr  fp1,fp0
MDLCFC2F jlu   *+l'*              BRANCH  TO   FALSE  IF NOT TRUE
MDLCFC2T jlu   *+l'*              BRANCH  TO   TRUE  (OPTIONAL)
MDLCFC2L EQU   *-MDLCFC2
*
MDLCFC2P EQU   0                  LITERAL POOL USAGE (EXCL FIELD LEN)
*
MDLCFC2R DC    AL1(CSV1OFF),AL1(MDLCFC2+02-MDLCFC2)   VALUE  1  OFF
         DC    AL1(CSSRClof),AL1(MDLCFC2_lA+02-MDLCFC2) FIELD  1  OFF
         DC    AL1(CSSRCLNR),AL1(MDLCFC2A+01-MDLCFC2) FIELD  1  LEN
         DC    AL1(CSdfpexps),AL1(MDLcfc2b+02-MDLcfc2) dfp exp
         DC    AL1(CSdfpopt),AL1(MDLcfc2d-MDLcfc2) optimise loads
         DC    AL1(CSRELOPR),AL1(MDLCFC2F+1-MDLCFC2)  RELATIONAL CC
         DC    AL1(CSFALSEO),AL1(MDLCFC2F+2-MDLCFC2)  FALSE  BRANCH
         DC    AL1(CSTRUEO),AL1(MDLCFC2T+2-MDLCFC2)   TRUE   BRANCH
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        COMPARE FIELDS           (NUMERIC - PACKED)                  *
***********************************************************************
MDLCFc3  LAY   R14,0(,R2)         LOAD constant
mdlcfc3_la LAY R15,0(0,0)         get address
mdlcfc3A PACK  WORKAREA,0(0,r15)  CONVERT PACKED
         lmg   r0,r1,workarea
         cxstr fp1,r0
mdlcfc3b lghi  r15,*-*            Create biased exponent
         iextr fp1,fp1,r15          and insert
mdlcfc3d ld    fp0,0(0,r14)
         ld    fp2,8(0,r14)
         cxtr  fp1,fp0
mdlcfc3F jlu   *+l'*              BRANCH  TO   FALSE  IF NOT TRUE
mdlcfc3T jlu   *+l'*              BRANCH  TO   TRUE  (OPTIONAL)
mdlcfc3L EQU   *-mdlcfc3
*
mdlcfc3P EQU   4                  LITERAL POOL USAGE (EXCL FIELD LEN)
*
mdlcfc3R DC    AL1(CSv1off),AL1(mdlcfc3+02-mdlcfc3)  ACCUM  2  OFF
         DC    AL1(CSsrclof),AL1(mdlcfc3_lA+02-mdlcfc3) FIELD  2  OFF
         DC    AL1(CSsrcLNR),AL1(mdlcfc3A+01-mdlcfc3) FIELD  1  LEN R/2
         DC    AL1(CSdfpexps),AL1(mdlcfc3b+02-mdlcfc3) SHIFT DEC PLACES
         DC    AL1(CSdfpopt),AL1(mdlcfc3d-mdlcfc3) optimise loads
         DC    AL1(CSRELOPR),AL1(mdlcfc3F+1-mdlcfc3)  RELATIONAL CC
         DC    AL1(CSFALSEO),AL1(mdlcfc3F+2-mdlcfc3)  FALSE  BRANCH
         DC    AL1(CSTRUEO),AL1(mdlcfc3T+2-mdlcfc3)   TRUE   BRANCH
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        COMPARE FIELDS           (NUMERIC - NUMERIC)                 *
***********************************************************************
MDLCFC4  LAY   R14,0(,R2)         COMPARE CONSTANT
MDLCFC4_la LAY R15,0(0,0)         get address
         ld    fp4,0(0,r14)       load first operand into fp4/6
         ld    fp6,8(0,r14)
mdlcfc4b mvc   dblwork(0),0(r15)   copy event field to workplace
         ic    r0,0(0,r15)        save first character into r15
         if tmll,r0,x'00f0',z     test to see if not ones
mdlcfc4c   xc dblwork(0),hexff   flip all the bits
         endif
         ni    dblwork,x'0f'      clean top nibble in workarea
mdlcfc4d mvo   workar2,dblwork(0) CONVERT SOURCE FIELD
         ni workar2+l'workar2-1,x'f0'     clean the sign bits
         if tmll,r0,x'00f0',o     test to see if all ones
           oi workar2+l'workar2-1,x'0c'   and set sign to X'c'
         else
           oi workar2+l'workar2-1,x'0d'   and set sign to X'd'
         endif
         lmg   r0,r1,workar2
         cxstr fp1,r0
MDLcfc4e lghi  r15,*-*           Create biased exponent
         iextr fp1,fp1,r15       and insert
         cxtr  fp1,fp4            COMPARE TWO  FIELDS
MDLCFC4F jlu   *+l'*              BRANCH  TO   FALSE IF  NOT TRUE
MDLCFC4T jlu   *+l'*              BRANCH  TO   TRUE (OPTIONAL)
MDLCFC4L EQU   *-MDLCFC4
*
MDLCFC4P EQU   0                  LITERAL POOL USAGE (EXCL FIELD LEN)
*
MDLCFC4R DC    AL1(CSV1OFF),AL1(MDLCFC4+02-MDLCFC4)   VALUE   1 OFF
         DC    AL1(CSSRCloF),AL1(MDLCFC4_LA+02-MDLCFC4) src field off
         DC    AL1(CSSRCLN),AL1(MDLCFC4B+01-MDLCFC4) TGT FIELD LEN L/2
         DC    AL1(CSSRCLN),AL1(MDLCFC4C+01-MDLCFC4) SRC FIELD LEN L/2
         DC    AL1(CSSRCLNR),AL1(MDLCFC4d+01-MDLCFC4) TGT FIELD LEN R/2
         DC    AL1(CSdfpexps),AL1(mdlcfc4e+02-mdlcfc4) dfp exp
         DC    AL1(CSRELOPR),AL1(MDLCFC4F+1-MDLCFC4)  RELATIONAL CC
         DC    AL1(CSFALSEO),AL1(MDLCFC4F+2-MDLCFC4)  FALSE  BRANCH
         DC    AL1(CSTRUEO),AL1(MDLCFC4T+2-MDLCFC4)   TRUE   BRANCH
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        COMPARE FIELD            (BINARY    CONSTANT)                *
***********************************************************************
MDLcfc5u LAY   R14,0(,R2)          CONSTANT ADDRESS
mdlcfc5u_la LAY R15,0(0,0)         get address
         ld    fp4,0(0,r14)        Load constant
         ld    fp6,8(0,r14)
         XGR   R0,r0
MDLcfc5uD ICMy R0,B'0000',0(R15)
*
         cxgtr fp1,r0             convert from fixed to DFP
MDLcfc5ue lghi  r15,*-*           Create biased exponent
         iextr fp1,fp1,r15       and insert
         cxtr  fp1,fp4            COMPARE TWO  FIELDS
MDLcfc5uF jlu  *+l'*              BRANCH  TO   FALSE  IF NOT TRUE
MDLcfc5uT jlu  *+l'*              BRANCH  TO   TRUE  (OPTIONAL)
MDLcfc5uL EQU  *-MDLcfc5u
*
MDLcfc5uP EQU  0                  LITERAL POOL USAGE (EXCL FIELD LEN)
*
MDLcfc5uR DC   AL1(CSV1OFF),AL1(MDLcfc5u+02-MDLcfc5u) VALUE  1  OFFSET
         DC    AL1(CSSRCloF),AL1(MDLcfc5u_la+02-MDLcfc5u) SOURCE OFFSET
         DC    AL1(CSBYTMSS),AL1(MDLcfc5uD+01-MDLcfc5u) ICM BYTE MASK
         DC    AL1(CSdfpexps),AL1(MDLcfc5ue+02-MDLcfc5u) dfp exp
         DC    AL1(CSRELOPR),AL1(MDLcfc5uF+1-MDLcfc5u) RELATIONAL CC
         DC    AL1(CSFALSEO),AL1(MDLcfc5uF+2-MDLcfc5u) FALSE BRANCH
         DC    AL1(CSTRUEO),AL1(MDLcfc5uT+2-MDLcfc5u) TRUE   BRANCH
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        COMPARE FIELD            (BINARY    CONSTANT)                *
***********************************************************************
MDLCFC5  LAY   R14,0(,R2)          CONSTANT ADDRESS
mdlcfc5_la LAY R15,0(0,0)          get address
         ld    fp4,0(0,r14)        Load constant
         ld    fp6,8(0,r14)
         XGR   R0,r0
         if tm,0(r15),x'80',o
           lghi r0,-1              fill with 1's
         endif
MDLCFC5D ICMy  R0,B'0000',0(R15)
*
         cxgtr fp1,r0             convert from fixed to DFP
MDLcfc5e lghi  r15,*-*           Create biased exponent
         iextr fp1,fp1,r15       and insert
         cxtr  fp1,fp4            COMPARE TWO  FIELDS
MDLCFC5F jlu   *+l'*              BRANCH  TO   FALSE  IF NOT TRUE
MDLCFC5T jlu   *+l'*              BRANCH  TO   TRUE  (OPTIONAL)
MDLCFC5L EQU   *-MDLCFC5
*
MDLCFC5P EQU   0                  LITERAL POOL USAGE (EXCL FIELD LEN)
*
MDLCFC5R DC    AL1(CSV1OFF),AL1(MDLCFC5+02-MDLCFC5)   VALUE  1  OFFSET
         DC    AL1(CSSRCloF),AL1(MDLCFC5_la+02-MDLCFC5) SOURCE  OFFSET
         DC    AL1(CSBYTMSS),AL1(MDLCFC5D+01-MDLCFC5) ICM  BYTE MASK
         DC    AL1(CSdfpexps),AL1(MDLcfc5e+02-MDLcfc5) dfp exp
         DC    AL1(CSRELOPR),AL1(MDLCFC5F+1-MDLCFC5)  RELATIONAL CC
         DC    AL1(CSFALSEO),AL1(MDLCFC5F+2-MDLCFC5)  FALSE  BRANCH
         DC    AL1(CSTRUEO),AL1(MDLCFC5T+2-MDLCFC5)   TRUE   BRANCH
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        COMPARE FIELD            (BINARY    CONSTANT)                *
***********************************************************************
MDLCFc5_88 LAY R14,0(,R2)          CONSTANT ADDRESS
MDLCFc5_88B LG R0,0(0,0)
         ld    fp4,0(0,r14)        Load constant
         ld    fp6,8(0,r14)
         cxgtr fp1,r0             convert from fixed to DFP
MDLcfc5_88e lghi  r15,*-*           Create biased exponent
         iextr fp1,fp1,r15       and insert
         cxtr  fp1,fp4            COMPARE TWO  FIELDS
MDLCFc5_88F jlu *+l'*             BRANCH  TO   FALSE  IF NOT TRUE
MDLCFc5_88T jlu *+l'*             BRANCH  TO   TRUE  (OPTIONAL)
MDLCFc5_88L EQU *-MDLCFc5_88
*
MDLCFc5_88P EQU 0                 LITERAL POOL USAGE (EXCL FIELD LEN)
*
MDLCFc5_88R DC AL1(CSV1OFF),AL1(MDLCFc5_88+02-MDLCFc5_88) VALUE 1 OFF
         DC    AL1(CSSRCloF),AL1(MDLCFc5_88B+02-MDLCFc5_88) SOURCE OFF
         DC    AL1(CSdfpexps),AL1(MDLcfc5_88e+02-MDLcfc5_88) dfp exp
         DC    AL1(CSRELOPR),AL1(MDLCFc5_88F+1-MDLCFc5_88) REL cc
         DC    AL1(CSFALSEO),AL1(MDLCFc5_88F+2-MDLCFc5_88) FALSE BR
         DC    AL1(CSTRUEO),AL1(MDLCFc5_88T+2-MDLCFc5_88) TRUE BR
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        COMPARE FIELD            (BINARY    CONSTANT)                *
***********************************************************************
MDLcfc6  LAY   R14,0(,R2)          CONSTANT ADDRESS
mdlcfc6_la LAY R15,0(0,0)          get address
         ld    fp4,0(0,r14)        Load constant
         ld    fp6,8(0,r14)
         XGR   R0,r0
mdlcfc6m mvc   workarea(0),0(r15) move event field to workarea
         xi    workarea,x'80'      flip the top bit
         if tm,workarea,x'80',nz If negative ...
           lghi r0,-1              fill with 1's
         endif
mdlcfc6d ICMy  R0,B'0000',workarea
*
         cxgtr fp1,r0             convert from fixed to DFP
MDLcfc6e lghi  r15,*-*           Create biased exponent
         iextr fp1,fp1,r15       and insert
         cxtr  fp1,fp4            COMPARE TWO  FIELDS
MDLcfc6F jlu   *+l'*              BRANCH  TO   FALSE  IF NOT TRUE
MDLcfc6T jlu   *+l'*              BRANCH  TO   TRUE  (OPTIONAL)
MDLcfc6L EQU   *-MDLcfc6
*
MDLcfc6P EQU   0                  LITERAL POOL USAGE (EXCL FIELD LEN)
*
MDLcfc6R DC    AL1(CSV1OFF),AL1(MDLcfc6+02-MDLcfc6)   VALUE  1  OFFSET
         DC    AL1(CSSRCloF),AL1(MDLcfc6_la+02-MDLcfc6) SOURCE  OFFSET
         DC    AL1(CSSRCln),AL1(MDLcfc6m+01-MDLcfc6) SOURCE  length
         DC    AL1(CSBYTMSS),AL1(MDLcfc6D+01-MDLcfc6) ICM  BYTE MASK
         DC    AL1(CSdfpexps),AL1(MDLcfc6e+02-MDLcfc6) dfp exp
         DC    AL1(CSRELOPR),AL1(MDLcfc6F+1-MDLcfc6)  RELATIONAL CC
         DC    AL1(CSFALSEO),AL1(MDLcfc6F+2-MDLcfc6)  FALSE  BRANCH
         DC    AL1(CSTRUEO),AL1(MDLcfc6T+2-MDLcfc6)   TRUE   BRANCH
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        COMPARE FIELD            (BINARY    CONSTANT)                *
***********************************************************************
MDLcfc6_88 LAY R14,0(,R2)          CONSTANT ADDRESS
MDLcfc6_88B Lay R15,0(0,0)
mdlcfc6_88m mvc  workarea(0),0(r15) move event field to workarea
         xi    workarea,x'80'         flip the top bit
         LG    R0,workarea
         ld    fp4,0(0,r14)        Load constant
         ld    fp6,8(0,r14)
         cxgtr fp1,r0             convert from fixed to DFP
MDLcfc6_88e lghi  r15,*-*           Create biased exponent
         iextr fp1,fp1,r15       and insert
         cxtr  fp1,fp4            COMPARE TWO  FIELDS
MDLcfc6_88F jlu *+l'*             BRANCH  TO   FALSE  IF NOT TRUE
MDLcfc6_88T jlu *+l'*             BRANCH  TO   TRUE  (OPTIONAL)
MDLcfc6_88L EQU *-MDLcfc6_88
*
MDLcfc6_88P EQU 0                 LITERAL POOL USAGE (EXCL FIELD LEN)
*
MDLcfc6_88R DC AL1(CSV1OFF),AL1(MDLcfc6_88+02-MDLcfc6_88) VALUE 1 OFF
         DC    AL1(CSSRCloF),AL1(MDLcfc6_88B+02-MDLcfc6_88) SOURCE OFF
         DC    AL1(CSSRCln),AL1(MDLcfc6_88m+01-MDLcfc6_88) SOURCE len
         DC    AL1(CSdfpexps),AL1(MDLcfc6_88e+02-MDLcfc6_88) dfp exp
         DC    AL1(CSRELOPR),AL1(MDLcfc6_88F+1-MDLcfc6_88) REL cc
         DC    AL1(CSFALSEO),AL1(MDLcfc6_88F+2-MDLcfc6_88) FALSE BR
         DC    AL1(CSTRUEO),AL1(MDLcfc6_88T+2-MDLcfc6_88) TRUE BR
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        COMPARE FIELDS           (PACKs  - PACKED)                   *
***********************************************************************
mdlcfc8  LAY   R14,0(0,0)         LOAD  SOURCE address
mdlcfc8_la LAY R15,0(0,r2)        CONSTANT ADDRESS
         ld    fp4,0(0,r15)       load first operand into fp4/6
         ld    fp6,8(0,r15)
MDLcfc8d mvo   WORKAREA,0(0,R14) CONVERT SOURCE FIELD
         oi workarea+l'workarea-1,x'0F'     and set sign to X'f'
         lmg   r0,r1,workarea
         cxstr fp1,r0             convert to dfp
MDLcfc8e lghi  r15,*-*            Create biased exponent
         iextr fp1,fp1,r15       and insert
         cxtr  fp1,fp4            COMPARE TWO  FIELDS
mdlcfc8F jlu   *+l'*              BRANCH  TO   FALSE  IF NOT TRUE
mdlcfc8T jlu   *+l'*              BRANCH  TO   TRUE  (OPTIONAL)
mdlcfc8L EQU   *-mdlcfc8
*
mdlcfc8P EQU   0                  LITERAL POOL USAGE (EXCL FIELD LEN)
*
mdlcfc8R DC    AL1(CSSRCloF),AL1(mdlcfc8+02-mdlcfc8)   FIELD  1  OFF
         DC    AL1(CSv1off),AL1(mdlcfc8_la+02-mdlcfc8)  FIELD  2  OFF
         DC    AL1(CSSRCLNR),AL1(mdlcfc8d+01-mdlcfc8) TARGET    LENGTH
         DC    AL1(CSdfpexps),AL1(mdlcfc8e+02-mdlcfc8) SHIFT DEC PLACES
         DC    AL1(CSRELOPR),AL1(mdlcfc8F+1-mdlcfc8)  RELATIONAL CC
         DC    AL1(CSFALSEO),AL1(mdlcfc8F+2-mdlcfc8)  FALSE  BRANCH
         DC    AL1(CSTRUEO),AL1(mdlcfc8T+2-mdlcfc8)   TRUE   BRANCH
         DC   2XL1'FF'
***********************************************************************
*        Compare fields cfec    (normalised date constant/date field)
***********************************************************************
mdlcfc9  LAY   R15,0(0,0)         Load source field address
MDLcfc9B llgt  R5,0(,R2)          LOAD LOGIC  TABLE  ROW ADDRESS
         BAS   R10,dateNorm_indirect CONVERT field to normalised date
mdlcfc9_la LAY  R14,0(0,r2)      LOAD constant address
mdlcfc9c CLC   workarea(16),0(R14) COMPARE dates
MDLCFC9F jlu   *+l'*              BRANCH  TO   FALSE  IF NOT TRUE
MDLCFC9T jlu   *+l'*              BRANCH  TO   TRUE  (OPTIONAL)
MDLcfc9L EQU   *-MDLcfc9
*
MDLcfc9P EQU   4                  LITERAL POOL USAGE (EXCL FIELD LEN)
*
mdlcfc9R DC    AL1(CSSRCloF),AL1(mdlcfc9+02-mdlcfc9)   FIELD  1  OFF
         DC    AL1(CSv1off),AL1(mdlcfc9_la+02-mdlcfc9)  FIELD  2  OFF
         DC    AL1(CScmpdt1),AL1(mdlcfc9c-mdlcfc9)    date compare
         DC    AL1(CSLTROFF),AL1(MDLcfc9B+02-MDLcfc9) LOGIC  TABLE ROW
         DC    AL1(CSRELOPR),AL1(MDLcfc9F+1-MDLcfc9)  RELATIONAL CC
         DC    AL1(CSFALSEO),AL1(MDLcfc9F+02-MDLcfc9) FALSE  BRANCH
         DC    AL1(CSTRUEO),AL1(MDLcfc9T+02-MDLcfc9)  TRUE   BRANCH
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        COMPARE FIELD            (CHARACTER CONSTANT)                *
***********************************************************************
MDLCFCx1 LAY   R14,0(,R2)         COMPARE CONSTANT
MDLCFCxLA LAY  R15,0(0,0)         get address
MDLCFCx1A CLC  0(0,r14),0(R15)    COMPARE TWO  FIELDS
MDLCFCx1F jlu  *+l'*              BRANCH  TO   FALSE  IF NOT TRUE
MDLCFCx1T jlu  *+l'*              BRANCH  TO   TRUE  (OPTIONAL)
MDLCFCx1L EQU  *-MDLCFCx1
*
MDLCFCx1P EQU  0                  LITERAL POOL USAGE (EXCL FIELD LEN)
*
MDLCFCx1R DC   AL1(csv1offr),AL1(MDLCFCx1+02-MDLCFCx1) VALUE 1  OFF
         DC    AL1(CSSRCLN),AL1(MDLCFCx1A+01-MDLCFCx1) FIELD 1  LEN
         DC    AL1(cssrclofr),AL1(MDLCFCxLA+02-MDLCFCx1) FIELD 1 OFF
         DC    AL1(CSRELOPR),AL1(MDLCFCx1F+1-MDLCFCx1) RELATIONAL CC
         DC    AL1(CSFALSEO),AL1(MDLCFCx1F+2-MDLCFCx1) FALSE BRANCH
         DC    AL1(CSTRUEO),AL1(MDLCFCx1T+2-MDLCFCx1) TRUE   BRANCH
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        COMPARE FIELD            (PACKED    CONSTANT)                *
***********************************************************************
MDLCFCx2 LAY   R14,0(,R2)         COMPARE CONSTANT
MDLCFCx2_la LAY R15,0(0,0)        get address
MDLCFCx2A ZAP  WORKAREA,0(0,r15)  CONVERT PACKED
         lmg   r0,r1,workarea
         cxstr fp1,r0
MDLCFCx2b lghi r15,*-*           Create biased exponent
         iextr fp1,fp1,r15       and insert
MDLCFCx2d ld   fp0,0(0,r14)
         ld    fp2,8(0,r14)
         cxtr  fp0,fp1
MDLCFCx2F jlu  *+l'*              BRANCH  TO   FALSE  IF NOT TRUE
MDLCFCx2T jlu  *+l'*              BRANCH  TO   TRUE  (OPTIONAL)
MDLCFCx2L EQU  *-MDLCFCx2
*
MDLCFCx2P EQU  0                  LITERAL POOL USAGE (EXCL FIELD LEN)
*
MDLCFCx2R DC   AL1(csv1offr),AL1(MDLCFCx2+02-MDLCFCx2) VALUE 1  OFF
         DC    AL1(cssrclofr),AL1(MDLCFCx2_lA+02-MDLCFCx2) FIELD 1 OFF
         DC    AL1(CSSRCLNR),AL1(MDLCFCx2A+01-MDLCFCx2) FIELD 1 LEN
         DC    AL1(CSdfpexps),AL1(MDLCFCx2b+02-MDLCFCx2) dfp exp
         DC    AL1(CSdfpopt),AL1(MDLCFCx2d-MDLCFCx2) optimise loads
         DC    AL1(CSRELOPR),AL1(MDLCFCx2F+1-MDLCFCx2) RELATIONAL CC
         DC    AL1(CSFALSEO),AL1(MDLCFCx2F+2-MDLCFCx2) FALSE BRANCH
         DC    AL1(CSTRUEO),AL1(MDLCFCx2T+2-MDLCFCx2) TRUE   BRANCH
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        COMPARE FIELDS           (NUMERIC - PACKED)                  *
***********************************************************************
MDLCFCx3 LAY   R14,0(,R2)         LOAD constant
MDLCFCx3_la LAY R15,0(0,0)        get address
MDLCFCx3A PACK WORKAREA,0(0,r15)  CONVERT PACKED
         lmg   r0,r1,workarea
         cxstr fp1,r0
MDLCFCx3b lghi r15,*-*            Create biased exponent
         iextr fp1,fp1,r15          and insert
MDLCFCx3d ld   fp0,0(0,r14)
         ld    fp2,8(0,r14)
         cxtr  fp0,fp1
MDLCFCx3F jlu  *+l'*              BRANCH  TO   FALSE  IF NOT TRUE
MDLCFCx3T jlu  *+l'*              BRANCH  TO   TRUE  (OPTIONAL)
MDLCFCx3L EQU  *-MDLCFCx3
*
MDLCFCx3P EQU  4                  LITERAL POOL USAGE (EXCL FIELD LEN)
*
MDLCFCx3R DC   AL1(csv1offr),AL1(MDLCFCx3+02-MDLCFCx3) ACCUM 2 OFF
         DC    AL1(cssrclofr),AL1(MDLCFCx3_lA+02-MDLCFCx3) FIELD 2 OFF
         DC    AL1(CSsrcLNR),AL1(MDLCFCx3A+01-MDLCFCx3) FIELD 1 LEN R/2
    DC    AL1(CSdfpexps),AL1(MDLCFCx3b+02-MDLCFCx3) SHIFT DEC PLACES
         DC    AL1(CSdfpopt),AL1(MDLCFCx3d-MDLCFCx3) optimise loads
         DC    AL1(CSRELOPR),AL1(MDLCFCx3F+1-MDLCFCx3) RELATIONAL CC
         DC    AL1(CSFALSEO),AL1(MDLCFCx3F+2-MDLCFCx3) FALSE BRANCH
         DC    AL1(CSTRUEO),AL1(MDLCFCx3T+2-MDLCFCx3) TRUE   BRANCH
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        COMPARE FIELDS           (NUMERIC - NUMERIC)                 *
***********************************************************************
MDLCFCx4 LAY   R14,0(,R2)         COMPARE CONSTANT
MDLCFCx4_la LAY R15,0(0,0)        get address
         ld    fp4,0(0,r14)       load first operand into fp4/6
         ld    fp6,8(0,r14)
MDLCFCx4b mvc  dblwork(0),0(r15)   copy event field to workplace
         ic    r0,0(0,r15)        save first character into r15
         if tmll,r0,x'00f0',z     test to see if not ones
MDLCFCx4c  xc dblwork(0),hexff   flip all the bits
         endif
         ni    dblwork,x'0f'      clean top nibble in workarea
MDLCFCx4d mvo  workar2,dblwork(0) CONVERT SOURCE FIELD
         ni workar2+l'workar2-1,x'f0'     clean the sign bits
         if tmll,r0,x'00f0',o     test to see if all ones
           oi workar2+l'workar2-1,x'0c'   and set sign to X'c'
         else
           oi workar2+l'workar2-1,x'0d'   and set sign to X'd'
         endif
         lmg   r0,r1,workar2
         cxstr fp1,r0
MDLCFCx4e lghi r15,*-*           Create biased exponent
         iextr fp1,fp1,r15       and insert
         cxtr  fp4,fp1            COMPARE TWO  FIELDS
MDLCFCx4F jlu  *+l'*              BRANCH  TO   FALSE IF  NOT TRUE
MDLCFCx4T jlu  *+l'*              BRANCH  TO   TRUE (OPTIONAL)
MDLCFCx4L EQU  *-MDLCFCx4
*
MDLCFCx4P EQU  0                  LITERAL POOL USAGE (EXCL FIELD LEN)
*
MDLCFCx4R DC   AL1(csv1offr),AL1(MDLCFCx4+02-MDLCFCx4) VALUE  1 OFF
         DC    AL1(cssrclofr),AL1(MDLCFCx4_LA+02-MDLCFCx4) src fld off
   DC    AL1(CSSRCLN),AL1(MDLCFCx4B+01-MDLCFCx4) TGT FIELD LEN L/2
   DC    AL1(CSSRCLN),AL1(MDLCFCx4C+01-MDLCFCx4) SRC FIELD LEN L/2
   DC    AL1(CSSRCLNR),AL1(MDLCFCx4d+01-MDLCFCx4) TGT FIELD LEN R/2
         DC    AL1(CSdfpexps),AL1(MDLCFCx4e+02-MDLCFCx4) dfp exp
         DC    AL1(CSRELOPR),AL1(MDLCFCx4F+1-MDLCFCx4) RELATIONAL CC
         DC    AL1(CSFALSEO),AL1(MDLCFCx4F+2-MDLCFCx4) FALSE BRANCH
         DC    AL1(CSTRUEO),AL1(MDLCFCx4T+2-MDLCFCx4) TRUE   BRANCH
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        COMPARE FIELD            (BINARY    CONSTANT)                *
***********************************************************************
MDLCFCx5u LAY  R14,0(,R2)          CONSTANT ADDRESS
MDLCFCx5u_la LAY R15,0(0,0)        get address
         ld    fp4,0(0,r14)        Load constant
         ld    fp6,8(0,r14)
         XGR   R0,r0
MDLCFCx5uD ICMy R0,B'0000',0(R15)
*
         cxgtr fp1,r0             convert from fixed to DFP
MDLCFCx5ue lghi r15,*-*           Create biased exponent
         iextr fp1,fp1,r15       and insert
         cxtr  fp4,fp1            COMPARE TWO  FIELDS
MDLCFCx5uF jlu *+l'*              BRANCH  TO   FALSE  IF NOT TRUE
MDLCFCx5uT jlu *+l'*              BRANCH  TO   TRUE  (OPTIONAL)
MDLCFCx5uL EQU *-MDLCFCx5u
*
MDLCFCx5uP EQU 0                  LITERAL POOL USAGE (EXCL FIELD LEN)
*
MDLCFCx5uR DC  AL1(csv1offr),AL1(MDLCFCx5u+02-MDLCFCx5u) VALUE 1 OFFSET
   DC    AL1(cssrclofr),AL1(MDLCFCx5u_la+02-MDLCFCx5u) SOURCE OFFSET
   DC    AL1(CSBYTMSS),AL1(MDLCFCx5uD+01-MDLCFCx5u) ICM BYTE MASK
   DC    AL1(CSdfpexps),AL1(MDLCFCx5ue+02-MDLCFCx5u) dfp exp
         DC    AL1(CSRELOPR),AL1(MDLCFCx5uF+1-MDLCFCx5u) RELATIONAL CC
         DC    AL1(CSFALSEO),AL1(MDLCFCx5uF+2-MDLCFCx5u) FALSE BRANCH
         DC    AL1(CSTRUEO),AL1(MDLCFCx5uT+2-MDLCFCx5u) TRUE BRANCH
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        COMPARE FIELD            (BINARY    CONSTANT)                *
***********************************************************************
MDLCFCx5 LAY   R14,0(,R2)          CONSTANT ADDRESS
MDLCFCx5_la LAY R15,0(0,0)         get address
         ld    fp4,0(0,r14)        Load constant
         ld    fp6,8(0,r14)
         XGR   R0,r0
         if tm,0(r15),x'80',o
           lghi r0,-1              fill with 1's
         endif
MDLCFCx5D ICMy R0,B'0000',0(R15)
*
         cxgtr fp1,r0             convert from fixed to DFP
MDLCFCx5e lghi r15,*-*           Create biased exponent
         iextr fp1,fp1,r15       and insert
         cxtr  fp4,fp1            COMPARE TWO  FIELDS
MDLCFCx5F jlu  *+l'*              BRANCH  TO   FALSE  IF NOT TRUE
MDLCFCx5T jlu  *+l'*              BRANCH  TO   TRUE  (OPTIONAL)
MDLCFCx5L EQU  *-MDLCFCx5
*
MDLCFCx5P EQU  0                  LITERAL POOL USAGE (EXCL FIELD LEN)
*
MDLCFCx5R DC   AL1(csv1offr),AL1(MDLCFCx5+02-MDLCFCx5) VALUE 1  OFFSET
         DC    AL1(cssrclofr),AL1(MDLCFCx5_la+02-MDLCFCx5) SOURCE OFFS
         DC    AL1(CSBYTMSS),AL1(MDLCFCx5D+01-MDLCFCx5) ICM BYTE MASK
         DC    AL1(CSdfpexps),AL1(MDLCFCx5e+02-MDLCFCx5) dfp exp
         DC    AL1(CSRELOPR),AL1(MDLCFCx5F+1-MDLCFCx5) RELATIONAL CC
         DC    AL1(CSFALSEO),AL1(MDLCFCx5F+2-MDLCFCx5) FALSE BRANCH
         DC    AL1(CSTRUEO),AL1(MDLCFCx5T+2-MDLCFCx5) TRUE   BRANCH
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        COMPARE FIELD            (BINARY    CONSTANT)                *
***********************************************************************
MDLCFCx5_88 LAY R14,0(,R2)         CONSTANT ADDRESS
MDLCFCx5_88B LG R0,0(0,0)
         ld    fp4,0(0,r14)        Load constant
         ld    fp6,8(0,r14)
         cxgtr fp1,r0             convert from fixed to DFP
MDLCFCx5_88e lghi r15,*-*           Create biased exponent
         iextr fp1,fp1,r15       and insert
         cxtr  fp4,fp1            COMPARE TWO  FIELDS
MDLCFCx5_88F jlu *+l'*            BRANCH  TO   FALSE  IF NOT TRUE
MDLCFCx5_88T jlu *+l'*            BRANCH  TO   TRUE  (OPTIONAL)
MDLCFCx5_88L EQU *-MDLCFCx5_88
*
MDLCFCx5_88P EQU 0                LITERAL POOL USAGE (EXCL FIELD LEN)
*
MDLCFCx5_88R ds 0h
   DC    AL1(csv1offr),AL1(MDLCFCx5_88+02-MDLCFCx5_88) VALUE 1 OFF
   DC    AL1(cssrclofr),AL1(MDLCFCx5_88B+02-MDLCFCx5_88) SOURCE OFF
   DC    AL1(CSdfpexps),AL1(MDLCFCx5_88e+02-MDLCFCx5_88) dfp exp
         DC    AL1(CSRELOPR),AL1(MDLCFCx5_88F+1-MDLCFCx5_88) REL cc
         DC    AL1(CSFALSEO),AL1(MDLCFCx5_88F+2-MDLCFCx5_88) FALSE BR
         DC    AL1(CSTRUEO),AL1(MDLCFCx5_88T+2-MDLCFCx5_88) TRUE BR
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        COMPARE FIELD            (BINARY    CONSTANT)                *
***********************************************************************
MDLCFCx6 LAY   R14,0(,R2)          CONSTANT ADDRESS
MDLCFCx6_la LAY R15,0(0,0)         get address
         ld    fp4,0(0,r14)        Load constant
         ld    fp6,8(0,r14)
         XGR   R0,r0
MDLCFCx6m mvc  workarea(0),0(r15) move event field to workarea
         xi    workarea,x'80'      flip the top bit
         if tm,workarea,x'80',nz If negative ...
           lghi r0,-1              fill with 1's
         endif
MDLCFCx6d ICMy R0,B'0000',workarea
*
         cxgtr fp1,r0             convert from fixed to DFP
MDLCFCx6e lghi r15,*-*           Create biased exponent
         iextr fp1,fp1,r15       and insert
         cxtr  fp4,fp1            COMPARE TWO  FIELDS
MDLCFCx6F jlu  *+l'*              BRANCH  TO   FALSE  IF NOT TRUE
MDLCFCx6T jlu  *+l'*              BRANCH  TO   TRUE  (OPTIONAL)
MDLCFCx6L EQU  *-MDLCFCx6
*
MDLCFCx6P EQU  0                  LITERAL POOL USAGE (EXCL FIELD LEN)
*
MDLCFCx6R DC   AL1(csv1offr),AL1(MDLCFCx6+02-MDLCFCx6) VALUE 1  OFFSET
         DC    AL1(cssrclofr),AL1(MDLCFCx6_la+02-MDLCFCx6) SOURCE OFFS
         DC    AL1(CSSRCln),AL1(MDLCFCx6m+01-MDLCFCx6) SOURCE length
         DC    AL1(CSBYTMSS),AL1(MDLCFCx6D+01-MDLCFCx6) ICM BYTE MASK
         DC    AL1(CSdfpexps),AL1(MDLCFCx6e+02-MDLCFCx6) dfp exp
         DC    AL1(CSRELOPR),AL1(MDLCFCx6F+1-MDLCFCx6) RELATIONAL CC
         DC    AL1(CSFALSEO),AL1(MDLCFCx6F+2-MDLCFCx6) FALSE BRANCH
         DC    AL1(CSTRUEO),AL1(MDLCFCx6T+2-MDLCFCx6) TRUE   BRANCH
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        COMPARE FIELD            (BINARY    CONSTANT)                *
***********************************************************************
MDLCFCx6_88 LAY R14,0(,R2)         CONSTANT ADDRESS
MDLCFCx6_88B Lay R15,0(0,0)
MDLCFCx6_88m mvc workarea(0),0(r15) move event field to workarea
         xi    workarea,x'80'         flip the top bit
         LG    R0,workarea
         ld    fp4,0(0,r14)        Load constant
         ld    fp6,8(0,r14)
         cxgtr fp1,r0             convert from fixed to DFP
MDLCFCx6_88e lghi r15,*-*           Create biased exponent
         iextr fp1,fp1,r15       and insert
         cxtr  fp4,fp1            COMPARE TWO  FIELDS
MDLCFCx6_88F jlu *+l'*            BRANCH  TO   FALSE  IF NOT TRUE
MDLCFCx6_88T jlu *+l'*            BRANCH  TO   TRUE  (OPTIONAL)
MDLCFCx6_88L EQU *-MDLCFCx6_88
*
MDLCFCx6_88P EQU 0                LITERAL POOL USAGE (EXCL FIELD LEN)
*
MDLCFCx6_88R DC AL1(csv1offr),AL1(MDLCFCx6_88+02-MDLCFCx6_88) VAL 1OFF
         DC    AL1(cssrclofr),AL1(MDLCFCx6_88B+02-MDLCFCx6_88) Src OFF
         DC    AL1(CSSRCln),AL1(MDLCFCx6_88m+01-MDLCFCx6_88) SOURCE len
         DC    AL1(CSdfpexps),AL1(MDLCFCx6_88e+02-MDLCFCx6_88) dfp exp
         DC    AL1(CSRELOPR),AL1(MDLCFCx6_88F+1-MDLCFCx6_88) REL cc
         DC    AL1(CSFALSEO),AL1(MDLCFCx6_88F+2-MDLCFCx6_88) FALSE BR
         DC    AL1(CSTRUEO),AL1(MDLCFCx6_88T+2-MDLCFCx6_88) TRUE BR
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        COMPARE FIELDS           (Accumulator and ednum)             *
***********************************************************************
mdlcfax7 llgt  R5,0(,R2)          LOAD LOGIC  TABLE  ROW ADDRESS
         LA    R1,WORKAREA
mdlcfax7bb BAS  R10,*-*            CALL "GVBDL96"  (FORMAT  FIELD)
mdlcfax7A jlu  *+l'*              FORMAT UNSUCCESSFUL BRANCH (FALSE)
         ld    fp4,workarea       load field into fp4/6
         ld    fp6,workarea+8
mdlcfax7B LAY  R1,0(,R2)         Addr Accumulator (not r14 as changed)
         ld    fp1,0(,r1)
         ld    fp3,8(,r1)
         cxtr  fp1,fp4            COMPARE VALUES
mdlcfax7F jlu  *+l'*              BRANCH  TO   FALSE  IF  NOT TRUE
mdlcfax7T jlu  *+l'*              BRANCH  TO   TRUE  (OPTIONAL)
mdlcfax7L EQU  *-mdlcfax7
*
mdlcfax7P EQU  4                  LITERAL POOL USAGE (EXCL FIELD LEN)
*
mdlcfax7R DC   AL1(CSLTROFF),AL1(mdlcfax7+02-mdlcfax7) LOGIC TBLROW ADR
         DC    AL1(CSdl96call),AL1(mdlcfax7bb-mdlcfax7) MR96 BAS
         DC    AL1(CSFALSEO),AL1(mdlcfax7A+2-mdlcfax7) FALSE BRANCH
         DC    AL1(CSACCOF2),AL1(mdlcfax7B+02-mdlcfax7) ACCUM OFFSET
         DC    AL1(CSRELOPR),AL1(mdlcfax7F+1-mdlcfax7) RELATIONAL CC
         DC    AL1(CSFALSEO),AL1(mdlcfax7F+2-mdlcfax7) FALSE BRANCH
         DC    AL1(CSTRUEO),AL1(mdlcfax7T+2-mdlcfax7) TRUE   BRANCH
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        COMPARE FIELDS           (PACKs  - PACKED)                   *
***********************************************************************
MDLCFCx8 LAY   R14,0(0,0)         LOAD  SOURCE address
MDLCFCx8_la LAY R15,0(0,r2)       CONSTANT ADDRESS
         ld    fp4,0(0,r15)       load first operand into fp4/6
         ld    fp6,8(0,r15)
MDLCFCx8d mvo  WORKAREA,0(0,R14) CONVERT SOURCE FIELD
         oi workarea+l'workarea-1,x'0F'     and set sign to X'f'
         lmg   r0,r1,workarea
         cxstr fp1,r0             convert to dfp
MDLCFCx8e lghi r15,*-*            Create biased exponent
         iextr fp1,fp1,r15       and insert
         cxtr  fp4,fp1            COMPARE TWO  FIELDS
MDLCFCx8F jlu  *+l'*              BRANCH  TO   FALSE  IF NOT TRUE
MDLCFCx8T jlu  *+l'*              BRANCH  TO   TRUE  (OPTIONAL)
MDLCFCx8L EQU  *-MDLCFCx8
*
MDLCFCx8P EQU  0                  LITERAL POOL USAGE (EXCL FIELD LEN)
*
MDLCFCx8R DC   AL1(cssrclofr),AL1(MDLCFCx8+02-MDLCFCx8) FIELD 1  OFF
         DC    AL1(csv1offr),AL1(MDLCFCx8_la+02-MDLCFCx8) FIELD 2 OFF
         DC    AL1(CSSRCLNR),AL1(MDLCFCx8d+01-MDLCFCx8) TARGET  LENGTH
   DC    AL1(CSdfpexps),AL1(MDLCFCx8e+02-MDLCFCx8) SHIFT DEC PLACES
         DC    AL1(CSRELOPR),AL1(MDLCFCx8F+1-MDLCFCx8) RELATIONAL CC
         DC    AL1(CSFALSEO),AL1(MDLCFCx8F+2-MDLCFCx8) FALSE BRANCH
         DC    AL1(CSTRUEO),AL1(MDLCFCx8T+2-MDLCFCx8) TRUE   BRANCH
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        Compare fields cfce    (date field/normalised date constant)
***********************************************************************
mdlcfcx9  LAY   R15,0(0,0)         Load source field address
MDLcfcx9B llgt  R5,0(,R2)          LOAD LOGIC  TABLE  ROW ADDRESS
          BAS   R10,dateNorm_indirect CONVERT field to normalised date
mdlcfcx9_la LAY   R14,0(0,r2)      LOAD constant address
mdlcfcx9c CLC   0(16,R14),Workarea COMPARE dates
MDLCFCx9F jlu   *+l'*              BRANCH  TO   FALSE  IF NOT TRUE
MDLCFCx9T jlu   *+l'*              BRANCH  TO   TRUE  (OPTIONAL)
MDLcfcx9L EQU   *-MDLcfcx9
*
MDLcfcx9P EQU   4                  LITERAL POOL USAGE (EXCL FIELD LEN)
*
mdlcfcx9R DC    AL1(CSSRClofr),AL1(mdlcfcx9+02-mdlcfcx9)  FIELD  1  OFF
         DC    AL1(CSv1offr),AL1(mdlcfcx9_la+02-mdlcfcx9) FIELD  2  OFF
         DC    AL1(CScmpdt2),AL1(mdlcfcx9c-mdlcfcx9)    compare date
         DC    AL1(CSLTROFF),AL1(MDLcfcx9B+02-MDLcfcx9) LOGIC TABLE ROW
         DC    AL1(CSRELOPR),AL1(MDLcfcx9F+1-MDLcfcx9)  RELATIONAL CC
         DC    AL1(CSFALSEO),AL1(MDLcfcx9F+02-MDLcfcx9) FALSE  BRANCH
         DC    AL1(CSTRUEO),AL1(MDLcfcx9T+02-MDLcfcx9)  TRUE   BRANCH
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        COMPARE FIELD            (Accumulator and alpha)             *
***********************************************************************
mdlcfax1 LAY   R14,0(,R2)         COMPARE Accumulator
mdlcfaxLA LAY  R15,0(0,0)         get address
mdlcfax1A CLC  0(0,r15),0(R14)    COMPARE TWO  FIELDS
mdlcfax1F jlu  *+l'*              BRANCH  TO   FALSE  IF NOT TRUE
mdlcfax1T jlu  *+l'*              BRANCH  TO   TRUE  (OPTIONAL)
mdlcfax1L EQU  *-mdlcfax1
*
mdlcfax1P EQU  0                  LITERAL POOL USAGE (EXCL FIELD LEN)
*
mdlcfax1R DC   AL1(csaccof2),AL1(mdlcfax1+02-mdlcfax1) VALUE 1  OFF
         DC    AL1(CStgtLN),AL1(mdlcfax1A+01-mdlcfax1) FIELD 1  LEN
         DC    AL1(cstgtlof),AL1(mdlcfaxLA+02-mdlcfax1) FIELD 1 OFF
         DC    AL1(CSRELOPR),AL1(mdlcfax1F+1-mdlcfax1) RELATIONAL CC
         DC    AL1(CSFALSEO),AL1(mdlcfax1F+2-mdlcfax1) FALSE BRANCH
         DC    AL1(CSTRUEO),AL1(mdlcfax1T+2-mdlcfax1) TRUE   BRANCH
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        COMPARE FIELD            (Accum - Packed )                   *
***********************************************************************
mdlcfax2 LAY   R14,0(,R2)         COMPARE Accumulator
mdlcfax2_la LAY R15,0(0,0)        get address of Packed field
mdlcfax2A ZAP  WORKAREA,0(0,r15)  CONVERT PACKED
         lmg   r0,r1,workarea
         cxstr fp1,r0
mdlcfax2b lghi r15,*-*           Create biased exponent
         iextr fp1,fp1,r15       and insert
mdlcfax2d ld   fp0,0(0,r14)
         ld    fp2,8(0,r14)
         cxtr  fp0,fp1
mdlcfax2F jlu  *+l'*              BRANCH  TO   FALSE  IF NOT TRUE
mdlcfax2T jlu  *+l'*              BRANCH  TO   TRUE  (OPTIONAL)
mdlcfax2L EQU  *-mdlcfax2
*
mdlcfax2P EQU  0                  LITERAL POOL USAGE (EXCL FIELD LEN)
*
mdlcfax2R DC   AL1(csaccof2),AL1(mdlcfax2+02-mdlcfax2) Accum OFF
         DC    AL1(cstgtlof),AL1(mdlcfax2_lA+02-mdlcfax2) FIELD 1 OFF
         DC    AL1(CStgtLNR),AL1(mdlcfax2A+01-mdlcfax2) FIELD 1 LEN
         DC    AL1(CSdfpexp),AL1(mdlcfax2b+02-mdlcfax2) dfp exp (event)
         DC    AL1(CSdfpopt),AL1(mdlcfax2d-mdlcfax2) optimise loads
         DC    AL1(CSRELOPR),AL1(mdlcfax2F+1-mdlcfax2) RELATIONAL CC
         DC    AL1(CSFALSEO),AL1(mdlcfax2F+2-mdlcfax2) FALSE BRANCH
         DC    AL1(CSTRUEO),AL1(mdlcfax2T+2-mdlcfax2) TRUE   BRANCH
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        COMPARE FIELDS           (Accum - zoned)                     *
***********************************************************************
mdlcfax3 LAY   R14,0(,R2)         LOAD constant
mdlcfax3_la LAY R15,0(0,0)        get address
mdlcfax3A PACK WORKAREA,0(0,r15)  CONVERT PACKED
         lmg   r0,r1,workarea
         cxstr fp1,r0
mdlcfax3b lghi r15,*-*            Create biased exponent
         iextr fp1,fp1,r15          and insert
mdlcfax3d ld   fp0,0(0,r14)
         ld    fp2,8(0,r14)
         cxtr  fp0,fp1
mdlcfax3F jlu  *+l'*              BRANCH  TO   FALSE  IF NOT TRUE
mdlcfax3T jlu  *+l'*              BRANCH  TO   TRUE  (OPTIONAL)
mdlcfax3L EQU  *-mdlcfax3
*
mdlcfax3P EQU  4                  LITERAL POOL USAGE (EXCL FIELD LEN)
*
mdlcfax3R DC   AL1(csaccof2),AL1(mdlcfax3+02-mdlcfax3) ACCUM 2 OFF
         DC    AL1(cstgtlof),AL1(mdlcfax3_lA+02-mdlcfax3) FIELD 2 OFF
         DC    AL1(CStgtLNR),AL1(mdlcfax3A+01-mdlcfax3) FIELD 1 LEN R/2
        DC    AL1(CSdfpexp),AL1(mdlcfax3b+02-mdlcfax3) SHIFT DEC PLACES
         DC    AL1(CSdfpopt),AL1(mdlcfax3d-mdlcfax3) optimise loads
         DC    AL1(CSRELOPR),AL1(mdlcfax3F+1-mdlcfax3) RELATIONAL CC
         DC    AL1(CSFALSEO),AL1(mdlcfax3F+2-mdlcfax3) FALSE BRANCH
         DC    AL1(CSTRUEO),AL1(mdlcfax3T+2-mdlcfax3) TRUE   BRANCH
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        COMPARE FIELDS           (Accum - Psort)                     *
***********************************************************************
mdlcfax4 LAY   R14,0(,R2)         COMPARE accummulator
mdlcfax4_la LAY R15,0(0,0)        get address of field
         ld    fp4,0(0,r14)       load first operand into fp4/6
         ld    fp6,8(0,r14)
mdlcfax4b mvc  dblwork(0),0(r15)   copy event field to workplace
         ic    r0,0(0,r15)        save first character into r15
         if tmll,r0,x'00f0',z     test to see if not ones
mdlcfax4c  xc dblwork(0),hexff   flip all the bits
         endif
         ni    dblwork,x'0f'      clean top nibble in workarea
mdlcfax4d mvo  workar2,dblwork(0) CONVERT SOURCE FIELD
         ni workar2+l'workar2-1,x'f0'     clean the sign bits
         if tmll,r0,x'00f0',o     test to see if all ones
           oi workar2+l'workar2-1,x'0c'   and set sign to X'c'
         else
           oi workar2+l'workar2-1,x'0d'   and set sign to X'd'
         endif
         lmg   r0,r1,workar2
         cxstr fp1,r0
mdlcfax4e lghi r15,*-*           Create biased exponent
         iextr fp1,fp1,r15       and insert
         cxtr  fp4,fp1            COMPARE TWO  FIELDS
mdlcfax4F jlu  *+l'*              BRANCH  TO   FALSE IF  NOT TRUE
mdlcfax4T jlu  *+l'*              BRANCH  TO   TRUE (OPTIONAL)
mdlcfax4L EQU  *-mdlcfax4
*
mdlcfax4P EQU  0                  LITERAL POOL USAGE (EXCL FIELD LEN)
*
mdlcfax4R DC   AL1(csaccof2),AL1(mdlcfax4+02-mdlcfax4) Accumm OFF
         DC    AL1(cstgtlof),AL1(mdlcfax4_LA+02-mdlcfax4) src fld off
   DC    AL1(CStgtLN),AL1(mdlcfax4B+01-mdlcfax4) TGT FIELD LEN L/2
   DC    AL1(CStgtLN),AL1(mdlcfax4C+01-mdlcfax4) SRC FIELD LEN L/2
   DC    AL1(CStgtLNR),AL1(mdlcfax4d+01-mdlcfax4) TGT FIELD LEN R/2
         DC    AL1(CSdfpexp),AL1(mdlcfax4e+02-mdlcfax4) dfp exp
         DC    AL1(CSRELOPR),AL1(mdlcfax4F+1-mdlcfax4) RELATIONAL CC
         DC    AL1(CSFALSEO),AL1(mdlcfax4F+2-mdlcfax4) FALSE BRANCH
         DC    AL1(CSTRUEO),AL1(mdlcfax4T+2-mdlcfax4) TRUE   BRANCH
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        COMPARE FIELD            (ACCUM / UNSIGNED BINARY)           *
***********************************************************************
mdlcfax5u LAY  R14,0(,R2)          ACCUMULATOR
mdlcfax5u_la LAY R15,0(0,0)        get address field
         ld    fp4,0(0,r14)        Load constant
         ld    fp6,8(0,r14)
         XGR   R0,r0
mdlcfax5uD ICMy R0,B'0000',0(R15)
*
         cxgtr fp1,r0             convert from fixed to DFP
mdlcfax5ue lghi r15,*-*           Create biased exponent (dec places)
         iextr fp1,fp1,r15       and insert
         cxtr  fp4,fp1            COMPARE TWO  FIELDS
mdlcfax5uF jlu *+l'*              BRANCH  TO   FALSE  IF NOT TRUE
mdlcfax5uT jlu *+l'*              BRANCH  TO   TRUE  (OPTIONAL)
mdlcfax5uL EQU *-mdlcfax5u
*
mdlcfax5uP EQU 0                  LITERAL POOL USAGE (EXCL FIELD LEN)
*
mdlcfax5uR DC  AL1(csaccof2),AL1(mdlcfax5u+02-mdlcfax5u) VALUE 1 OFFSET
   DC   AL1(cstgtlof),AL1(mdlcfax5u_la+02-mdlcfax5u) SOURCE OFFSET
   DC   AL1(CSBYTMSK),AL1(mdlcfax5uD+01-mdlcfax5u) ICM BYTE MASK
   DC   AL1(CSdfpexp),AL1(mdlcfax5ue+02-mdlcfax5u) dfp exp (Event fld)
         DC    AL1(CSRELOPR),AL1(mdlcfax5uF+1-mdlcfax5u) RELATIONAL CC
         DC    AL1(CSFALSEO),AL1(mdlcfax5uF+2-mdlcfax5u) FALSE BRANCH
         DC    AL1(CSTRUEO),AL1(mdlcfax5uT+2-mdlcfax5u) TRUE BRANCH
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        COMPARE FIELD            (ACCUM / SIGNED BINARY)             *
***********************************************************************
mdlcfax5 LAY   R14,0(,R2)          accumulator
mdlcfax5_la LAY R15,0(0,0)         get address field
         ld    fp4,0(0,r14)        Load constant
         ld    fp6,8(0,r14)
         XGR   R0,r0
         if tm,0(r15),x'80',o
           lghi r0,-1              fill with 1's
         endif
mdlcfax5D ICMy R0,B'0000',0(R15)
*
         cxgtr fp1,r0             convert from fixed to DFP
mdlcfax5e lghi r15,*-*           Create biased exponent (dec places)
         iextr fp1,fp1,r15       and insert
         cxtr  fp4,fp1            COMPARE TWO  FIELDS
mdlcfax5F jlu  *+l'*              BRANCH  TO   FALSE  IF NOT TRUE
mdlcfax5T jlu  *+l'*              BRANCH  TO   TRUE  (OPTIONAL)
mdlcfax5L EQU  *-mdlcfax5
*
mdlcfax5P EQU  0                  LITERAL POOL USAGE (EXCL FIELD LEN)
*
mdlcfax5R DC   AL1(csaccof2),AL1(mdlcfax5+02-mdlcfax5) ACCUM    OFFSET
         DC    AL1(cstgtlof),AL1(mdlcfax5_la+02-mdlcfax5) SOURCE OFFS
         DC    AL1(CSBYTMSK),AL1(mdlcfax5D+01-mdlcfax5) ICM BYTE MASK
         DC    AL1(CSdfpexp),AL1(mdlcfax5e+02-mdlcfax5) dfp exp (field)
         DC    AL1(CSRELOPR),AL1(mdlcfax5F+1-mdlcfax5) RELATIONAL CC
         DC    AL1(CSFALSEO),AL1(mdlcfax5F+2-mdlcfax5) FALSE BRANCH
         DC    AL1(CSTRUEO),AL1(mdlcfax5T+2-mdlcfax5) TRUE   BRANCH
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        COMPARE FIELD            (ACCUM / binary 8)                  *
***********************************************************************
mdlcfax5_88 LAY R14,0(,R2)         Accumulator
mdlcfax5_88B LG R0,0(0,0)
         ld    fp4,0(0,r14)        Load accumulator
         ld    fp6,8(0,r14)
         cxgtr fp1,r0              convert binary to DFP
mdlcfax5_88e lghi r15,*-*          Create biased exponent
         iextr fp1,fp1,r15         and insert
         cxtr  fp4,fp1            COMPARE
mdlcfax5_88F jlu *+l'*            BRANCH  TO   FALSE  IF NOT TRUE
mdlcfax5_88T jlu *+l'*            BRANCH  TO   TRUE  (OPTIONAL)
mdlcfax5_88L EQU *-mdlcfax5_88
*
mdlcfax5_88P EQU 0                LITERAL POOL USAGE (EXCL FIELD LEN)
*
mdlcfax5_88R ds 0h
   DC    AL1(csaccof2),AL1(mdlcfax5_88+02-mdlcfax5_88) ACCUM
   DC    AL1(cstgtlof),AL1(mdlcfax5_88B+02-mdlcfax5_88) SOURCE OFF
   DC    AL1(CSdfpexp),AL1(mdlcfax5_88e+02-mdlcfax5_88) dfp exp
         DC    AL1(CSRELOPR),AL1(mdlcfax5_88F+1-mdlcfax5_88) REL cc
         DC    AL1(CSFALSEO),AL1(mdlcfax5_88F+2-mdlcfax5_88) FALSE BR
         DC    AL1(CSTRUEO),AL1(mdlcfax5_88T+2-mdlcfax5_88) TRUE BR
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        COMPARE FIELD            (Accum - binary sort)               *
***********************************************************************
mdlcfax6 LAY   R14,0(,R2)          Accumulator
mdlcfax6_la LAY R15,0(0,0)         get address of Bsort
         ld    fp4,0(0,r14)        Load constant
         ld    fp6,8(0,r14)
         XGR   R0,r0
mdlcfax6m mvc  workarea(0),0(r15)  move event field to workarea
         xi    workarea,x'80'      flip the top bit
         if tm,workarea,x'80',nz If negative ...
           lghi r0,-1              fill with 1's
         endif
mdlcfax6d ICMy R0,B'0000',workarea
*
         cxgtr fp1,r0             convert from fixed to DFP
mdlcfax6e lghi r15,*-*           Create biased exponent
         iextr fp1,fp1,r15       and insert
         cxtr  fp4,fp1            COMPARE TWO  FIELDS
mdlcfax6F jlu  *+l'*              BRANCH  TO   FALSE  IF NOT TRUE
mdlcfax6T jlu  *+l'*              BRANCH  TO   TRUE  (OPTIONAL)
mdlcfax6L EQU  *-mdlcfax6
*
mdlcfax6P EQU  0                  LITERAL POOL USAGE (EXCL FIELD LEN)
*
mdlcfax6R DC   AL1(csaccof2),AL1(mdlcfax6+02-mdlcfax6) Accum    OFFSET
         DC    AL1(cstgtlof),AL1(mdlcfax6_la+02-mdlcfax6) SOURCE OFFS
         DC    AL1(CStgtln),AL1(mdlcfax6m+01-mdlcfax6) SOURCE length
         DC    AL1(CSBYTMSK),AL1(mdlcfax6D+01-mdlcfax6) ICM BYTE MASK
         DC    AL1(CSdfpexp),AL1(mdlcfax6e+02-mdlcfax6) dfp exp
         DC    AL1(CSRELOPR),AL1(mdlcfax6F+1-mdlcfax6) RELATIONAL CC
         DC    AL1(CSFALSEO),AL1(mdlcfax6F+2-mdlcfax6) FALSE BRANCH
         DC    AL1(CSTRUEO),AL1(mdlcfax6T+2-mdlcfax6) TRUE   BRANCH
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        COMPARE FIELD            (Accum - binary sort)               *
***********************************************************************
mdlcfax6_88 LAY R14,0(,R2)         Accumulator
mdlcfax6_88B Lay R15,0(0,0) Addr of bsort
mdlcfax6_88m mvc workarea(0),0(r15) move event field to workarea
         xi    workarea,x'80'         flip the top bit
         LG    R0,workarea
         ld    fp4,0(0,r14)        Load constant
         ld    fp6,8(0,r14)
         cxgtr fp1,r0              convert from fixed to DFP
mdlcfax6_88e lghi r15,*-*          Create biased exponent
         iextr fp1,fp1,r15          and insert
         cxtr  fp4,fp1            COMPARE TWO  FIELDS
mdlcfax6_88F jlu *+l'*            BRANCH  TO   FALSE  IF NOT TRUE
mdlcfax6_88T jlu *+l'*            BRANCH  TO   TRUE  (OPTIONAL)
mdlcfax6_88L EQU *-mdlcfax6_88
*
mdlcfax6_88P EQU 0                LITERAL POOL USAGE (EXCL FIELD LEN)
*
mdlcfax6_88R DC AL1(csaccof2),AL1(mdlcfax6_88+02-mdlcfax6_88) Accum
         DC    AL1(cstgtlof),AL1(mdlcfax6_88B+02-mdlcfax6_88) Src OFF
         DC    AL1(CStgtln),AL1(mdlcfax6_88m+01-mdlcfax6_88) SOURCE len
         DC    AL1(CSdfpexp),AL1(mdlcfax6_88e+02-mdlcfax6_88) dfp exp
         DC    AL1(CSRELOPR),AL1(mdlcfax6_88F+1-mdlcfax6_88) REL cc
         DC    AL1(CSFALSEO),AL1(mdlcfax6_88F+2-mdlcfax6_88) FALSE BR
         DC    AL1(CSTRUEO),AL1(mdlcfax6_88T+2-mdlcfax6_88) TRUE BR
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        COMPARE FIELDS           (Accum - BCD)                       *
***********************************************************************
mdlcfax8 LAY   R14,0(0,0)         LOAD  SOURCE address
mdlcfax8_la LAY R15,0(0,r2)       Accumulator
         ld    fp4,0(0,r15)       load first operand into fp4/6
         ld    fp6,8(0,r15)
mdlcfax8d mvo  WORKAREA,0(0,R14) CONVERT SOURCE FIELD
         oi workarea+l'workarea-1,x'0F'     and set sign to X'f'
         lmg   r0,r1,workarea
         cxstr fp1,r0             convert to dfp
mdlcfax8e lghi r15,*-*            Create biased exponent
         iextr fp1,fp1,r15       and insert
         cxtr  fp4,fp1            COMPARE TWO  FIELDS
mdlcfax8F jlu  *+l'*              BRANCH  TO   FALSE  IF NOT TRUE
mdlcfax8T jlu  *+l'*              BRANCH  TO   TRUE  (OPTIONAL)
mdlcfax8L EQU  *-mdlcfax8
*
mdlcfax8P EQU  0                  LITERAL POOL USAGE (EXCL FIELD LEN)
*
mdlcfax8R DC   AL1(cstgtlof),AL1(mdlcfax8+02-mdlcfax8) FIELD 1  OFF
         DC    AL1(csaccof2),AL1(mdlcfax8_la+02-mdlcfax8) Accumulator
         DC    AL1(CStgtLNR),AL1(mdlcfax8d+01-mdlcfax8) TARGET  LENGTH
   DC    AL1(CSdfpexp),AL1(mdlcfax8e+02-mdlcfax8) SHIFT DEC PLACES
         DC    AL1(CSRELOPR),AL1(mdlcfax8F+1-mdlcfax8) RELATIONAL CC
         DC    AL1(CSFALSEO),AL1(mdlcfax8F+2-mdlcfax8) FALSE BRANCH
         DC    AL1(CSTRUEO),AL1(mdlcfax8T+2-mdlcfax8) TRUE   BRANCH
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        COMPARE FIELDS           (NORMALIZED DATE COMPARISON)
***********************************************************************
MDLCF00  LAy   R0,0(,0)           LOAD  SOURCE DATE   ADDRESS
MDLCF00A LAy   R1,0(,0)           LOAD  TARGET DATE   ADDRESS
MDLCF00B llgt  R5,0(,R2)          LOAD LOGIC  TABLE  ROW ADDRESS
         BAS   R10,DATECMP1_indirect NORMALIZE AND COMPARE DATES
MDLCF00C CLC   LKUPKEY(8),LKUPKEY+8     COMPARE    NORMALIZED DATES
MDLCF00F jlu   *+l'*              BRANCH TO    FALSE  IF  NOT TRUE
MDLCF00T jlu   *+l'*              BRANCH TO    TRUE
MDLCF00L EQU   *-MDLCF00
*
MDLCF00P EQU   4                  LITERAL POOL USAGE (EXCL FIELD LEN)
*
MDLCF00R DC    AL1(CSSRCloF),AL1(MDLCF00+02-MDLCF00)  SOURCE OFFSET
         DC    AL1(CSTGTloF),AL1(MDLCF00A+02-MDLCF00) TARGET OFFSET
         DC    AL1(CSLTROFF),AL1(MDLCF00B+02-MDLCF00) LOGIC  TABLE ROW
         DC    AL1(CSRELOPR),AL1(MDLCF00F+1-MDLCF00)  RELATIONAL CC
         DC    AL1(CSFALSEM),AL1(MDLCF00F+02-MDLCF00) FALSE  BRANCH
         DC    AL1(CSTRUEO),AL1(MDLCF00T+02-MDLCF00)  TRUE   BRANCH
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        COMPARE FIELDS           (CHARACTER - DIFF LENGTH)           *
***********************************************************************
MDLCF01  LAY   R14,0(0,0)         LOAD  SOURCE address
MDLCF01_la LAY R15,0(,R2)         CONSTANT ADDRESS
MDLCF01C CLC   0(0,r14),0(R15)    COMPARE TWO  FIELDS
MDLCF01F jlu   *+l'*              BRANCH  TO   FALSE  IF NOT TRUE
MDLCF01T jlu   *+l'*              BRANCH  TO   TRUE  (OPTIONAL)
MDLCF01L EQU   *-MDLCF01
*
MDLCF01P EQU   0                  LITERAL POOL USAGE (EXCL FIELD LEN)
*
MDLCF01R DC    AL1(CSSRCLN),AL1(MDLCF01C+01-MDLCF01)  FIELD  1  LEN
         DC    AL1(CSSRCloF),AL1(MDLCF01+02-MDLCF01)  FIELD  1  OFF
         DC    AL1(CSTGTloF),AL1(MDLCF01_la+02-MDLCF01)  FIELD  2  OFF
         DC    AL1(CSRELOPR),AL1(MDLCF01F+1-MDLCF01)  RELATIONAL CC
         DC    AL1(CSFALSEO),AL1(MDLCF01F+2-MDLCF01)  FALSE  BRANCH
         DC    AL1(CSTRUEO),AL1(MDLCF01T+2-MDLCF01)   TRUE   BRANCH
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        COMPARE FIELDS           (PACKED - PACKED)                   *
***********************************************************************
MDLCF03  LAY   R14,0(0,0)         LOAD  SOURCE address
MDLCF03_la LAY R15,0(0,0)         CONSTANT ADDRESS
MDLCF03A ZAP   WORKAREA,0(0,r14)  CONVERT PACKED
         lmg   r0,r1,workarea
         cxstr fp1,r0
MDLcf03b lghi  r14,*-*           Create biased exponent
         iextr fp1,fp1,r14       and insert
MDLCF03c ZAP   WORKAREA,0(0,r15)  CONVERT PACKED
         lmg   r0,r1,workarea
         cxstr fp4,r0
MDLcf03d lghi  r14,*-*           Create biased exponent
         iextr fp4,fp4,r14       and insert
         cxtr  fp1,fp4
MDLCF03F jlu   *+l'*              BRANCH  TO   FALSE  IF NOT TRUE
MDLCF03T jlu   *+l'*              BRANCH  TO   TRUE  (OPTIONAL)
MDLCF03L EQU   *-MDLCF03
*
MDLCF03P EQU   0                  LITERAL POOL USAGE (EXCL FIELD LEN)
*
MDLCF03R DC    AL1(CSSRCLNr),AL1(MDLCF03a+01-MDLCF03)  FIELD  1 LEN r/2
         DC    AL1(CSTGTLNR),AL1(MDLCF03c+01-MDLCF03)  FIELD  2 LEN R/2
         DC    AL1(CSSRCloF),AL1(MDLCF03+02-MDLCF03)   FIELD  1  OFF
         DC    AL1(CSTGTloF),AL1(MDLCF03_la+02-MDLCF03)  FIELD  2  OFF
         DC    AL1(CSdfpexps),AL1(MDLcf03b+02-MDLcf03) dfp exp
         DC    AL1(CSdfpexp),AL1(MDLcf03d+02-MDLcf03) dfp exp
         DC    AL1(CSRELOPR),AL1(MDLCF03F+1-MDLCF03)  RELATIONAL CC
         DC    AL1(CSFALSEO),AL1(MDLCF03F+2-MDLCF03)  FALSE  BRANCH
         DC    AL1(CSTRUEO),AL1(MDLCF03T+2-MDLCF03)   TRUE   BRANCH
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        COMPARE FIELDS           (PACKED - NUMERIC)                  *
***********************************************************************
MDLCF04  LAY   R14,0(0,0)         LOAD  target address
MDLCF04_la LAY R15,0(0,0)               source
MDLCF04k PACK  WORKAREA,0(0,R14)  PACK NUMERIC FIELD
         lmg   r0,r1,workarea
         cxstr fp1,r0
MDLcf04b lghi  r14,*-*           Create biased exponent
         iextr fp1,fp1,r14       and insert
MDLCF04a zap   WORKAREA,0(0,R15)  PACK NUMERIC FIELD
         lmg   r0,r1,workarea
         cxstr fp4,r0
MDLcf04d lghi  r14,*-*           Create biased exponent
         iextr fp4,fp4,r14       and insert
         cxtr  fp4,fp1
MDLCF04F jlu   *+l'*              BRANCH  TO   FALSE  IF NOT TRUE
MDLCF04T jlu   *+l'*              BRANCH  TO   TRUE  (OPTIONAL)
MDLCF04L EQU   *-MDLCF04
*
MDLCF04P EQU   0                  LITERAL POOL USAGE (EXCL FIELD LEN)
*
MDLCF04R ds 0h
         DC    AL1(CSTGTLNR),AL1(MDLCF04k+01-MDLCF04) FIELD  2  LEN R/2
         DC    AL1(CSTGTloF),AL1(MDLCF04+02-MDLCF04)  FIELD  2  OFF
         DC    AL1(CSSRCLNr),AL1(MDLCF04A+01-MDLCF04) FIELD  1  LEN L/2
         DC    AL1(CSSRCLoF),AL1(MDLCF04_la+02-MDLCF04) FIELD  1  OFF
         DC    AL1(CSdfpexps),AL1(MDLcf04d+02-MDLcf04) dfp exp
         DC    AL1(CSdfpexp),AL1(MDLcf04b+02-MDLcf04) dfp exp
         DC    AL1(CSRELOPR),AL1(MDLCF04F+1-MDLCF04)  RELATIONAL CC
         DC    AL1(CSFALSEO),AL1(MDLCF04F+2-MDLCF04)  FALSE  BRANCH
         DC    AL1(CSTRUEO),AL1(MDLCF04T+2-MDLCF04)   TRUE   BRANCH
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        COMPARE FIELDS           (SORTP  - NUMERIC)                  *
***********************************************************************
mdlcf15  LAY   R14,0(0,0)         LOAD  target address
mdlcf15_la LAY R15,0(0,0)               source
MDLcf15b mvc   workar2(0),0(r15)  copy event field to workplace
         ic    r0,0(0,r15)        save first character into r0
         if tmll,r0,x'00f0',z     test to see if not ones
mdlcf15c   xc workar2(0),hexff   flip all the bits
         endif
         ni    workar2,x'0f'      clean top nibble in workarea
MDLcf15d mvo   WORKAREA,workar2(0)  CONVERT SOURCE FIELD
         ni workarea+l'workarea-1,x'f0'     clean the sign bits
         if tmll,r0,x'00f0',o     test to see if all ones
           oi workarea+l'workarea-1,x'0c'   and set sign to X'c'
         else
           oi workarea+l'workarea-1,x'0d'   and set sign to X'd'
         endif
         lmg   r0,r1,workarea
         cxstr fp4,r0
MDLcf15e lghi  r15,*-*           Create biased exponent
         iextr fp4,fp4,r15       and insert
mdlcf15k PACK  WORKAR2,0(0,R14) PACK NUMERIC FIELD
         lmg   r0,r1,workar2
         cxstr fp1,r0
MDLcf15a lghi  r14,*-*           Create biased exponent
         iextr fp1,fp1,r14       and insert
         cxtr  fp4,fp1
mdlcf15F jlu   *+l'*              BRANCH  TO   FALSE  IF NOT TRUE
mdlcf15T jlu   *+l'*              BRANCH  TO   TRUE  (OPTIONAL)
mdlcf15L EQU   *-mdlcf15
*
mdlcf15P EQU   0                  LITERAL POOL USAGE (EXCL FIELD LEN)
*
mdlcf15R ds    0h
         DC    AL1(CSTGTLNR),AL1(mdlcf15k+01-mdlcf15) FIELD  2  LEN R/2
         DC    AL1(CSTGTloF),AL1(mdlcf15+02-mdlcf15)  FIELD  2  OFF
         DC    AL1(CSSRCLoF),AL1(mdlcf15_la+02-mdlcf15) FIELD  1  OFF
         DC    AL1(CSsrcLN),AL1(MDLcf15b+01-MDLcf15) TARGET    OFFSET
         DC    AL1(CSsrcLN),AL1(MDLcf15c+01-MDLcf15) TARGET    OFFSET
         DC    AL1(CSsrcLNR),AL1(MDLcf15d+01-MDLcf15) TARGET    LENGTH
         DC    AL1(CSdfpexps),AL1(MDLcf15e+02-MDLcf15) dfp exp
         DC    AL1(CSdfpexp),AL1(MDLcf15a+02-MDLcf15) dfp exp
         DC    AL1(CSRELOPR),AL1(mdlcf15F+1-mdlcf15)  RELATIONAL CC
         DC    AL1(CSFALSEO),AL1(mdlcf15F+2-mdlcf15)  FALSE  BRANCH
         DC    AL1(CSTRUEO),AL1(mdlcf15T+2-mdlcf15)   TRUE   BRANCH
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        COMPARE FIELDS           (PACKED - BINARY)                   *
***********************************************************************
MDLCF05  ds    0h                 CONVERT BINARY FIELD
mdlcf05_la lay r14,0(0,0)         source address
MDLCF05aa ZAP  WORKAREA,0(0,r14)  CONVERT PACKED
         lmg   r0,r1,workarea
         cxstr fp1,r0
MDLcf05b lghi  r14,*-*           Create biased exponent
         iextr fp1,fp1,r14       and insert
         xgr   r0,r0
MDLCF05S TMy   0(0),X'80'
         if (o)
           lghi r0,-1              fill with 1's
         endif
MDLCF05A ICMy  R0,B'0000',0(0)
         cxgtr fp4,r0
MDLcf05e lghi  r15,*-*           Create biased exponent
         iextr fp4,fp4,r15       and insert
         cxtr  fp1,fp4
MDLCF05F jlu   *+l'*              BRANCH  TO   FALSE  IF NOT TRUE
MDLCF05T jlu   *+l'*              BRANCH  TO   TRUE  (OPTIONAL)
MDLCF05L EQU   *-MDLCF05
*
MDLCF05P EQU   0                  LITERAL POOL USAGE (EXCL FIELD LEN)
*
MDLCF05R DC    AL1(CSTGTloF),AL1(MDLCF05S+02-MDLCF05) FIELD  2  OFFSET
         DC    AL1(CSBYTMSK),AL1(MDLCF05A+01-MDLCF05) BYTE      MASK
         DC    AL1(CStgtloF),AL1(MDLCF05A+02-MDLCF05) FIELD  2  OFFSET
         DC    AL1(CSSRCLNr),AL1(MDLCF05aa+01-MDLCF05) FIELD  1 LEN r/2
         DC    AL1(CSSRCloF),AL1(MDLCF05_la+02-MDLCF05) FIELD  1  OFF
         DC    AL1(CSdfpexps),AL1(MDLcf05b+02-MDLcf05) dfp exp
         DC    AL1(CSdfpexp),AL1(MDLcf05e+02-MDLcf05) dfp exp
         DC    AL1(CSRELOPR),AL1(MDLCF05F+1-MDLCF05)  RELATIONAL CC
         DC    AL1(CSFALSEO),AL1(MDLCF05F+2-MDLCF05)  FALSE  BRANCH
         DC    AL1(CSTRUEO),AL1(MDLCF05T+2-MDLCF05)   TRUE   BRANCH
         DC   2XL1'FF'
***********************************************************************
*        COMPARE FIELDS           (PACKED - BINARY)                   *
***********************************************************************
MDLCF05u ds    0h                 CONVERT BINARY FIELD
mdlcf05u_la lay r14,0(0,0)        source address
MDLCF05uaa ZAP  WORKAREA,0(0,r14)  CONVERT PACKED
         lmg   r0,r1,workarea
         cxstr fp1,r0
MDLcf05ub lghi  r14,*-*           Create biased exponent
         iextr fp1,fp1,r14       and insert
         xgr   r0,r0
MDLCF05uA ICMy R0,B'0000',0(0)
         cxgtr fp4,r0
MDLcf05ue lghi  r15,*-*           Create biased exponent
         iextr fp4,fp4,r15       and insert
         cxtr  fp1,fp4
MDLCF05uF jlu  *+l'*              BRANCH  TO   FALSE  IF NOT TRUE
MDLCF05uT jlu  *+l'*              BRANCH  TO   TRUE  (OPTIONAL)
MDLCF05uL EQU  *-MDLCF05u
*
MDLCF05uP EQU  0                  LITERAL POOL USAGE (EXCL FIELD LEN)
*
MDLCF05uR dc   AL1(CSBYTMSK),AL1(MDLCF05uA+01-MDLCF05u) BYTE    MASK
         DC    AL1(CSTGTloF),AL1(MDLCF05uA+02-MDLCF05u) FIELD 2 OFFSET
         DC    AL1(CSdfpexp),AL1(MDLcf05ue+02-MDLcf05u) dfp exp
         DC    AL1(CSSRCloF),AL1(MDLCF05u_la+02-MDLCF05u) FIELD 1 OFF
         DC    AL1(CSSRCLNr),AL1(MDLCF05uaa+01-MDLCF05u) FIELD 1 LENr/2
         DC    AL1(CSdfpexps),AL1(MDLcf05ub+02-MDLcf05u) dfp exp
         DC    AL1(CSRELOPR),AL1(MDLCF05uF+1-MDLCF05u) RELATIONAL CC
         DC    AL1(CSFALSEO),AL1(MDLCF05uF+2-MDLCF05u) FALSE BRANCH
         DC    AL1(CSTRUEO),AL1(MDLCF05uT+2-MDLCF05u) TRUE   BRANCH
         DC   2XL1'FF'
***********************************************************************
*        COMPARE FIELDS           (PACKED - BINARY 8)                 *
***********************************************************************
MDLCF05_b8 LG  R15,0(0,0)          CONVERT BINARY FIELD
mdlcf05_b8la lay r14,0(0,0)       source address
MDLCF05_b8aa ZAP  WORKAREA,0(0,r14)  CONVERT PACKED
         lmg   r0,r1,workarea
         cxstr fp1,r0
MDLcf05_b8b lghi  r14,*-*           Create biased exponent
         iextr fp1,fp1,r14       and insert
         cxgtr fp4,r15
MDLcf05_b8e lghi  r15,*-*           Create biased exponent
         iextr fp4,fp4,r15       and insert
         cxtr  fp1,fp4
MDLCF05_b8F jlu *+l'*             BRANCH  TO   FALSE  IF NOT TRUE
MDLCF05_b8T jlu *+l'*             BRANCH  TO   TRUE  (OPTIONAL)
MDLCF05_b8L EQU *-MDLCF05_b8
*
MDLCF05_b8P EQU 0                 LITERAL POOL USAGE (EXCL FIELD LEN)
*
MDLCF05_b8R DC AL1(CSTGTlof),AL1(MDLCF05_b8+02-MDLCF05_b8) FIELD 2 OFF
         DC    AL1(CSSRClof),AL1(MDLCF05_b8la+02-MDLCF05_b8) F1 OFF
         DC    AL1(CSSRCLNR),AL1(MDLCF05_b8aa+01-MDLCF05_b8) F1 LEN L/2
         DC    AL1(CSdfpexps),AL1(MDLcf05_b8b+02-MDLcf05_b8) dfp exp
         DC    AL1(CSdfpexp),AL1(MDLcf05_b8e+02-MDLcf05_b8) dfp exp
         DC    AL1(CSRELOPR),AL1(MDLCF05_b8F+1-MDLCF05_b8) REL CC
         DC    AL1(CSFALSEO),AL1(MDLCF05_b8F+2-MDLCF05_b8) FALSE BRANCH
         DC    AL1(CSTRUEO),AL1(MDLCF05_b8T+2-MDLCF05_b8) TRUE BRANCH
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        COMPARE FIELDS           (SORTP  - BINARY)                   *
***********************************************************************
mdlcf34  XgR R0,R0                  CONVERT BINARY FIELD
mdlcf34S TMy 0(0),X'80'
         if (o)
           lghi r0,-1              fill with 1's
         endif
mdlcf34A ICMy R0,B'0000',0(0)
         Cxgtr fp4,r0
mdlcf34se lghi r14,*-*
         iextr fp4,fp4,r14
mdlcf34_la lay r15,0(0,0)         source address
mdlcf34b mvc       workar2(0),0(r15)  copy event field to workplace
         ic    r0,0(0,r15)        save first character into r0
         if tmll,r0,x'00f0',z     test to see if not ones
mdlcf34c       xc workar2(0),hexff   flip all the bits
         endif
         ni    workar2,x'0f'      clean top nibble in workarea
mdlcf34d mvo   WORKAREA,workar2(0)  CONVERT SOURCE FIELD
         ni workarea+l'workarea-1,x'f0'     clean the sign bits
         if tmll,r0,x'00f0',o     test to see if all ones
           oi workarea+l'workarea-1,x'0c'   and set sign to X'c'
         else
           oi workarea+l'workarea-1,x'0d'   and set sign to X'd'
         endif
         lmg   r0,r1,workarea
         cxstr fp1,r0
MDLcf34g lghi  r15,*-*           Create biased exponent
         iextr fp1,fp1,r15       and insert
         cxtr fp1,fp4
mdlcf34F jlu *+l'*                BRANCH  TO   FALSE  IF NOT TRUE
mdlcf34T jlu *+l'*                BRANCH  TO   TRUE  (OPTIONAL)
mdlcf34L EQU *-mdlcf34
*
mdlcf34P EQU 0                    LITERAL POOL USAGE (EXCL FIELD LEN)
*
mdlcf34R ds 0h
  DC AL1(CSTGTloF),AL1(mdlcf34S+02-mdlcf34) FIELD 2 OFFSET
  DC    AL1(CSBYTMSK),AL1(mdlcf34A+01-mdlcf34) BYTE MASK
  DC    AL1(CSTGTloF),AL1(mdlcf34A+02-mdlcf34) FIELD 2 OFFSET
  DC    AL1(CSdfpexp),AL1(mdlcf34se+02-mdlcf34) FIELD 2 OFFSET
  DC    AL1(CSSRCloF),AL1(mdlcf34_la+02-mdlcf34) FIELD 1 OFF
  DC    AL1(CSSRCLN),AL1(mdlcf34B+01-mdlcf34) FIELD 1 LEN L/2
  DC    AL1(CSSRCLN),AL1(mdlcf34C+01-mdlcf34) FIELD 1 LEN L/2
  DC    AL1(CSSRCLNR),AL1(mdlcf34d+01-mdlcf34) TARGET LENGTH
  DC    AL1(CSdfpexps),AL1(mdlcf34g+02-mdlcf34) FIELD 2 OFFSET
  DC    AL1(CSRELOPR),AL1(mdlcf34F+1-mdlcf34) RELATIONAL CC
  DC    AL1(CSFALSEO),AL1(mdlcf34F+2-mdlcf34) FALSE BRANCH
  DC    AL1(CSTRUEO),AL1(mdlcf34T+2-mdlcf34) TRUE BRANCH
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        COMPARE FIELDS           (SORTP  - BINARY)                   *
***********************************************************************
mdlcf34u Xgr R0,R0                 CONVERT BINARY FIELD
mdlcf34uA ICMy R0,B'0000',0(0)
         Cxgtr fp4,r0
mdlcf34use lghi r14,*-*
         iextr fp4,fp4,r14
mdlcf34u_la lay r15,0(0,0)        source address
mdlcf34ub mvc      workar2(0),0(r15)  copy event field to workplace
         ic    r0,0(0,r15)        save first character into r0
         if tmll,r0,x'00f0',z     test to see if not ones
mdlcf34uc      xc workar2(0),hexff   flip all the bits
         endif
         ni    workar2,x'0f'      clean top nibble in workarea
mdlcf34ud mvo  WORKAREA,workar2(0)  CONVERT SOURCE FIELD
         ni workarea+l'workarea-1,x'f0'     clean the sign bits
         if tmll,r0,x'00f0',o     test to see if all ones
           oi workarea+l'workarea-1,x'0c'   and set sign to X'c'
         else
           oi workarea+l'workarea-1,x'0d'   and set sign to X'd'
           endif
         lmg   r0,r1,workarea
         cxstr fp1,r0
MDLcf34ug lghi  r15,*-*           Create biased exponent
         iextr fp1,fp1,r15       and insert
          cxtr fp1,fp4
mdlcf34uF jlu *+l'*               BRANCH  TO   FALSE  IF NOT TRUE
mdlcf34uT jlu *+l'*               BRANCH  TO   TRUE  (OPTIONAL)
mdlcf34uL EQU *-mdlcf34u
*
mdlcf34uP EQU 0                   LITERAL POOL USAGE (EXCL FIELD LEN)
*
mdlcf34uR ds 0h
  DC    AL1(CSBYTMSK),AL1(mdlcf34uA+01-mdlcf34u) BYTE MASK
  DC    AL1(CSTGTloF),AL1(mdlcf34uA+02-mdlcf34u) FIELD 2 OFFSET
  DC    AL1(CSdfpexp),AL1(mdlcf34use+02-mdlcf34u) dfpexp
  DC    AL1(CSSRCloF),AL1(mdlcf34u_la+02-mdlcf34u) FIELD 1 OFF
  DC    AL1(CSSRCLN),AL1(mdlcf34uB+01-mdlcf34u) FIELD 1 LEN L/2
  DC    AL1(CSSRCLN),AL1(mdlcf34uC+01-mdlcf34u) FIELD 1 LEN L/2
  DC    AL1(CSSRCLNR),AL1(mdlcf34ud+01-mdlcf34u) TARGET LENGTH
  DC    AL1(CSdfpexps),AL1(mdlcf34ug+02-mdlcf34u) dfpexp
  DC    AL1(CSRELOPR),AL1(mdlcf34uF+1-mdlcf34u) RELATIONAL CC
  DC    AL1(CSFALSEO),AL1(mdlcf34uF+2-mdlcf34u) FALSE BRANCH
  DC    AL1(CSTRUEO),AL1(mdlcf34uT+2-mdlcf34u) TRUE BRANCH
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        COMPARE FIELDS           (PACKED - BINARY 8)                 *
***********************************************************************
mdlcf34_b8 LG R0,0(0,0)          CONVERT BINARY FIELD
         Cxgtr fp4,r0
mdlcf34_b8se lghi r14,*-*
         iextr fp4,fp4,r14
mdlcf34_b8la lay r15,0(0,0)       source address
mdlcf34_b8b mvc  workar2(0),0(r15)  copy event field to workplace
         ic    r0,0(0,r15)        save first character into r0
         if tmll,r0,x'00f0',z     test to see if not ones
mdlcf34_b8c xc workar2(0),hexff   flip all the bits
         endif
         ni    workar2,x'0f'      clean top nibble in workarea
mdlcf34_b8d mvo WORKAREA,workar2(0)  CONVERT SOURCE FIELD
         ni workarea+l'workarea-1,x'f0'     clean the sign bits
         if tmll,r0,x'00f0',o     test to see if all ones
           oi workarea+l'workarea-1,x'0c'   and set sign to X'c'
         else
           oi workarea+l'workarea-1,x'0d'   and set sign to X'd'
         endif
         lmg   r0,r1,workarea
         cxstr fp1,r0
MDLcf34_b8g lghi  r15,*-*           Create biased exponent
         iextr fp1,fp1,r15       and insert
         cxtr fp1,fp4
mdlcf34_b8F jlu *+l'*             BRANCH  TO   FALSE  IF NOT TRUE
mdlcf34_b8T jlu *+l'*             BRANCH  TO   TRUE  (OPTIONAL)
mdlcf34_b8L EQU *-mdlcf34_b8
*
mdlcf34_b8P EQU 0                 LITERAL POOL USAGE (EXCL FIELD LEN)
*
mdlcf34_b8R ds 0h
  DC    AL1(CSTGTlof),AL1(mdlcf34_b8+02-mdlcf34_b8) FIELD 2 OFF
  DC    AL1(CSdfpexp),AL1(mdlcf34_b8se+02-mdlcf34_b8) dfpexp
  DC    AL1(CSSRClof),AL1(mdlcf34_b8la+02-mdlcf34_b8) F1 OFF
  DC    AL1(CSSRCLN),AL1(mdlcf34_b8B+01-mdlcf34_b8) FIELD 1 LEN L/2
  DC    AL1(CSSRCLN),AL1(mdlcf34_b8C+01-mdlcf34_b8) FIELD 1 LEN L/2
  DC    AL1(CSSRCLNR),AL1(mdlcf34_b8d+01-mdlcf34_b8) TARGET LENGTH
  DC    AL1(CSdfpexps),AL1(mdlcf34_b8g+02-mdlcf34_b8) dfpexp
  DC    AL1(CSRELOPR),AL1(mdlcf34_b8F+1-mdlcf34_b8) REL CC
  DC    AL1(CSFALSEO),AL1(mdlcf34_b8F+2-mdlcf34_b8) FALSE BRANCH
  DC    AL1(CSTRUEO),AL1(mdlcf34_b8T+2-mdlcf34_b8) TRUE BRANCH
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        COMPARE FIELDS           (Bsort  - BINARY)                   *
***********************************************************************
mdlcf35u LAY   R14,0(0,0)         get address
         XgR    R0,R0
mdlcf35um mvc  workarea(0),0(r14) move event field to workarea
         xi    workarea,x'80'      flip the top bit
         if tm,workarea,x'80',nz If negative ...
           lghi r0,-1              fill with 1's
         endif
mdlcf35ua ICMy R0,B'0000',workarea
         Cxgtr fp1,r0
mdlcf35use lghi r14,*-*
         iextr fp1,fp1,r14
         XgR    R15,R15            CONVERT BINARY FIELD
mdlcf35uB ICMy R15,B'0000',0(0)
         cxgtr fp4,r15
MDLcf35ug lghi  r15,*-*           Create biased exponent
         iextr fp4,fp4,r15       and insert
         cxtr fp1,fp4
mdlcf35uF jlu  *+l'*              BRANCH  TO   FALSE  IF NOT TRUE
mdlcf35uT jlu  *+l'*              BRANCH  TO   TRUE  (OPTIONAL)
mdlcf35uL EQU  *-mdlcf35u
*
mdlcf35uP EQU  0                  LITERAL POOL USAGE (EXCL FIELD LEN)
*
mdlcf35uR DC   AL1(CSSRCloF),AL1(mdlcf35u+02-mdlcf35u) FIELD 1 OFFSET
         DC    AL1(CSsrcln),AL1(MDLcf35um+01-MDLcf35u) length
         DC    AL1(CSBYTMSS),AL1(mdlcf35uA+01-mdlcf35u) BYTE    MASK
  DC    AL1(CSdfpexps),AL1(mdlcf35use+02-mdlcf35u) dfpexp
         DC    AL1(CSBYTMSK),AL1(mdlcf35uB+01-mdlcf35u) BYTE    MASK
         DC    AL1(CSTGTloF),AL1(mdlcf35uB+02-mdlcf35u) FIELD 2 OFFSET
  DC    AL1(CSdfpexp),AL1(mdlcf35ug+02-mdlcf35u) dfpexp
         DC    AL1(CSRELOPR),AL1(mdlcf35uF+1-mdlcf35u) RELATIONAL CC
         DC    AL1(CSFALSEO),AL1(mdlcf35uF+2-mdlcf35u) FALSE BRANCH
         DC    AL1(CSTRUEO),AL1(mdlcf35uT+2-mdlcf35u) TRUE   BRANCH
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        COMPARE FIELDS           (BINARY8 - BINARY)                  *
***********************************************************************
mdlcf35u_8b LAY R14,0(0,0)        get address
mdlcf35u_8bm mvc workarea(0),0(r14) move event field to workarea
           xi   workarea,x'80'     flip the sign
           LG   r0,workarea
         Cxgtr fp1,r0
mdlcf35u_8bse lghi r14,*-*
         iextr fp1,fp1,r14
         xgr  r15,r15
mdlcf35u_8bA ICMy R15,B'0000',0(0)
         cxgtr fp4,r15
MDLcf35u_8bg lghi  r15,*-*           Create biased exponent
         iextr fp4,fp4,r15       and insert
         cxtr fp1,fp4
mdlcf35u_8bF jlu *+l'*            BRANCH  TO   FALSE  IF NOT TRUE
mdlcf35u_8bT jlu *+l'*            BRANCH  TO   TRUE  (OPTIONAL)
mdlcf35u_8bL EQU *-mdlcf35u_8b
*
mdlcf35u_8bP EQU 0                LITERAL POOL USAGE (EXCL FIELD LEN)
*
mdlcf35u_8bR DC AL1(CSSRCloF),AL1(mdlcf35u_8b+02-mdlcf35u_8b) Fld1 off
         DC    AL1(CSsrcln),AL1(mdlcf35u_8bm+01-mdlcf35u_8b) FLD 1 OFF
  DC    AL1(CSdfpexps),AL1(mdlcf35u_8bse+02-mdlcf35u_8b) dfpexp
         DC    AL1(CSBYTMSK),AL1(mdlcf35u_8bA+01-mdlcf35u_8b) MASK
         DC    AL1(CStgtloF),AL1(mdlcf35u_8bA+02-mdlcf35u_8b) FLD 1 OFF
  DC    AL1(CSdfpexp),AL1(mdlcf35u_8bg+02-mdlcf35u_8b) dfpexp
         DC    AL1(CSRELOPR),AL1(mdlcf35u_8bF+1-mdlcf35u_8b) REL CC
         DC    AL1(CSFALSEO),AL1(mdlcf35u_8bF+2-mdlcf35u_8b) FALSE BR
         DC    AL1(CSTRUEO),AL1(mdlcf35u_8bT+2-mdlcf35u_8b) TRUE BR
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        COMPARE FIELDS           (Bsort - signed Binary)             *
***********************************************************************
mdlcf35  LAY   R14,0(0,0)         get address
         Xgr   R0,R0
mdlcf35m mvc   workarea(0),0(r14) move event field to workarea
         xi    workarea,x'80'      flip the top bit
         if tm,workarea,x'80',nz If negative ...
           lghi r0,-1              fill with 1's
         endif
mdlcf35a ICMy  R0,B'0000',workarea
         Cxgtr fp1,r0
mdlcf35se lghi r14,*-*
         iextr fp1,fp1,r14
         xgr   R15,R15            CONVERT BINARY FIELD
mdlcf35I TMy   0(0),X'80'
         if (o)
           lghi r15,-1              fill with 1's
         endif
mdlcf35B ICMy  R15,B'0000',0(0)
         cxgtr fp4,r15
MDLcf35g lghi  r15,*-*           Create biased exponent
         iextr fp4,fp4,r15       and insert
         cxtr fp1,fp4
mdlcf35F jlu   *+l'*              BRANCH  TO   FALSE  IF NOT TRUE
mdlcf35T jlu   *+l'*              BRANCH  TO   TRUE  (OPTIONAL)
mdlcf35L EQU   *-mdlcf35
*
mdlcf35P EQU   0                  LITERAL POOL USAGE (EXCL FIELD LEN)
*
mdlcf35R DC    AL1(CSSRCloF),AL1(mdlcf35+02-mdlcf35) FIELD  1  OFFSET
         DC    AL1(CSsrcln),AL1(MDLcf35m+01-MDLcf35)  length
         DC    AL1(CSBYTMSS),AL1(mdlcf35A+01-mdlcf35) BYTE      MASK
  DC    AL1(CSdfpexps),AL1(mdlcf35se+02-mdlcf35) dfpexp
         DC    AL1(CSTGTloF),AL1(mdlcf35I+02-mdlcf35) FIELD  2  OFFSET
         DC    AL1(CSBYTMSK),AL1(mdlcf35B+01-mdlcf35) BYTE      MASK
         DC    AL1(CSTGTloF),AL1(mdlcf35B+02-mdlcf35) FIELD  2  OFFSET
  DC    AL1(CSdfpexp),AL1(mdlcf35g+02-mdlcf35) dfpexp
         DC    AL1(CSRELOPR),AL1(mdlcf35F+1-mdlcf35)  RELATIONAL CC
         DC    AL1(CSFALSEO),AL1(mdlcf35F+2-mdlcf35)  FALSE  BRANCH
         DC    AL1(CSTRUEO),AL1(mdlcf35T+2-mdlcf35)   TRUE   BRANCH
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        COMPARE FIELDS           (Bsort -  BINARY8)                  *
***********************************************************************
mdlcf35_b8 LAY R14,0(0,0)         get address
         Xgr   R0,R0
mdlcf35_b8m mvc   workarea(0),0(r14) move event field to workarea
         xi    workarea,x'80'      flip the top bit
         if tm,workarea,x'80',nz If negative ...
           lghi r0,-1              fill with 1's
         endif
mdlcf35_b8A ICMy R0,B'0000',workarea
         Cxgtr fp1,r0
mdlcf35_b8se lghi r14,*-*
         iextr fp1,fp1,r14
mdlcf35_b8B LG   R15,0(0,0)
         cxgtr fp4,r15
MDLcf35_b8g lghi  r15,*-*           Create biased exponent
         iextr fp4,fp4,r15       and insert
         cxtr fp1,fp4
mdlcf35_b8F jlu *+l'*             BRANCH  TO   FALSE  IF NOT TRUE
mdlcf35_b8T jlu *+l'*             BRANCH  TO   TRUE  (OPTIONAL)
mdlcf35_b8L EQU *-mdlcf35_b8
*
mdlcf35_b8P EQU 0                 LITERAL POOL USAGE (EXCL FIELD LEN)
*
mdlcf35_b8R DC AL1(CSSRCloF),AL1(mdlcf35_b8+02-mdlcf35_b8) FIELD 1 OFF
         DC    AL1(CSsrcln),AL1(MDLcf35_b8m+01-MDLcf35_b8)  length
         DC    AL1(CSBYTMSS),AL1(mdlcf35_b8A+01-mdlcf35_b8) BYTE MASK
  DC    AL1(CSdfpexps),AL1(mdlcf35_b8se+02-mdlcf35_b8) dfpexp
         DC    AL1(CSTGTloF),AL1(mdlcf35_b8B+02-mdlcf35_b8) FIELD 2 OFF
  DC    AL1(CSdfpexp),AL1(mdlcf35_b8g+02-mdlcf35_b8) dfpexp
         DC    AL1(CSRELOPR),AL1(mdlcf35_b8F+1-mdlcf35_b8) RELATION CC
         DC    AL1(CSFALSEO),AL1(mdlcf35_b8F+2-mdlcf35_b8) FALSE BRANCH
         DC    AL1(CSTRUEO),AL1(mdlcf35_b8T+2-mdlcf35_b8) TRUE BRANCH
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        COMPARE FIELDS           (Bsort8 - BINARY)                   *
***********************************************************************
mdlcf35_8b LAY R14,0(0,0)         get address
mdlcf35_8bm mvc workarea(0),0(r14) move event field to workarea
           xi   workarea,x'80'     flip the sign
           LG   r0,workarea
         Cxgtr fp1,r0
mdlcf35_8bse lghi r14,*-*
         iextr fp1,fp1,r14
         xgr  r15,r15
mdlcf35_8bS TMy 0(0),X'80'
         if (o)
           lghi r15,-1              fill with 1's
         endif
mdlcf35_8bA ICMy R15,B'0000',0(0)
         cxgtr fp4,r15
MDLcf35_8bg lghi  r15,*-*           Create biased exponent
         iextr fp4,fp4,r15       and insert
         cxtr fp1,fp4
mdlcf35_8bF jlu *+l'*             BRANCH  TO   FALSE  IF NOT TRUE
mdlcf35_8bT jlu *+l'*             BRANCH  TO   TRUE  (OPTIONAL)
mdlcf35_8bL EQU *-mdlcf35_8b
*
mdlcf35_8bP EQU 0                 LITERAL POOL USAGE (EXCL FIELD LEN)
*
mdlcf35_8bR DC AL1(CSSRCloF),AL1(mdlcf35_8b+02-mdlcf35_8b) FIELD 1 OFF
         DC    AL1(CSsrcln),AL1(mdlcf35_8bm+01-mdlcf35_8b) FIELD 1 OFF
  DC    AL1(CSdfpexps),AL1(mdlcf35_8bse+02-mdlcf35_8b) dfpexp
         DC    AL1(CSTGTloF),AL1(mdlcf35_8bS+02-mdlcf35_8b) FIELD 2 OFF
         DC    AL1(CSBYTMSK),AL1(mdlcf35_8bA+01-mdlcf35_8b) BYTE MASK
         DC    AL1(CStgtloF),AL1(mdlcf35_8bA+02-mdlcf35_8b) FIELD 1 OFF
  DC    AL1(CSdfpexp),AL1(mdlcf35_8bg+02-mdlcf35_8b) dfpexp
         DC    AL1(CSRELOPR),AL1(mdlcf35_8bF+1-mdlcf35_8b) RELATION CC
         DC    AL1(CSFALSEO),AL1(mdlcf35_8bF+2-mdlcf35_8b) FALSE BRANCH
         DC    AL1(CSTRUEO),AL1(mdlcf35_8bT+2-mdlcf35_8b) TRUE BRANCH
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        COMPARE FIELDS           (BINARY8 - BINARY8)                 *
***********************************************************************
mdlcf35_88 LAY R14,0(0,0)         get address
mdlcf35_88m mvc workarea(0),0(r14) move event field to workarea
           xi   workarea,x'80'     flip the sign
           LG   r0,workarea
         Cxgtr fp1,r0
mdlcf35_88se lghi r14,*-*
         iextr fp1,fp1,r14
mdlcf35_88A LG  R15,0(0,0)
         cxgtr fp4,r15
MDLcf35_88g lghi  r15,*-*           Create biased exponent
         iextr fp4,fp4,r15       and insert
         cxtr fp1,fp4
mdlcf35_88F jlu *+l'*             BRANCH  TO   FALSE  IF NOT TRUE
mdlcf35_88T jlu *+l'*             BRANCH  TO   TRUE  (OPTIONAL)
mdlcf35_88L EQU *-mdlcf35_88
*
mdlcf35_88P EQU 0                 LITERAL POOL USAGE (EXCL FIELD LEN)
*
mdlcf35_88R DC AL1(CSSRCloF),AL1(mdlcf35_88+02-mdlcf35_88) FIELD 1 OFF
         DC    AL1(CSsrcln),AL1(mdlcf35_88m+01-mdlcf35_88) FIELD 1 OFF
  DC    AL1(CSdfpexps),AL1(mdlcf35_88se+02-mdlcf35_88) dfpexp
         DC    AL1(CStgtloF),AL1(mdlcf35_88A+02-mdlcf35_88) FIELD 1 OFF
  DC    AL1(CSdfpexp),AL1(mdlcf35_88g+02-mdlcf35_88) dfpexp
         DC    AL1(CSRELOPR),AL1(mdlcf35_88F+1-mdlcf35_88) RELATION CC
         DC    AL1(CSFALSEO),AL1(mdlcf35_88F+2-mdlcf35_88) FALSE BRANCH
         DC    AL1(CSTRUEO),AL1(mdlcf35_88T+2-mdlcf35_88) TRUE BRANCH
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        COMPARE FIELDS           (BINARY - Bsort)                    *
***********************************************************************
mdlcf42u LAY   R14,0(0,0)         get address
         Xgr   R0,R0
mdlcf42um mvc  workarea(0),0(r14) move event field to workarea
         xi    workarea,x'80'      flip the top bit
         if tm,workarea,x'80',nz If negative ...
           lghi r0,-1              fill with 1's
         endif
mdlcf42ua ICMy R0,B'0000',workarea
         Cxgtr fp1,r0
mdlcf42use lghi r14,*-*
         iextr fp1,fp1,r14
         XGR   R15,R15            CONVERT BINARY FIELD
mdlcf42uB ICMy R15,B'0000',0(0)
         cxgtr fp4,r15
MDLcf42ug lghi  r15,*-*           Create biased exponent
         iextr fp4,fp4,r15       and insert
         cxtr fp4,fp1
mdlcf42uF jlu  *+l'*              BRANCH  TO   FALSE  IF NOT TRUE
mdlcf42uT jlu  *+l'*              BRANCH  TO   TRUE  (OPTIONAL)
mdlcf42uL EQU  *-mdlcf42u
*
mdlcf42uP EQU  0                  LITERAL POOL USAGE (EXCL FIELD LEN)
*
mdlcf42uR DC   AL1(CStgtloF),AL1(mdlcf42u+02-mdlcf42u) FIELD 1 OFFSET
         DC    AL1(CStgtln),AL1(mdlcf42um+01-mdlcf42u) length
         DC    AL1(CSBYTMSk),AL1(mdlcf42uA+01-mdlcf42u) BYTE    MASK
  DC    AL1(CSdfpexp),AL1(mdlcf42use+02-mdlcf42u) dfpexp
         DC    AL1(CSBYTMSs),AL1(mdlcf42uB+01-mdlcf42u) BYTE    MASK
         DC    AL1(CSsrcloF),AL1(mdlcf42uB+02-mdlcf42u) FIELD 2 OFFSET
  DC    AL1(CSdfpexps),AL1(mdlcf42ug+02-mdlcf42u) dfpexp
         DC    AL1(CSRELOPR),AL1(mdlcf42uF+1-mdlcf42u) RELATIONAL CC
         DC    AL1(CSFALSEO),AL1(mdlcf42uF+2-mdlcf42u) FALSE BRANCH
         DC    AL1(CSTRUEO),AL1(mdlcf42uT+2-mdlcf42u) TRUE   BRANCH
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        COMPARE FIELDS           (BINARY - Bsort )                   *
***********************************************************************
mdlcf42  LAY   R14,0(0,0)         get address
         xgr   R0,R0
mdlcf42m mvc   workarea(0),0(r14) move event field to workarea
         xi    workarea,x'80'      flip the top bit
         if tm,workarea,x'80',nz If negative ...
           lghi r0,-1              fill with 1's
         endif
mdlcf42a ICMy  R0,B'0000',workarea
         Cxgtr fp1,r0
mdlcf42se lghi r14,*-*
         iextr fp1,fp1,r14
         Xgr   R15,R15            CONVERT BINARY FIELD
mdlcf42I TMy   0(0),X'80'
         if (o)
           lghi r15,-1              fill with 1's
         endif
mdlcf42B ICMy  R15,B'0000',0(0)
         cxgtr fp4,r15
MDLcf42g lghi  r15,*-*           Create biased exponent
         iextr fp4,fp4,r15       and insert
         cxtr fp4,fp1
mdlcf42F jlu   *+l'*              BRANCH  TO   FALSE  IF NOT TRUE
mdlcf42T jlu   *+l'*              BRANCH  TO   TRUE  (OPTIONAL)
mdlcf42L EQU   *-mdlcf42
*
mdlcf42P EQU   0                  LITERAL POOL USAGE (EXCL FIELD LEN)
*
mdlcf42R DC    AL1(CStgtloF),AL1(mdlcf42+02-mdlcf42) FIELD  1  OFFSET
         DC    AL1(CStgtln),AL1(mdlcf42m+01-mdlcf42)  length
         DC    AL1(CSBYTMSk),AL1(mdlcf42A+01-mdlcf42) BYTE      MASK
         DC    AL1(CSsrcloF),AL1(mdlcf42I+02-mdlcf42) FIELD  2  OFFSET
         DC    AL1(CSBYTMSs),AL1(mdlcf42B+01-mdlcf42) BYTE      MASK
         DC    AL1(CSsrcloF),AL1(mdlcf42B+02-mdlcf42) FIELD  2  OFFSET
  DC    AL1(CSdfpexp),AL1(mdlcf42se+02-mdlcf42) dfpexp
  DC    AL1(CSdfpexps),AL1(mdlcf42g+02-mdlcf42) dfpexp
         DC    AL1(CSRELOPR),AL1(mdlcf42F+1-mdlcf42)  RELATIONAL CC
         DC    AL1(CSFALSEO),AL1(mdlcf42F+2-mdlcf42)  FALSE  BRANCH
         DC    AL1(CSTRUEO),AL1(mdlcf42T+2-mdlcf42)   TRUE   BRANCH
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        COMPARE FIELDS           (BINARY - BSORT8)                   *
***********************************************************************
mdlcf42u_b8 LAY R14,0(0,0)        get address
         Xgr   R15,R15
mdlcf42u_b8m mvc  workarea(0),0(r14) move event field to workarea
         xi workarea,x'80'         flip the top bit and setcc
         lg R0,workarea
         Cxgtr fp1,r0
mdlcf42u_b8se lghi r14,*-*
         iextr fp1,fp1,r14
mdlcf42u_b8B ICMy R15,B'0000',0(0)
         cxgtr fp4,r15
MDLcf42u_b8g lghi  r15,*-*           Create biased exponent
         iextr fp4,fp4,r15       and insert
         cxtr fp4,fp1
mdlcf42u_b8F jlu *+l'*            BRANCH  TO   FALSE  IF NOT TRUE
mdlcf42u_b8T jlu *+l'*            BRANCH  TO   TRUE  (OPTIONAL)
mdlcf42u_b8L EQU *-mdlcf42u_b8
*
mdlcf42u_b8P EQU 0                LITERAL POOL USAGE (EXCL FIELD LEN)
*
mdlcf42u_b8R DC AL1(CStgtloF),AL1(mdlcf42u_b8+02-mdlcf42u_b8) F1 OFF
         DC    AL1(CStgtln),AL1(mdlcf42u_b8m+01-mdlcf42u_b8) len
         DC    AL1(CSsrcloF),AL1(mdlcf42u_b8b+02-mdlcf42u_b8) F2 OFF
         DC    AL1(CSBYTMSs),AL1(mdlcf42u_b8b+01-mdlcf42u_b8) MASK
  DC    AL1(CSdfpexp),AL1(mdlcf42u_b8se+02-mdlcf42u_b8) dfpexp
  DC    AL1(CSdfpexps),AL1(mdlcf42u_b8g+02-mdlcf42u_b8) dfpexp
         DC    AL1(CSRELOPR),AL1(mdlcf42u_b8F+1-mdlcf42u_b8) REL CC
         DC    AL1(CSFALSEO),AL1(mdlcf42u_b8F+2-mdlcf42u_b8) FALSE BR
         DC    AL1(CSTRUEO),AL1(mdlcf42u_b8T+2-mdlcf42u_b8) TRUE BR
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        COMPARE FIELDS           (BINARY - BSORT8)                   *
***********************************************************************
mdlcf42_b8 LAY R14,0(0,0)        get address
         Xgr   R15,R15
mdlcf42_b8m mvc   workarea(0),0(r14) move event field to workarea
         xi workarea,x'80'         flip the top bit and setcc
         lg R0,workarea
         Cxgtr fp1,r0
mdlcf42_b8se lghi r14,*-*
         iextr fp1,fp1,r14
mdlcf42_b8I TMy   0(0),X'80'
         if (o)
           lghi r15,-1             fill with 1's
         endif
mdlcf42_b8B ICMy  R15,B'0000',0(0)
         cxgtr fp4,r15
MDLcf42_b8g lghi  r15,*-*           Create biased exponent
         iextr fp4,fp4,r15       and insert
         cxtr fp4,fp1
mdlcf42_b8F jlu *+l'*             BRANCH  TO   FALSE  IF NOT TRUE
mdlcf42_b8T jlu *+l'*             BRANCH  TO   TRUE  (OPTIONAL)
mdlcf42_b8L EQU *-mdlcf42_b8
*
mdlcf42_b8P EQU 0                 LITERAL POOL USAGE (EXCL FIELD LEN)
*
mdlcf42_b8R DC AL1(CStgtloF),AL1(mdlcf42_b8+02-mdlcf42_b8) FIELD 1 OFF
         DC    AL1(CStgtln),AL1(mdlcf42_b8m+01-mdlcf42_b8)  length
         DC    AL1(CSsrcloF),AL1(mdlcf42_b8i+02-mdlcf42_b8) FIELD 2 OFF
         DC    AL1(CSsrcloF),AL1(mdlcf42_b8b+02-mdlcf42_b8) FIELD 2 OFF
         DC    AL1(CSBYTMSs),AL1(mdlcf42_b8b+01-mdlcf42_b8) BYTE MASK
  DC    AL1(CSdfpexp),AL1(mdlcf42_b8se+02-mdlcf42_b8) dfpexp
  DC    AL1(CSdfpexps),AL1(mdlcf42_b8g+02-mdlcf42_b8) dfpexp
         DC    AL1(CSRELOPR),AL1(mdlcf42_b8F+1-mdlcf42_b8) RELATION CC
         DC    AL1(CSFALSEO),AL1(mdlcf42_b8F+2-mdlcf42_b8) FALSE BRANCH
         DC    AL1(CSTRUEO),AL1(mdlcf42_b8T+2-mdlcf42_b8) TRUE BRANCH
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        COMPARE FIELDS           (BINARY8 - BSORT )                  *
***********************************************************************
mdlcf42_8b LAY R14,0(0,0)         get address
         Xgr   R0,R0
mdlcf42_8bm mvc workarea(0),0(r14) move event field to workarea
         xi    workarea,x'80'      flip the top bit
         if tm,workarea,x'80',nz If negative ...
           lghi r0,-1              fill with 1's
         endif
mdlcf42_8ba ICMy  R0,B'0000',workarea
         Cxgtr fp1,r0
mdlcf42_8bse lghi r14,*-*
         iextr fp1,fp1,r14
mdlcf42_8bb lg  R15,0(0,0)
         cxgtr fp4,r15
MDLcf42_8bg lghi  r15,*-*           Create biased exponent
         iextr fp4,fp4,r15       and insert
         cxtr fp4,fp1
mdlcf42_8bF jlu *+l'*             BRANCH  TO   FALSE  IF NOT TRUE
mdlcf42_8bT jlu *+l'*             BRANCH  TO   TRUE  (OPTIONAL)
mdlcf42_8bL EQU *-mdlcf42_8b
*
mdlcf42_8bP EQU 0                 LITERAL POOL USAGE (EXCL FIELD LEN)
*
mdlcf42_8bR DC AL1(CStgtloF),AL1(mdlcf42_8b+02-mdlcf42_8b) FIELD 1 OFF
         DC    AL1(CStgtln),AL1(mdlcf42_8bm+01-mdlcf42_8b) FIELD 1 OFF
         DC    AL1(CSBYTMSk),AL1(mdlcf42_8bA+01-mdlcf42_8b) BYTE MASK
         DC    AL1(CSsrcloF),AL1(mdlcf42_8bb+02-mdlcf42_8b) FIELD 2 OFF
  DC    AL1(CSdfpexp),AL1(mdlcf42_8bse+02-mdlcf42_8b) dfpexp
  DC    AL1(CSdfpexps),AL1(mdlcf42_8bg+02-mdlcf42_8b) dfpexp
         DC    AL1(CSRELOPR),AL1(mdlcf42_8bF+1-mdlcf42_8b) RELATION CC
         DC    AL1(CSFALSEO),AL1(mdlcf42_8bF+2-mdlcf42_8b) FALSE BRANCH
         DC    AL1(CSTRUEO),AL1(mdlcf42_8bT+2-mdlcf42_8b) TRUE BRANCH
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        COMPARE FIELDS           (BINARY8 - BINARY8)                 *
***********************************************************************
mdlcf42_88 Lg  R0,0(0,0)          get value address
         Cxgtr fp4,r0
mdlcf42_88se lghi r14,*-*
         iextr fp4,fp4,r14
mdlcf42_88A LAY R15,0(0,0)
mdlcf42_88m mvc workarea(0),0(r15) move event field to workarea
           xi   workarea,x'80'     flip the sign
           LG   r15,workarea
         cxgtr fp1,r15
MDLcf42_88g lghi  r15,*-*           Create biased exponent
         iextr fp1,fp1,r15       and insert
         cxtr fp4,fp1
mdlcf42_88F jlu *+l'*             BRANCH  TO   FALSE  IF NOT TRUE
mdlcf42_88T jlu *+l'*             BRANCH  TO   TRUE  (OPTIONAL)
mdlcf42_88L EQU *-mdlcf42_88
*
mdlcf42_88P EQU 0                 LITERAL POOL USAGE (EXCL FIELD LEN)
*
mdlcf42_88R DC AL1(CSsrcloF),AL1(mdlcf42_88+02-mdlcf42_88) FIELD 1 OFF
  DC    AL1(CSdfpexps),AL1(mdlcf42_88se+02-mdlcf42_88) dfpexp
         DC    AL1(CStgtloF),AL1(mdlcf42_88A+02-mdlcf42_88) FIELD 1 OFF
         DC    AL1(CStgtln),AL1(mdlcf42_88m+01-mdlcf42_88) FIELD 1 OFF
  DC    AL1(CSdfpexp),AL1(mdlcf42_88g+02-mdlcf42_88) dfpexp
         DC    AL1(CSRELOPR),AL1(mdlcf42_88F+1-mdlcf42_88) RELATION CC
         DC    AL1(CSFALSEO),AL1(mdlcf42_88F+2-mdlcf42_88) FALSE BRANCH
         DC    AL1(CSTRUEO),AL1(mdlcf42_88T+2-mdlcf42_88) TRUE BRANCH
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        COMPARE FIELDS           (BINs   - PACKED)                   *
***********************************************************************
mdlcf06    LAY R14,0(0,0)         get address
mdlcf06_la LAY R15,0(0,0)         get address
mdlcf06B zap   workarea,0(0,r15)   COMPARE TWO  FIELDS
         lmg   r0,r1,workarea
         cxstr fp1,r0
mdlcf06se lghi r15,*-*
         iextr fp1,fp1,r15       and insert
mdlcf06m mvc   workarea(0),0(r14) move event field to workarea
         Xgr   R0,R0              CONVERT BINARY FIELD
         xi    workarea,x'80'      flip the top bit
         if tm,workarea,x'80',nz If negative ...
           lghi r0,-1              fill with 1's
         endif
mdlcf06A ICMy  R0,B'0000',workarea
         Cxgtr fp4,r0
MDLcf06g lghi  r14,*-*           Create biased exponent
         iextr fp4,fp4,r14
         cxtr  fp4,fp1
mdlcf06F jlu   *+l'*              BRANCH  TO   FALSE  IF NOT TRUE
mdlcf06T jlu   *+l'*              BRANCH  TO   TRUE  (OPTIONAL)
mdlcf06L EQU   *-mdlcf06
*
mdlcf06P EQU   0                  LITERAL POOL USAGE (EXCL FIELD LEN)
*
mdlcf06R DC    AL1(CSSRCloF),AL1(mdlcf06+02-mdlcf06) FIELD  1  OFFSET
         DC    AL1(CStgtlof),AL1(mdlcf06_lA+02-mdlcf06) FIELD  1  OFF
         DC    AL1(CSsrcln),AL1(MDLcf06m+01-MDLcf06)  length
         DC    AL1(CSBYTMSS),AL1(mdlcf06A+01-mdlcf06) BYTE      MASK
         DC    AL1(CSTGTLNR),AL1(mdlcf06B+01-mdlcf06) FIELD  2  LEN R/2
  DC    AL1(CSdfpexp),AL1(mdlcf06se+02-mdlcf06) dfpexp
  DC    AL1(CSdfpexps),AL1(mdlcf06g+02-mdlcf06) dfpexp
         DC    AL1(CSRELOPR),AL1(mdlcf06F+1-mdlcf06)  RELATIONAL CC
         DC    AL1(CSFALSEO),AL1(mdlcf06F+2-mdlcf06)  FALSE  BRANCH
         DC    AL1(CSTRUEO),AL1(mdlcf06T+2-mdlcf06)   TRUE   BRANCH
         DC   2XL1'FF'
***********************************************************************
*        COMPARE FIELDS           (BINs   8 - PACKED)                 *
***********************************************************************
mdlcf06_b8   LAY R14,0(0,0)       load source address
mdlcf06_b8la LAY R15,0(0,0)         get address
mdlcf06_b8B zap  workarea,0(0,r15)   COMPARE TWO  FIELDS
         lmg   r0,r1,workarea
         cxstr fp1,r0
mdlcf06_b8se lghi r15,*-*
         iextr fp1,fp1,r15       and insert
mdlcf06_b8m mvc workarea(0),0(r14) move source field to workarea
         xi    workarea,x'80'     flip the top bit
         LG    R0,workarea
         Cxgtr fp4,r0
MDLcf06_b8g lghi  r14,*-*           Create biased exponent
         iextr fp4,fp4,r14
         cxtr  fp4,fp1
mdlcf06_b8F jlu *+l'*             BRANCH  TO   FALSE  IF NOT TRUE
mdlcf06_b8T jlu *+l'*             BRANCH  TO   TRUE  (OPTIONAL)
mdlcf06_b8L EQU *-mdlcf06_b8
*
mdlcf06_b8P EQU 0                 LITERAL POOL USAGE (EXCL FIELD LEN)
*
mdlcf06_b8R ds 0h
         DC    AL1(CSsrclof),AL1(mdlcf06_b8+02-mdlcf06_b8) FIELD 1 OFF
         DC    AL1(CStgtlof),AL1(mdlcf06_b8lA+02-mdlcf06_b8) FLD 1 OFF
         DC    AL1(CSsrcln),AL1(MDLcf06_b8m+01-MDLcf06_b8) length
         DC    AL1(CSTGTLNR),AL1(mdlcf06_b8B+01-mdlcf06_b8) FLD 2 L R/2
  DC    AL1(CSdfpexp),AL1(mdlcf06_b8se+02-mdlcf06_b8) dfpexp
  DC    AL1(CSdfpexps),AL1(mdlcf06_b8g+02-mdlcf06_b8) dfpexp
         DC    AL1(CSRELOPR),AL1(mdlcf06_b8F+1-mdlcf06_b8) REL. CC
         DC    AL1(CSFALSEO),AL1(mdlcf06_b8F+2-mdlcf06_b8) FALSE BRANCH
         DC    AL1(CSTRUEO),AL1(mdlcf06_b8T+2-mdlcf06_b8) TRUE BRANCH
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        COMPARE FIELDS           (BINs   - PACKED)                   *
***********************************************************************
mdlcf84    LAY R14,0(0,0)         get address
mdlcf84_la LAY R15,0(0,0)         get address
mdlcf84b   zap  workarea,0(0,r15)   COMPARE TWO  FIELDS
         lmg   r0,r1,workarea
         cxstr fp1,r0
mdlcf84se lghi r15,*-*
         iextr fp1,fp1,r15       and insert
mdlcf84m mvc   workarea(0),0(r14) move event field to workarea
         Xgr   R0,R0              CONVERT BINARY FIELD
         xi    workarea,x'80'      flip the top bit
         if tm,workarea,x'80',nz If negative ...
           lghi r0,-1              fill with 1's
         endif
mdlcf84A ICMy  R0,B'0000',workarea
         Cxgtr fp4,r0
MDLcf84g lghi  r14,*-*           Create biased exponent
         iextr fp4,fp4,r14
         cxtr  fp1,fp4
mdlcf84F jlu   *+l'*              BRANCH  TO   FALSE  IF NOT TRUE
mdlcf84T jlu   *+l'*              BRANCH  TO   TRUE  (OPTIONAL)
mdlcf84L EQU   *-mdlcf84
*
mdlcf84P EQU   0                  LITERAL POOL USAGE (EXCL FIELD LEN)
*
mdlcf84R DC    AL1(CStgtloF),AL1(mdlcf84+02-mdlcf84) FIELD  1  OFFSET
         DC    AL1(CSsrclof),AL1(mdlcf84_lA+02-mdlcf84) FIELD  1  OFF
         DC    AL1(CStgtln),AL1(mdlcf84m+01-mdlcf84)  length
         DC    AL1(CSBYTMSk),AL1(mdlcf84A+01-mdlcf84) BYTE      MASK
         DC    AL1(CSsrcLNr),AL1(mdlcf84B+01-mdlcf84) FIELD  2  LEN R/2
  DC    AL1(CSdfpexps),AL1(mdlcf84se+02-mdlcf84) dfpexp
  DC    AL1(CSdfpexp),AL1(mdlcf84g+02-mdlcf84) dfpexp
         DC    AL1(CSRELOPR),AL1(mdlcf84F+1-mdlcf84)  RELATIONAL CC
         DC    AL1(CSFALSEO),AL1(mdlcf84F+2-mdlcf84)  FALSE  BRANCH
         DC    AL1(CSTRUEO),AL1(mdlcf84T+2-mdlcf84)   TRUE   BRANCH
         DC   2XL1'FF'
***********************************************************************
*        COMPARE FIELDS           (BINs   8 - PACKED)                 *
***********************************************************************
mdlcf84_b8 LAY   R14,0(0,0)         load source address
mdlcf84_b8la LAY R15,0(0,0)         get address
mdlcf84_b8b  zap  workarea,0(0,r15)   COMPARE TWO  FIELDS
         lmg   r0,r1,workarea
         cxstr fp1,r0
mdlcf84_b8se lghi r15,*-*
         iextr fp1,fp1,r15       and insert
mdlcf84_b8m mvc workarea(0),0(r14) move source field to workarea
         xi    workarea,x'80'     flip the top bit
         LG    R0,workarea
         Cxgtr fp4,r0
MDLcf84_b8g lghi  r14,*-*           Create biased exponent
         iextr fp4,fp4,r14
         cxtr  fp1,fp4
mdlcf84_b8F jlu *+l'*             BRANCH  TO   FALSE  IF NOT TRUE
mdlcf84_b8T jlu *+l'*             BRANCH  TO   TRUE  (OPTIONAL)
mdlcf84_b8L EQU *-mdlcf84_b8
*
mdlcf84_b8P EQU 0                 LITERAL POOL USAGE (EXCL FIELD LEN)
*
mdlcf84_b8R ds 0h
         DC    AL1(CStgtlof),AL1(mdlcf84_b8+02-mdlcf84_b8) FIELD 1 OFF
         DC    AL1(CSsrclof),AL1(mdlcf84_b8lA+02-mdlcf84_b8) FLD 1 OFF
         DC    AL1(CStgtln),AL1(mdlcf84_b8m+01-mdlcf84_b8) length
         DC    AL1(CSsrcLNr),AL1(mdlcf84_b8B+01-mdlcf84_b8) FLD 2 L R/2
  DC    AL1(CSdfpexps),AL1(mdlcf84_b8se+02-mdlcf84_b8) dfpexp
  DC    AL1(CSdfpexp),AL1(mdlcf84_b8g+02-mdlcf84_b8) dfpexp
         DC    AL1(CSRELOPR),AL1(mdlcf84_b8F+1-mdlcf84_b8) REL. CC
         DC    AL1(CSFALSEO),AL1(mdlcf84_b8F+2-mdlcf84_b8) FALSE BRANCH
         DC    AL1(CSTRUEO),AL1(mdlcf84_b8T+2-mdlcf84_b8) TRUE BRANCH
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        COMPARE FIELDS           (NUMERIC - PACKED)                  *
***********************************************************************
MDLCF07  LAY   R14,0(0,0)         LOAD  target address
MDLCF07_la LAY R15,0(0,0)               source
mdlcf07a  zap  workarea,0(0,r15)   COMPARE TWO  FIELDS
         lmg   r0,r1,workarea
         cxstr fp4,r0
mdlcf07se lghi r15,*-*
         iextr fp4,fp4,r15       and insert
MDLCF07k PACK  WORKAREA,0(0,r14)  CONVERT NUMERIC TO PACKED
         lmg   r0,r1,workarea
         cxstr fp1,r0
MDLcf07g lghi  r14,*-*           Create biased exponent
         iextr fp1,fp1,r14
         cxtr  fp1,fp4
MDLCF07F jlu   *+l'*              BRANCH  TO   FALSE IF  NOT TRUE
MDLCF07T jlu   *+l'*              BRANCH  TO   TRUE (OPTIONAL)
MDLCF07L EQU   *-MDLCF07
*
MDLCF07P EQU   0                  LITERAL POOL USAGE (EXCL FIELD LEN)
*
MDLCF07R DC    AL1(CSSRCloF),AL1(MDLCF07+02-MDLCF07)  FIELD  1  OFF
         DC    AL1(CSSRCLNR),AL1(MDLCF07k+01-MDLCF07) FIELD  1  LEN R/2
         DC    AL1(CSTGTLNR),AL1(MDLCF07A+01-MDLCF07) FIELD  2  LEN R/2
         DC    AL1(CSTGTloF),AL1(MDLCF07_lA+02-MDLCF07) FIELD  2  OFF
  DC    AL1(CSdfpexp),AL1(mdlcf07se+02-mdlcf07) dfpexp
  DC    AL1(CSdfpexps),AL1(mdlcf07g+02-mdlcf07) dfpexp
         DC    AL1(CSRELOPR),AL1(MDLCF07F+1-MDLCF07)  RELATIONAL CC
         DC    AL1(CSFALSEO),AL1(MDLCF07F+2-MDLCF07)  FALSE  BRANCH
         DC    AL1(CSTRUEO),AL1(MDLCF07T+2-MDLCF07)   TRUE   BRANCH
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        COMPARE FIELDS           (NUMERIC - NUMERIC)                 *
***********************************************************************
MDLCF08  LAY   R14,0(0,0)         LOAD  target address
MDLCF08_la LAY R15,0(0,0)               source
MDLCF08k PACK  WORKAREA,0(0,r14)  CONVERT NUMERIC TO PACKED
         lmg   r0,r1,workarea
         cxstr fp1,r0
mdlcf08se lghi r14,*-*
         iextr fp1,fp1,r14       and insert
MDLCF08A PACK  WORKAR2,0(0,r15)   CONVERT NUMERIC TO PACKED
         lmg   r0,r1,workar2
         cxstr fp4,r0
MDLcf08g lghi  r15,*-*           Create biased exponent
         iextr fp4,fp4,r15
         cxtr  fp1,fp4
MDLCF08F jlu   *+l'*              BRANCH  TO   FALSE IF  NOT TRUE
MDLCF08T jlu   *+l'*              BRANCH  TO   TRUE (OPTIONAL)
MDLCF08L EQU   *-MDLCF08
*
MDLCF08P EQU   0                  LITERAL POOL USAGE (EXCL FIELD LEN)
*
MDLCF08R DC    AL1(CSSRCLNR),AL1(MDLCF08k+01-MDLCF08) SRC FIELD LEN R/2
         DC    AL1(CSSRClof),AL1(MDLCF08+02-MDLCF08)  SRC FIELD OFF
         DC    AL1(CSTGTLNR),AL1(MDLCF08A+01-MDLCF08) TGT FIELD LEN R/2
         DC    AL1(CSTGTlof),AL1(MDLCF08_la+02-MDLCF08) TGT FIELD OFF
  DC    AL1(CSdfpexps),AL1(mdlcf08se+02-mdlcf08) dfpexp
  DC    AL1(CSdfpexp),AL1(mdlcf08g+02-mdlcf08) dfpexp
         DC    AL1(CSRELOPR),AL1(MDLCF08F+1-MDLCF08)  RELATIONAL CC
         DC    AL1(CSFALSEO),AL1(MDLCF08F+2-MDLCF08)  FALSE  BRANCH
         DC    AL1(CSTRUEO),AL1(MDLCF08T+2-MDLCF08)   TRUE   BRANCH
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        COMPARE FIELDS           (NUMERIC - BINARY)                  *
***********************************************************************
MDLCF09  LAY   R14,0(0,0)         LOAD source address
MDLCF09k PACK  WORKAREA,0(0,R14)  CONVERT NUMERIC TO PACKED
         lmg   r0,r1,workarea
         cxstr fp1,r0
mdlcf09se lghi r14,*-*
         iextr fp1,fp1,r14       and insert
         Xgr   R0,R0              CONVERT BINARY  TO PACKED
MDLCF09S TMY   0(0),X'80'
         if (o)
           lghi r0,-1              fill with 1's
         endif
MDLCF09A ICMY  R0,B'0000',0(0)
         Cxgtr fp4,r0
MDLcf09g lghi  r14,*-*           Create biased exponent
         iextr fp4,fp4,r14
         cxtr  fp1,fp4
MDLCF09F jlu   *+l'*              BRANCH  TO   FALSE IF  NOT TRUE
MDLCF09T jlu   *+l'*              BRANCH  TO   TRUE (OPTIONAL)
MDLCF09L EQU   *-MDLCF09
*
MDLCF09P EQU   0                  LITERAL POOL USAGE (EXCL FIELD LEN)
*
MDLCF09R DC    AL1(CSSRCLNR),AL1(MDLCF09k+01-MDLCF09) SRC FIELD LEN R/2
         DC    AL1(CSSRClof),AL1(MDLCF09+02-MDLCF09)  SRC FIELD OFF
         DC    AL1(CSTGTloF),AL1(MDLCF09S+02-MDLCF09) TGT FIELD OFF
         DC    AL1(CSBYTMSK),AL1(MDLCF09A+01-MDLCF09) TGT FIELD LEN L/2
         DC    AL1(CSTGTloF),AL1(MDLCF09A+02-MDLCF09) TGT FIELD OFF
  DC    AL1(CSdfpexps),AL1(mdlcf09se+02-mdlcf09) dfpexp
  DC    AL1(CSdfpexp),AL1(mdlcf09g+02-mdlcf09) dfpexp
         DC    AL1(CSRELOPR),AL1(MDLCF09F+1-MDLCF09)  RELATIONAL CC
         DC    AL1(CSFALSEO),AL1(MDLCF09F+2-MDLCF09)  FALSE  BRANCH
         DC    AL1(CSTRUEO),AL1(MDLCF09T+2-MDLCF09)   TRUE   BRANCH
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        COMPARE FIELDS           (NUMERIC - BINARY 8)                *
***********************************************************************
MDLCF09_b8  LAY   R14,0(0,0)       LOAD  source address
mdlcf09_b8k PACK WORKAREA,0(0,R14) CONVERT NUMERIC TO PACKED
         lmg   r0,r1,workarea
         cxstr fp1,r0
mdlcf09_b8se lghi r14,*-*
         iextr fp1,fp1,r14       and insert
mdlcf09_b8A LG    R0,0(0,0)
         Cxgtr fp4,r0
MDLcf09_b8g lghi  r14,*-*           Create biased exponent
         iextr fp4,fp4,r14
         cxtr  fp1,fp4
mdlcf09_b8F jlu *+l'*             BRANCH  TO   FALSE IF  NOT TRUE
mdlcf09_b8T jlu *+l'*             BRANCH  TO   TRUE (OPTIONAL)
mdlcf09_b8L EQU *-mdlcf09_b8
*
mdlcf09_b8P EQU 0                 LITERAL POOL USAGE (EXCL FIELD LEN)
*
mdlcf09_b8R ds 0h
  DC    AL1(CSSRCLNR),AL1(mdlcf09_b8k+01-mdlcf09_b8) SRC FIELD LEN R/2
  DC    AL1(CSSRClof),AL1(mdlcf09_b8+02-mdlcf09_b8) SRC FIELD OFF
  DC    AL1(CSTGTlof),AL1(mdlcf09_b8A+02-mdlcf09_b8) TGT FIELD OFF
  DC    AL1(CSdfpexps),AL1(mdlcf09_b8se+02-mdlcf09_b8) dfpexp
  DC    AL1(CSdfpexp),AL1(mdlcf09_b8g+02-mdlcf09_b8) dfpexp
  DC    AL1(CSRELOPR),AL1(mdlcf09_b8F+1-mdlcf09_b8) RELATIONAL CC
  DC    AL1(CSFALSEO),AL1(mdlcf09_b8F+2-mdlcf09_b8) FALSE BRANCH
  DC    AL1(CSTRUEO),AL1(mdlcf09_b8T+2-mdlcf09_b8) TRUE BRANCH
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        COMPARE FIELDS           (NUMERIC - BINARY)                  *
***********************************************************************
MDLCF09u LAY   R14,0(0,0)         LOAD source address
MDLCF09uk PACK WORKAREA,0(0,R14)  CONVERT NUMERIC TO PACKED
         lmg   r0,r1,workarea
         cxstr fp1,r0
mdlcf09use lghi r14,*-*
         iextr fp1,fp1,r14       and insert
         Xgr   R0,R0              CONVERT BINARY  TO PACKED
MDLCF09uA ICMY R0,B'0000',0(0)
         Cxgtr fp4,r0
MDLcf09ug lghi  r14,*-*           Create biased exponent
         iextr fp4,fp4,r14
         cxtr  fp1,fp4
MDLCF09uF jlu  *+l'*              BRANCH  TO   FALSE IF  NOT TRUE
MDLCF09uT jlu  *+l'*              BRANCH  TO   TRUE (OPTIONAL)
MDLCF09uL EQU  *-MDLCF09u
*
MDLCF09uP EQU  0                  LITERAL POOL USAGE (EXCL FIELD LEN)
*
MDLCF09uR dc   AL1(CSSRCLNR),AL1(MDLCF09uk+01-MDLCF09u) SRC FLD LEN R/2
         DC    AL1(CSSRClof),AL1(MDLCF09u+02-MDLCF09u) SRC FLD OFF
         DC    AL1(CSBYTMSK),AL1(MDLCF09uA+01-MDLCF09u) TGT FLD LEN L/2
         DC    AL1(CSTGTloF),AL1(MDLCF09uA+02-MDLCF09u) TGT FLD OFF
  DC    AL1(CSdfpexps),AL1(mdlcf09use+02-mdlcf09u) dfpexp
  DC    AL1(CSdfpexp),AL1(mdlcf09ug+02-mdlcf09u) dfpexp
         DC    AL1(CSRELOPR),AL1(MDLCF09uF+1-MDLCF09u) RELA CC
         DC    AL1(CSFALSEO),AL1(MDLCF09uF+2-MDLCF09u) FALSE BRANCH
         DC    AL1(CSTRUEO),AL1(MDLCF09uT+2-MDLCF09u) TRUE   BRANCH
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        COMPARE FIELDS           (NUMERIC - BINARY)                  *
***********************************************************************
mdlcf36u LAY   R14,0(0,0)         LOAD source address
         MVI   WORKAR2+L'WORKAR2-1,X'0F' ADD SIGN NIBBLE 'F'
mdlcf36uQ MVO  WORKAR2,0(0,r14)   CONVERT BCD TO UNSIGNED PACKED
         lmg   r0,r1,workar2
         cxstr fp1,r0
mdlcf36use lghi r14,*-*
         iextr fp1,fp1,r14       and insert
         XGR   R0,R0              CONVERT BINARY  TO PACKED
mdlcf36uA ICMY R0,B'0000',0(0)
         Cxgtr fp4,r0
MDLcf36ug lghi  r14,*-*           Create biased exponent
         iextr fp4,fp4,r14
         cxtr  fp1,fp4
mdlcf36uF jlu  *+l'*              BRANCH  TO   FALSE IF  NOT TRUE
mdlcf36uT jlu  *+l'*              BRANCH  TO   TRUE (OPTIONAL)
mdlcf36uL EQU  *-mdlcf36u
*
mdlcf36uP EQU  0                  LITERAL POOL USAGE (EXCL FIELD LEN)
*
mdlcf36uR DC   AL1(CSSRClof),AL1(mdlcf36u+02-mdlcf36u) SRC FIELD OFF
         DC    AL1(CSSRCLNr),AL1(mdlcf36uQ+01-mdlcf36u) FIELD 2 LEN L/2
         DC    AL1(CSBYTMSK),AL1(mdlcf36uA+01-mdlcf36u) TGT FD LEN L/2
         DC    AL1(CSTGTloF),AL1(mdlcf36uA+02-mdlcf36u) TGT FIELD OFF
  DC    AL1(CSdfpexps),AL1(mdlcf36use+02-mdlcf36u) dfpexp
  DC    AL1(CSdfpexp),AL1(mdlcf36ug+02-mdlcf36u) dfpexp
         DC    AL1(CSRELOPR),AL1(mdlcf36uF+1-mdlcf36u) RELATIONAL CC
         DC    AL1(CSFALSEO),AL1(mdlcf36uF+2-mdlcf36u) FALSE BRANCH
         DC    AL1(CSTRUEO),AL1(mdlcf36uT+2-mdlcf36u) TRUE   BRANCH
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        COMPARE FIELDS           (NUMERIC - BINARY)                  *
***********************************************************************
mdlcf36  LAY   R14,0(0,0)         LOAD source address
         MVI   WORKAR2+L'WORKAR2-1,X'0F' ADD SIGN NIBBLE 'F'
mdlcf36Q MVO   WORKAR2,0(0,r14)   CONVERT BCD TO UNSIGNED PACKED
         lmg   r0,r1,workar2
         cxstr fp1,r0
mdlcf36se lghi r14,*-*
         iextr fp1,fp1,r14       and insert
         Xgr   R0,R0              CONVERT BINARY  TO PACKED
mdlcf36S TMY   0(0),X'80'
         if (o)
           lghi r0,-1              fill with 1's
         endif
mdlcf36A ICMY  R0,B'0000',0(0)
         Cxgtr fp4,r0
MDLcf36g lghi  r14,*-*           Create biased exponent
         iextr fp4,fp4,r14
         cxtr  fp1,fp4
mdlcf36F jlu   *+l'*              BRANCH  TO   FALSE IF  NOT TRUE
mdlcf36T jlu   *+l'*              BRANCH  TO   TRUE (OPTIONAL)
mdlcf36L EQU   *-mdlcf36
*
mdlcf36P EQU   0                  LITERAL POOL USAGE (EXCL FIELD LEN)
*
mdlcf36R DC    AL1(CSSRClof),AL1(mdlcf36+02-mdlcf36)  SRC FIELD OFF
         DC    AL1(CSSRCLNr),AL1(mdlcf36Q+01-mdlcf36) FIELD  2  LEN L/2
         DC    AL1(CSTGTloF),AL1(mdlcf36S+02-mdlcf36) TGT FIELD OFF
         DC    AL1(CSBYTMSK),AL1(mdlcf36A+01-mdlcf36) TGT FIELD LEN L/2
         DC    AL1(CSTGTloF),AL1(mdlcf36A+02-mdlcf36) TGT FIELD OFF
  DC    AL1(CSdfpexps),AL1(mdlcf36se+02-mdlcf36) dfpexp
  DC    AL1(CSdfpexp),AL1(mdlcf36g+02-mdlcf36) dfpexp
         DC    AL1(CSRELOPR),AL1(mdlcf36F+1-mdlcf36)  RELATIONAL CC
         DC    AL1(CSFALSEO),AL1(mdlcf36F+2-mdlcf36)  FALSE  BRANCH
         DC    AL1(CSTRUEO),AL1(mdlcf36T+2-mdlcf36)   TRUE   BRANCH
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        COMPARE FIELDS           (NUMERIC - BINARY 8)                *
***********************************************************************
mdlcf36_b8  LAY   R14,0(0,0)       LOAD  source address
         MVI   WORKAR2+L'WORKAR2-1,X'0F' ADD SIGN NIBBLE 'F'
mdlcf36_b8Q MVO   WORKAR2,0(0,r14)   CONVERT BCD TO UNSIGNED PACKED
         lmg   r0,r1,workar2
         cxstr fp1,r0
mdlcf36_b8se lghi r14,*-*
         iextr fp1,fp1,r14       and insert
mdlcf36_b8A LG    R0,0(0,0)
         Cxgtr fp4,r0
MDLcf36_b8g lghi  r14,*-*           Create biased exponent
         iextr fp4,fp4,r14
         cxtr  fp1,fp4
mdlcf36_b8F jlu *+l'*             BRANCH  TO   FALSE IF  NOT TRUE
mdlcf36_b8T jlu *+l'*             BRANCH  TO   TRUE (OPTIONAL)
mdlcf36_b8L EQU *-mdlcf36_b8
*
mdlcf36_b8P EQU 0                 LITERAL POOL USAGE (EXCL FIELD LEN)
*
mdlcf36_b8R DC AL1(CSSRCLof),AL1(mdlcf36_b8+02-mdlcf36_b8) src fldl/l
  DC    AL1(CSSRCLNr),AL1(mdlcf36_b8q+01-mdlcf36_b8) SRC FIELD LEN L/2
  DC    AL1(CSdfpexps),AL1(mdlcf36_b8se+02-mdlcf36_b8) dfpexp
  DC    AL1(CSTGTlof),AL1(mdlcf36_b8A+02-mdlcf36_b8) TGT FIELD OFF
  DC    AL1(CSdfpexp),AL1(mdlcf36_b8g+02-mdlcf36_b8) dfpexp
  DC    AL1(CSRELOPR),AL1(mdlcf36_b8F+1-mdlcf36_b8) RELATIONAL CC
  DC    AL1(CSFALSEO),AL1(mdlcf36_b8F+2-mdlcf36_b8) FALSE BRANCH
  DC    AL1(CSTRUEO),AL1(mdlcf36_b8T+2-mdlcf36_b8) TRUE BRANCH
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        COMPARE FIELDS           (NUMERIC - BINARY)                  *
***********************************************************************
mdlcf67u LAY   R14,0(0,0)         LOAD source address
         MVI   WORKAR2+L'WORKAR2-1,X'0F' ADD SIGN NIBBLE 'F'
mdlcf67uQ MVO  WORKAR2,0(0,r14)   CONVERT BCD TO UNSIGNED PACKED
         lmg   r0,r1,workar2
         cxstr fp1,r0
mdlcf67use lghi r14,*-*
         iextr fp1,fp1,r14       and insert
         XGR   R0,R0              CONVERT BINARY  TO PACKED
mdlcf67uA ICMY R0,B'0000',0(0)
         Cxgtr fp4,r0
MDLcf67ug lghi  r14,*-*           Create biased exponent
         iextr fp4,fp4,r14
         cxtr  fp4,fp1
mdlcf67uF jlu  *+l'*              BRANCH  TO   FALSE IF  NOT TRUE
mdlcf67uT jlu  *+l'*              BRANCH  TO   TRUE (OPTIONAL)
mdlcf67uL EQU  *-mdlcf67u
*
mdlcf67uP EQU  0                  LITERAL POOL USAGE (EXCL FIELD LEN)
*
mdlcf67uR DC   AL1(CStgtlof),AL1(mdlcf67u+02-mdlcf67u) SRC FIELD OFF
         DC    AL1(CStgtLNr),AL1(mdlcf67uQ+01-mdlcf67u) FIELD 2 LEN L/2
         DC    AL1(CSBYTMSs),AL1(mdlcf67uA+01-mdlcf67u) TGT FLEN L/2
         DC    AL1(CSsrcloF),AL1(mdlcf67uA+02-mdlcf67u) TGT FIELD OFF
  DC    AL1(CSdfpexp),AL1(mdlcf67use+02-mdlcf67u) dfpexp
  DC    AL1(CSdfpexps),AL1(mdlcf67ug+02-mdlcf67u) dfpexp
         DC    AL1(CSRELOPR),AL1(mdlcf67uF+1-mdlcf67u) RELATIONAL CC
         DC    AL1(CSFALSEO),AL1(mdlcf67uF+2-mdlcf67u) FALSE BRANCH
         DC    AL1(CSTRUEO),AL1(mdlcf67uT+2-mdlcf67u) TRUE   BRANCH
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        COMPARE FIELDS           (NUMERIC - BINARY)                  *
***********************************************************************
mdlcf67  LAY   R14,0(0,0)         LOAD source address
         MVI   WORKAR2+L'WORKAR2-1,X'0F' ADD SIGN NIBBLE 'F'
mdlcf67Q MVO   WORKAR2,0(0,r14)   CONVERT BCD TO UNSIGNED PACKED
         lmg   r0,r1,workar2
         cxstr fp1,r0
mdlcf67se lghi r14,*-*
         iextr fp1,fp1,r14       and insert
         Xgr   R0,R0              CONVERT BINARY  TO PACKED
mdlcf67S TMY   0(0),X'80'
         if (o)
           lghi r0,-1              fill with 1's
         endif
mdlcf67A ICMY  R0,B'0000',0(0)
         Cxgtr fp4,r0
MDLcf67g lghi  r14,*-*           Create biased exponent
         iextr fp4,fp4,r14
         cxtr  fp4,fp1
mdlcf67F jlu   *+l'*              BRANCH  TO   FALSE IF  NOT TRUE
mdlcf67T jlu   *+l'*              BRANCH  TO   TRUE (OPTIONAL)
mdlcf67L EQU   *-mdlcf67
*
mdlcf67P EQU   0                  LITERAL POOL USAGE (EXCL FIELD LEN)
*
mdlcf67R DC    AL1(CStgtlof),AL1(mdlcf67+02-mdlcf67)  SRC FIELD OFF
         DC    AL1(CStgtLNr),AL1(mdlcf67Q+01-mdlcf67) FIELD  2  LEN L/2
         DC    AL1(CSsrcloF),AL1(mdlcf67S+02-mdlcf67) TGT FIELD OFF
         DC    AL1(CSBYTMSs),AL1(mdlcf67A+01-mdlcf67) TGT FIELD LEN L/2
         DC    AL1(CSsrcloF),AL1(mdlcf67A+02-mdlcf67) TGT FIELD OFF
  DC    AL1(CSdfpexp),AL1(mdlcf67se+02-mdlcf67) dfpexp
  DC    AL1(CSdfpexps),AL1(mdlcf67g+02-mdlcf67) dfpexp
         DC    AL1(CSRELOPR),AL1(mdlcf67F+1-mdlcf67)  RELATIONAL CC
         DC    AL1(CSFALSEO),AL1(mdlcf67F+2-mdlcf67)  FALSE  BRANCH
         DC    AL1(CSTRUEO),AL1(mdlcf67T+2-mdlcf67)   TRUE   BRANCH
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        COMPARE FIELDS           (NUMERIC - BINARY 8)                *
***********************************************************************
mdlcf67_b8  LAY   R14,0(0,0)       LOAD  source address
         MVI   WORKAR2+L'WORKAR2-1,X'0F' ADD SIGN NIBBLE 'F'
mdlcf67_b8Q MVO   WORKAR2,0(0,r14)   CONVERT BCD TO UNSIGNED PACKED
         lmg   r0,r1,workar2
         cxstr fp1,r0
mdlcf67_b8se lghi r14,*-*
         iextr fp1,fp1,r14       and insert
mdlcf67_b8A LG    R0,0(0,0)
         Cxgtr fp4,r0
MDLcf67_b8g lghi  r14,*-*           Create biased exponent
         iextr fp4,fp4,r14
         cxtr  fp4,fp1
mdlcf67_b8F jlu *+l'*             BRANCH  TO   FALSE IF  NOT TRUE
mdlcf67_b8T jlu *+l'*             BRANCH  TO   TRUE (OPTIONAL)
mdlcf67_b8L EQU *-mdlcf67_b8
*
mdlcf67_b8P EQU 0                 LITERAL POOL USAGE (EXCL FIELD LEN)
*
mdlcf67_b8R DC AL1(CStgtLof),AL1(mdlcf67_b8+02-mdlcf67_b8) src fldl/l
  DC    AL1(CStgtLNr),AL1(mdlcf67_b8q+01-mdlcf67_b8) SRC FIELD LEN L/2
  DC    AL1(CSsrclof),AL1(mdlcf67_b8A+02-mdlcf67_b8) TGT FIELD OFF
  DC    AL1(CSdfpexp),AL1(mdlcf67_b8se+02-mdlcf67_b8) dfpexp
  DC    AL1(CSdfpexps),AL1(mdlcf67_b8g+02-mdlcf67_b8) dfpexp
  DC    AL1(CSRELOPR),AL1(mdlcf67_b8F+1-mdlcf67_b8) RELATIONAL CC
  DC    AL1(CSFALSEO),AL1(mdlcf67_b8F+2-mdlcf67_b8) FALSE BRANCH
  DC    AL1(CSTRUEO),AL1(mdlcf67_b8T+2-mdlcf67_b8) TRUE BRANCH
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        COMPARE FIELDS           (NUMERIC - BINARY)                  *
***********************************************************************
mdlcf50  LAY   R14,0(0,0)         LOAD source address
mdlcf50la  LAY   R15,0(0,0)         get address
         MVI   WORKAR2+L'WORKAR2-1,X'0F' ADD SIGN NIBBLE 'F'
mdlcf50Q MVO   WORKAR2,0(0,r14)   CONVERT BCD TO UNSIGNED PACKED
         lmg   r0,r1,workar2
         cxstr fp1,r0
mdlcf50se lghi r14,*-*
         iextr fp1,fp1,r14       and insert
         xgr   R0,R0              CONVERT BINARY  TO PACKED
mdlcf50m mvc   workarea(0),0(r15) move event field to workarea
         xi    workarea,x'80'      flip the top bit
         if tm,workarea,x'80',nz If negative ...
           lghi r0,-1              fill with 1's
         endif
mdlcf50a ICMy  R0,B'0000',workarea
         Cxgtr fp4,r0
MDLcf50g lghi  r14,*-*           Create biased exponent
         iextr fp4,fp4,r14
         cxtr  fp1,fp4
mdlcf50F jlu   *+l'*              BRANCH  TO   FALSE IF  NOT TRUE
mdlcf50T jlu   *+l'*              BRANCH  TO   TRUE (OPTIONAL)
mdlcf50L EQU   *-mdlcf50
*
mdlcf50P EQU   0                  LITERAL POOL USAGE (EXCL FIELD LEN)
*
mdlcf50R DC    AL1(CSSRClof),AL1(mdlcf50+02-mdlcf50)  SRC FIELD OFF
         DC    AL1(CSSRCLNr),AL1(mdlcf50Q+01-mdlcf50) FIELD  2  LEN L/2
         DC    AL1(CStgtloF),AL1(mdlcf50la+02-mdlcf50) FIELD  1  OFFSET
         DC    AL1(CStgtln),AL1(mdlcf50m+01-mdlcf50)  length
         DC    AL1(CSBYTMSk),AL1(mdlcf50A+01-mdlcf50) BYTE      MASK
  DC    AL1(CSdfpexps),AL1(mdlcf50se+02-mdlcf50) dfpexp
  DC    AL1(CSdfpexp),AL1(mdlcf50g+02-mdlcf50) dfpexp
         DC    AL1(CSRELOPR),AL1(mdlcf50F+1-mdlcf50)  RELATIONAL CC
         DC    AL1(CSFALSEO),AL1(mdlcf50F+2-mdlcf50)  FALSE  BRANCH
         DC    AL1(CSTRUEO),AL1(mdlcf50T+2-mdlcf50)   TRUE   BRANCH
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        COMPARE FIELDS           (NUMERIC - BINARY 8)                *
***********************************************************************
mdlcf50_b8  LAY   R14,0(0,0)       LOAD  source address
mdlcf50_b8la LAY   R15,0(0,0)
         MVI   WORKAR2+L'WORKAR2-1,X'0F' ADD SIGN NIBBLE 'F'
mdlcf50_b8Q MVO   WORKAR2,0(0,r14)   CONVERT BCD TO UNSIGNED PACKED
         lmg   r0,r1,workar2
         cxstr fp1,r0
mdlcf50_b8se lghi r14,*-*
         iextr fp1,fp1,r14       and insert
mdlcf50_b8m mvc   workarea(0),0(r15) move event field to workarea
         xi    workarea,x'80'  flip top bit
         lg    R0,workarea
         Cxgtr fp4,r0
MDLcf50_b8g lghi  r14,*-*           Create biased exponent
         iextr fp4,fp4,r14
         cxtr  fp1,fp4
mdlcf50_b8F jlu *+l'*             BRANCH  TO   FALSE IF  NOT TRUE
mdlcf50_b8T jlu *+l'*             BRANCH  TO   TRUE (OPTIONAL)
mdlcf50_b8L EQU *-mdlcf50_b8
*
mdlcf50_b8P EQU 0                 LITERAL POOL USAGE (EXCL FIELD LEN)
*
mdlcf50_b8R DC AL1(CSSRCLof),AL1(mdlcf50_b8+02-mdlcf50_b8) src fldl/l
  DC    AL1(CSSRCLNr),AL1(mdlcf50_b8q+01-mdlcf50_b8) SRC FIELD LEN L/2
  DC    AL1(CSTGTlof),AL1(mdlcf50_b8lA+02-mdlcf50_b8) TGT FIELD OFF
  DC    AL1(CSTGTln),AL1(mdlcf50_b8m+01-mdlcf50_b8) TGT FIELD OFF
  DC    AL1(CSdfpexps),AL1(mdlcf50_b8se+02-mdlcf50_b8) dfpexp
  DC    AL1(CSdfpexp),AL1(mdlcf50_b8g+02-mdlcf50_b8) dfpexp
  DC    AL1(CSRELOPR),AL1(mdlcf50_b8F+1-mdlcf50_b8) RELATIONAL CC
  DC    AL1(CSFALSEO),AL1(mdlcf50_b8F+2-mdlcf50_b8) FALSE BRANCH
  DC    AL1(CSTRUEO),AL1(mdlcf50_b8T+2-mdlcf50_b8) TRUE BRANCH
         DC   2XL1'FF'
***********************************************************************
mdlcf54  LAY   R4,0(0,0)          get address - must be 1st inst in
*                                 model so that we get r5 on lookups
MDLcf54s llgt  R5,0(,R2)          load logic table row address
         LA    R1,WORKAR2
mdlcf54b BAS   R10,*-*            CALL "GVBDL96"  (FORMAT  FIELD)
MDLcf54Aa jlu   *+l'*             FORMAT UNSUCCESSFUL BRANCH (FALSE)
*        do NOT use R14 here as it gets NOPed out
         ld    fp4,workar2        load first operand into fp4/6
         ld    fp6,workar2+8
         Xgr   R0,R0              CONVERT BINARY  TO DFP
mdlcf54m mvc   workarea(0),0(r4)  move event field to workarea
         xi    workarea,x'80'      flip the top bit
         if tm,workarea,x'80',nz If negative ...
           lghi r0,-1              fill with 1's
         endif
mdlcf54a ICMy  R0,B'0000',workarea
         cxgtr fp1,r0             convert from fixed to DFP
MDLcf54e lghi  r15,*-*           Create biased exponent
         iextr fp1,fp1,r15       and insert
         cxtr  fp4,fp1            COMPARE TWO  FIELDS
mdlcf54F jlu   *+l'*              BRANCH  TO   FALSE IF  NOT TRUE
mdlcf54T jlu   *+l'*              BRANCH  TO   TRUE (OPTIONAL)
mdlcf54L EQU   *-mdlcf54
*
mdlcf54P EQU   0                  LITERAL POOL USAGE (EXCL FIELD LEN)
*
mdlcf54r DC    AL1(CStgtloF),AL1(mdlcf54+02-mdlcf54) FIELD  1  OFFSET
         DC    AL1(CSltroff),AL1(mdlcf54s+02-mdlcf54)  SRC FIELD OFF
         DC    AL1(CSdl96calln),AL1(MDLcf54b-MDLcf54)  MR96 BAS
         DC    AL1(CSFALSEO),AL1(MDLcf54Aa+2-MDLcf54)  FALSE  BRANCH
         DC    AL1(CStgtln),AL1(mdlcf54m+01-mdlcf54)  length
         DC    AL1(CSBYTMSk),AL1(mdlcf54A+01-mdlcf54) BYTE      MASK
         DC    AL1(CSdfpexp),AL1(MDLcf54e+02-MDLcf54) dfp exp
         DC    AL1(CSRELOPR),AL1(mdlcf54F+1-mdlcf54)  RELATIONAL CC
         DC    AL1(CSFALSEO),AL1(mdlcf54F+2-mdlcf54)  FALSE  BRANCH
         DC    AL1(CSTRUEO),AL1(mdlcf54T+2-mdlcf54)   TRUE   BRANCH
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        COMPARE FIELDS           (NUMERIC - BINARY 8)                *
***********************************************************************
mdlcf54_b8  LAY   R4,0(0,0)
MDLcf54_b8s llgt  R5,0(,R2)          load logic table row address
         LA    R1,WORKAR2
mdlcf54_b8b BAS   R10,*-*            CALL "GVBDL96"  (FORMAT  FIELD)
MDLcf54_b8Aa jlu   *+l'*             FORMAT UNSUCCESSFUL BRANCH (FALSE)
*        do NOT use R14 here as it gets NOPed out
         ld    fp4,workar2        load first operand into fp4/6
         ld    fp6,workar2+8
mdlcf54_b8m mvc   workarea(0),0(r4)  move event field to workarea
            xi    workarea,x'80'  flip top bit
            lg    R0,workarea
         cxgtr fp1,r0             convert from fixed to DFP
MDLcf54_b8e lghi  r15,*-*           Create biased exponent
         iextr fp1,fp1,r15       and insert
         cxtr  fp4,fp1            COMPARE TWO  FIELDS
mdlcf54_b8F jlu *+l'*             BRANCH  TO   FALSE IF  NOT TRUE
mdlcf54_b8T jlu *+l'*             BRANCH  TO   TRUE (OPTIONAL)
mdlcf54_b8L EQU *-mdlcf54_b8
*
mdlcf54_b8P EQU 0                 LITERAL POOL USAGE (EXCL FIELD LEN)
*
mdlcf54_b8R ds 0h
  DC    AL1(CSTGTlof),AL1(mdlcf54_b8+02-mdlcf54_b8) TGT FIELD OFF
  DC    AL1(CSltroff),AL1(mdlcf54_b8s+02-mdlcf54_b8)  SRC FIELD OFF
  DC    AL1(CSdl96calln),AL1(MDLcf54_b8b-MDLcf54_b8)  MR96 BAS
  DC    AL1(CSFALSEO),AL1(MDLcf54_b8Aa+2-MDLcf54_b8)  FALSE  BRANCH
  DC    AL1(CSTGTln),AL1(mdlcf54_b8m+01-mdlcf54_b8) TGT FIELD OFF
  DC    AL1(CSdfpexp),AL1(MDLcf54_b8e+02-MDLcf54_b8) dfp exp
  DC    AL1(CSRELOPR),AL1(mdlcf54_b8F+1-mdlcf54_b8) RELATIONAL CC
  DC    AL1(CSFALSEO),AL1(mdlcf54_b8F+2-mdlcf54_b8) FALSE BRANCH
  DC    AL1(CSTRUEO),AL1(mdlcf54_b8T+2-mdlcf54_b8) TRUE BRANCH
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        COMPARE FIELDS           (NUMERIC - BINARY)                  *
***********************************************************************
mdlcf68  LAY   R14,0(0,0)         LOAD target address
mdlcf68la  LAY   R15,0(0,0)         get address
         MVI   WORKAR2+L'WORKAR2-1,X'0F' ADD SIGN NIBBLE 'F'
mdlcf68Q MVO   WORKAR2,0(0,r14)   CONVERT BCD TO UNSIGNED PACKED
         lmg   r0,r1,workar2
         cxstr fp1,r0
MDLcf68d lghi  r14,*-*           Create biased exponent
         iextr fp1,fp1,r14       and insert
         Xgr   R0,R0              CONVERT BINARY  TO PACKED
mdlcf68m mvc   workarea(0),0(r15) move event field to workarea
         xi    workarea,x'80'      flip the top bit
         if tm,workarea,x'80',nz If negative ...
           lghi r0,-1             fill with 1's
         endif
mdlcf68a ICMy  R0,B'0000',workarea
         cxgtr fp4,r0
MDLcf68e lghi  r14,*-*           Create biased exponent
         iextr fp4,fp4,r14       and insert
         cxtr  fp4,fp1            COMPARE TWO  FIELDS
mdlcf68F jlu   *+l'*              BRANCH  TO   FALSE IF  NOT TRUE
mdlcf68T jlu   *+l'*              BRANCH  TO   TRUE (OPTIONAL)
mdlcf68L EQU   *-mdlcf68
*
mdlcf68P EQU   0                  LITERAL POOL USAGE (EXCL FIELD LEN)
*
mdlcf68R DC    AL1(CStgtlof),AL1(mdlcf68+02-mdlcf68)  SRC FIELD OFF
         DC    AL1(CStgtLNr),AL1(mdlcf68Q+01-mdlcf68) FIELD  2  LEN L/2
         DC    AL1(CSdfpexp),AL1(mdlcf68d+02-mdlcf68) dfp exp
         DC    AL1(CSsrcloF),AL1(mdlcf68la+02-mdlcf68) FIELD  1  OFFSET
         DC    AL1(CSsrcln),AL1(mdlcf68m+01-mdlcf68)  length
         DC    AL1(CSBYTMSs),AL1(mdlcf68A+01-mdlcf68) BYTE      MASK
         DC    AL1(CSdfpexps),AL1(mdlcf68e+02-mdlcf68) dfp exp
         DC    AL1(CSRELOPR),AL1(mdlcf68F+1-mdlcf68)  RELATIONAL CC
         DC    AL1(CSFALSEO),AL1(mdlcf68F+2-mdlcf68)  FALSE  BRANCH
         DC    AL1(CSTRUEO),AL1(mdlcf68T+2-mdlcf68)   TRUE   BRANCH
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        COMPARE FIELDS           (NUMERIC - BINARY 8)                *
***********************************************************************
mdlcf68_b8   LAY  R14,0(0,0)       LOAD  source address
mdlcf68_b8la LAY  R15,0(0,0)
         MVI   WORKAR2+L'WORKAR2-1,X'0F' ADD SIGN NIBBLE 'F'
mdlcf68_b8Q MVO   WORKAR2,0(0,r14)   CONVERT BCD TO UNSIGNED PACKED
         lmg   r0,r1,workar2
         cxstr fp1,r0
MDLcf68_b8d lghi  r14,*-*           Create biased exponent
         iextr fp1,fp1,r14       and insert
mdlcf68_b8m mvc   workarea(0),0(r15) move event field to workarea
         xi    workarea,x'80'  flip top bit
         lg    R0,workarea
         Cxgtr fp4,r0
MDLcf68_b8e lghi  r14,*-*           Create biased exponent
         iextr fp4,fp4,r14       and insert
         cxtr  fp4,fp1            COMPARE TWO  FIELDS
mdlcf68_b8F jlu *+l'*             BRANCH  TO   FALSE IF  NOT TRUE
mdlcf68_b8T jlu *+l'*             BRANCH  TO   TRUE (OPTIONAL)
mdlcf68_b8L EQU *-mdlcf68_b8
*
mdlcf68_b8P EQU 0                 LITERAL POOL USAGE (EXCL FIELD LEN)
*
mdlcf68_b8R DC AL1(CStgtLof),AL1(mdlcf68_b8+02-mdlcf68_b8) src fldl/l
  DC    AL1(CStgtLNr),AL1(mdlcf68_b8q+01-mdlcf68_b8) SRC FIELD LEN L/2
  DC    AL1(CSdfpexp),AL1(mdlcf68_b8d+02-mdlcf68_b8) dfp exp
  DC    AL1(CSsrclof),AL1(mdlcf68_b8lA+02-mdlcf68_b8) TGT FIELD OFF
  DC    AL1(CSsrcln),AL1(mdlcf68_b8m+01-mdlcf68_b8) TGT FIELD OFF
  DC    AL1(CSdfpexps),AL1(mdlcf68_b8e+02-mdlcf68_b8) dfp exp
  DC    AL1(CSRELOPR),AL1(mdlcf68_b8F+1-mdlcf68_b8) RELATIONAL CC
  DC    AL1(CSFALSEO),AL1(mdlcf68_b8F+2-mdlcf68_b8) FALSE BRANCH
  DC    AL1(CSTRUEO),AL1(mdlcf68_b8T+2-mdlcf68_b8) TRUE BRANCH
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        COMPARE FIELDS           (PACKs  - PACKED)                   *
***********************************************************************
mdlcf69  LAY   R14,0(0,0)         LOAD  SOURCE address
mdlcf69_la LAY R15,0(0,0)         CONSTANT ADDRESS
         MVI   WORKAR2+L'WORKAR2-1,X'0F' ADD SIGN NIBBLE 'F'
mdlcf69b mvo   workar2,0(0,r14)   CONVERT BCD TO UNSIGNED PACKED
         MVI   WORKARea+L'WORKARea-1,X'0F' ADD SIGN NIBBLE 'F'
mdlcf69bb mvo  workarea,0(0,r15)  CONVERT BCD TO UNSIGNED PACKED
         lmg   r0,r1,workar2
         cxstr fp1,r0
MDLcf69d lghi  r14,*-*           Create biased exponent
         iextr fp1,fp1,r14       and insert
         lmg   r0,r1,workarea
         cxstr fp4,r0
MDLcf69e lghi  r14,*-*           Create biased exponent
         iextr fp4,fp4,r14       and insert
         cxtr  fp1,fp4            COMPARE TWO FIELDS
mdlcf69F jlu   *+l'*              BRANCH  TO   FALSE  IF NOT TRUE
mdlcf69T jlu   *+l'*              BRANCH  TO   TRUE  (OPTIONAL)
mdlcf69L EQU   *-mdlcf69
*
mdlcf69P EQU   0                  LITERAL POOL USAGE (EXCL FIELD LEN)
*
mdlcf69R DC    AL1(CSSRCloF),AL1(mdlcf69+02-mdlcf69)   FIELD  1  OFF
         DC    AL1(CSTGTloF),AL1(mdlcf69_la+02-mdlcf69)  FIELD  2  OFF
         DC    AL1(CSdfpexp),AL1(mdlcf69d+02-mdlcf69) dfp exp
         DC    AL1(CSSRCLNR),AL1(mdlcf69b+01-mdlcf69) TARGET    LENGTH
         DC    AL1(CStgtLNR),AL1(mdlcf69bb+01-mdlcf69) TARGET    LENGTH
         DC    AL1(CSdfpexps),AL1(mdlcf69e+02-mdlcf69) dfp exp
         DC    AL1(CSRELOPR),AL1(mdlcf69F+1-mdlcf69)  RELATIONAL CC
         DC    AL1(CSFALSEO),AL1(mdlcf69F+2-mdlcf69)  FALSE  BRANCH
         DC    AL1(CSTRUEO),AL1(mdlcf69T+2-mdlcf69)   TRUE   BRANCH
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        COMPARE FIELDS           (PACKs  - PACKED)                   *
***********************************************************************
mdlcf75  LAY   R4,0(0,0)          Target ADDRESS
mdlcf75_ly llgt R5,0(,r2)          load logic table address
         la    r1,workar2
mdlcf75b BAS   R10,*-*            CALL "GVBDL96"  (FORMAT  FIELD)
MDLcf75Aa jlu   *+l'*             FORMAT UNSUCCESSFUL BRANCH (FALSE)
*        do NOT use R14 here as it gets NOPed out
         ld    fp4,workar2        load first operand into fp4/6
         ld    fp6,workar2+8
         MVI   WORKARea+L'WORKARea-1,X'0F' ADD SIGN NIBBLE 'F'
mdlcf75bb mvo  workarea,0(0,r4)   CONVERT BCD TO UNSIGNED PACKED
         lmg   r0,r1,workarea
         cxstr fp1,r0             convert to dfp
MDLcf75e lghi  r15,*-*            Create biased exponent
         iextr fp1,fp1,r15       and insert
         cxtr  fp4,fp1            COMPARE TWO  FIELDS
mdlcf75F jlu   *+l'*              BRANCH  TO   FALSE  IF NOT TRUE
mdlcf75T jlu   *+l'*              BRANCH  TO   TRUE  (OPTIONAL)
mdlcf75L EQU   *-mdlcf75
*
mdlcf75P EQU   0                  LITERAL POOL USAGE (EXCL FIELD LEN)
*
mdlcf75r DC    AL1(CSTGTloF),AL1(mdlcf75+02-mdlcf75)  FIELD  2  OFF
         DC    AL1(CSltroff),AL1(mdlcf75_ly+02-mdlcf75)   FIELD  1  OFF
         DC    AL1(CSdl96calln),AL1(MDLcf75b-MDLcf75)  MR96 BAS
         DC    AL1(CSFALSEO),AL1(MDLcf75Aa+2-MDLcf75)  FALSE  BRANCH
         DC    AL1(CStgtLNR),AL1(mdlcf75bb+01-mdlcf75) TARGET    LENGTH
         DC    AL1(CSdfpexp),AL1(MDLcf75e+02-MDLcf75) dfp exp
         DC    AL1(CSRELOPR),AL1(mdlcf75F+1-mdlcf75)  RELATIONAL CC
         DC    AL1(CSFALSEO),AL1(mdlcf75F+2-mdlcf75)  FALSE  BRANCH
         DC    AL1(CSTRUEO),AL1(mdlcf75T+2-mdlcf75)   TRUE   BRANCH
         DC   2XL1'FF'
                        SPACE 3
*
mdlcf37u Xgr   R4,R4              CONVERT BINARY  TO DFP
mdlcf37uc ICMY R4,B'0000',0(0)
         cxgtr fp1,r4             convert from fixed to DFP
MDLcf37ue lghi  r15,*-*           Create biased exponent
         iextr fp1,fp1,r15       and insert
mdlcf37us llgt  R5,0(,R2)          load logic table row address
         LA    R1,workar2
mdlcf37ub BAS   R10,*-*            CALL "GVBDL96"  (FORMAT  FIELD)
mdlcf37uA jlu  *+l'*              FORMAT UNSUCCESSFUL BRANCH (FALSE)
*        do NOT use R14 here as it gets NOPed out
         ld    fp4,workar2        load first operand into fp4/6
         ld    fp6,workar2+8
         cxtr  fp4,fp1            COMPARE TWO  FIELDS
mdlcf37uF jlu  *+l'*              BRANCH  TO   FALSE IF  NOT TRUE
mdlcf37uT jlu  *+l'*              BRANCH  TO   TRUE (OPTIONAL)
mdlcf37uL EQU  *-mdlcf37u
*
mdlcf37uP EQU  4                  LITERAL POOL USAGE (EXCL FIELD LEN)
*
mdlcf37ur dc   AL1(CStgtlof),AL1(mdlcf37uc+02-mdlcf37u) TARGET  OFFSET
          DC   AL1(CSltroff),AL1(mdlcf37us+02-mdlcf37u) TARGET   OFFSET
         DC    AL1(CSdl96calln),AL1(MDLcf37ub-MDLcf37u)  MR96 BAS
         DC    AL1(CSFALSEO),AL1(mdlcf37uA+2-mdlcf37u) FALSE BRANCH
         DC    AL1(CSbytmsk),AL1(mdlcf37uc+01-mdlcf37u) TARGET  OFFSET
         DC    AL1(CSdfpexp),AL1(MDLcf37ue+02-MDLcf37u) dfp exp
         DC    AL1(CSRELOPR),AL1(mdlcf37uF+1-mdlcf37u) RELATIONAL CC
         DC    AL1(CSFALSEO),AL1(mdlcf37uF+2-mdlcf37u) FALSE BRANCH
         DC    AL1(CSTRUEO),AL1(mdlcf37uT+2-mdlcf37u) TRUE   BRANCH
         DC   2XL1'FF'
                        SPACE 3
*
mdlcf37  xgr  R4,R4              CONVERT BINARY  TO DFP
mdlcf37b TMY   0(0),X'80'
         if (o)
           lghi r4,-1              fill with 1's
         endif
mdlcf37c ICMY  R4,B'0000',0(0)
         cxgtr fp1,r4             convert from fixed to DFP
MDLcf37e lghi  r15,*-*            Create biased exponent
         iextr fp1,fp1,r15       and insert
mdlcf37s llgt  R5,0(,R2)          load logic table row address
         LA    R1,workar2
mdlcf37bb BAS  R10,*-*            CALL "GVBDL96"  (FORMAT  FIELD)
mdlcf37A jlu   *+l'*              FORMAT UNSUCCESSFUL BRANCH (FALSE)
*        do NOT use R14 here as it gets NOPed out
         ld    fp4,workar2        load first operand into fp4/6
         ld    fp6,workar2+8
         cxtr  fp4,fp1            COMPARE TWO  FIELDS
mdlcf37F jlu   *+l'*              BRANCH  TO   FALSE IF  NOT TRUE
mdlcf37T jlu   *+l'*              BRANCH  TO   TRUE (OPTIONAL)
mdlcf37L EQU   *-mdlcf37
*
mdlcf37P EQU   4                  LITERAL POOL USAGE (EXCL FIELD LEN)
*
mdlcf37r DC    AL1(CStgtlof),AL1(mdlcf37b+02-mdlcf37) TARGET    OFFSET
         DC    AL1(CSltroff),AL1(mdlcf37s+02-mdlcf37)  TARGET    OFFSET
         DC    AL1(CSdl96calln),AL1(MDLcf37bb-MDLcf37)  MR96 BAS
         DC    AL1(CSFALSEO),AL1(mdlcf37A+2-mdlcf37)  FALSE  BRANCH
         DC    AL1(CStgtlof),AL1(mdlcf37c+02-mdlcf37) TARGET    OFFSET
         DC    AL1(CSbytmsk),AL1(mdlcf37c+01-mdlcf37) TARGET    OFFSET
         DC    AL1(CSdfpexp),AL1(MDLcf37e+02-MDLcf37) dfp exp
         DC    AL1(CSRELOPR),AL1(mdlcf37F+1-mdlcf37)  RELATIONAL CC
         DC    AL1(CSFALSEO),AL1(mdlcf37F+2-mdlcf37)  FALSE  BRANCH
         DC    AL1(CSTRUEO),AL1(mdlcf37T+2-mdlcf37)   TRUE   BRANCH
         DC   2XL1'FF'
                        SPACE 3
mdlcf37_b8  LG   R4,0(,0)
         cxgtr fp1,r4             convert from fixed to DFP
MDLcf37_b8e lghi  r15,*-*            Create biased exponent
         iextr fp1,fp1,r15       and insert
mdlcf37_b8s llgt R5,0(,R2)        load logic table row address
         LA    R1,workar2
mdlcf37_b8bb BAS  R10,*-*            CALL "GVBDL96"  (FORMAT  FIELD)
mdlcf37_b8A jlu *+l'*             FORMAT UNSUCCESSFUL BRANCH (FALSE)
*        do NOT use R14 here as it gets NOPed out
         ld    fp4,workar2        load first operand into fp4/6
         ld    fp6,workar2+8
         cxtr  fp4,fp1            COMPARE TWO  FIELDS
mdlcf37_b8F jlu *+l'*             BRANCH  TO   FALSE IF  NOT TRUE
mdlcf37_b8T jlu *+l'*             BRANCH  TO   TRUE (OPTIONAL)
mdlcf37_b8L EQU *-mdlcf37_b8
*
mdlcf37_b8P EQU 4                 LITERAL POOL USAGE (EXCL FIELD LEN)
*
mdlcf37_b8r dc AL1(CStgtlof),AL1(mdlcf37_b8+02-mdlcf37_b8) TARGET OFF
         DC    AL1(CSltroff),AL1(mdlcf37_b8s+02-mdlcf37_b8) TARGET OFF
         DC    AL1(CSdl96calln),AL1(MDLcf37_b8bb-MDLcf37_b8)  MR96 BAS
         DC    AL1(CSFALSEO),AL1(mdlcf37_b8A+2-mdlcf37_b8) FALSE BRANCH
         DC    AL1(CSdfpexp),AL1(MDLcf37_b8e+02-MDLcf37_b8) dfp exp
         DC    AL1(CSRELOPR),AL1(mdlcf37_b8F+1-mdlcf37_b8) REL CC
         DC    AL1(CSFALSEO),AL1(mdlcf37_b8F+2-mdlcf37_b8) FALSE BR
         DC    AL1(CSTRUEO),AL1(mdlcf37_b8T+2-mdlcf37_b8) TRUE BR
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        COMPARE FIELDS           (pack    - BCD)                     *
***********************************************************************
mdlcf10  LAY R15,0(0,0)           get address
mdlcf10_la LAY R14,0(0,0)         get address
         MVI   WORKAR2+L'WORKAR2-1,X'0F' ADD SIGN NIBBLE 'F'
mdlcf10Q MVO   WORKAR2,0(0,r15)   CONVERT BCD TO UNSIGNED PACKED
         lmg   r0,r1,workar2
         cxstr fp1,r0             convert to dfp
MDLcf10d lghi  r15,*-*            Create biased exponent
         iextr fp1,fp1,r15       and insert
mdlcf10c zap   WORKAR2,0(0,r14)  COMPARE TWO  FIELDS
         lmg   r0,r1,workar2
         cxstr fp4,r0             convert to dfp
MDLcf10e lghi  r15,*-*            Create biased exponent
         iextr fp4,fp4,r15       and insert
         cxtr  fp1,fp4           COMPARE TWO  FIELDS
mdlcf10F jlu   *+l'*              BRANCH  TO   FALSE IF  NOT TRUE
mdlcf10T jlu   *+l'*              BRANCH  TO   TRUE (OPTIONAL)
mdlcf10L EQU   *-mdlcf10
*
mdlcf10P EQU   0                  LITERAL POOL USAGE (EXCL FIELD LEN)
*
mdlcf10R DC    AL1(CSSRClof),AL1(mdlcf10+02-mdlcf10)  FIELD  1  OFF
         DC    AL1(CStgtlof),AL1(mdlcf10_lA+02-mdlcf10) FIELD  2  OFF
         DC    AL1(CSSRCLNr),AL1(mdlcf10Q+01-mdlcf10) FIELD  2  LEN L/2
         DC    AL1(CSdfpexps),AL1(MDLcf10d+02-MDLcf10) dfp exp
         DC    AL1(CStgtLNr),AL1(mdlcf10c+01-mdlcf10) FIELD  2  LEN L/2
         DC    AL1(CSdfpexp),AL1(MDLcf10e+02-MDLcf10) dfp exp
         DC    AL1(CSRELOPR),AL1(mdlcf10F+1-mdlcf10)  RELATIONAL CC
         DC    AL1(CSFALSEO),AL1(mdlcf10F+2-mdlcf10)  FALSE  BRANCH
         DC    AL1(CSTRUEO),AL1(mdlcf10T+2-mdlcf10)   TRUE   BRANCH
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        COMPARE FIELDS           (pack    - BCD)                     *
***********************************************************************
mdlcf56  LAY R15,0(0,0)           get address
mdlcf56_la LAY R14,0(0,0)         get address
         MVI   WORKAR2+L'WORKAR2-1,X'0F' ADD SIGN NIBBLE 'F'
mdlcf56Q MVO   WORKAR2,0(0,r15)   CONVERT BCD TO UNSIGNED PACKED
         lmg   r0,r1,workar2
         cxstr fp1,r0             convert to dfp
MDLcf56d lghi  r15,*-*            Create biased exponent
         iextr fp1,fp1,r15       and insert
mdlcf56c zap   WORKAR2,0(0,r14)  COMPARE TWO  FIELDS
         lmg   r0,r1,workar2
         cxstr fp4,r0             convert to dfp
MDLcf56e lghi  r15,*-*            Create biased exponent
         iextr fp4,fp4,r15       and insert
         cxtr  fp4,fp1           COMPARE TWO  FIELDS
mdlcf56F jlu   *+l'*              BRANCH  TO   FALSE IF  NOT TRUE
mdlcf56T jlu   *+l'*              BRANCH  TO   TRUE (OPTIONAL)
mdlcf56L EQU   *-mdlcf56
*
mdlcf56P EQU   0                  LITERAL POOL USAGE (EXCL FIELD LEN)
*
mdlcf56R DC    AL1(CStgtlof),AL1(mdlcf56+02-mdlcf56)  FIELD  1  OFF
         DC    AL1(CSsrclof),AL1(mdlcf56_lA+02-mdlcf56) FIELD  2  OFF
         DC    AL1(CStgtLNr),AL1(mdlcf56Q+01-mdlcf56) FIELD  2  LEN L/2
         DC    AL1(CSsrcLNr),AL1(mdlcf56c+01-mdlcf56) FIELD  2  LEN L/2
         DC    AL1(CSdfpexp),AL1(MDLcf56d+02-MDLcf56) dfp exp
         DC    AL1(CSdfpexps),AL1(MDLcf56e+02-MDLcf56) dfp exp
         DC    AL1(CSRELOPR),AL1(mdlcf56F+1-mdlcf56)  RELATIONAL CC
         DC    AL1(CSFALSEO),AL1(mdlcf56F+2-mdlcf56)  FALSE  BRANCH
         DC    AL1(CSTRUEO),AL1(mdlcf56T+2-mdlcf56)   TRUE   BRANCH
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        COMPARE FIELDS           (BINARY - PACKED)                   *
***********************************************************************
MDLcf11u Xgr   R0,R0              CONVERT BINARY FIELD
MDLcf11u_la LAY R15,0(0,0)        get address
MDLcf11uA ICMY R0,B'0000',0(0)
         cxgtr fp4,r0
MDLcf11ud lghi  r14,*-*            Create biased exponent
         iextr fp4,fp4,r14       and insert
mdlcf11uc zap   workarea,0(0,r15)
         lmg   r0,r1,workarea
         cxstr fp1,r0
MDLcf11ue lghi  r15,*-*            Create biased exponent
         iextr fp1,fp1,r15       and insert
          cxtr fp4,fp1            COMPARE TWO  FIELDS
MDLcf11uF jlu  *+l'*              BRANCH  TO   FALSE  IF NOT TRUE
MDLcf11uT jlu  *+l'*              BRANCH  TO   TRUE  (OPTIONAL)
MDLcf11uL EQU  *-MDLcf11u
*
MDLcf11uP EQU  0                  LITERAL POOL USAGE (EXCL FIELD LEN)
*
MDLcf11uR  DC  AL1(CSBYTMSS),AL1(MDLcf11uA+01-MDLcf11u) BYTE    MASK
         DC    AL1(CSSRCloF),AL1(MDLcf11uA+02-MDLcf11u) FIELD 1 OFFSET
         DC    AL1(CSdfpexps),AL1(MDLcf11ud+02-MDLcf11u) dfpexp
         DC    AL1(CStgtlof),AL1(MDLcf11u_lA+02-MDLcf11u) FIELD 1 OFF
         DC    AL1(CSdfpexp),AL1(MDLcf11ue+02-MDLcf11u) dfpexp
         DC    AL1(CSTGTLNR),AL1(MDLcf11uc+01-MDLcf11u) FIELD 2 LEN R/2
         DC    AL1(CSRELOPR),AL1(MDLcf11uF+1-MDLcf11u) RELATIONAL CC
         DC    AL1(CSFALSEO),AL1(MDLcf11uF+2-MDLcf11u) FALSE BRANCH
         DC    AL1(CSTRUEO),AL1(MDLcf11uT+2-MDLcf11u) TRUE   BRANCH
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        COMPARE FIELDS           (BINARY - PACKED)                   *
***********************************************************************
MDLCF11  XgR    R0,R0              CONVERT BINARY FIELD
MDLcf11_la LAY R15,0(0,0)         get address
MDLCF11S TMY   0(0),X'80'
         if (o)
           lghi r0,-1              fill with 1's
         endif
MDLCF11A ICMY  R0,B'0000',0(0)
         cxgtr fp4,r0
MDLcf11d lghi  r14,*-*            Create biased exponent
         iextr fp4,fp4,r14        and insert
mdlcf11b zap   workarea,0(0,r15)
         lmg   r0,r1,workarea
         cxstr fp1,r0
MDLcf11e lghi  r15,*-*            Create biased exponent
         iextr fp1,fp1,r15       and insert
         cxtr  fp4,fp1            COMPARE TWO  FIELDS
MDLCF11F jlu   *+l'*              BRANCH  TO   FALSE  IF NOT TRUE
MDLCF11T jlu   *+l'*              BRANCH  TO   TRUE  (OPTIONAL)
MDLCF11L EQU   *-MDLCF11
*
MDLCF11P EQU   0                  LITERAL POOL USAGE (EXCL FIELD LEN)
*
MDLCF11R DC    AL1(CSSRCloF),AL1(MDLCF11S+02-MDLCF11) FIELD  1  OFFSET
         DC    AL1(CSBYTMSS),AL1(MDLCF11A+01-MDLCF11) BYTE      MASK
         DC    AL1(CSSRCloF),AL1(MDLCF11A+02-MDLCF11) FIELD  1  OFFSET
         DC    AL1(CSdfpexps),AL1(MDLcf11d+02-MDLcf11) dfpexp
         DC    AL1(CSdfpexp),AL1(MDLcf11e+02-MDLcf11)  dfpexp
         DC    AL1(CStgtlof),AL1(MDLcf11_lA+02-MDLcf11) FIELD  1  OFF
         DC    AL1(CSTGTLNR),AL1(MDLCF11B+01-MDLCF11) FIELD  2  LEN R/2
         DC    AL1(CSRELOPR),AL1(MDLCF11F+1-MDLCF11)  RELATIONAL CC
         DC    AL1(CSFALSEO),AL1(MDLCF11F+2-MDLCF11)  FALSE  BRANCH
         DC    AL1(CSTRUEO),AL1(MDLCF11T+2-MDLCF11)   TRUE   BRANCH
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        COMPARE FIELDS           (BINARY 8 - PACKED)                 *
***********************************************************************
mdlcf11_b8 LG  R0,0(0,0)          CONVERT BINARY FIELD
         cxgtr fp4,r0
MDLcf11_b8d lghi  r14,*-*            Create biased exponent
         iextr fp4,fp4,r14        and insert
MDLcf11_b8la LAY R15,0(0,0)         get address
mdlcf11_b8b zap   workarea,0(0,r15)
         lmg   r0,r1,workarea
         cxstr fp1,r0
MDLcf11_b8e lghi  r15,*-*            Create biased exponent
         iextr fp1,fp1,r15       and insert
         cxtr  fp4,fp1            COMPARE TWO  FIELDS
mdlcf11_b8F jlu *+l'*             BRANCH  TO   FALSE  IF NOT TRUE
mdlcf11_b8T jlu *+l'*             BRANCH  TO   TRUE  (OPTIONAL)
mdlcf11_b8L EQU *-mdlcf11_b8
*
mdlcf11_b8P EQU 0                 LITERAL POOL USAGE (EXCL FIELD LEN)
*
mdlcf11_b8R ds 0h
         DC    AL1(CSsrclof),AL1(mdlcf11_b8+02-mdlcf11_b8) FIELD 1 OFF
         DC    AL1(CSdfpexps),AL1(MDLcf11_b8d+02-MDLcf11_b8) dfpexp
         DC    AL1(CStgtlof),AL1(MDLcf11_b8lA+02-MDLcf11_b8) FLD 1 OFF
         DC    AL1(CSTGTLNR),AL1(mdlcf11_b8B+01-mdlcf11_b8) FLD 2 L R/2
         DC    AL1(CSdfpexp),AL1(MDLcf11_b8e+02-MDLcf11_b8)  dfpexp
         DC    AL1(CSRELOPR),AL1(mdlcf11_b8F+1-mdlcf11_b8) REL. CC
         DC    AL1(CSFALSEO),AL1(mdlcf11_b8F+2-mdlcf11_b8) FALSE BRANCH
         DC    AL1(CSTRUEO),AL1(mdlcf11_b8T+2-mdlcf11_b8) TRUE BRANCH
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        COMPARE FIELDS           (BINARY - NUMERIC)                  *
***********************************************************************
MDLcf12u XGR   R0,R0              CONVERT BINARY FIELD
MDLcf12u_la LAY R15,0(0,0)        get address
MDLcf12uA ICMy R0,B'0000',0(0)
         cxgtr fp4,r0
MDLcf12ud lghi r14,*-*            Create biased exponent
         iextr fp4,fp4,r14        and insert
MDLcf12uB PACK WORKAREA,0(0,r15) CONVERT NUMERIC
         lmg   r0,r1,workarea
         cxstr fp1,r0
MDLcf12ue lghi r15,*-*            Create biased exponent
         iextr fp1,fp1,r15       and insert
         cxtr  fp4,fp1            COMPARE TWO FIELDS
MDLcf12uF jlu  *+l'*              BRANCH  TO   FALSE  IF NOT TRUE
MDLcf12uT jlu  *+l'*              BRANCH  TO   TRUE  (OPTIONAL)
MDLcf12uL EQU  *-MDLcf12u
*
MDLcf12uP EQU  0                  LITERAL POOL USAGE (EXCL FIELD LEN)
*
MDLcf12uR  dc  AL1(CSBYTMSS),AL1(MDLcf12uA+01-MDLcf12u) BYTE    MASK
         DC    AL1(CSSRClof),AL1(MDLcf12uA+02-MDLcf12u) FIELD 1 OFFSET
         DC    AL1(CSdfpexps),AL1(MDLcf12ud+02-MDLcf12u) FIELD 1 OFFSET
         DC    AL1(CStgtlof),AL1(MDLcf12u_lA+02-MDLcf12u) FIELD 1 OFF
         DC    AL1(CSTGTLNR),AL1(MDLcf12uB+01-MDLcf12u) FIELD 2 LEN R/2
         DC    AL1(CSdfpexp),AL1(MDLcf12ue+02-MDLcf12u) FIELD 1 OFFSET
         DC    AL1(CSRELOPR),AL1(MDLcf12uF+1-MDLcf12u) RELATIONAL CC
         DC    AL1(CSFALSEO),AL1(MDLcf12uF+2-MDLcf12u) FALSE BRANCH
         DC    AL1(CSTRUEO),AL1(MDLcf12uT+2-MDLcf12u) TRUE   BRANCH
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        COMPARE FIELDS           (BINARY - NUMERIC)                  *
***********************************************************************
MDLCF12  XgR    R0,R0              CONVERT BINARY FIELD
MDLcf12_la LAY R15,0(0,0)         get address
MDLCF12S TMy   0(0),X'80'
         if (o)
           lghi r0,-1              fill with 1's
         endif
MDLCF12A ICMy  R0,B'0000',0(0)
         cxgtr fp4,r0
MDLcf12d lghi  r14,*-*            Create biased exponent
         iextr fp4,fp4,r14        and insert
MDLCF12B PACK  WORKAREA,0(0,r15) CONVERT NUMERIC
         lmg   r0,r1,workarea
         cxstr fp1,r0
MDLcf12e lghi  r15,*-*            Create biased exponent
         iextr fp1,fp1,r15       and insert
         cxtr  fp4,fp1            COMPARE TWO  FIELDS
MDLCF12F jlu   *+l'*              BRANCH  TO   FALSE  IF NOT TRUE
MDLCF12T jlu   *+l'*              BRANCH  TO   TRUE  (OPTIONAL)
MDLCF12L EQU   *-MDLCF12
*
MDLCF12P EQU   0                  LITERAL POOL USAGE (EXCL FIELD LEN)
*
MDLCF12R DC    AL1(CSSRClof),AL1(MDLCF12S+02-MDLCF12) FIELD  1  OFFSET
         DC    AL1(CSBYTMSS),AL1(MDLCF12A+01-MDLCF12) BYTE      MASK
         DC    AL1(CSSRClof),AL1(MDLCF12A+02-MDLCF12) FIELD  1  OFFSET
         DC    AL1(CStgtlof),AL1(MDLcf12_lA+02-MDLcf12) FIELD  1  OFF
         DC    AL1(CSTGTLNR),AL1(MDLCF12B+01-MDLCF12) FIELD  2  LEN R/2
         DC    AL1(CSRELOPR),AL1(MDLCF12F+1-MDLCF12)  RELATIONAL CC
         DC    AL1(CSFALSEO),AL1(MDLCF12F+2-MDLCF12)  FALSE  BRANCH
         DC    AL1(CSTRUEO),AL1(MDLCF12T+2-MDLCF12)   TRUE   BRANCH
         DC    AL1(CSdfpexps),AL1(MDLcf12d+02-MDLcf12) dfpexp
         DC    AL1(CSdfpexp),AL1(MDLcf12e+02-MDLcf12)   dfpexp
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        COMPARE FIELDS           (BINARY 8 - NUMERIC)                *
***********************************************************************
mdlcf12_b8 LG  R0,0(0,0)          CONVERT BINARY FIELD
MDLcf12_b8la LAY R15,0(0,0)         get address
         cxgtr fp4,r0
MDLcf12_b8d lghi  r14,*-*            Create biased exponent
         iextr fp4,fp4,r14        and insert
mdlcf12_b8B PACK WORKAREA,0(0,r15) CONVERT NUMERIC
         lmg   r0,r1,workarea
         cxstr fp1,r0
MDLcf12_b8e lghi  r15,*-*            Create biased exponent
         iextr fp1,fp1,r15       and insert
         cxtr  fp4,fp1            COMPARE TWO  FIELDS
mdlcf12_b8F jlu *+l'*             BRANCH  TO   FALSE  IF NOT TRUE
mdlcf12_b8T jlu *+l'*             BRANCH  TO   TRUE  (OPTIONAL)
mdlcf12_b8L EQU *-mdlcf12_b8
*
mdlcf12_b8P EQU 0                 LITERAL POOL USAGE (EXCL FIELD LEN)
*
mdlcf12_b8R DC AL1(CSSRCLOF),AL1(mdlcf12_b8+02-MDLCF12_b8)  FIELD 1 OFF
         DC    AL1(CStgtlof),AL1(MDLcf12_b8lA+02-MDLcf12_b8) FLD 1 OFF
         DC    AL1(CSTGTLNR),AL1(MDLCF12_b8B+01-MDLCF12_b8) FLD 2 LEN R
         DC    AL1(CSdfpexps),AL1(MDLcf12_b8d+02-MDLcf12_b8) dfpexp
         DC    AL1(CSdfpexp),AL1(MDLcf12_b8e+02-MDLcf12_b8)   dfpexp
         DC    AL1(CSRELOPR),AL1(mdlcf12_b8F+1-MDLCF12_b8) RELATION CC
         DC    AL1(CSFALSEO),AL1(mdlcf12_b8F+2-mdlcf12_b8) FALSE BRANCH
         DC    AL1(CSTRUEO),AL1(mdlcf12_b8T+2-mdlcf12_b8) TRUE BRANCH
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        COMPARE FIELDS           (BINARY - BINARY)                   *
***********************************************************************
MDLcf13uu Xgr  R0,R0              CONVERT BINARY FIELD
         Xgr   R15,R15            CONVERT BINARY FIELD
MDLcf13uuA ICMy R0,B'0000',0(0)
         cxgtr fp4,r0
MDLcf13uud lghi  r14,*-*            Create biased exponent
         iextr fp4,fp4,r14        and insert
MDLcf13uuB ICMy R15,B'0000',0(0)
         cxgtr fp1,r15
MDLcf13uue lghi  r14,*-*            Create biased exponent
         iextr fp1,fp1,r14        and insert
         cxtr fp4,fp1            COMPARE TWO  FIELDS
MDLcf13uuF jlu *+l'*              BRANCH  TO   FALSE  IF NOT TRUE
MDLcf13uuT jlu *+l'*              BRANCH  TO   TRUE  (OPTIONAL)
MDLcf13uuL EQU *-MDLcf13uu
*
MDLcf13uuP EQU 0                  LITERAL POOL USAGE (EXCL FIELD LEN)
*
MDLcf13uuR dc  AL1(CSBYTMSS),AL1(MDLcf13uuA+01-MDLcf13uu) BYTE  MASK
         DC    AL1(CSSRCloF),AL1(MDLcf13uuA+02-MDLCF13uu) FIELD 1 OFF
         DC    AL1(CSdfpexps),AL1(MDLcf13uud+02-MDLcf13uu) dfpexp
         DC    AL1(CSBYTMSK),AL1(MDLcf13uuB+01-MDLcf13uu) BYTE  MASK
         DC    AL1(CSTGTloF),AL1(MDLcf13uuB+02-MDLCF13uu) FIELD 2 OFF
         DC    AL1(CSdfpexp),AL1(MDLcf13uue+02-MDLcf13uu)   dfpexp
         DC    AL1(CSRELOPR),AL1(MDLcf13uuF+1-MDLcf13uu) RELATIONAL CC
         DC    AL1(CSFALSEO),AL1(MDLcf13uuF+2-MDLcf13uu) FALSE BRANCH
         DC    AL1(CSTRUEO),AL1(MDLcf13uuT+2-MDLcf13uu) TRUE BRANCH
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        COMPARE FIELDS           (BINARY - BINARY8)                  *
***********************************************************************
MDLcf13uu_b8 XgR R0,R0             CONVERT BINARY FIELD
MDLcf13uu_b8A ICMy R0,B'0000',0(0)
         cxgtr fp4,r0
MDLcf13uu_b8d lghi  r14,*-*            Create biased exponent
         iextr fp4,fp4,r14        and insert
MDLcf13uu_b8B LG R15,0(0,0)
         cxgtr fp1,r15
MDLcf13uu_b8e lghi  r14,*-*            Create biased exponent
         iextr fp1,fp1,r14        and insert
         cxtr fp4,fp1            COMPARE TWO  FIELDS
MDLcf13uu_b8F jlu *+l'*           BRANCH  TO   FALSE  IF NOT TRUE
MDLcf13uu_b8T jlu *+l'*           BRANCH  TO   TRUE  (OPTIONAL)
MDLcf13uu_b8L EQU *-MDLcf13uu_b8
*
MDLcf13uu_b8P EQU 0               LITERAL POOL USAGE (EXCL FIELD LEN)
*
MDLcf13uu_b8R DC AL1(CSBYTMSS),AL1(MDLcf13uu_b8A+01-MDLcf13uu_b8) MASK
         DC    AL1(CSSRCloF),AL1(MDLcf13uu_b8A+02-MDLcf13uu_b8) F1 OFF
         DC    AL1(CSdfpexps),AL1(MDLcf13uu_b8d+02-MDLcf13uu_b8) dfpexp
         DC    AL1(CSTGTloF),AL1(MDLcf13uu_b8B+02-MDLcf13uu_b8) F2 OFF
         DC    AL1(CSdfpexp),AL1(MDLcf13uu_b8e+02-MDLcf13uu_b8)  dfpexp
         DC    AL1(CSRELOPR),AL1(MDLcf13uu_b8F+1-MDLcf13uu_b8) REL CC
         DC    AL1(CSFALSEO),AL1(MDLcf13uu_b8F+2-MDLcf13uu_b8) FALSE BR
         DC    AL1(CSTRUEO),AL1(MDLcf13uu_b8T+2-MDLcf13uu_b8) TRUE BR
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        COMPARE FIELDS           (BINARY8 - BINARY)                  *
***********************************************************************
MDLcf13uu_8b LG R0,0(0,0)          CONVERT BINARY FIELD
         xgr r15,r15
MDLcf13uu_8bA ICMy R15,B'0000',0(0)
         cxgtr fp1,r15
MDLcf13uu_8bd lghi  r14,*-*            Create biased exponent
         iextr fp1,fp1,r14        and insert
         cxgtr fp4,r0
MDLcf13uu_8be lghi  r14,*-*            Create biased exponent
         iextr fp4,fp4,r14        and insert
         cxtr fp4,fp1            COMPARE TWO  FIELDS
MDLcf13uu_8bF jlu *+l'*           BRANCH  TO   FALSE  IF NOT TRUE
MDLcf13uu_8bT jlu *+l'*           BRANCH  TO   TRUE  (OPTIONAL)
MDLcf13uu_8bL EQU *-MDLcf13uu_8b
*
MDLcf13uu_8bP EQU 0               LITERAL POOL USAGE (EXCL FIELD LEN)
*
MDLcf13uu_8bR DC AL1(CSSRCloF),AL1(MDLcf13uu_8b+02-MDLCF13uu_8b) F1 OFF
         DC    AL1(CSdfpexps),AL1(MDLcf13uu_8be+02-MDLcf13uu_8b) dfpexp
         DC    AL1(CSBYTMSK),AL1(MDLcf13uu_8bA+01-MDLcf13uu_8b) MASK
         DC    AL1(CStgtloF),AL1(MDLcf13uu_8bA+02-MDLcf13uu_8b) F1 OFF
         DC    AL1(CSdfpexp),AL1(MDLcf13uu_8bd+02-MDLcf13uu_8b)  dfpexp
         DC    AL1(CSRELOPR),AL1(MDLcf13uu_8bF+1-MDLcf13uu_8b) REL CC
         DC    AL1(CSFALSEO),AL1(MDLcf13uu_8bF+2-MDLcf13uu_8b) FALSE BR
         DC    AL1(CSTRUEO),AL1(MDLcf13uu_8bT+2-MDLcf13uu_8b) TRUE BR
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        COMPARE FIELDS           (BINARY - BINARY)                   *
***********************************************************************
MDLcf13su Xgr  R0,R0              CONVERT BINARY FIELD
MDLcf13suA ICMy R0,B'0000',0(0)
         cxgtr fp4,r0
MDLcf13sud lghi  r14,*-*            Create biased exponent
         iextr fp4,fp4,r14        and insert
         Xgr   R15,R15            CONVERT BINARY FIELD
MDLcf13suI TMy 0(0),X'80'
         if (o)
           lghi r15,-1            fill with 1's
         endif
MDLcf13suB ICMy R15,B'0000',0(0)
         cxgtr fp1,r15
MDLcf13sue lghi  r14,*-*            Create biased exponent
         iextr fp1,fp1,r14        and insert
         cxtr fp4,fp1            COMPARE TWO  FIELDS
MDLcf13suF jlu *+l'*              BRANCH  TO   FALSE  IF NOT TRUE
MDLcf13suT jlu *+l'*              BRANCH  TO   TRUE  (OPTIONAL)
MDLcf13suL EQU *-MDLcf13su
*
MDLcf13suP EQU 0                  LITERAL POOL USAGE (EXCL FIELD LEN)
*
MDLcf13suR DC  AL1(CSBYTMSS),AL1(MDLcf13suA+01-MDLcf13su) BYTE  MASK
         DC    AL1(CSSRCloF),AL1(MDLcf13suA+02-MDLcf13su) FIELD 1 OFF
         DC    AL1(CSdfpexps),AL1(MDLcf13sud+02-MDLcf13su) dfpexp
         DC    AL1(CSTGTloF),AL1(MDLcf13suI+02-MDLcf13su) FIELD 2 OFF
         DC    AL1(CSdfpexp),AL1(MDLcf13sue+02-MDLcf13su)  dfpexp
         DC    AL1(CSBYTMSK),AL1(MDLcf13suB+01-MDLcf13su) BYTE  MASK
         DC    AL1(CSTGTloF),AL1(MDLcf13suB+02-MDLcf13su) FIELD 2 OFF
         DC    AL1(CSRELOPR),AL1(MDLcf13suF+1-MDLcf13su) RELATIONAL CC
         DC    AL1(CSFALSEO),AL1(MDLcf13suF+2-MDLcf13su) FALSE BRANCH
         DC    AL1(CSTRUEO),AL1(MDLcf13suT+2-MDLcf13su) TRUE BRANCH
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        COMPARE FIELDS           (BINARY - BINARY8)                  *
***********************************************************************
MDLcf13su_b8 XgR R0,R0             CONVERT BINARY FIELD
MDLcf13su_b8A ICMy R0,B'0000',0(0)
         cxgtr fp4,r0
MDLcf13su_b8d lghi  r14,*-*            Create biased exponent
         iextr fp4,fp4,r14        and insert
MDLcf13su_b8B LG R15,0(0,0)
         cxgtr fp1,r15
MDLcf13su_b8e lghi  r14,*-*            Create biased exponent
         iextr fp1,fp1,r14        and insert
         cxtr fp4,fp1            COMPARE TWO  FIELDS
MDLcf13su_b8F jlu *+l'*           BRANCH  TO   FALSE  IF NOT TRUE
MDLcf13su_b8T jlu *+l'*           BRANCH  TO   TRUE  (OPTIONAL)
MDLcf13su_b8L EQU *-MDLcf13su_b8
*
MDLcf13su_b8P EQU 0               LITERAL POOL USAGE (EXCL FIELD LEN)
*
MDLcf13su_b8R DC AL1(CSBYTMSS),AL1(MDLcf13su_b8A+01-MDLcf13su_b8) MASK
         DC    AL1(CSSRCloF),AL1(MDLcf13su_b8A+02-MDLcf13su_b8) F 1 OFF
         DC    AL1(CSdfpexps),AL1(MDLcf13su_b8d+02-MDLcf13su_b8) dfpexp
         DC    AL1(CSTGTloF),AL1(MDLcf13su_b8B+02-MDLcf13su_b8) F 2 OFF
         DC    AL1(CSdfpexp),AL1(MDLcf13su_b8e+02-MDLcf13su_b8)  dfpexp
         DC    AL1(CSRELOPR),AL1(MDLcf13su_b8F+1-MDLcf13su_b8) REL CC
         DC    AL1(CSFALSEO),AL1(MDLcf13su_b8F+2-MDLcf13su_b8) FALSE BR
         DC    AL1(CSTRUEO),AL1(MDLcf13su_b8T+2-MDLcf13su_b8) TRUE BR
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        COMPARE FIELDS           (BINARY8 - BINARY)                  *
***********************************************************************
MDLcf13su_8b LG R0,0(0,0)          CONVERT BINARY FIELD
         cxgtr fp4,r0
MDLcf13su_8bd lghi  r14,*-*            Create biased exponent
         iextr fp4,fp4,r14        and insert
         xgr r15,r15
MDLcf13su_8bS TMy 0(0),X'80'
         if (o)
           lghi r15,-1              fill with 1's
         endif
MDLcf13su_8bA ICMy R15,B'0000',0(0)
         cxgtr fp1,r15
MDLcf13su_8be lghi  r14,*-*            Create biased exponent
         iextr fp1,fp1,r14        and insert
         cxtr fp4,fp1            COMPARE TWO  FIELDS
MDLcf13su_8bF jlu *+l'*           BRANCH  TO   FALSE  IF NOT TRUE
MDLcf13su_8bT jlu *+l'*           BRANCH  TO   TRUE  (OPTIONAL)
MDLcf13su_8bL EQU *-MDLcf13su_8b
*
MDLcf13su_8bP EQU 0               LITERAL POOL USAGE (EXCL FIELD LEN)
*
MDLcf13su_8bR DC AL1(CSSRCloF),AL1(MDLcf13su_8b+02-MDLcf13su_8b) F1 OFF
         DC    AL1(CSdfpexps),AL1(MDLcf13su_8bd+02-MDLcf13su_8b) dfpexp
         DC    AL1(CSTGTloF),AL1(MDLcf13su_8bS+02-MDLcf13su_8b) F2 OFF
         DC    AL1(CSBYTMSK),AL1(MDLcf13su_8bA+01-MDLcf13su_8b) MASK
         DC    AL1(CStgtloF),AL1(MDLcf13su_8bA+02-MDLcf13su_8b) F1 OFF
         DC    AL1(CSdfpexp),AL1(MDLcf13su_8be+02-MDLcf13su_8b)  dfpexp
         DC    AL1(CSRELOPR),AL1(MDLcf13su_8bF+1-MDLcf13su_8b) REL CC
         DC    AL1(CSFALSEO),AL1(MDLcf13su_8bF+2-MDLcf13su_8b) FALSE BR
         DC    AL1(CSTRUEO),AL1(MDLcf13su_8bT+2-MDLcf13su_8b) TRUE BR
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        COMPARE FIELDS           (BINARY - BINARY)                   *
***********************************************************************
MDLcf13us Xgr  R0,R0              CONVERT BINARY FIELD
MDLcf13usI TMy 0(0),X'80'
         if (o)
           lghi r0,-1            fill with 1's
         endif
MDLcf13usA ICMy R0,B'0000',0(0)
         cxgtr fp4,r0
MDLcf13usd lghi  r14,*-*            Create biased exponent
         iextr fp4,fp4,r14        and insert
         Xgr   R15,R15            CONVERT BINARY FIELD
MDLcf13usB ICMy R15,B'0000',0(0)
         cxgtr fp1,r15
MDLcf13use lghi  r14,*-*            Create biased exponent
         iextr fp1,fp1,r14        and insert
         cxtr fp4,fp1            COMPARE TWO  FIELDS
MDLcf13usF jlu *+l'*              BRANCH  TO   FALSE  IF NOT TRUE
MDLcf13usT jlu *+l'*              BRANCH  TO   TRUE  (OPTIONAL)
MDLcf13usL EQU *-MDLcf13us
*
MDLcf13usP EQU 0                  LITERAL POOL USAGE (EXCL FIELD LEN)
*
MDLcf13usR DC  AL1(CSBYTMSS),AL1(MDLcf13usA+01-MDLcf13us) BYTE  MASK
         DC    AL1(CSSRCloF),AL1(MDLcf13usA+02-MDLcf13us) FIELD 1 OFF
         DC    AL1(CSsrcloF),AL1(MDLcf13usI+02-MDLcf13us) FIELD 2 OFF
         DC    AL1(CSdfpexps),AL1(MDLcf13usd+02-MDLcf13us) dfpexp
         DC    AL1(CSBYTMSK),AL1(MDLcf13usB+01-MDLcf13us) BYTE  MASK
         DC    AL1(CSTGTloF),AL1(MDLcf13usB+02-MDLcf13us) FIELD 2 OFF
         DC    AL1(CSdfpexp),AL1(MDLcf13use+02-MDLcf13us)  dfpexp
         DC    AL1(CSRELOPR),AL1(MDLcf13usF+1-MDLcf13us) RELATIONAL CC
         DC    AL1(CSFALSEO),AL1(MDLcf13usF+2-MDLcf13us) FALSE BRANCH
         DC    AL1(CSTRUEO),AL1(MDLcf13usT+2-MDLcf13us) TRUE BRANCH
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        COMPARE FIELDS           (BINARY - BINARY8)                  *
***********************************************************************
MDLcf13us_b8 XgR R0,R0             CONVERT BINARY FIELD
MDLCF13us_b8S TMy 0(0),X'80'
         if (o)
           lghi r0,-1            fill with 1's
         endif
MDLcf13us_b8A ICMy R0,B'0000',0(0)
         cxgtr fp4,r0
MDLcf13us_b8d lghi  r14,*-*            Create biased exponent
         iextr fp4,fp4,r14        and insert
MDLcf13us_b8B LG R15,0(0,0)
         cxgtr fp1,r15
MDLcf13us_b8e lghi  r14,*-*            Create biased exponent
         iextr fp1,fp1,r14        and insert
         cxtr fp4,fp1            COMPARE TWO  FIELDS
MDLcf13us_b8F jlu *+l'*           BRANCH  TO   FALSE  IF NOT TRUE
MDLcf13us_b8T jlu *+l'*           BRANCH  TO   TRUE  (OPTIONAL)
MDLcf13us_b8L EQU *-MDLcf13us_b8
*
MDLcf13us_b8P EQU 0               LITERAL POOL USAGE (EXCL FIELD LEN)
*
MDLcf13us_b8R DC AL1(CSBYTMSS),AL1(MDLcf13us_b8A+01-MDLcf13us_b8) MASK
         DC    AL1(CSSRCloF),AL1(MDLcf13us_b8A+02-MDLcf13us_b8) F 1 OFF
         DC    AL1(CSSRCloF),AL1(MDLcf13us_b8s+02-MDLcf13us_b8) F 1 OFF
         DC    AL1(CSdfpexps),AL1(MDLcf13us_b8d+02-MDLcf13us_b8) dfpexp
         DC    AL1(CSTGTloF),AL1(MDLcf13us_b8B+02-MDLcf13us_b8) F 2 OFF
         DC    AL1(CSdfpexp),AL1(MDLcf13us_b8e+02-MDLcf13us_b8)  dfpexp
         DC    AL1(CSRELOPR),AL1(MDLcf13us_b8F+1-MDLcf13us_b8) REL CC
         DC    AL1(CSFALSEO),AL1(MDLcf13us_b8F+2-MDLcf13us_b8) FALSE BR
         DC    AL1(CSTRUEO),AL1(MDLcf13us_b8T+2-MDLcf13us_b8) TRUE BR
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        COMPARE FIELDS           (BINARY8 - BINARY)                  *
***********************************************************************
MDLcf13us_8b LG R0,0(0,0)          CONVERT BINARY FIELD
         cxgtr fp4,r0
MDLcf13us_8bd lghi  r14,*-*            Create biased exponent
         iextr fp4,fp4,r14        and insert
         xgr r15,r15
MDLcf13us_8bA ICMy R15,B'0000',0(0)
         cxgtr fp1,r15
MDLcf13us_8be lghi  r14,*-*            Create biased exponent
         iextr fp1,fp1,r14        and insert
         cxtr fp4,fp1            COMPARE TWO  FIELDS
MDLcf13us_8bF jlu *+l'*           BRANCH  TO   FALSE  IF NOT TRUE
MDLcf13us_8bT jlu *+l'*           BRANCH  TO   TRUE  (OPTIONAL)
MDLcf13us_8bL EQU *-MDLcf13us_8b
*
MDLcf13us_8bP EQU 0               LITERAL POOL USAGE (EXCL FIELD LEN)
*
MDLcf13us_8bR DC AL1(CSSRCloF),AL1(MDLcf13us_8b+02-MDLcf13us_8b) F1 OFF
         DC    AL1(CSdfpexps),AL1(MDLcf13us_8bd+02-MDLcf13us_8b) dfpexp
         DC    AL1(CSBYTMSK),AL1(MDLcf13us_8bA+01-MDLcf13us_8b) MASK
         DC    AL1(CStgtloF),AL1(MDLcf13us_8bA+02-MDLcf13us_8b) F1 OFF
         DC    AL1(CSdfpexp),AL1(MDLcf13us_8be+02-MDLcf13us_8b)  dfpexp
         DC    AL1(CSRELOPR),AL1(MDLcf13us_8bF+1-MDLcf13us_8b) REL CC
         DC    AL1(CSFALSEO),AL1(MDLcf13us_8bF+2-MDLcf13us_8b) FALSE BR
         DC    AL1(CSTRUEO),AL1(MDLcf13us_8bT+2-MDLcf13us_8b) TRUE BR
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        COMPARE FIELDS           (BINARY - BINARY)                   *
***********************************************************************
MDLCF13  Xgr   R0,R0              CONVERT BINARY FIELD
MDLCF13Ss TMy   0(0),X'80'
         if (o)
           lghi r0,-1              fill with 1's
         endif
MDLCF13A ICMy  R0,B'0000',0(0)
         cxgtr fp4,r0
MDLcf13d lghi  r14,*-*            Create biased exponent
         iextr fp4,fp4,r14        and insert
         Xgr   R15,R15            CONVERT BINARY FIELD
MDLCF13I TMy   0(0),X'80'
         if (o)
           lghi r15,-1             fill with 1's
         endif
MDLCF13B ICMy  R15,B'0000',0(0)
         cxgtr fp1,r15
MDLcf13e lghi  r14,*-*            Create biased exponent
         iextr fp1,fp1,r14        and insert
         cxtr fp4,fp1            COMPARE TWO  FIELDS
MDLCF13F jlu   *+l'*              BRANCH  TO   FALSE  IF NOT TRUE
MDLCF13T jlu   *+l'*              BRANCH  TO   TRUE  (OPTIONAL)
MDLCF13L EQU   *-MDLCF13
*
MDLCF13P EQU   0                  LITERAL POOL USAGE (EXCL FIELD LEN)
*
MDLCF13R DC    AL1(CSSRCloF),AL1(MDLCF13Ss+02-MDLCF13) FIELD  1  OFFSET
         DC    AL1(CSBYTMSS),AL1(MDLCF13A+01-MDLCF13) BYTE      MASK
         DC    AL1(CSSRCloF),AL1(MDLCF13A+02-MDLCF13) FIELD  1  OFFSET
         DC    AL1(CSdfpexps),AL1(MDLcf13d+02-MDLcf13) dfpexp
         DC    AL1(CSTGTloF),AL1(MDLCF13I+02-MDLCF13) FIELD  2  OFFSET
         DC    AL1(CSBYTMSK),AL1(MDLCF13B+01-MDLCF13) BYTE      MASK
         DC    AL1(CSTGTloF),AL1(MDLCF13B+02-MDLCF13) FIELD  2  OFFSET
         DC    AL1(CSdfpexp),AL1(MDLcf13e+02-MDLcf13)  dfpexp
         DC    AL1(CSRELOPR),AL1(MDLCF13F+1-MDLCF13)  RELATIONAL CC
         DC    AL1(CSFALSEO),AL1(MDLCF13F+2-MDLCF13)  FALSE  BRANCH
         DC    AL1(CSTRUEO),AL1(MDLCF13T+2-MDLCF13)   TRUE   BRANCH
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        COMPARE FIELDS           (BINARY - BINARY8)                  *
***********************************************************************
MDLCF13_b8 XgR  R0,R0              CONVERT BINARY FIELD
MDLCF13_b8S TMy 0(0),X'80'
         if (o)
           lghi r0,-1            fill with 1's
         endif
MDLCF13_b8A ICMy R0,B'0000',0(0)
         cxgtr fp4,r0
MDLcf13_b8d lghi  r14,*-*            Create biased exponent
         iextr fp4,fp4,r14        and insert
MDLCF13_b8B LG   R15,0(0,0)
         cxgtr fp1,r15
MDLcf13_b8e lghi  r14,*-*            Create biased exponent
         iextr fp1,fp1,r14        and insert
         cxtr fp4,fp1            COMPARE TWO  FIELDS
MDLCF13_b8F jlu *+l'*             BRANCH  TO   FALSE  IF NOT TRUE
MDLCF13_b8T jlu *+l'*             BRANCH  TO   TRUE  (OPTIONAL)
MDLCF13_b8L EQU *-MDLCF13_b8
*
MDLCF13_b8P EQU 0                 LITERAL POOL USAGE (EXCL FIELD LEN)
*
MDLCF13_b8R DC AL1(CSSRCloF),AL1(MDLCF13_b8S+02-MDLCF13_b8) FIELD 1 OFF
         DC    AL1(CSBYTMSS),AL1(MDLCF13_b8A+01-MDLCF13_b8) BYTE MASK
         DC    AL1(CSSRCloF),AL1(MDLCF13_b8A+02-MDLCF13_b8) FIELD 1 OFF
         DC    AL1(CSdfpexps),AL1(MDLcf13_b8d+02-MDLcf13_b8) dfpexp
         DC    AL1(CSTGTloF),AL1(MDLCF13_b8B+02-MDLCF13_b8) FIELD 2 OFF
         DC    AL1(CSdfpexp),AL1(MDLcf13_b8e+02-MDLcf13_b8)  dfpexp
         DC    AL1(CSRELOPR),AL1(MDLCF13_b8F+1-MDLCF13_b8) RELATION CC
         DC    AL1(CSFALSEO),AL1(MDLCF13_b8F+2-MDLCF13_b8) FALSE BRANCH
         DC    AL1(CSTRUEO),AL1(MDLCF13_b8T+2-MDLCF13_b8) TRUE BRANCH
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        COMPARE FIELDS           (BINARY8 - BINARY)                  *
***********************************************************************
MDLCF13_8b LG   R0,0(0,0)          CONVERT BINARY FIELD
         cxgtr fp4,r0
MDLcf13_8bd lghi  r14,*-*            Create biased exponent
         iextr fp4,fp4,r14        and insert
         xgr r15,r15
MDLCF13_8bS TMy 0(0),X'80'
         if (o)
           lghi r15,-1            fill with 1's
         endif
MDLCF13_8bA ICMy R15,B'0000',0(0)
         cxgtr fp1,r15
MDLcf13_8be lghi  r14,*-*            Create biased exponent
         iextr fp1,fp1,r14        and insert
         cxtr fp4,fp1            COMPARE TWO  FIELDS
MDLCF13_8bF jlu *+l'*             BRANCH  TO   FALSE  IF NOT TRUE
MDLCF13_8bT jlu *+l'*             BRANCH  TO   TRUE  (OPTIONAL)
MDLCF13_8bL EQU *-MDLCF13_8b
*
MDLCF13_8bP EQU 0                 LITERAL POOL USAGE (EXCL FIELD LEN)
*
MDLCF13_8bR DC AL1(CSSRCloF),AL1(MDLCF13_8b+02-MDLCF13_8b) FIELD 1 OFF
         DC    AL1(CSdfpexps),AL1(MDLcf13_8bd+02-MDLcf13_8b) dfpexp
         DC    AL1(CSTGTloF),AL1(MDLCF13_8bS+02-MDLCF13_8b) FIELD 2 OFF
         DC    AL1(CSBYTMSK),AL1(MDLCF13_8bA+01-MDLCF13_8b) BYTE MASK
         DC    AL1(CStgtloF),AL1(MDLCF13_8bA+02-MDLCF13_8b) FIELD 1 OFF
         DC    AL1(CSdfpexp),AL1(MDLcf13_8be+02-MDLcf13_8b)  dfpexp
         DC    AL1(CSRELOPR),AL1(MDLCF13_8bF+1-MDLCF13_8b) RELATION CC
         DC    AL1(CSFALSEO),AL1(MDLCF13_8bF+2-MDLCF13_8b) FALSE BRANCH
         DC    AL1(CSTRUEO),AL1(MDLCF13_8bT+2-MDLCF13_8b) TRUE BRANCH
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        COMPARE FIELDS           (BINARY8 - BINARY8)                 *
***********************************************************************
MDLCF13_88 LG   R0,0(0,0)          CONVERT BINARY FIELD
         cxgtr fp4,r0
MDLcf13_88d lghi  r14,*-*            Create biased exponent
         iextr fp4,fp4,r14        and insert
MDLCF13_88A LG  R15,0(0,0)
         cxgtr fp1,r15
MDLcf13_88e lghi  r14,*-*            Create biased exponent
         iextr fp1,fp1,r14        and insert
         cxtr fp4,fp1            COMPARE TWO  FIELDS
MDLCF13_88F jlu *+l'*             BRANCH  TO   FALSE  IF NOT TRUE
MDLCF13_88T jlu *+l'*             BRANCH  TO   TRUE  (OPTIONAL)
MDLCF13_88L EQU *-MDLCF13_88
MDLCF13_88P EQU 0                 LITERAL POOL USAGE (EXCL FIELD LEN)
MDLCF13_88R DC AL1(CSSRCloF),AL1(MDLCF13_88+02-MDLCF13_88) FIELD 1 OFF
         DC    AL1(CSdfpexps),AL1(MDLcf13_88d+02-MDLcf13_88) dfpexp
         DC    AL1(CStgtloF),AL1(MDLCF13_88A+02-MDLCF13_88) FIELD 1 OFF
         DC    AL1(CSdfpexp),AL1(MDLcf13_88e+02-MDLcf13_88)  dfpexp
         DC    AL1(CSRELOPR),AL1(MDLCF13_88F+1-MDLCF13_88) RELATION CC
         DC    AL1(CSFALSEO),AL1(MDLCF13_88F+2-MDLCF13_88) FALSE BRANCH
         DC    AL1(CSTRUEO),AL1(MDLCF13_88T+2-MDLCF13_88) TRUE BRANCH
         DC   2XL1'FF'

mdlcf46  LAY   R14,0(0,0)         get address
mdlcf46_la LAY R15,0(0,0)         get address
         XR    R0,R0              CONVERT BINARY FIELD
mdlcf46m mvc   workarea(0),0(r14) move event field to workarea
         xi    workarea,x'80'      flip the top bit
         if tm,workarea,x'80',nz If negative ...
           lhi r0,-1              fill with 1's
         endif
mdlcf46a ICMy  R0,B'0000',workarea
mdlcf46mm mvc   workarea(0),0(r15) move event field to workarea
         xr r15,r15
         xi    workarea,x'80'      flip the top bit
         if tm,workarea,x'80',nz If negative ...
           lhi r15,-1             fill with 1's
         endif
mdlcf46aa ICMy  R15,B'0000',workarea
         CR    R15,r0             COMPARE TWO  FIELDS
mdlcf46F jlu   *+l'*              BRANCH  TO   FALSE  IF NOT TRUE
mdlcf46T jlu   *+l'*              BRANCH  TO   TRUE  (OPTIONAL)
mdlcf46L EQU   *-mdlcf46
*
mdlcf46P EQU   0                  LITERAL POOL USAGE (EXCL FIELD LEN)
*
mdlcf46R DC    AL1(CStgtloF),AL1(mdlcf46+02-mdlcf46) FIELD  1  OFFSET
         DC    AL1(CStgtln),AL1(mdlcf46m+01-mdlcf46)  length
         DC    AL1(CSBYTMSk),AL1(mdlcf46A+01-mdlcf46) BYTE      MASK
         DC    AL1(CSSRCloF),AL1(mdlcf46_la+02-mdlcf46) FIELD  1 OFF
         DC    AL1(CSsrcln),AL1(mdlcf46mm+01-mdlcf46)  length
         DC    AL1(CSBYTMSS),AL1(mdlcf46Aa+01-mdlcf46) BYTE      MASK
         DC    AL1(CSRELOPR),AL1(mdlcf46F+1-mdlcf46)  RELATIONAL CC
         DC    AL1(CSFALSEO),AL1(mdlcf46F+2-mdlcf46)  FALSE  BRANCH
         DC    AL1(CSTRUEO),AL1(mdlcf46T+2-mdlcf46)   TRUE   BRANCH
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        COMPARE FIELDS           (BINARY - BINARY8)                  *
***********************************************************************
mdlcf46_b8 LAY R14,0(0,0)         get address
mdlcf46_b8la LAY R15,0(0,0)         get address
mdlcf46_b8mm mvc   workarea(0),0(r14) move event field to workarea
         xi workarea,x'80'        flip the top bit
         LG    R0,workarea
mdlcf46_b8m mvc   workarea(0),0(r15) move event field to workarea
         Xgr   R1,R1
         xi    workarea,x'80'      flip the top bit
         if tm,workarea,x'80',nz If negative ...
           lghi r1,-1              fill with 1's
         endif
mdlcf46_b8A ICMy R1,B'0000',workarea
         CGR   R1,r0              COMPARE TWO  FIELDS
mdlcf46_b8F jlu *+l'*             BRANCH  TO   FALSE  IF NOT TRUE
mdlcf46_b8T jlu *+l'*             BRANCH  TO   TRUE  (OPTIONAL)
mdlcf46_b8L EQU *-mdlcf46_b8
*
mdlcf46_b8P EQU 0                 LITERAL POOL USAGE (EXCL FIELD LEN)
*
mdlcf46_b8R DC AL1(CStgtloF),AL1(mdlcf46_b8+02-mdlcf46_b8) FIELD 1 OFF
         DC    AL1(CStgtln),AL1(mdlcf46_b8mm+01-mdlcf46_b8) length
         DC    AL1(CSSRCloF),AL1(mdlcf46_b8la+02-mdlcf46_b8) FLD 1 OFF
         DC    AL1(CSsrcln),AL1(mdlcf46_b8m+01-mdlcf46_b8) length
         DC    AL1(CSBYTMSS),AL1(mdlcf46_b8A+01-mdlcf46_b8) BYTE MASK
         DC    AL1(CSRELOPR),AL1(mdlcf46_b8F+1-mdlcf46_b8) RELATION CC
         DC    AL1(CSFALSEO),AL1(mdlcf46_b8F+2-mdlcf46_b8) FALSE BRANCH
         DC    AL1(CSTRUEO),AL1(mdlcf46_b8T+2-mdlcf46_b8) TRUE BRANCH
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        COMPARE FIELDS           (BINARY8 - BINARY)                  *
***********************************************************************
mdlcf46_8b LAY R14,0(0,0)         get address
mdlcf46_8bla LAY R15,0(0,0)         get address
mdlcf46_8bmm mvc   workarea(0),0(r14) move event field to workarea
         xi workarea,x'80'        flip the top bit
         LG    R0,workarea
mdlcf46_8bm mvc   workarea(0),0(r15) move event field to workarea
         Xgr   R1,R1
         xi    workarea,x'80'      flip the top bit
         if tm,workarea,x'80',nz If negative ...
           lghi r1,-1              fill with 1's
         endif
mdlcf46_8bA ICMy R1,B'0000',workarea
         CGR   R0,R1              COMPARE TWO  FIELDS
mdlcf46_8bF jlu *+l'*             BRANCH  TO   FALSE  IF NOT TRUE
mdlcf46_8bT jlu *+l'*             BRANCH  TO   TRUE  (OPTIONAL)
mdlcf46_8bL EQU *-mdlcf46_8b
*
mdlcf46_8bP EQU 0                 LITERAL POOL USAGE (EXCL FIELD LEN)
*
mdlcf46_8bR DC AL1(CSSRCloF),AL1(mdlcf46_8b+02-mdlcf46_8b) FIELD 1 OFF
         DC    AL1(CSSRCln),AL1(mdlcf46_8bmm+01-mdlcf46_8b) FIELD 1 OFF
         DC    AL1(CSTGTloF),AL1(mdlcf46_8bla+02-mdlcf46_8b) Fld 2 OFF
         DC    AL1(CStgtln),AL1(mdlcf46_8bm+01-mdlcf46_8b) FIELD 1 OFF
         DC    AL1(CSBYTMSK),AL1(mdlcf46_8bA+01-mdlcf46_8b) BYTE MASK
         DC    AL1(CSRELOPR),AL1(mdlcf46_8bF+1-mdlcf46_8b) RELATION CC
         DC    AL1(CSFALSEO),AL1(mdlcf46_8bF+2-mdlcf46_8b) FALSE BRANCH
         DC    AL1(CSTRUEO),AL1(mdlcf46_8bT+2-mdlcf46_8b) TRUE BRANCH
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        COMPARE FIELDS           (BINARY8 - BINARY8)                 *
***********************************************************************
mdlcf46_88 LAY R14,0(0,0)         get address
mdlcf46_88la LAY R15,0(0,0)         get address
mdlcf46_88mm mvc   workarea(0),0(r14) move event field to workarea
         xi workarea,x'80'        flip the top bit
         LG    R0,workarea
mdlcf46_88m  mvc   workarea(0),0(r15) move event field to workarea
         xi workarea,x'80'        flip the top bit
         LG    R15,workarea
         CGR   R0,R15             COMPARE TWO  FIELDS
mdlcf46_88F jlu *+l'*             BRANCH  TO   FALSE  IF NOT TRUE
mdlcf46_88T jlu *+l'*             BRANCH  TO   TRUE  (OPTIONAL)
mdlcf46_88L EQU *-mdlcf46_88
*
mdlcf46_88P EQU 0                 LITERAL POOL USAGE (EXCL FIELD LEN)
*
mdlcf46_88R DC AL1(CSSRCloF),AL1(mdlcf46_88+02-mdlcf46_88) FIELD 1 OFF
         DC    AL1(CSsrcln),AL1(mdlcf46_88mm+01-mdlcf46_88) FIELD 1 OFF
         DC    AL1(CStgtloF),AL1(mdlcf46_88lA+02-mdlcf46_88) FIELD 1OFF
         DC    AL1(CStgtln),AL1(mdlcf46_88m+01-mdlcf46_88) FIELD 1 OFF
         DC    AL1(CSRELOPR),AL1(mdlcf46_88F+1-mdlcf46_88) RELATION CC
         DC    AL1(CSFALSEO),AL1(mdlcf46_88F+2-mdlcf46_88) FALSE BRANCH
         DC    AL1(CSTRUEO),AL1(mdlcf46_88T+2-mdlcf46_88) TRUE BRANCH
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        compare  pack  to edit                                       *
***********************************************************************
mdlcf14  LAY   R4,0(0,0)           get address
mdlcf14s llgt  R5,0(,R2)          load logic table row address
         LA    R1,WORKAREA
mdlcf14bb BAS   R10,*-*            CALL "GVBDL96"  (FORMAT  FIELD)
mdlcf14A jlu   *+l'*              FORMAT UNSUCCESSFUL BRANCH (FALSE)
*        do NOT use R14 here as it gets NOPed out
         ld    fp4,workarea       load first operand into fp4/6
         ld    fp6,workarea+8
mdlcf14k zap   WORKAR2,0(0,r4)    Move the data
         lmg   r0,r1,workar2 load into gp0/1
         cxstr fp1,r0             convert to DFP in fp1
MDLcf14e lghi  r15,*-*            Create biased exponent
         iextr fp1,fp1,r15       and insert
         cxtr  fp4,fp1
mdlcf14F jlu   *+l'*              BRANCH  TO   FALSE IF  NOT TRUE
mdlcf14T jlu   *+l'*              BRANCH  TO   TRUE (OPTIONAL)
mdlcf14L EQU   *-mdlcf14
*
mdlcf14P EQU   4                  LITERAL POOL USAGE (EXCL FIELD LEN)
*
mdlcf14r DC    AL1(CStgtlof),AL1(mdlcf14+02-mdlcf14) source  OFFSET
         DC    AL1(CSltroff),AL1(mdlcf14s+02-mdlcf14)  TARGET    OFFSET
         DC    AL1(CSdl96calln),AL1(MDLcf14bb-MDLcf14)  MR96 BAS
         DC    AL1(CSFALSEO),AL1(mdlcf14A+2-mdlcf14)  FALSE  BRANCH
         DC    AL1(CStgtLNR),AL1(mdlcf14k+01-mdlcf14) FIELD  1  LEN R/2
         DC    AL1(CSdfpexp),AL1(MDLcf14e+02-MDLcf14) dfp exp
         DC    AL1(CSRELOPR),AL1(mdlcf14F+1-mdlcf14)  RELATIONAL CC
         DC    AL1(CSFALSEO),AL1(mdlcf14F+2-mdlcf14)  FALSE  BRANCH
         DC    AL1(CSTRUEO),AL1(mdlcf14T+2-mdlcf14)   TRUE   BRANCH
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        compare  pack  to edit                                       *
***********************************************************************
mdlcf77  LAY   R4,0(0,0)          get address
mdlcf77s llgt  R5,0(,R2)          load logic table row address
         LA    R1,WORKAREA
mdlcf77c BAS   R10,*-*            CONVERT EDITED/MASKED  NUMERIC
mdlcf77A jlu   *+l'*              FORMAT UNSUCCESSFUL BRANCH (FALSE)
*        do NOT use R14 here as it gets NOPed out
         ld    fp4,workarea       load first operand into fp4/6
         ld    fp6,workarea+8
mdlcf77k zap   workar2,0(0,r4)    COMPARE TWO  FIELDS
         lmg   r0,r1,workar2
         cxstr fp1,r0             convert to dfp
MDLcf77e lghi  r15,*-*            Create biased exponent
         iextr fp1,fp1,r15       and insert
         cxtr  fp1,fp4            COMPARE TWO  FIELDS
mdlcf77F jlu   *+l'*              BRANCH  TO   FALSE IF  NOT TRUE
mdlcf77T jlu   *+l'*              BRANCH  TO   TRUE (OPTIONAL)
mdlcf77L EQU   *-mdlcf77
*
mdlcf77P EQU   4                  LITERAL POOL USAGE (EXCL FIELD LEN)
*
mdlcf77r DC    AL1(CSsrclof),AL1(mdlcf77+02-mdlcf77) source  OFFSET
         DC    AL1(CSltroff),AL1(mdlcf77s+02-mdlcf77)  TARGET    OFFSET
         DC    AL1(CSFALSEO),AL1(mdlcf77A+2-mdlcf77)  FALSE  BRANCH
         DC    AL1(CSdl96callr),AL1(MDLcf77c-MDLcf77)  MR96 BAS
         DC    AL1(CSsrcLNr),AL1(mdlcf77k+01-mdlcf77) FIELD  1  LEN R/2
         DC    AL1(CSdfpexps),AL1(MDLcf77e+02-MDLcf77) dfp exp
         DC    AL1(CSRELOPR),AL1(mdlcf77F+1-mdlcf77)  RELATIONAL CC
         DC    AL1(CSFALSEO),AL1(mdlcf77F+2-mdlcf77)  FALSE  BRANCH
         DC    AL1(CSTRUEO),AL1(mdlcf77T+2-mdlcf77)   TRUE   BRANCH
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
mdlcf78  LAY   R4,0(0,0)          get address
mdlcf78s llgt  R5,0(,R2)          load logic table row address
         LA    R1,WORKAREA
mdlcf78bas BAS R10,*-*            CONVERT EDITED/MASKED  NUMERIC
mdlcf78A jlu   *+l'*              FORMAT UNSUCCESSFUL BRANCH (FALSE)
*        do NOT use R14 here as it gets NOPed out
         ld    fp4,workarea       load first operand into fp4/6
         ld    fp6,workarea+8
mdlcf78b mvc   dblwork(0),0(r4)   copy event field to workplace
         ic    r0,0(0,r4)         save first character into r0
         if tmll,r0,x'00f0',z     test to see if not ones
mdlcf78c   xc dblwork(0),hexff   flip all the bits
         endif
         ni    dblwork,x'0f'      clean top nibble in workarea
mdlcf78d mvo   workar2,dblwork(0) CONVERT SOURCE FIELD
         ni workar2+l'workar2-1,x'f0'     clean the sign bits
         if tmll,r0,x'00f0',o     test to see if all ones
           oi workar2+l'workar2-1,x'0c'   and set sign to X'c'
         else
           oi workar2+l'workar2-1,x'0d'   and set sign to X'd'
         endif
         lmg   r0,r1,workar2
         cxstr fp1,r0             convert to dfp
MDLcf78e lghi  r15,*-*           Create biased exponent
         iextr fp1,fp1,r15       and insert
         cxtr  fp1,fp4            COMPARE TWO  FIELDS
mdlcf78F jlu   *+l'*              BRANCH  TO   FALSE IF  NOT TRUE
mdlcf78T jlu   *+l'*              BRANCH  TO   TRUE (OPTIONAL)
mdlcf78L EQU   *-mdlcf78
*
mdlcf78P EQU   4                  LITERAL POOL USAGE (EXCL FIELD LEN)
*
mdlcf78r DC    AL1(CSsrclof),AL1(mdlcf78+02-mdlcf78) source  OFFSET
         DC    AL1(CSltroff),AL1(mdlcf78s+02-mdlcf78)  TARGET    OFFSET
         DC    AL1(CSFALSEO),AL1(mdlcf78A+2-mdlcf78)  FALSE  BRANCH
         DC    AL1(CSdl96callr),AL1(MDLcf78bas-MDLcf78)  MR96 BAS
         DC    AL1(CSsrcLN),AL1(mdlcf78b+01-mdlcf78) TARGET    OFFSET
         DC    AL1(CSsrcLN),AL1(mdlcf78c+01-mdlcf78) TARGET    OFFSET
         DC    AL1(CSsrcLNR),AL1(mdlcf78d+01-mdlcf78) TARGET    LENGTH
         DC    AL1(CSdfpexps),AL1(mdlcf78e+02-mdlcf78) dfp exp
         DC    AL1(CSRELOPR),AL1(mdlcf78F+1-mdlcf78)  RELATIONAL CC
         DC    AL1(CSFALSEO),AL1(mdlcf78F+2-mdlcf78)  FALSE  BRANCH
         DC    AL1(CSTRUEO),AL1(mdlcf78T+2-mdlcf78)   TRUE   BRANCH
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
mdlcf79u Xgr   R4,R4              CONVERT BINARY  TO PACKED
mdlcf79ui ICMY R4,B'0000',0(0)
mdlcf79us llgt  R5,0(,R2)          load logic table row address
         LA    R1,WORKAREA
mdlcf79uc bas  R10,*-*            CONVERT EDITED/MASKED  NUMERIC
mdlcf79uA jlu  *+l'*              FORMAT UNSUCCESSFUL BRANCH (FALSE)
*        do NOT use R14 here as it gets NOPed out
         ld    fp4,workarea       load first operand into fp4/6
         ld    fp6,workarea+8
         cxgtr fp1,r4
MDLcf79ue lghi  r15,*-*            Create biased exponent
         iextr fp1,fp1,r15       and insert
         cxtr  fp1,fp4
mdlcf79uF jlu  *+l'*              BRANCH  TO   FALSE IF  NOT TRUE
mdlcf79uT jlu  *+l'*              BRANCH  TO   TRUE (OPTIONAL)
mdlcf79uL EQU  *-mdlcf79u
*
mdlcf79uP EQU  4                  LITERAL POOL USAGE (EXCL FIELD LEN)
*
mdlcf79ur DC   AL1(CSBYTMSs),AL1(mdlcf79ui+01-mdlcf79u) TGT FLD LEN L/2
         dc    AL1(CSltroff),AL1(mdlcf79us+02-mdlcf79u) TARGET   OFFSET
         DC    AL1(CSdl96callr),AL1(MDLcf79uc-MDLcf79u)  MR96 BAS
         DC    AL1(CSFALSEO),AL1(mdlcf79uA+2-mdlcf79u) FALSE BRANCH
         DC    AL1(CSsrcloF),AL1(mdlcf79ui+02-mdlcf79u) TGT FIELD OFF
         DC    AL1(CSdfpexps),AL1(MDLcf79ue+02-MDLcf79u) dfp exp
         DC    AL1(CSRELOPR),AL1(mdlcf79uF+1-mdlcf79u) RELATIONAL CC
         DC    AL1(CSFALSEO),AL1(mdlcf79uF+2-mdlcf79u) FALSE BRANCH
         DC    AL1(CSTRUEO),AL1(mdlcf79uT+2-mdlcf79u) TRUE   BRANCH
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
mdlcf79  XgR   R4,R4              CONVERT BINARY  TO PACKED
mdlcf79S TMY   0(0),X'80'
         if (o)
           lghi r4,-1              fill with 1's
         endif
mdlcf79i ICMY  R4,B'0000',0(0)
mdlcf79ly llgt R5,0(,R2)          load logic table row address
         LA    R1,WORKAREA
mdlcf79c BAS   R10,*-*            CONVERT EDITED/MASKED  NUMERIC
mdlcf79A jlu   *+l'*              FORMAT UNSUCCESSFUL BRANCH (FALSE)
*        do NOT use R14 here as it gets NOPed out
         ld    fp4,workarea       load first operand into fp4/6
         ld    fp6,workarea+8
         cxgtr fp1,r4
MDLcf79e lghi  r15,*-*            Create biased exponent
         iextr fp1,fp1,r15       and insert
         cxtr  fp1,fp4
mdlcf79F jlu   *+l'*              BRANCH  TO   FALSE IF  NOT TRUE
mdlcf79T jlu   *+l'*              BRANCH  TO   TRUE (OPTIONAL)
mdlcf79L EQU   *-mdlcf79
*
mdlcf79P EQU   4                  LITERAL POOL USAGE (EXCL FIELD LEN)
*
mdlcf79r DC    AL1(CSsrcloF),AL1(mdlcf79S+02-mdlcf79) TGT FIELD OFF
         DC    AL1(CSltroff),AL1(mdlcf79ly+02-mdlcf79) TARGET OFFSET
         DC    AL1(CSdl96callr),AL1(MDLcf79c-MDLcf79)  MR96 BAS
         DC    AL1(CSFALSEO),AL1(mdlcf79A+2-mdlcf79)  FALSE  BRANCH
         DC    AL1(CSBYTMSs),AL1(mdlcf79i+01-mdlcf79) TGT FIELD LEN L/2
         DC    AL1(CSsrcloF),AL1(mdlcf79i+02-mdlcf79) TGT FIELD OFF
         DC    AL1(CSdfpexps),AL1(MDLcf79e+02-MDLcf79) dfp exp
         DC    AL1(CSRELOPR),AL1(mdlcf79F+1-mdlcf79)  RELATIONAL CC
         DC    AL1(CSFALSEO),AL1(mdlcf79F+2-mdlcf79)  FALSE  BRANCH
         DC    AL1(CSTRUEO),AL1(mdlcf79T+2-mdlcf79)   TRUE   BRANCH
         DC   2XL1'FF'
                        SPACE 3
mdlcf79_b8  LG  R4,0(0,0)
mdlcf79_b8s llgt R5,0(,R2)          load logic table row address
         LA    R1,WORKAR2
mdlcf79_b8c BAS   R10,*-*            CONVERT EDITED/MASKED  NUMERIC
mdlcf79_b8A jlu *+l'*             FORMAT UNSUCCESSFUL BRANCH (FALSE)
*        do NOT use R14 here as it gets NOPed out
         ld    fp4,workar2       load first operand into fp4/6
         ld    fp6,workar2+8
         cxgtr fp1,r4
MDLcf79_b8e lghi  r15,*-*            Create biased exponent
         iextr fp1,fp1,r15       and insert
         cxtr  fp1,fp4
mdlcf79_b8F jlu *+l'*             BRANCH  TO   FALSE IF  NOT TRUE
mdlcf79_b8T jlu *+l'*             BRANCH  TO   TRUE (OPTIONAL)
mdlcf79_b8L EQU *-mdlcf79_b8
*
mdlcf79_b8P EQU 4                 LITERAL POOL USAGE (EXCL FIELD LEN)
*
mdlcf79_b8r dc AL1(CSsrcloF),AL1(mdlcf79_b8+02-mdlcf79_b8) TGT FD OFF
         DC    AL1(CSltroff),AL1(mdlcf79_b8s+02-mdlcf79_b8) TARGET OFF
         DC    AL1(CSdl96callr),AL1(MDLcf79_b8c-MDLcf79_b8)  MR96 BAS
         DC    AL1(CSdfpexps),AL1(MDLcf79_b8e+02-MDLcf79_b8) dfp exp
         DC    AL1(CSFALSEO),AL1(mdlcf79_b8A+2-mdlcf79_b8) FALSE BRANCH
         DC    AL1(CSRELOPR),AL1(mdlcf79_b8F+1-mdlcf79_b8) REL cc
         DC    AL1(CSFALSEO),AL1(mdlcf79_b8F+2-mdlcf79_b8) FALSE BR
         DC    AL1(CSTRUEO),AL1(mdlcf79_b8T+2-mdlcf79_b8) TRUE BR
         DC   2XL1'FF'
                        SPACE 3
mdlcf80  LAY   R4,0(0,0)         get address
mdlcf80s llgt  R5,0(,R2)          load logic table row address
         LA    R1,WORKAR2
mdlcf80c BAS   R10,*-*            CONVERT EDITED/MASKED  NUMERIC
mdlcf80A jlu   *+l'*              FORMAT UNSUCCESSFUL BRANCH (FALSE)
*        do NOT use R14 here as it gets NOPed out
         ld    fp4,workar2       load first operand into fp4/6
         ld    fp6,workar2+8
         Xgr   R0,R0              CONVERT BINARY  TO PACKED
mdlcf80m mvc   workarea(0),0(r4)  move event field to workarea
         xi    workarea,x'80'      flip the top bit
         if tm,workarea,x'80',nz If negative ...
           lghi r0,-1              fill with 1's
         endif
mdlcf80i ICMy  R0,B'0000',workarea
         cxgtr fp1,r0
MDLcf80e lghi  r15,*-*            Create biased exponent
         iextr fp1,fp1,r15       and insert
         cxtr  fp1,fp4
mdlcf80F jlu   *+l'*              BRANCH  TO   FALSE IF  NOT TRUE
mdlcf80T jlu   *+l'*              BRANCH  TO   TRUE (OPTIONAL)
mdlcf80L EQU   *-mdlcf80
*
mdlcf80P EQU   0                  LITERAL POOL USAGE (EXCL FIELD LEN)
*
mdlcf80r DC    AL1(CSsrcloF),AL1(mdlcf80+02-mdlcf80) FIELD  1  OFFSET
         DC    AL1(CSltroff),AL1(mdlcf80s+02-mdlcf80)  TARGET    OFFSET
         DC    AL1(CSdl96callr),AL1(MDLcf80c-MDLcf80)  MR96 BAS
         DC    AL1(CSFALSEO),AL1(mdlcf80A+2-mdlcf80)  FALSE  BRANCH
         DC    AL1(CSsrcln),AL1(mdlcf80m+01-mdlcf80)  length
         DC    AL1(CSBYTMSs),AL1(mdlcf80i+01-mdlcf80) BYTE      MASK
         DC    AL1(CSdfpexps),AL1(MDLcf80e+02-MDLcf80) dfp exp
         DC    AL1(CSRELOPR),AL1(mdlcf80F+1-mdlcf80)  RELATIONAL CC
         DC    AL1(CSFALSEO),AL1(mdlcf80F+2-mdlcf80)  FALSE  BRANCH
         DC    AL1(CSTRUEO),AL1(mdlcf80T+2-mdlcf80)   TRUE   BRANCH
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        COMPARE FIELDS           (NUMERIC - BINARY 8)                *
***********************************************************************
mdlcf80_b8  LAY   R4,0(0,0)
mdlcf80_b8s llgt R5,0(,R2)          load logic table row address
         LA    R1,WORKAR2
mdlcf80_b8c BAS   R10,*-*            CONVERT EDITED/MASKED  NUMERIC
mdlcf80_b8A jlu *+l'*             FORMAT UNSUCCESSFUL BRANCH (FALSE)
*        do NOT use R14 here as it gets NOPed out
         ld    fp4,workar2       load first operand into fp4/6
         ld    fp6,workar2+8
mdlcf80_b8m mvc   workarea(0),0(r4)  move event field to workarea
            xi    workarea,x'80'  flip top bit
            lg    R0,workarea
         cxgtr fp1,r0
MDLcf80_b8e lghi  r15,*-*            Create biased exponent
         iextr fp1,fp1,r15       and insert
         cxtr  fp1,fp4
mdlcf80_b8F jlu *+l'*             BRANCH  TO   FALSE IF  NOT TRUE
mdlcf80_b8T jlu *+l'*             BRANCH  TO   TRUE (OPTIONAL)
mdlcf80_b8L EQU *-mdlcf80_b8
*
mdlcf80_b8P EQU 0                 LITERAL POOL USAGE (EXCL FIELD LEN)
*
mdlcf80_b8r ds 0h
  DC    AL1(CSsrclof),AL1(mdlcf80_b8+02-mdlcf80_b8) TGT FIELD OFF
  DC    AL1(CSltroff),AL1(mdlcf80_b8s+02-mdlcf80_b8) TARGET OFF
  DC    AL1(CSdl96callr),AL1(MDLcf80_b8c-MDLcf80_b8)  MR96 BAS
  DC    AL1(CSFALSEO),AL1(mdlcf80_b8A+2-mdlcf80_b8) FALSE BRANCH
  DC    AL1(CSsrcln),AL1(mdlcf80_b8m+01-mdlcf80_b8) TGT FIELD OFF
  DC    AL1(CSdfpexps),AL1(MDLcf80_b8e+02-MDLcf80_b8) dfp exp
  DC    AL1(CSRELOPR),AL1(mdlcf80_b8F+1-mdlcf80_b8) RELATIONAL CC
  DC    AL1(CSFALSEO),AL1(mdlcf80_b8F+2-mdlcf80_b8) FALSE BRANCH
  DC    AL1(CSTRUEO),AL1(mdlcf80_b8T+2-mdlcf80_b8) TRUE BRANCH
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
mdlcf81  LAY   R4,0(0,0)         CONSTANT ADDRESS
mdlcf81s llgt  R5,0(,R2)          load logic table row address
         LA    R1,WORKAR2
mdlcf81c BAS   R10,*-*            CONVERT EDITED/MASKED  NUMERIC
mdlcf81A jlu   *+l'*              FORMAT UNSUCCESSFUL BRANCH (FALSE)
*        do NOT use R14 here as it gets NOPed out
         ld    fp4,workar2       load first operand into fp4/6
         ld    fp6,workar2+8
         MVI   WORKARea+L'WORKARea-1,X'0F' ADD SIGN NIBBLE 'F'
mdlcf81bb mvo  workarea,0(0,r4)   CONVERT BCD TO UNSIGNED PACKED
         lmg   r0,r1,workarea
         cxstr fp1,r0
MDLcf81e lghi  r15,*-*            Create biased exponent
         iextr fp1,fp1,r15       and insert
         cxtr  fp1,fp4
mdlcf81F jlu   *+l'*              BRANCH  TO   FALSE  IF NOT TRUE
mdlcf81T jlu   *+l'*              BRANCH  TO   TRUE  (OPTIONAL)
mdlcf81L EQU   *-mdlcf81
*
mdlcf81P EQU   0                  LITERAL POOL USAGE (EXCL FIELD LEN)
*
mdlcf81r DC    AL1(CSsrcloF),AL1(mdlcf81+02-mdlcf81)  FIELD  2  OFF
         DC    AL1(CSltroff),AL1(mdlcf81s+02-mdlcf81)  TARGET    OFFSET
         DC    AL1(CSdl96callr),AL1(MDLcf81c-MDLcf81)  MR96 BAS
         DC    AL1(CSFALSEO),AL1(mdlcf81A+2-mdlcf81)  FALSE  BRANCH
         DC    AL1(CSsrcLNR),AL1(mdlcf81bb+01-mdlcf81) TARGET    LENGTH
         DC    AL1(CSdfpexps),AL1(MDLcf81e+02-MDLcf81) dfp exp
         DC    AL1(CSRELOPR),AL1(mdlcf81F+1-mdlcf81)  RELATIONAL CC
         DC    AL1(CSFALSEO),AL1(mdlcf81F+2-mdlcf81)  FALSE  BRANCH
         DC    AL1(CSTRUEO),AL1(mdlcf81T+2-mdlcf81)   TRUE   BRANCH
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
mdlcf82  llgt  R5,0(,R2)          load logic table row address
         LA    R1,WORKARea
mdlcf82b BAS   R10,*-*            CALL "GVBDL96"  (FORMAT  FIELD)
mdlcf82A jlu   *+l'*              FORMAT UNSUCCESSFUL BRANCH (FALSE)
*        do NOT use R14 here as it gets NOPed out
         ld    fp1,workarea       load first operand into fp4/6
         ld    fp3,workarea+8
mdlcf82s llgt  R5,0(,R2)          load logic table row address
         LA    R1,WORKAR2
mdlcf82c BAS   R10,*-*            CONVERT EDITED/MASKED  NUMERIC
mdlcf82sa jlu  *+l'*              FORMAT UNSUCCESSFUL BRANCH (FALSE)
         ld    fp4,workar2       load first operand into fp4/6
         ld    fp6,workar2+8
         cxtr  fp1,fp4
mdlcf82F jlu   *+l'*              BRANCH  TO   FALSE  IF NOT TRUE
mdlcf82T jlu   *+l'*              BRANCH  TO   TRUE  (OPTIONAL)
mdlcf82L EQU   *-mdlcf82
*
mdlcf82P EQU   0                  LITERAL POOL USAGE (EXCL FIELD LEN)
*
mdlcf82r DC    AL1(CSltroff),AL1(mdlcf82+02-mdlcf82)  TARGET    OFFSET
         DC    AL1(CSdl96calln),AL1(MDLcf82b-MDLcf82)  MR96 BAS
         DC    AL1(CSFALSEO),AL1(mdlcf82A+2-mdlcf82)  FALSE  BRANCH
         DC    AL1(CSltroff),AL1(mdlcf82s+02-mdlcf82)  TARGET    OFFSET
         DC    AL1(CSdl96callr),AL1(MDLcf82c-MDLcf82)  MR96 BAS
         DC    AL1(CSFALSEO),AL1(mdlcf82sA+2-mdlcf82)  FALSE  BRANCH
         DC    AL1(CSRELOPR),AL1(mdlcf82F+1-mdlcf82)  RELATIONAL CC
         DC    AL1(CSFALSEO),AL1(mdlcf82F+2-mdlcf82)  FALSE  BRANCH
         DC    AL1(CSTRUEO),AL1(mdlcf82T+2-mdlcf82)   TRUE   BRANCH
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        COMPARE FIELDS           (BINARYs- NUMERIC)                  *
***********************************************************************
mdlcf16  LAY   R14,0(0,0)         load source address
mdlcf16_la LAY R15,0(0,0)         get address
mdlcf16m mvc   workarea(0),0(r14) move event field to workarea
         xgr   R0,R0              CONVERT BINARY FIELD
         xi    workarea,x'80'      flip the top bit
         if tm,workarea,x'80',nz If negative ...
           lghi r0,-1             fill with 1's
         endif
mdlcf16A ICMy  R0,B'0000',workarea
         cxgtr fp4,r0
MDLcf16se lghi  r14,*-*           Create biased exponent
         iextr fp4,fp4,r14       and insert
mdlcf16B PACK  WORKAREA,0(0,r15) CONVERT NUMERIC
         lmg   r0,r1,workarea     load into gp0/1
         cxstr fp1,r0             convert to DFP
MDLcf16e lghi  r15,*-*           Create biased exponent
         iextr fp1,fp1,r15       and insert
         cxtr  fp4,fp1
mdlcf16F jlu   *+l'*              BRANCH  TO   FALSE  IF NOT TRUE
mdlcf16T jlu   *+l'*              BRANCH  TO   TRUE  (OPTIONAL)
mdlcf16L EQU   *-mdlcf16
*
mdlcf16P EQU   0                  LITERAL POOL USAGE (EXCL FIELD LEN)
*
mdlcf16R DC    AL1(CSSRClof),AL1(mdlcf16+02-mdlcf16) FIELD  1  OFFSET
         DC    AL1(CStgtlof),AL1(mdlcf16_lA+02-mdlcf16) FIELD  1  OFF
         DC    AL1(CSsrcln),AL1(MDLcf16m+01-MDLcf16)  length
         DC    AL1(CSBYTMSS),AL1(mdlcf16A+01-mdlcf16) BYTE      MASK
         DC    AL1(CSdfpexps),AL1(mdlcf16se+02-mdlcf16) dfp exp
         DC    AL1(CSTGTLNR),AL1(mdlcf16B+01-mdlcf16) FIELD  2  LEN R/2
         DC    AL1(CSdfpexp),AL1(mdlcf16e+02-mdlcf16) dfp exp
         DC    AL1(CSRELOPR),AL1(mdlcf16F+1-mdlcf16)  RELATIONAL CC
         DC    AL1(CSFALSEO),AL1(mdlcf16F+2-mdlcf16)  FALSE  BRANCH
         DC    AL1(CSTRUEO),AL1(mdlcf16T+2-mdlcf16)   TRUE   BRANCH
         DC   2XL1'FF'
***********************************************************************
*        COMPARE FIELDS           (BINARY 8 - NUMERIC)                *
***********************************************************************
mdlcf16_b8 LAY   R14,0(0,0)       load source address
mdlcf16_b8la LAY R15,0(0,0)         get address
mdlcf16_b8m mvc workarea(0),0(r14) move source field to workarea
         xi    workarea,x'80'     flip the top bit
         LG    R0,workarea
         cxgtr fp4,r0
MDLcf16_b8se lghi  r14,*-*           Create biased exponent
         iextr fp4,fp4,r14       and insert
mdlcf16_b8B PACK WORKAREA,0(0,r15) CONVERT NUMERIC
         lmg   r0,r1,workarea     load into gp0/1
         cxstr fp1,r0             convert to DFP
MDLcf16_b8e lghi  r15,*-*           Create biased exponent
         iextr fp1,fp1,r15       and insert
         cxtr  fp4,fp1
mdlcf16_b8F jlu *+l'*             BRANCH  TO   FALSE  IF NOT TRUE
mdlcf16_b8T jlu *+l'*             BRANCH  TO   TRUE  (OPTIONAL)
mdlcf16_b8L EQU *-mdlcf16_b8
*
mdlcf16_b8P EQU 0                 LITERAL POOL USAGE (EXCL FIELD LEN)
*
mdlcf16_b8R DC AL1(CSSRCLOF),AL1(mdlcf16_b8+02-mdlcf16_b8)  FIELD 1 OFF
         DC    AL1(CStgtlof),AL1(mdlcf16_b8lA+02-mdlcf16_b8) FLD 1 OFF
         DC    AL1(CSsrcln),AL1(MDLcf16_b8m+01-MDLcf16_b8) length
         DC    AL1(CSdfpexps),AL1(mdlcf16_b8se+02-mdlcf16_b8) dfp exp
         DC    AL1(CSTGTLNR),AL1(mdlcf16_b8B+01-mdlcf16_b8) FLD 2 LEN R
         DC    AL1(CSdfpexp),AL1(mdlcf16_b8e+02-mdlcf16_b8) dfp exp
         DC    AL1(CSRELOPR),AL1(mdlcf16_b8F+1-mdlcf16_b8) RELATION CC
         DC    AL1(CSFALSEO),AL1(mdlcf16_b8F+2-mdlcf16_b8) FALSE BRANCH
         DC    AL1(CSTRUEO),AL1(mdlcf16_b8T+2-mdlcf16_b8) TRUE BRANCH
         DC   2XL1'FF'
***********************************************************************
*        COMPARE FIELDS           (BINARYs- NUMERIC)                  *
***********************************************************************
mdlcf83  LAY   R14,0(0,0)         load target a
mdlcf83_la LAY R15,0(0,0)              source a
mdlcf83m mvc   workarea(0),0(r14) move event field to workarea
         Xgr   R0,R0              CONVERT BINARY FIELD
         xi    workarea,x'80'      flip the top bit
         if tm,workarea,x'80',nz If negative ...
           lghi r0,-1              fill with 1's
         endif
mdlcf83A ICMy  R0,B'0000',workarea
         cxgtr fp1,r0
MDLcf83e lghi  r14,*-*           Create biased exponent
         iextr fp1,fp1,r14       and insert
mdlcf83B PACK  WORKAREA,0(0,r15) CONVERT NUMERIC
         lmg   r0,r1,workarea     load into gp0/1
         cxstr fp4,r0             convert to DFP
MDLcf83se lghi  r15,*-*           Create biased exponent
         iextr fp4,fp4,r15       and insert
         cxtr  fp4,fp1
mdlcf83F jlu   *+l'*              BRANCH  TO   FALSE  IF NOT TRUE
mdlcf83T jlu   *+l'*              BRANCH  TO   TRUE  (OPTIONAL)
mdlcf83L EQU   *-mdlcf83
*
mdlcf83P EQU   0                  LITERAL POOL USAGE (EXCL FIELD LEN)
*
mdlcf83R DC    AL1(CStgtlof),AL1(mdlcf83+02-mdlcf83) FIELD  1  OFFSET
         DC    AL1(CSsrclof),AL1(mdlcf83_lA+02-mdlcf83) FIELD  1  OFF
         DC    AL1(CStgtln),AL1(mdlcf83m+01-mdlcf83)  length
         DC    AL1(CSBYTMSk),AL1(mdlcf83A+01-mdlcf83) BYTE      MASK
         DC    AL1(CSdfpexp),AL1(mdlcf83e+02-mdlcf83) dfp exp
         DC    AL1(CSsrcLNR),AL1(mdlcf83B+01-mdlcf83) FIELD  2  LEN R/2
         DC    AL1(CSdfpexps),AL1(mdlcf83se+02-mdlcf83) dfp exp
         DC    AL1(CSRELOPR),AL1(mdlcf83F+1-mdlcf83)  RELATIONAL CC
         DC    AL1(CSFALSEO),AL1(mdlcf83F+2-mdlcf83)  FALSE  BRANCH
         DC    AL1(CSTRUEO),AL1(mdlcf83T+2-mdlcf83)   TRUE   BRANCH
         DC   2XL1'FF'
***********************************************************************
*        COMPARE FIELDS           (BINARY 8 - NUMERIC)                *
***********************************************************************
mdlcf83_b8 LAY   R14,0(0,0)       load target address
mdlcf83_b8la LAY R15,0(0,0)            source
mdlcf83_b8m mvc workarea(0),0(r14) move target field to workarea
         xi    workarea,x'80'     flip the top bit
         LG    R0,workarea
         cxgtr fp1,r0
MDLcf83_b8e lghi  r14,*-*           Create biased exponent
         iextr fp1,fp1,r14       and insert
mdlcf83_b8B PACK WORKAREA,0(0,r15) CONVERT NUMERIC
         lmg   r0,r1,workarea     load into gp0/1
         cxstr fp4,r0             convert to DFP
MDLcf83_b8se lghi  r15,*-*           Create biased exponent
         iextr fp4,fp4,r15       and insert
         cxtr  fp4,fp1
mdlcf83_b8F jlu *+l'*             BRANCH  TO   FALSE  IF NOT TRUE
mdlcf83_b8T jlu *+l'*             BRANCH  TO   TRUE  (OPTIONAL)
mdlcf83_b8L EQU *-mdlcf83_b8
*
mdlcf83_b8P EQU 0                 LITERAL POOL USAGE (EXCL FIELD LEN)
*
mdlcf83_b8R DC AL1(CStgtLOF),AL1(mdlcf83_b8+02-mdlcf83_b8)  FIELD 1 OFF
         DC    AL1(CSsrclof),AL1(mdlcf83_b8lA+02-mdlcf83_b8) FLD 1 OFF
         DC    AL1(CStgtln),AL1(mdlcf83_b8m+01-mdlcf83_b8) length
         DC    AL1(CSdfpexp),AL1(mdlcf83_b8e+02-mdlcf83_b8) dfp exp
         DC    AL1(CSsrcLNR),AL1(mdlcf83_b8B+01-mdlcf83_b8) FLD 2 LEN R
         DC    AL1(CSdfpexps),AL1(mdlcf83_b8se+02-mdlcf83_b8) dfp exp
         DC    AL1(CSRELOPR),AL1(mdlcf83_b8F+1-mdlcf83_b8) RELATION CC
         DC    AL1(CSFALSEO),AL1(mdlcf83_b8F+2-mdlcf83_b8) FALSE BRANCH
         DC    AL1(CSTRUEO),AL1(mdlcf83_b8T+2-mdlcf83_b8) TRUE BRANCH
         DC   2XL1'FF'
***********************************************************************
*        COMPARE FIELDS           (NUMERIC - BCD)                     *
***********************************************************************
MDLcf17  LAY R14,0(0,0)           get address
MDLcf17_la LAY R15,0(0,0)         get address
MDLCF17k PACK  WORKAREA,0(0,r15)  CONVERT NUMERIC TO PACKED
         lmg   r0,r1,workarea     load into gp0/1
         cxstr fp1,r0             convert to DFP
MDLcf17e lghi  r15,*-*           Create biased exponent
         iextr fp1,fp1,r15       and insert
         MVI   WORKAR2+L'WORKAR2-1,X'0F' ADD SIGN NIBBLE 'F'
MDLCF17Q MVO   WORKAR2,0(0,r14)   CONVERT BCD TO UNSIGNED PACKED
         lmg   r0,r1,workar2      load into gp0/1
         cxstr fp4,r0             convert to DFP
MDLcf17se lghi  r15,*-*           Create biased exponent
         iextr fp4,fp4,r15       and insert
         cxtr  fp4,fp1
MDLCF17F jlu   *+l'*              BRANCH  TO   FALSE IF  NOT TRUE
MDLCF17T jlu   *+l'*              BRANCH  TO   TRUE (OPTIONAL)
MDLCF17L EQU   *-MDLCF17
*
MDLCF17P EQU   0                  LITERAL POOL USAGE (EXCL FIELD LEN)
*
MDLCF17R DC    AL1(CStgtLNr),AL1(MDLCF17k+01-MDLCF17) FIELD  1  LEN L/2
         DC    AL1(CSSRClof),AL1(MDLCF17+02-MDLCF17)  FIELD  1  OFF
         DC    AL1(CSsrcLNR),AL1(MDLCF17Q+01-MDLCF17) FIELD  2  LEN R/2
         DC    AL1(CStgtlof),AL1(MDLcf17_lA+02-MDLcf17) FIELD  2  OFF
         DC    AL1(CSdfpexp),AL1(mdlcf17e+02-mdlcf17) dfp exp
         DC    AL1(CSdfpexps),AL1(mdlcf17se+02-mdlcf17) dfp exp
         DC    AL1(CSRELOPR),AL1(MDLCF17F+1-MDLCF17)  RELATIONAL CC
         DC    AL1(CSFALSEO),AL1(MDLCF17F+2-MDLCF17)  FALSE  BRANCH
         DC    AL1(CSTRUEO),AL1(MDLCF17T+2-MDLCF17)   TRUE   BRANCH
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        COMPARE FIELDS           (NUMERIC - BCD)                     *
***********************************************************************
mdlcf55  LAY R14,0(0,0)           get target
mdlcf55_la LAY R15,0(0,0)         get source
mdlcf55k PACK  WORKAREA,0(0,r14)  CONVERT NUMERIC TO PACKED
         MVI   WORKAR2+L'WORKAR2-1,X'0F' ADD SIGN NIBBLE 'F'
mdlcf55Q MVO   WORKAR2,0(0,r15)   CONVERT BCD TO UNSIGNED PACKED
         lmg   r0,r1,workar2
         cxstr fp1,r0             convert to dfp
MDLcf55d lghi  r15,*-*            Create biased exponent
         iextr fp1,fp1,r15       and insert
         lmg   r0,r1,workarea
         cxstr fp4,r0             convert to dfp
MDLcf55e lghi  r15,*-*            Create biased exponent
         iextr fp4,fp4,r15       and insert
         cxtr  fp4,fp1           COMPARE TWO  FIELDS
mdlcf55F jlu   *+l'*              BRANCH  TO   FALSE IF  NOT TRUE
mdlcf55T jlu   *+l'*              BRANCH  TO   TRUE (OPTIONAL)
mdlcf55L EQU   *-mdlcf55
*
mdlcf55P EQU   0                  LITERAL POOL USAGE (EXCL FIELD LEN)
*
mdlcf55R DC    AL1(CSsrcLNr),AL1(mdlcf55k+01-mdlcf55) FIELD  1  LEN r/2
         DC    AL1(CSsrclof),AL1(mdlcf55+02-mdlcf55)  FIELD  1  OFF
         DC    AL1(CStgtLNR),AL1(mdlcf55Q+01-mdlcf55) FIELD  2  LEN r/2
         DC    AL1(CStgtlof),AL1(mdlcf55_lA+02-mdlcf55) FIELD  2  OFF
         DC    AL1(CSdfpexp),AL1(MDLcf55d+02-MDLcf55) dfp exp
         DC    AL1(CSdfpexps),AL1(MDLcf55e+02-MDLcf55) dfp exp
         DC    AL1(CSRELOPR),AL1(mdlcf55F+1-mdlcf55)  RELATIONAL CC
         DC    AL1(CSFALSEO),AL1(mdlcf55F+2-mdlcf55)  FALSE  BRANCH
         DC    AL1(CSTRUEO),AL1(mdlcf55T+2-mdlcf55)   TRUE   BRANCH
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
mdlcf76  LAY   R4,0(0,0)           get target
MDLcf76la llgt  R5,0(,R2)          load logic table row address
         LA    R1,WORKAR2
mdlcf76c BAS   R10,*-*            CONVERT EDITED/MASKED  NUMERIC
MDLcf76A jlu   *+l'*              FORMAT UNSUCCESSFUL BRANCH (FALSE)
*        do NOT use R14 here as it gets NOPed out
         ld    fp4,workar2        load first operand into fp4/6
         ld    fp6,workar2+8
mdlcf76k PACK  WORKAREA,0(0,r4)   CONVERT NUMERIC TO PACKED
         lmg   r0,r1,workarea
         cxstr fp1,r0             convert to dfp
MDLcf76b lghi  r15,*-*           Create biased exponent
         iextr fp1,fp1,r15       and insert
         cxtr  fp1,fp4            COMPARE TWO  FIELDS
mdlcf76F jlu   *+l'*              BRANCH  TO   FALSE IF  NOT TRUE
mdlcf76T jlu   *+l'*              BRANCH  TO   TRUE (OPTIONAL)
mdlcf76L EQU   *-mdlcf76
*
mdlcf76P EQU   0                  LITERAL POOL USAGE (EXCL FIELD LEN)
*
mdlcf76R DC    AL1(CSsrcLNr),AL1(mdlcf76k+01-mdlcf76) FIELD  1  LEN r/2
         DC    AL1(CSsrclof),AL1(mdlcf76+02-mdlcf76)  FIELD  1  OFF
         DC    AL1(CSltroff),AL1(mdlcf76la+02-mdlcf76) TARGET OFFSET
         DC    AL1(CSdl96callr),AL1(MDLcf76c-MDLcf76)  MR96 BAS
         DC    AL1(CSdfpexps),AL1(MDLcf76b+02-MDLcf76) dfp exp
         DC    AL1(CSFALSEO),AL1(mdlcf76A+2-mdlcf76)  FALSE  BRANCH
         DC    AL1(CSRELOPR),AL1(mdlcf76F+1-mdlcf76)  RELATIONAL CC
         DC    AL1(CSFALSEO),AL1(mdlcf76F+2-mdlcf76)  FALSE  BRANCH
         DC    AL1(CSTRUEO),AL1(mdlcf76T+2-mdlcf76)   TRUE   BRANCH
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        compare  alnum to edit                                       *
***********************************************************************
MDLcf18  LAY   R4,0(0,0)          get address
MDLcf18s llgt  R5,0(,R2)          load logic table row address
         LA    R1,WORKAREA
mdlcf18bb BAS   R10,*-*            CALL "GVBDL96"  (FORMAT  FIELD)
MDLcf18A jlu   *+l'*              FORMAT UNSUCCESSFUL BRANCH (FALSE)
*        do NOT use R14 here as it gets NOPed out
         ld    fp4,workarea       load first operand into fp4/6
         ld    fp6,workarea+8
MDLCF18k PACK  WORKAR2,0(0,r4)   CONVERT NUMERIC TO PACKED
         lmg   r0,r1,workar2 load into gp0/1
         cxstr fp1,r0             convert to DFP in fp1
MDLcf18b lghi  r15,*-*           Create biased exponent
         iextr fp1,fp1,r15       and insert
         cxtr  fp4,fp1
MDLCF18F jlu   *+l'*              BRANCH  TO   FALSE IF  NOT TRUE
MDLCF18T jlu   *+l'*              BRANCH  TO   TRUE (OPTIONAL)
MDLcf18L EQU   *-MDLcf18
*
mdlcf18P EQU   4                  LITERAL POOL USAGE (EXCL FIELD LEN)
*
mdlcf18r DC    AL1(CStgtlof),AL1(mdlcf18+02-mdlcf18) source  OFFSET
         DC    AL1(CSltroff),AL1(mdlcf18s+02-mdlcf18)  TARGET    OFFSET
         DC    AL1(CSdl96calln),AL1(mdlcf18bb-MDLcf18)  MR96 BAS
         DC    AL1(CSFALSEO),AL1(mdlcf18A+2-mdlcf18)  FALSE  BRANCH
         DC    AL1(CStgtLNR),AL1(MDLCF18k+01-MDLCF18) FIELD  1  LEN R/2
         DC    AL1(CSdfpexp),AL1(MDLcf18b+02-MDLcf18) dfp exp
         DC    AL1(CSRELOPR),AL1(MDLCF18F+1-MDLCF18)  RELATIONAL CC
         DC    AL1(CSFALSEO),AL1(MDLCF18F+2-MDLCF18)  FALSE  BRANCH
         DC    AL1(CSTRUEO),AL1(MDLCF18T+2-MDLCF18)   TRUE   BRANCH
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        COMPARE FIELDS           (PACKs  - PACKED)                   *
***********************************************************************
mdlcf19  LAY   R14,0(0,0)         LOAD  SOURCE address
mdlcf19_la LAY R15,0(0,0)         CONSTANT ADDRESS
mdlcf19b mvc   workar2(0),0(r15)  copy event field to workplace
         ic    r0,0(0,r15)        save first character into r0
         if tmll,r0,x'00f0',z     test to see if not ones
mdlcf19c   xc workar2(0),hexff   flip all the bits
         endif
         ni    workar2,x'0f'      clean top nibble in workarea
mdlcf19d mvo   WORKAREA,workar2(0)  CONVERT SOURCE FIELD
         ni workarea+l'workarea-1,x'f0'     clean the sign bits
         if tmll,r0,x'00f0',o     test to see if all ones
           oi workarea+l'workarea-1,x'0c'   and set sign to X'c'
         else
           oi workarea+l'workarea-1,x'0d'   and set sign to X'd'
         endif
         lmg   r0,r1,workarea     load into gp0/1
         cxstr fp1,r0             convert to DFP in fp1
MDLcf19e lghi  r15,*-*           Create biased exponent
         iextr fp1,fp1,r15       and insert
mdlcf19a pack  workar2,0(0,r14)   pack the input data
         lmg   r0,r1,workar2 load into gp0/1
         cxstr fp4,r0             convert to DFP in fp4
MDLcf19se lghi  r15,*-*           Create biased exponent
         iextr fp4,fp4,r15       and insert
         cxtr  fp4,fp1
mdlcf19F jlu   *+l'*              BRANCH  TO   FALSE  IF NOT TRUE
mdlcf19T jlu   *+l'*              BRANCH  TO   TRUE  (OPTIONAL)
mdlcf19L EQU   *-mdlcf19
*
mdlcf19P EQU   0                  LITERAL POOL USAGE (EXCL FIELD LEN)
*
mdlcf19R DC    AL1(CSSRCloF),AL1(mdlcf19+02-mdlcf19)   FIELD  1  OFF
         DC    AL1(CSTGTloF),AL1(mdlcf19_la+02-mdlcf19)  FIELD  2  OFF
         DC    AL1(CStgtLN),AL1(mdlcf19b+01-mdlcf19) TARGET    OFFSET
         DC    AL1(CStgtLN),AL1(mdlcf19c+01-mdlcf19) TARGET    OFFSET
         DC    AL1(CStgtlNR),AL1(mdlcf19d+01-mdlcf19) TARGET    LENGTH
         DC    AL1(CSsrcLNR),AL1(mdlcf19a+01-mdlcf19) TARGET    LENGTH
         DC    AL1(CSdfpexps),AL1(MDLcf19se+02-MDLcf19) dfp exp
         DC    AL1(CSdfpexp),AL1(mdlcf19e+02-mdlcf19) dfpexp
         DC    AL1(CSRELOPR),AL1(mdlcf19F+1-mdlcf19)  RELATIONAL CC
         DC    AL1(CSFALSEO),AL1(mdlcf19F+2-mdlcf19)  FALSE  BRANCH
         DC    AL1(CSTRUEO),AL1(mdlcf19T+2-mdlcf19)   TRUE   BRANCH
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        COMPARE FIELDS           (CONSTANT/ACCUMULATOR)              *
***********************************************************************
MDLCF20  LAY   R14,0(,R2)         LOAD ACCUMULATOR ADDR (CHG'D TO "LY")
MDLCF20C LAY   R15,0(,R2)         LOAD CONSTANT    ADDR
mdlcf20d ld    fp0,0(0,r14)
         ld    fp2,8(0,r14)
         ld    fp4,0(0,r15)
         ld    fp6,8(0,r15)
         cxtr  fp4,fp0
MDLCF20F jlu   *+l'*              BRANCH  TO    FALSE  IF NOT TRUE
MDLCF20T jlu   *+l'*              BRANCH  TO   TRUE (OPTIONAL)
MDLCF20L EQU   *-MDLCF20
*
MDLCF20P EQU   4                  LITERAL POOL USAGE (EXCL FIELD LEN)
*
MDLCF20R DC    AL1(CSACCOFF),AL1(MDLCF20+02-MDLCF20)  ACCUM     OFF
         DC    AL1(CSACCVAL),AL1(MDLCF20C+02-MDLCF20) VALUE  1  OFF
         DC    AL1(CSRELOP2),AL1(MDLCF20F+1-MDLCF20)  REL  OPERATOR
         DC    AL1(CSFALSEO),AL1(MDLCF20F+2-MDLCF20)  FALSE  BRANCH
         DC    AL1(CSTRUEO),AL1(MDLCF20T+2-MDLCF20)   TRUE   BRANCH
         DC    AL1(CSdfpopt),AL1(MDLcf20d-MDLcf20) dfp load optimise
         DC   2XL1'FF'

mdlcf2ar LAY   R14,0(,R2)         LOAD ACCUMULATOR ADDR (CHG'D TO "LY")
mdlcf2arC LAY  R15,0(,R2)         LOAD CONSTANT    ADDR
mdlcf2ard ld   fp0,0(0,r14)
         ld    fp2,8(0,r14)
         ld    fp4,0(0,r15)
         ld    fp6,8(0,r15)
         cxtr  fp4,fp0
mdlcf2arF jlu  *+l'*              BRANCH  TO    FALSE  IF NOT TRUE
mdlcf2arT jlu  *+l'*              BRANCH  TO   TRUE (OPTIONAL)
mdlcf2arL EQU  *-mdlcf2ar
*
mdlcf2arP EQU  4                  LITERAL POOL USAGE (EXCL FIELD LEN)
*
mdlcf2arR DC   AL1(CSACCval),AL1(mdlcf2ar+02-mdlcf2ar) ACCUM    OFF
         DC    AL1(CSACCoff),AL1(mdlcf2arC+02-mdlcf2ar) VALUE 1 OFF
         DC    AL1(CSRELOP2),AL1(mdlcf2arF+1-mdlcf2ar) REL OPERATOR
         DC    AL1(CSFALSEO),AL1(mdlcf2arF+2-mdlcf2ar) FALSE BRANCH
         DC    AL1(CSTRUEO),AL1(mdlcf2arT+2-mdlcf2ar) TRUE   BRANCH
         DC    AL1(CSdfpopt),AL1(mdlcf2ard-mdlcf2ar) dfp load optimise
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        COMPARE FIELDS           (PACKED - PACKED)                   *
***********************************************************************
MDLCF21  LAY   R14,0(,R2)         LOAD ACCUMULATOR ADDR (CHG'D TO "LY")
MDLcf21_la LAY R15,0(0,0)         get address
MDLCF21A ZAP   WORKAREA,0(0,r15)  CONVERT PACKED
         lmg   r0,r1,workarea
         cxstr fp1,r0
MDLcf21b lghi  r15,*-*           Create biased exponent
         iextr fp1,fp1,r15       and insert
mdlcf21d ld    fp0,0(0,r14)
         ld    fp2,8(0,r14)
         cxtr  fp1,fp0
MDLCF21F jlu   *+l'*              BRANCH  TO   FALSE  IF NOT TRUE
MDLCF21T jlu   *+l'*              BRANCH  TO   TRUE  (OPTIONAL)
MDLCF21L EQU   *-MDLCF21
*
MDLCF21P EQU   4                  LITERAL POOL USAGE (EXCL FIELD LEN)
*
MDLCF21R DC    AL1(CSACCOF2),AL1(MDLCF21+02-MDLCF21)  ACCUM  2  OFF
         DC    AL1(CSTGTLNR),AL1(MDLCF21A+01-MDLCF21) FIELD  1  LEN L/2
         DC    AL1(CStgtlof),AL1(MDLcf21_lA+02-MDLcf21) FIELD  2  OFF
         DC    AL1(CSdfpexp),AL1(MDLcf21b+02-MDLcf21) dfp exp
         DC    AL1(CSdfpopt),AL1(MDLcf21d-MDLcf21) optimise loads
         DC    AL1(CSRELOPR),AL1(MDLCF21F+1-MDLCF21)  RELATIONAL CC
         DC    AL1(CSFALSEO),AL1(MDLCF21F+2-MDLCF21)  FALSE  BRANCH
         DC    AL1(CSTRUEO),AL1(MDLCF21T+2-MDLCF21)   TRUE   BRANCH
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        COMPARE FIELDS           (NUMERIC - PACKED)                  *
***********************************************************************
MDLCF22  LAY   R14,0(,R2)         LOAD ACCUMULATOR ADDR (CHG'D TO "LY")
MDLcf22_la LAY R15,0(0,0)         get address
MDLCF22A PACK  WORKAREA,0(0,r15)  CONVERT PACKED
         lmg   r0,r1,workarea
         cxstr fp1,r0
mdlcf22b lghi  r15,*-*            Create biased exponent
         iextr fp1,fp1,r15          and insert
mdlcf22d ld    fp0,0(0,r14)
         ld    fp2,8(0,r14)
         cxtr  fp1,fp0
MDLCF22F jlu   *+l'*              BRANCH  TO   FALSE  IF NOT TRUE
MDLCF22T jlu   *+l'*              BRANCH  TO   TRUE  (OPTIONAL)
MDLCF22L EQU   *-MDLCF22
*
MDLCF22P EQU   4                  LITERAL POOL USAGE (EXCL FIELD LEN)
*
MDLCF22R DC    AL1(CSACCOF2),AL1(MDLCF22+02-MDLCF22)  ACCUM  2  OFF
         DC    AL1(CStgtlof),AL1(MDLcf22_lA+02-MDLcf22) FIELD  2  OFF
         DC    AL1(CSTGTLNR),AL1(MDLCF22A+01-MDLCF22) FIELD  1  LEN R/2
         DC    AL1(CSdfpexp),AL1(MDLcf22b+02-MDLcf22) SHIFT DEC PLACES
         DC    AL1(CSdfpopt),AL1(MDLcf22d-MDLcf22) optimise loads
         DC    AL1(CSRELOPR),AL1(MDLCF22F+1-MDLCF22)  RELATIONAL CC
         DC    AL1(CSFALSEO),AL1(MDLCF22F+2-MDLCF22)  FALSE  BRANCH
         DC    AL1(CSTRUEO),AL1(MDLCF22T+2-MDLCF22)   TRUE   BRANCH
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        COMPARE FIELDS           (PACKs  - PACKED)                   *
***********************************************************************
MDLCF02  LAY   R14,0(0,0)         LOAD  SOURCE address
mdlcf02_la LAY R15,0(0,0)         CONSTANT ADDRESS
mdlcf02Cp zap  workarea,0(0,r14)  COMPARE TWO  FIELDS
         lmg   r0,r1,workarea     load into gp0/1
         cxstr fp1,r0             convert to DFP
MDLcf02e lghi  r14,*-*           Create biased exponent
         iextr fp1,fp1,r14       and insert
mdlcf02b mvc   workar2(0),0(r15)  copy event field to workplace
         ic    r0,0(0,r15)        save first character into r0
         if tmll,r0,x'00f0',z     test to see if not ones
mdlcf02c   xc workar2(0),hexff   flip all the bits
         endif
         ni    workar2,x'0f'      clean top nibble in workarea
mdlcf02d mvo   WORKAREA,workar2(0)  CONVERT SOURCE FIELD
         ni workarea+l'workarea-1,x'f0'   clean the sign bits
         if tmll,r0,x'00f0',o     test to see if all ones
           oi workarea+l'workarea-1,x'0c' and set sign to X'c'
         else
           oi workarea+l'workarea-1,x'0d' and set sign to X'd'
         endif
         lmg   r0,r1,workarea     load into gp0/1
         cxstr fp4,r0             convert to DFP
MDLcf02se lghi  r15,*-*           Create biased exponent
         iextr fp4,fp4,r15       and insert
         cxtr  fp4,fp1
mdlcf02F jlu   *+l'*              BRANCH  TO   FALSE  IF NOT TRUE
mdlcf02T jlu   *+l'*              BRANCH  TO   TRUE  (OPTIONAL)
mdlcf02L EQU   *-mdlcf02
*
mdlcf02P EQU   0                  LITERAL POOL USAGE (EXCL FIELD LEN)
*
mdlcf02R DC    AL1(CStgtLNr),AL1(mdlcf02cp+01-mdlcf02) FIELD  1 LEN L/2
         DC    AL1(CStgtloF),AL1(mdlcf02+02-mdlcf02)   FIELD  1  OFF
         DC    AL1(CSdfpexp),AL1(mdlcf02e+02-mdlcf02) dfp exp
         DC    AL1(CSsrcloF),AL1(mdlcf02_la+02-mdlcf02)  FIELD  2  OFF
         DC    AL1(CSsrcLN),AL1(mdlcf02b+01-mdlcf02) TARGET    OFFSET
         DC    AL1(CSsrcLN),AL1(mdlcf02c+01-mdlcf02) TARGET    OFFSET
         DC    AL1(CSsrcLNR),AL1(mdlcf02d+01-mdlcf02) TARGET    LENGTH
         DC    AL1(CSdfpexps),AL1(mdlcf02se+02-mdlcf02) dfp exp
         DC    AL1(CSRELOPR),AL1(mdlcf02F+1-mdlcf02)  RELATIONAL CC
         DC    AL1(CSFALSEO),AL1(mdlcf02F+2-mdlcf02)  FALSE  BRANCH
         DC    AL1(CSTRUEO),AL1(mdlcf02T+2-mdlcf02)   TRUE   BRANCH
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        COMPARE FIELDS           (SORTP  - PACKED)                   *
***********************************************************************
MDLcf25  LAY   R14,0(,R2)         LOAD ACCUMULATOR ADDR (CHG'D TO "LY")
MDLcf25_la LAY R15,0(0,0)         get address
MDLcf25b mvc   workar2(0),0(r15)  copy event field to workplace
         ic    r0,0(0,r15)        save first character into r0
         if tmll,r0,x'00f0',z     test to see if not ones
mdlcf25c   xc workar2(0),hexff   flip all the bits
         endif
         ni    workar2,x'0f'      clean top nibble in workarea
MDLcf25d mvo   WORKAREA,workar2(0)  CONVERT SOURCE FIELD
         ni workarea+l'workarea-1,x'f0'     clean the sign bits
         if tmll,r0,x'00f0',o     test to see if all ones
           oi workarea+l'workarea-1,x'0c'   and set sign to X'c'
         else
           oi workarea+l'workarea-1,x'0d'   and set sign to X'd'
         endif
         lmg   r0,r1,workarea
         cxstr fp1,r0
MDLcf25e lghi  r15,*-*           Create biased exponent
         iextr fp1,fp1,r15       and insert
mdlcf25o ld    fp0,0(0,r14)
         ld    fp2,8(0,r14)
         cxtr  fp1,fp0
MDLcf25F jlu   *+l'*              BRANCH  TO   FALSE  IF NOT TRUE
MDLcf25T jlu   *+l'*              BRANCH  TO   TRUE  (OPTIONAL)
MDLcf25L EQU   *-MDLcf25
*
MDLcf25P EQU   4                  LITERAL POOL USAGE (EXCL FIELD LEN)
*
MDLcf25R DC    AL1(CSACCOF2),AL1(MDLcf25+02-MDLcf25)  ACCUM  2  OFF
         DC    AL1(CStgtlof),AL1(MDLcf25_lA+02-MDLcf25) FIELD  2  OFF
         DC    AL1(CSTGTLN),AL1(MDLcf25b+01-MDLcf25) TARGET    OFFSET
         DC    AL1(CSTGTLN),AL1(MDLcf25c+01-MDLcf25) TARGET    OFFSET
         DC    AL1(CSTGTLNR),AL1(MDLcf25d+01-MDLcf25) TARGET    LENGTH
         DC    AL1(CSdfpexp),AL1(MDLcf25e+02-MDLcf25) dfp exp
         DC    AL1(CSdfpopt),AL1(MDLcf25o-MDLcf25) optimise loads
         DC    AL1(CSRELOPR),AL1(MDLcf25F+1-MDLcf25)  RELATIONAL CC
         DC    AL1(CSFALSEO),AL1(MDLcf25F+2-MDLcf25)  FALSE  BRANCH
         DC    AL1(CSTRUEO),AL1(MDLcf25T+2-MDLcf25)   TRUE   BRANCH
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        COMPARE FIELDS           (BINARY - PACKED)                   *
***********************************************************************
MDLCF23  LAY   R14,0(,R2)         LOAD ACCUMULATOR ADDR (CHG'D TO "LY")
         Xgr   R0,R0              LOAD BINARY NUMBER
MDLcf23S TMy   0(0),X'80'
         if (o)
           lghi r0,-1             fill with 1's
         endif
MDLcf23A ICMy  R0,B'0000',0(0)
         cxgtr fp1,r0             convert to extended DFP
mdlcf23b lghi  r15,*-*            Create biased exponent
         iextr fp1,fp1,r15          and insert
mdlcf23d ld    fp0,0(0,r14)
         ld    fp2,8(0,r14)
         cxtr  fp1,fp0
MDLCF23F jlu   *+l'*              BRANCH  TO   FALSE  IF NOT TRUE
MDLCF23T jlu   *+l'*              BRANCH  TO   TRUE  (OPTIONAL)
MDLCF23L EQU   *-MDLCF23
*
MDLCF23P EQU   4                  LITERAL POOL USAGE (EXCL FIELD LEN)
*
MDLCF23R DC    AL1(CSTGTloF),AL1(MDLCF23S+02-MDLCF23) FIELD  1  OFFSET
         DC    AL1(CSBYTMSK),AL1(MDLCF23A+01-MDLCF23) BYTE      MASK
         DC    AL1(CSTGTloF),AL1(MDLCF23A+02-MDLCF23) FIELD  1  OFFSET
         DC    AL1(CSdfpexp),AL1(MDLcf23B+02-MDLcf23) DFP EXP
         DC    AL1(CSdfpopt),AL1(MDLcf23d-MDLcf23) optimise loads
         DC    AL1(CSACCOF2),AL1(MDLCF23+02-MDLCF23)  ACCUM  2  OFF
         DC    AL1(CSRELOPR),AL1(MDLCF23F+1-MDLCF23)  RELATIONAL CC
         DC    AL1(CSFALSEO),AL1(MDLCF23F+2-MDLCF23)  FALSE  BRANCH
         DC    AL1(CSTRUEO),AL1(MDLCF23T+2-MDLCF23)   TRUE   BRANCH
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        COMPARE FIELDS           (BINARY - PACKED)                   *
***********************************************************************
mdlcf23u  LAY  R14,0(,R2)         LOAD ACCUMULATOR ADDR (CHG'D TO "LY")
         XgR    R0,R0              CONVERT BINARY FIELD
mdlcf23uA ICMy R0,B'0000',0(0)
         cxgtr fp1,r0             convert to extended DFP
mdlcf23ub lghi  r15,*-*            Create biased exponent
         iextr fp1,fp1,r15          and insert
mdlcf23ud ld    fp0,0(0,r14)
         ld    fp2,8(0,r14)
         cxtr  fp1,fp0
mdlcf23uF jlu  *+l'*              BRANCH  TO   FALSE  IF NOT TRUE
mdlcf23uT jlu  *+l'*              BRANCH  TO   TRUE  (OPTIONAL)
mdlcf23uL EQU  *-mdlcf23u
*
mdlcf23uP EQU  4                  LITERAL POOL USAGE (EXCL FIELD LEN)
*
mdlcf23uR ds   0h
         DC    AL1(CSBYTMSK),AL1(mdlcf23uA+01-mdlcf23u) BYTE    MASK
         DC    AL1(CSTGTloF),AL1(mdlcf23uA+02-mdlcf23u) FIELD 1 OFFSET
         DC    AL1(CSdfpexp),AL1(MDLcf23uB+02-MDLcf23u) DFP Exponent
         DC    AL1(CSdfpopt),AL1(MDLcf23ud-MDLcf23u) DFP optimise
         DC    AL1(CSACCOF2),AL1(mdlcf23u+02-mdlcf23u) ACCUM 2 OFF
         DC    AL1(CSRELOPR),AL1(mdlcf23uF+1-mdlcf23u) RELATIONAL CC
         DC    AL1(CSFALSEO),AL1(mdlcf23uF+2-mdlcf23u) FALSE BRANCH
         DC    AL1(CSTRUEO),AL1(mdlcf23uT+2-mdlcf23u) TRUE   BRANCH
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        COMPARE FIELDS           (BINARY8- PACKED)                   *
***********************************************************************
MDLcf23_b8 LAY R14,0(,R2)        LOAD ACCUMULATOR ADDR (CHG'D TO "LY")
MDLcf23_b8b LG  R0,0(,0)
         cxgtr fp1,r0             convert to extended DFP
mdlcf23_b8c lghi  r15,*-*            Create biased exponent
         iextr fp1,fp1,r15          and insert
mdlcf23_b8d ld    fp0,0(0,r14)
         ld    fp2,8(0,r14)
         cxtr  fp1,fp0
MDLcf23_b8F jlu *+l'*             BRANCH  TO   FALSE  IF NOT TRUE
MDLcf23_b8T jlu *+l'*             BRANCH  TO   TRUE  (OPTIONAL)
MDLcf23_b8L EQU *-MDLcf23_b8
*
MDLcf23_b8P EQU 4                 LITERAL POOL USAGE (EXCL FIELD LEN)
*
MDLcf23_b8R ds 0h
         DC    AL1(CSACCOF2),AL1(MDLcf23_b8+02-MDLcf23_b8) ACC 2 OFF
         DC    AL1(CSTGTloF),AL1(MDLcf23_b8b+02-MDLcf23_b8) FLD 1 OFF
         DC   AL1(CSdfpexp),AL1(MDLcf23_b8C+02-MDLcf23_b8) shift
         DC   AL1(CSdfpopt),AL1(MDLcf23_b8d-MDLcf23_b8) optimise loads
         DC    AL1(CSRELOPR),AL1(MDLcf23_b8F+1-MDLcf23_b8) REL cc
         DC    AL1(CSFALSEO),AL1(MDLcf23_b8F+2-MDLcf23_b8) FALSE BRANCH
         DC    AL1(CSTRUEO),AL1(MDLcf23_b8T+2-MDLcf23_b8) TRUE BRANCH
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        COMPARE FIELDS           (sortb  - Accumulator)              *
***********************************************************************
MDLcf26  LAY   R14,0(,R2)         LOAD ACCUMULATOR ADDR (CHG'D TO "LY")
mdlcf26la lay  r15,0(0,0)         get event field address
mdlcf26m mvc   workarea(0),0(r15) move event field to workarea
         Xgr   R0,R0              LOAD BINARY NUMBER
         xi    workarea,x'80'      flip the top bit
         if tm,workarea,x'80',nz If negative ...
           lghi r0,-1             fill with 1's
         endif
MDLcf26A ICMy  R0,B'0000',workarea
         cxgtr fp1,r0             convert to DFP
mdlcf26b lghi  r15,*-*            Create biased exponent
         iextr fp1,fp1,r15          and insert
mdlcf26d ld    fp0,0(0,r14)
         ld    fp2,8(0,r14)
         cxtr  fp1,fp0
mdlcf26F jlu   *+l'*              BRANCH  TO   FALSE  IF NOT TRUE
mdlcf26T jlu   *+l'*              BRANCH  TO   TRUE  (OPTIONAL)
mdlcf26L EQU   *-mdlcf26
*
mdlcf26P EQU   4                  LITERAL POOL USAGE (EXCL FIELD LEN)
*
mdlcf26R DC    AL1(CSACCOF2),AL1(mdlcf26+02-mdlcf26) ACCUM  2  OFF
         DC    AL1(CSTGTloF),AL1(mdlcf26la+02-mdlcf26) FIELD  1  OFFSET
         DC    AL1(CStgtln),AL1(MDLcf26m+01-MDLcf26)  length
         DC    AL1(CSBYTMSK),AL1(mdlcf26A+01-mdlcf26) BYTE      MASK
         DC    AL1(CSdfpexp),AL1(MDLcf26B+02-MDLcf26) dfp exp
         DC    AL1(CSdfpopt),AL1(MDLcf26d-MDLcf26) optimise loads
         DC    AL1(CSRELOPR),AL1(mdlcf26F+1-mdlcf26)  RELATIONAL CC
         DC    AL1(CSFALSEO),AL1(mdlcf26F+2-mdlcf26)  FALSE  BRANCH
         DC    AL1(CSTRUEO),AL1(mdlcf26T+2-mdlcf26)   TRUE   BRANCH
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        COMPARE FIELDS           (sortb8 - PACKED)                   *
***********************************************************************
MDLcf26_b8 LAY R14,0(,R2)         LOAD ACCUMULATOR ADDR (CHG'D TO "LY")
mdlcf26_b8la lay r15,0(0,0)       get event field address
mdlcf26_b8m mvc workarea(0),0(r15) move event field to workarea
         xi    workarea,x'80'     flip the top bit
         LG    R0,workarea
         cxgtr fp1,r0             convert to extended DFP
mdlcf26_b8b lghi  r15,*-*            Create biased exponent
         iextr fp1,fp1,r15          and insert
mdlcf26_b8d ld    fp0,0(0,r14)
         ld    fp2,8(0,r14)
         cxtr  fp1,fp0
mdlcf26_b8F jlu *+l'*             BRANCH  TO   FALSE  IF NOT TRUE
mdlcf26_b8T jlu *+l'*             BRANCH  TO   TRUE  (OPTIONAL)
mdlcf26_b8L EQU *-mdlcf26_b8
*
mdlcf26_b8P EQU 4                 LITERAL POOL USAGE (EXCL FIELD LEN)
*
mdlcf26_b8R ds 0h
         DC    AL1(CSACCOF2),AL1(mdlcf26_b8+02-mdlcf26_b8) ACC 2 OFF
         DC    AL1(CSTGTloF),AL1(mdlcf26_b8la+02-mdlcf26_b8) FLD 1 OFF
         DC    AL1(CStgtln),AL1(MDLcf26_b8m+01-MDLcf26_b8) length
         DC    AL1(CSdfpexp),AL1(MDLcf26_b8B+02-MDLcf26_b8) dfp exp
         DC    AL1(CSdfpopt),AL1(MDLcf26_b8d-MDLcf26_b8) DFP load opt
         DC    AL1(CSRELOPR),AL1(mdlcf26_b8F+1-mdlcf26_b8) REL cc
         DC    AL1(CSFALSEO),AL1(mdlcf26_b8F+2-mdlcf26_b8) FALSE BRANCH
         DC    AL1(CSTRUEO),AL1(mdlcf26_b8T+2-mdlcf26_b8) TRUE BRANCH
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        COMPARE FIELDS    CFEA   (Ed num - Accum)                   *
***********************************************************************
MDLcf27  llgt  R5,0(,R2)          load logic table row address
         LA    R1,WORKAREA
mdlcf27bas BAS R10,*-*            CONVERT EDITED/MASKED  NUMERIC
MDLcf27A jlu   *+l'*              FORMAT UNSUCCESSFUL BRANCH (FALSE)
*        do NOT use R14 here as it gets NOPed out
MDLcf27b LAY   R1,0(,R2)         LOAD ACCUMULATOR ADDR (CHG'D TO "LY")
         ld    fp0,0(0,r1)        and load into fp regs
         ld    fp2,8(0,r1)
         ld    fp4,workarea
         ld    fp6,workarea+8
         cxtr  fp4,fp0
mdlcf27F jlu *+l'*             BRANCH  TO   FALSE  IF NOT TRUE
mdlcf27T jlu *+l'*             BRANCH  TO   TRUE  (OPTIONAL)
MDLcf27L EQU   *-MDLcf27
*
MDLcf27P EQU   4                  LITERAL POOL USAGE (EXCL FIELD LEN)
*
mdlcf27r DC    AL1(CSltroff),AL1(MDLcf27+02-MDLcf27)  TARGET    OFFSET
         DC    AL1(CSdl96call),AL1(MDLcf27bas-MDLcf27)  MR96 BAS
         DC    AL1(CSFALSEO),AL1(MDLcf27A+2-MDLcf27)  FALSE  BRANCH
         DC    AL1(CSACCOF2),AL1(MDLcf27b+02-MDLcf27) acc 2   OFFSET
         DC    AL1(CSRELOPR),AL1(mdlcf27F+1-mdlcf27) REL cc
         DC    AL1(CSFALSEO),AL1(mdlcf27F+2-mdlcf27) FALSE BRANCH
         DC    AL1(CSTRUEO),AL1(mdlcf27T+2-mdlcf27) TRUE BRANCH
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        COMPARE FIELDS           (PACKs  - PACKED)                   *
***********************************************************************
mdlcf28  LAY   R14,0(0,0)         LOAD  SOURCE address
mdlcf28_la LAY R15,0(0,0)         CONSTANT ADDRESS
mdlcf28b mvc   workar2(0),0(r15)  copy event field to workplace
         ic    r0,0(0,r15)        save first character into r0
         if tmll,r0,x'00f0',z     test to see if not ones
mdlcf28c   xc workar2(0),hexff   flip all the bits
         endif
         ni    workar2,x'0f'      clean top nibble in workarea
mdlcf28d mvo   WORKAREA,workar2(0)  CONVERT SOURCE FIELD
         ni workarea+l'workarea-1,x'f0'     clean the sign bits
         if tmll,r0,x'00f0',o     test to see if all ones
           oi workarea+l'workarea-1,x'0c'   and set sign to X'c'
         else
           oi workarea+l'workarea-1,x'0d'   and set sign to X'd'
         endif
         lmg   r0,r1,workarea     load into gp0/1
         cxstr fp1,r0             convert to DFP in fp1
MDLcf28e lghi  r15,*-*           Create biased exponent
         iextr fp1,fp1,r15       and insert
mdlcf28a zap   workar2,0(0,r14)   pack the input data
         lmg   r0,r1,workar2 load into gp0/1
         cxstr fp4,r0             convert to DFP in fp4
MDLcf28se lghi  r15,*-*           Create biased exponent
         iextr fp4,fp4,r15       and insert
         cxtr  fp4,fp1
*
mdlcf28F jlu   *+l'*              BRANCH  TO   FALSE  IF NOT TRUE
mdlcf28T jlu   *+l'*              BRANCH  TO   TRUE  (OPTIONAL)
mdlcf28L EQU   *-mdlcf28
*
mdlcf28P EQU   0                  LITERAL POOL USAGE (EXCL FIELD LEN)
*
mdlcf28R DC    AL1(CSSRCloF),AL1(mdlcf28+02-mdlcf28)   FIELD  1  OFF
         DC    AL1(CSTGTloF),AL1(mdlcf28_la+02-mdlcf28)  FIELD  2  OFF
         DC    AL1(CStgtLN),AL1(mdlcf28b+01-mdlcf28) TARGET    OFFSET
         DC    AL1(CStgtLN),AL1(mdlcf28c+01-mdlcf28) TARGET    OFFSET
         DC    AL1(CStgtLNR),AL1(mdlcf28d+01-mdlcf28) TARGET    LENGTH
         DC    AL1(CSsrcLNr),AL1(mdlcf28a+01-mdlcf28) TARGET    LENGTH
         DC    AL1(CSdfpexps),AL1(MDLcf28se+02-MDLcf28) dfp exp
         DC    AL1(CSdfpexp),AL1(mdlcf28e+02-mdlcf28) dfpexp
         DC    AL1(CSRELOPR),AL1(mdlcf28F+1-mdlcf28)  RELATIONAL CC
         DC    AL1(CSFALSEO),AL1(mdlcf28F+2-mdlcf28)  FALSE  BRANCH
         DC    AL1(CSTRUEO),AL1(mdlcf28T+2-mdlcf28)   TRUE   BRANCH
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        COMPARE FIELDS           (PACKs  - PACKED)                   *
***********************************************************************
mdlcf29  LAY   R14,0(0,0)         LOAD  SOURCE address
mdlcf29_la LAY R15,0(0,0)         CONSTANT ADDRESS
mdlcf29b mvc   workar2(0),0(r14)  copy event field to workplace
         ic    r0,0(0,r14)        save first character into r0
         if tmll,r0,x'00f0',z     test to see if not ones
mdlcf29c   xc workar2(0),hexff   flip all the bits
         endif
         ni    workar2,x'0f'      clean top nibble in workarea
mdlcf29d mvo   WORKAREA,workar2(0)  CONVERT SOURCE FIELD
         ni workarea+l'workarea-1,x'f0'   clean the sign bits
         if tmll,r0,x'00f0',o     test to see if all ones
           oi workarea+l'workarea-1,x'0c' and set sign to X'c'
         else
           oi workarea+l'workarea-1,x'0d' and set sign to X'd'
         endif
         lmg   r0,r1,workarea     load into gp0/1
         cxstr fp4,r0             convert to DFP in fp1
MDLcf29e lghi  r14,*-*           Create biased exponent
         iextr fp4,fp4,r14       and insert
mdlcf29bb mvc   workar2(0),0(r15)  copy event field to workplace
         ic    r0,0(0,r15)        save first character into r0
         if tmll,r0,x'00f0',z     test to see if not ones
mdlcf29cc   xc workar2(0),hexff   flip all the bits
         endif
         ni    workar2,x'0f'      clean top nibble in workarea
mdlcf29dd mvo   workarea,workar2(0)  CONVERT SOURCE FIELD
         ni workarea+l'workarea-1,x'f0'  clean the sign bits
         if tmll,r0,x'00f0',o     test to see if all ones
           oi workarea+l'workarea-1,x'0c' and set sign to X'c'
         else
           oi workarea+l'workarea-1,x'0d' and set sign to X'd'
         endif
         lmg   r0,r1,workarea     load into gp0/1
         cxstr fp1,r0             convert to DFP in fp1
MDLcf29ee lghi  r15,*-*           Create biased exponent
         iextr fp1,fp1,r15       and insert
         cxtr  fp4,fp1
mdlcf29F jlu   *+l'*              BRANCH  TO   FALSE  IF NOT TRUE
mdlcf29T jlu   *+l'*              BRANCH  TO   TRUE  (OPTIONAL)
mdlcf29L EQU   *-mdlcf29
*
mdlcf29P EQU   0                  LITERAL POOL USAGE (EXCL FIELD LEN)
*
mdlcf29R DC    AL1(CSSRCloF),AL1(mdlcf29+02-mdlcf29)   FIELD  1  OFF
         DC    AL1(CSTGTloF),AL1(mdlcf29_la+02-mdlcf29)  FIELD  2  OFF
         DC    AL1(CSSRCLN),AL1(mdlcf29b+01-mdlcf29) TARGET    OFFSET
         DC    AL1(CSSRCLN),AL1(mdlcf29c+01-mdlcf29) TARGET    OFFSET
         DC    AL1(CSSRCLNR),AL1(mdlcf29d+01-mdlcf29) TARGET    LENGTH
         DC    AL1(CSdfpexps),AL1(mdlcf29e+02-mdlcf29) dfp exp
         DC    AL1(CStgtLN),AL1(mdlcf29bb+01-mdlcf29) TARGET    OFFSET
         DC    AL1(CStgtLN),AL1(mdlcf29cc+01-mdlcf29) TARGET    OFFSET
         DC    AL1(CStgtLNR),AL1(mdlcf29dd+01-mdlcf29) TARGET    LENGTH
         DC    AL1(CSdfpexp),AL1(mdlcf29ee+02-mdlcf29) dfp exp
         DC    AL1(CSRELOPR),AL1(mdlcf29F+1-mdlcf29)  RELATIONAL CC
         DC    AL1(CSFALSEO),AL1(mdlcf29F+2-mdlcf29)  FALSE  BRANCH
         DC    AL1(CSTRUEO),AL1(mdlcf29T+2-mdlcf29)   TRUE   BRANCH
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        COMPARE FIELDS           (BINARY - PACKED)                   *
***********************************************************************
mdlcf38u xgr   R0,R0              CONVERT BINARY FIELD
mdlcf38u_la LAY R15,0(0,0)        get address
mdlcf38uA ICMY R0,B'0000',0(0)
         Cxgtr fp4,r0
MDLcf38use lghi  r14,*-*           Create biased exponent
         iextr fp4,fp4,r14       and insert
mdlcf38ub mvc  workar2(0),0(r15)  copy event field to workplace
         ic    r0,0(0,r15)        save first character into r0
         if tmll,r0,x'00f0',z     test to see if not ones
mdlcf38uc  xc workar2(0),hexff   flip all the bits
         endif
         ni    workar2,x'0f'      clean top nibble in workarea
mdlcf38ud mvo  WORKAREA,workar2(0)  CONVERT SOURCE FIELD
         ni workarea+l'workarea-1,x'f0'   clean the sign bits
         if tmll,r0,x'00f0',o     test to see if all ones
           oi workarea+l'workarea-1,x'0c' and set sign to X'c'
         else
           oi workarea+l'workarea-1,x'0d' and set sign to X'd'
         endif
         lmg   r0,r1,workarea     load into gp0/1
         cxstr fp1,r0             convert to DFP
MDLcf38ue lghi  r15,*-*           Create biased exponent
         iextr fp1,fp1,r15       and insert
         cxtr  fp4,fp1
mdlcf38uF jlu  *+l'*              BRANCH  TO   FALSE  IF NOT TRUE
mdlcf38uT jlu  *+l'*              BRANCH  TO   TRUE  (OPTIONAL)
mdlcf38uL EQU  *-mdlcf38u
*
mdlcf38uP EQU  0                  LITERAL POOL USAGE (EXCL FIELD LEN)
*
mdlcf38uR DC   AL1(CSBYTMSS),AL1(mdlcf38uA+01-mdlcf38u) BYTE    MASK
         DC    AL1(CSSRCloF),AL1(mdlcf38uA+02-mdlcf38u) FIELD 1 OFFSET
         DC    AL1(CSdfpexps),AL1(mdlcf38use+02-mdlcf38u) dfp exp
         DC    AL1(CStgtlof),AL1(mdlcf38u_lA+02-mdlcf38u) FIELD 1 OFF
         DC    AL1(CStgtLN),AL1(mdlcf38ub+01-mdlcf38u) TARGET  OFFSET
         DC    AL1(CStgtLN),AL1(mdlcf38uc+01-mdlcf38u) TARGET  OFFSET
         DC    AL1(CStgtLNR),AL1(mdlcf38ud+01-mdlcf38u) TARGET  LENGTH
         DC    AL1(CSdfpexp),AL1(mdlcf38ue+02-mdlcf38u) dfp exp
         DC    AL1(CSRELOPR),AL1(mdlcf38uF+1-mdlcf38u) RELATIONAL CC
         DC    AL1(CSFALSEO),AL1(mdlcf38uF+2-mdlcf38u) FALSE BRANCH
         DC    AL1(CSTRUEO),AL1(mdlcf38uT+2-mdlcf38u) TRUE   BRANCH
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        COMPARE FIELDS           (BINARY - PACKED)                   *
***********************************************************************
mdlcf38  Xgr   R0,R0              CONVERT BINARY FIELD
mdlcf38_la LAY R15,0(0,0)         get address
mdlcf38S TMY   0(0),X'80'
         if (o)
           lghi r0,-1              fill with 1's
         endif
mdlcf38A ICMY  R0,B'0000',0(0)
         Cxgtr fp4,r0
MDLcf38se lghi  r14,*-*           Create biased exponent
         iextr fp4,fp4,r14       and insert
mdlcf38b mvc   workar2(0),0(r15)  copy event field to workplace
         ic    r0,0(0,r15)        save first character into r0
         if tmll,r0,x'00f0',z     test to see if not ones
mdlcf38c   xc workar2(0),hexff   flip all the bits
         endif
         ni    workar2,x'0f'      clean top nibble in workarea
mdlcf38d mvo  WORKAREA,workar2(0)  CONVERT SOURCE FIELD
         ni workarea+l'workarea-1,x'f0'   clean the sign bits
         if tmll,r0,x'00f0',o     test to see if all ones
           oi workarea+l'workarea-1,x'0c' and set sign to X'c'
         else
           oi workarea+l'workarea-1,x'0d' and set sign to X'd'
         endif
         lmg   r0,r1,workarea     load into gp0/1
         cxstr fp1,r0             convert to DFP
MDLcf38e lghi  r15,*-*           Create biased exponent
         iextr fp1,fp1,r15       and insert
         cxtr  fp4,fp1
mdlcf38F jlu   *+l'*              BRANCH  TO   FALSE  IF NOT TRUE
mdlcf38T jlu   *+l'*              BRANCH  TO   TRUE  (OPTIONAL)
mdlcf38L EQU   *-mdlcf38
*
mdlcf38P EQU   0                  LITERAL POOL USAGE (EXCL FIELD LEN)
*
mdlcf38R DC    AL1(CSSRCloF),AL1(mdlcf38S+02-mdlcf38) FIELD  1  OFFSET
         DC    AL1(CSBYTMSS),AL1(mdlcf38A+01-mdlcf38) BYTE      MASK
         DC    AL1(CSSRCloF),AL1(mdlcf38A+02-mdlcf38) FIELD  1  OFFSET
         DC    AL1(CSdfpexps),AL1(mdlcf38se+02-mdlcf38) dfp exp
         DC    AL1(CStgtlof),AL1(mdlcf38_lA+02-mdlcf38) FIELD  1  OFF
         DC    AL1(CStgtLN),AL1(mdlcf38b+01-mdlcf38) TARGET    OFFSET
         DC    AL1(CStgtLN),AL1(mdlcf38c+01-mdlcf38) TARGET    OFFSET
         DC    AL1(CStgtLNR),AL1(mdlcf38d+01-mdlcf38) TARGET    LENGTH
         DC    AL1(CSdfpexp),AL1(mdlcf38e+02-mdlcf38) dfp exp
         DC    AL1(CSRELOPR),AL1(mdlcf38F+1-mdlcf38)  RELATIONAL CC
         DC    AL1(CSFALSEO),AL1(mdlcf38F+2-mdlcf38)  FALSE  BRANCH
         DC    AL1(CSTRUEO),AL1(mdlcf38T+2-mdlcf38)   TRUE   BRANCH
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        COMPARE FIELDS           (BINARY 8 - PACKED)                 *
***********************************************************************
mdlcf38_b8 LG  R0,0(0,0)          CONVERT BINARY FIELD
mdlcf38_b8la LAY R15,0(0,0)         get address
         Cxgtr fp4,r0
MDLcf38_b8se lghi  r14,*-*           Create biased exponent
         iextr fp4,fp4,r14       and insert
mdlcf38_b8b mvc   workar2(0),0(r15)  copy event field to workplace
         ic    r0,0(0,r15)        save first character into r0
         if tmll,r0,x'00f0',z     test to see if not ones
mdlcf38_b8c   xc workar2(0),hexff   flip all the bits
         endif
         ni    workar2,x'0f'      clean top nibble in workarea
mdlcf38_b8d mvo  WORKAREA,workar2(0)  CONVERT SOURCE FIELD
         ni workarea+l'workarea-1,x'f0'   clean the sign bits
         if tmll,r0,x'00f0',o     test to see if all ones
           oi workarea+l'workarea-1,x'0c' and set sign to X'c'
         else
           oi workarea+l'workarea-1,x'0d' and set sign to X'd'
         endif
         lmg   r0,r1,workarea     load into gp0/1
         cxstr fp1,r0             convert to DFP
MDLcf38_b8e lghi  r15,*-*           Create biased exponent
         iextr fp1,fp1,r15       and insert
         cxtr  fp4,fp1
mdlcf38_b8F jlu *+l'*             BRANCH  TO   FALSE  IF NOT TRUE
mdlcf38_b8T jlu *+l'*             BRANCH  TO   TRUE  (OPTIONAL)
mdlcf38_b8L EQU *-mdlcf38_b8
*
mdlcf38_b8P EQU 0                 LITERAL POOL USAGE (EXCL FIELD LEN)
*
mdlcf38_b8R ds 0h
         DC    AL1(CSsrclof),AL1(mdlcf38_b8+02-mdlcf38_b8) FIELD 1 OFF
         DC    AL1(CSdfpexps),AL1(mdlcf38_b8se+02-mdlcf38_b8) dfp exp
         DC    AL1(CStgtlof),AL1(mdlcf38_b8lA+02-mdlcf38_b8) FLD 1 OFF
         DC    AL1(CStgtLN),AL1(mdlcf38_b8b+01-mdlcf38_b8) TARGET OFF
         DC    AL1(CStgtLN),AL1(mdlcf38_b8c+01-mdlcf38_b8) TARGET OFF
         DC    AL1(CStgtLNR),AL1(mdlcf38_b8d+01-mdlcf38_b8) TARGET l
         DC    AL1(CSdfpexp),AL1(mdlcf38_b8e+02-mdlcf38_b8) dfp exp
         DC    AL1(CSRELOPR),AL1(mdlcf38_b8F+1-mdlcf38_b8) REL. CC
         DC    AL1(CSFALSEO),AL1(mdlcf38_b8F+2-mdlcf38_b8) FALSE BRANCH
         DC    AL1(CSTRUEO),AL1(mdlcf38_b8T+2-mdlcf38_b8) TRUE BRANCH
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        COMPARE FIELDS           (psort - bsort)                     *
***********************************************************************
mdlcf85  Xgr   R0,R0              CONVERT BINARY FIELD
mdlcf85_la LAY R15,0(0,0)         get address
mdlcf85s lay   r14,0(0,0)        CONVERT BINARY FIELD
mdlcf85m mvc   workarea(0),0(r14) move event field to workarea
         xi    workarea,x'80'      flip the top bit
         if tm,workarea,x'80',nz If negative ...
           lghi r0,-1              fill with 1's
         endif
mdlcf85A ICMy  R0,B'0000',workarea
         Cxgtr fp1,r0
MDLcf85e lghi  r14,*-*           Create biased exponent
         iextr fp1,fp1,r14       and insert
mdlcf85b mvc   workar2(0),0(r15)  copy event field to workplace
         ic    r0,0(0,r15)        save first character into r0
         if tmll,r0,x'00f0',z     test to see if not ones
mdlcf85c   xc workar2(0),hexff   flip all the bits
         endif
         ni    workar2,x'0f'      clean top nibble in workarea
mdlcf85d mvo   WORKAREA,workar2(0)  CONVERT SOURCE FIELD
         ni workarea+l'workarea-1,x'f0'   clean the sign bits
         if tmll,r0,x'00f0',o     test to see if all ones
           oi workarea+l'workarea-1,x'0c' and set sign to X'c'
         else
           oi workarea+l'workarea-1,x'0d' and set sign to X'd'
         endif
         lmg   r0,r1,workarea     load into gp0/1
         cxstr fp4,r0             convert to DFP
MDLcf85se lghi  r15,*-*           Create biased exponent
         iextr fp4,fp4,r15       and insert
         cxtr  fp4,fp1
mdlcf85F jlu   *+l'*              BRANCH  TO   FALSE  IF NOT TRUE
mdlcf85T jlu   *+l'*              BRANCH  TO   TRUE  (OPTIONAL)
mdlcf85L EQU   *-mdlcf85
*
mdlcf85P EQU   0                  LITERAL POOL USAGE (EXCL FIELD LEN)
*
mdlcf85R DC    AL1(CStgtloF),AL1(mdlcf85S+02-mdlcf85) FIELD  1  OFFSET
         DC    AL1(CSBYTMSk),AL1(mdlcf85A+01-mdlcf85) BYTE      MASK
         DC    AL1(CSdfpexp),AL1(mdlcf85e+02-mdlcf85) dfp exp
         DC    AL1(CSsrclof),AL1(mdlcf85_lA+02-mdlcf85) FIELD  1  OFF
         DC    AL1(CSsrcLN),AL1(mdlcf85b+01-mdlcf85) TARGET    OFFSET
         DC    AL1(CSsrcLN),AL1(mdlcf85c+01-mdlcf85) TARGET    OFFSET
         DC    AL1(CSsrcLNR),AL1(mdlcf85d+01-mdlcf85) TARGET    LENGTH
         DC    AL1(CSdfpexps),AL1(mdlcf85se+02-mdlcf85) dfp exp
         DC    AL1(CSRELOPR),AL1(mdlcf85F+1-mdlcf85)  RELATIONAL CC
         DC    AL1(CSFALSEO),AL1(mdlcf85F+2-mdlcf85)  FALSE  BRANCH
         DC    AL1(CSTRUEO),AL1(mdlcf85T+2-mdlcf85)   TRUE   BRANCH
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        COMPARE FIELDS           (BINARY 8 - PACKED)                 *
***********************************************************************
mdlcf85_b8 LAY   R14,0(0,0)         load source address
mdlcf85_b8la LAY R15,0(0,0)         get address
mdlcf85_b8m mvc workarea(0),0(r14) move source field to workarea
         xi    workarea,x'80'     flip the top bit
         LG    R0,workarea
         Cxgtr fp1,r0
MDLcf85_b8e lghi  r14,*-*           Create biased exponent
         iextr fp1,fp1,r14       and insert
mdlcf85_b8b mvc dblwork(0),0(r15) copy event field to workplace
         ic    r0,0(0,r15)        save first character into r0
         if tmll,r0,x'00f0',z     test to see if not ones
mdlcf85_b8c xc dblwork(0),hexff  flip all the bits
         endif
         ni    dblwork,x'0f'      clean top nibble in workarea
mdlcf85_b8d mvo WORKAREA,dblwork(0) CONVERT SOURCE FIELD
         ni workarea+l'workarea-1,x'f0'   clean the sign bits
         if tmll,r0,x'00f0',o     test to see if all ones
           oi workarea+l'workarea-1,x'0c' and set sign to X'c'
         else
           oi workarea+l'workarea-1,x'0d' and set sign to X'd'
         endif
         lmg   r0,r1,workarea     load into gp0/1
         cxstr fp4,r0             convert to DFP
MDLcf85_b8se lghi  r15,*-*           Create biased exponent
         iextr fp4,fp4,r15       and insert
         cxtr  fp4,fp1
mdlcf85_b8F jlu *+l'*             BRANCH  TO   FALSE  IF NOT TRUE
mdlcf85_b8T jlu *+l'*             BRANCH  TO   TRUE  (OPTIONAL)
mdlcf85_b8L EQU *-mdlcf85_b8
*
mdlcf85_b8P EQU 0                 LITERAL POOL USAGE (EXCL FIELD LEN)
*
mdlcf85_b8R ds 0h
         DC    AL1(CStgtlof),AL1(mdlcf85_b8+02-mdlcf85_b8) FIELD 1 OFF
         DC    AL1(CStgtLN),AL1(mdlcf85_b8m+01-mdlcf85_b8) TARGET OFF
         DC    AL1(CSdfpexp),AL1(mdlcf85_b8e+02-mdlcf85_b8) dfp exp
         DC    AL1(CSsrclof),AL1(mdlcf85_b8lA+02-mdlcf85_b8) FLD 1 OFF
         DC    AL1(CSsrcLN),AL1(mdlcf85_b8b+01-mdlcf85_b8) TARGET OFF
         DC    AL1(CSsrcLN),AL1(mdlcf85_b8c+01-mdlcf85_b8) TARGET OFF
         DC    AL1(CSsrcLNR),AL1(mdlcf85_b8d+01-mdlcf85_b8) TARGET l
         DC    AL1(CSdfpexps),AL1(mdlcf85_b8se+02-mdlcf85_b8) dfp exp
         DC    AL1(CSRELOPR),AL1(mdlcf85_b8F+1-mdlcf85_b8) REL. CC
         DC    AL1(CSFALSEO),AL1(mdlcf85_b8F+2-mdlcf85_b8) FALSE BRANCH
         DC    AL1(CSTRUEO),AL1(mdlcf85_b8T+2-mdlcf85_b8) TRUE BRANCH
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        COMPARE FIELDS           (CFEE Bsort - psort )               *
***********************************************************************
mdlcf39  lay   r14,0(0,0)        CONVERT BINARY FIELD
mdlcf39_la LAY R15,0(0,0)         get address
mdlcf39m mvc   workarea(0),0(r14) move event field to workarea
         Xgr   R0,R0              CONVERT BINARY FIELD
         xi    workarea,x'80'      flip the top bit
         if tm,workarea,x'80',nz If negative ...
           lghi r0,-1              fill with 1's
         endif
mdlcf39A ICMy  R0,B'0000',workarea
         Cxgtr fp4,r0
MDLcf39se lghi  r14,*-*           Create biased exponent
         iextr fp4,fp4,r14       and insert
mdlcf39b mvc   workar2(0),0(r15)  copy event field to workplace
         ic    r0,0(0,r15)        save first character into r0
         if tmll,r0,x'00f0',z     test to see if not ones
mdlcf39c   xc workar2(0),hexff   flip all the bits
         endif
         ni    workar2,x'0f'      clean top nibble in workarea
mdlcf39d mvo   WORKAREA,workar2(0)  CONVERT SOURCE FIELD
         ni workarea+l'workarea-1,x'f0'   clean the sign bits
         if tmll,r0,x'00f0',o     test to see if all ones
           oi workarea+l'workarea-1,x'0c' and set sign to X'c'
         else
           oi workarea+l'workarea-1,x'0d' and set sign to X'd'
         endif
         lmg   r0,r1,workarea     load into gp0/1
         cxstr fp1,r0             convert to DFP
MDLcf39e lghi  r15,*-*           Create biased exponent
         iextr fp1,fp1,r15       and insert
         cxtr  fp4,fp1
mdlcf39F jlu   *+l'*              BRANCH  TO   FALSE  IF NOT TRUE
mdlcf39T jlu   *+l'*              BRANCH  TO   TRUE  (OPTIONAL)
mdlcf39L EQU   *-mdlcf39
*
mdlcf39P EQU   0                  LITERAL POOL USAGE (EXCL FIELD LEN)
*
mdlcf39R DC    AL1(CSSRCloF),AL1(mdlcf39+02-mdlcf39) FIELD  1  OFFSET
         DC    AL1(CStgtlof),AL1(mdlcf39_lA+02-mdlcf39) FIELD  1  OFF
         DC    AL1(CSsrcln),AL1(MDLcf39m+01-MDLcf39)  length
         DC    AL1(CSBYTMSS),AL1(mdlcf39A+01-mdlcf39) BYTE      MASK
         DC    AL1(CSdfpexps),AL1(mdlcf39se+02-mdlcf39) dfp exp
         DC    AL1(CStgtLN),AL1(mdlcf39b+01-mdlcf39) TARGET    OFFSET
         DC    AL1(CStgtLN),AL1(mdlcf39c+01-mdlcf39) TARGET    OFFSET
         DC    AL1(CStgtLNR),AL1(mdlcf39d+01-mdlcf39) TARGET    LENGTH
         DC    AL1(CSdfpexp),AL1(mdlcf39e+02-mdlcf39) dfp exp
         DC    AL1(CSRELOPR),AL1(mdlcf39F+1-mdlcf39)  RELATIONAL CC
         DC    AL1(CSFALSEO),AL1(mdlcf39F+2-mdlcf39)  FALSE  BRANCH
         DC    AL1(CSTRUEO),AL1(mdlcf39T+2-mdlcf39)   TRUE   BRANCH
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        COMPARE FIELDS           (BINARY 8 - PACKED)                 *
***********************************************************************
mdlcf39_b8 LAY   R14,0(0,0)       load source address
mdlcf39_b8la LAY R15,0(0,0)         get address
mdlcf39_b8m mvc workarea(0),0(r14) move source field to workarea
         xi    workarea,x'80'     flip the top bit
         LG    R0,workarea
         Cxgtr fp4,r0
MDLcf39_b8se lghi  r14,*-*           Create biased exponent
         iextr fp4,fp4,r14       and insert
mdlcf39_b8b mvc workar2(0),0(r15) copy event field to workplace
         ic    r0,0(0,r15)        save first character into r0
         if tmll,r0,x'00f0',z     test to see if not ones
mdlcf39_b8c xc workar2(0),hexff  flip all the bits
         endif
         ni    workar2,x'0f'      clean top nibble in workarea
mdlcf39_b8d mvo   WORKAREA,workar2(0)  CONVERT SOURCE FIELD
         ni workarea+l'workarea-1,x'f0'   clean the sign bits
         if tmll,r0,x'00f0',o     test to see if all ones
           oi workarea+l'workarea-1,x'0c' and set sign to X'c'
         else
           oi workarea+l'workarea-1,x'0d' and set sign to X'd'
         endif
         lmg   r0,r1,workarea     load into gp0/1
         cxstr fp1,r0             convert to DFP
MDLcf39_b8e lghi  r15,*-*           Create biased exponent
         iextr fp1,fp1,r15       and insert
         cxtr  fp4,fp1
mdlcf39_b8F jlu *+l'*             BRANCH  TO   FALSE  IF NOT TRUE
mdlcf39_b8T jlu *+l'*             BRANCH  TO   TRUE  (OPTIONAL)
mdlcf39_b8L EQU *-mdlcf39_b8
*
mdlcf39_b8P EQU 0                 LITERAL POOL USAGE (EXCL FIELD LEN)
*
mdlcf39_b8R ds 0h
         DC    AL1(CSsrclof),AL1(mdlcf39_b8+02-mdlcf39_b8) FIELD 1 OFF
         DC    AL1(CStgtlof),AL1(mdlcf39_b8lA+02-mdlcf39_b8) FLD 1 OFF
         DC    AL1(CSsrcln),AL1(MDLcf39_b8m+01-MDLcf39_b8) length
         DC    AL1(CSdfpexps),AL1(mdlcf39_b8se+02-mdlcf39_b8) dfp exp
         DC    AL1(CSTGTLN),AL1(mdlcf39_b8B+01-mdlcf39_b8) FLD 2 L R/2
         DC    AL1(CStgtLN),AL1(mdlcf39_b8c+01-mdlcf39_b8) TARGET OFF
         DC    AL1(CStgtLNR),AL1(mdlcf39_b8d+01-mdlcf39_b8) TARGET l
         DC    AL1(CSdfpexp),AL1(mdlcf39_b8e+02-mdlcf39_b8) dfp exp
         DC    AL1(CSRELOPR),AL1(mdlcf39_b8F+1-mdlcf39_b8) REL. CC
         DC    AL1(CSFALSEO),AL1(mdlcf39_b8F+2-mdlcf39_b8) FALSE BRANCH
         DC    AL1(CSTRUEO),AL1(mdlcf39_b8T+2-mdlcf39_b8) TRUE BRANCH
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        COMPARE FIELDS           (pack    - BCD)                     *
***********************************************************************
mdlcf40  LAY R15,0(0,0)           get address
mdlcf40_la LAY R14,0(0,0)         get address
         MVI   workarea+L'workarea-1,X'0F' ADD SIGN NIBBLE 'F'
mdlcf40Q MVO   workarea,0(0,r15)  CONVERT BCD TO UNSIGNED PACKED
         lmg   r0,r1,workarea     load into gp0/1
         cxstr fp4,r0             convert to DFP
MDLcf40se lghi  r15,*-*           Create biased exponent
         iextr fp4,fp4,r15       and insert
mdlcf40b mvc   workar2(0),0(r14)  copy event field to workplace
         ic    r0,0(0,r14)        save first character into r0
         if tmll,r0,x'00f0',z     test to see if not ones
mdlcf40c   xc workar2(0),hexff   flip all the bits
         endif
         ni    workar2,x'0f'      clean top nibble in workarea
mdlcf40d mvo   WORKAREA,workar2(0)  CONVERT SOURCE FIELD
         ni workarea+l'workarea-1,x'f0'   clean the sign bits
         if tmll,r0,x'00f0',o     test to see if all ones
           oi workarea+l'workarea-1,x'0c' and set sign to X'c'
         else
           oi workarea+l'workarea-1,x'0d' and set sign to X'd'
         endif
         lmg   r0,r1,workarea     load into gp0/1
         cxstr fp1,r0             convert to DFP
MDLcf40e lghi  r15,*-*           Create biased exponent
         iextr fp1,fp1,r15       and insert
         cxtr  fp4,fp1
mdlcf40F jlu   *+l'*              BRANCH  TO   FALSE IF  NOT TRUE
mdlcf40T jlu   *+l'*              BRANCH  TO   TRUE (OPTIONAL)
mdlcf40L EQU   *-mdlcf40
*
mdlcf40P EQU   0                  LITERAL POOL USAGE (EXCL FIELD LEN)
*
mdlcf40R DC    AL1(CSSRClof),AL1(mdlcf40+02-mdlcf40)  FIELD  1  OFF
         DC    AL1(CStgtlof),AL1(mdlcf40_lA+02-mdlcf40) FIELD  2  OFF
         DC    AL1(CSSRCLNr),AL1(mdlcf40Q+01-mdlcf40) FIELD  2  LEN L/2
         DC    AL1(CSdfpexps),AL1(mdlcf40se+02-mdlcf40) dfp exp
         DC    AL1(CStgtLN),AL1(mdlcf40b+01-mdlcf40) TARGET    OFFSET
         DC    AL1(CStgtLN),AL1(mdlcf40c+01-mdlcf40) TARGET    OFFSET
         DC    AL1(CStgtLNR),AL1(mdlcf40d+01-mdlcf40) TARGET    LENGTH
         DC    AL1(CSdfpexp),AL1(mdlcf40e+02-mdlcf40) dfp exp
         DC    AL1(CSRELOPR),AL1(mdlcf40F+1-mdlcf40)  RELATIONAL CC
         DC    AL1(CSFALSEO),AL1(mdlcf40F+2-mdlcf40)  FALSE  BRANCH
         DC    AL1(CSTRUEO),AL1(mdlcf40T+2-mdlcf40)   TRUE   BRANCH
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        COMPARE FIELDS           (pack    - sortp )                 *
***********************************************************************
mdlcf66  LAY R14,0(0,0)           get address
mdlcf66_la LAY R15,0(0,0)         get address
         MVI   WORKAR2+L'WORKAR2-1,X'0F' ADD SIGN NIBBLE 'F'
mdlcf66Q MVO   WORKAR2,0(0,r15)   CONVERT BCD TO UNSIGNED PACKED
         lmg   r0,r1,workar2
         cxstr fp1,r0             convert to dfp
MDLcf66d lghi  r15,*-*            Create biased exponent
         iextr fp1,fp1,r15       and insert
mdlcf66b mvc   workar2(0),0(r14)  copy event field to workplace
         ic    r0,0(0,r14)        save first character into r0
         if tmll,r0,x'00f0',z     test to see if not ones
mdlcf66c   xc workar2(0),hexff   flip all the bits
         endif
         ni    workar2,x'0f'      clean top nibble in workarea
mdlcf66s mvo   WORKAREA,workar2(0)  CONVERT SOURCE FIELD
         ni workarea+l'workarea-1,x'f0'     clean the sign bits
         if tmll,r0,x'00f0',o     test to see if all ones
           oi workarea+l'workarea-1,x'0c'   and set sign to X'c'
         else
           oi workarea+l'workarea-1,x'0d'   and set sign to X'd'
         endif
         lmg   r0,r1,workarea
         cxstr fp4,r0             convert to dfp
MDLcf66e lghi  r15,*-*            Create biased exponent
         iextr fp4,fp4,r15       and insert
         cxtr  fp4,fp1           COMPARE TWO  FIELDS
mdlcf66F jlu   *+l'*              BRANCH  TO   FALSE IF  NOT TRUE
mdlcf66T jlu   *+l'*              BRANCH  TO   TRUE (OPTIONAL)
mdlcf66L EQU   *-mdlcf66
*
mdlcf66P EQU   0                  LITERAL POOL USAGE (EXCL FIELD LEN)
*
mdlcf66R DC    AL1(CSSRClof),AL1(mdlcf66+02-mdlcf66)  FIELD  1  OFF
         DC    AL1(CStgtlof),AL1(mdlcf66_lA+02-mdlcf66) FIELD  2  OFF
         DC    AL1(CStgtLNr),AL1(mdlcf66Q+01-mdlcf66) FIELD  2  LEN L/2
         DC    AL1(CSsrcLN),AL1(mdlcf66b+01-mdlcf66) TARGET    OFFSET
         DC    AL1(CSsrcLN),AL1(mdlcf66c+01-mdlcf66) TARGET    OFFSET
         DC    AL1(CSsrcLNR),AL1(mdlcf66s+01-mdlcf66) TARGET    LENGTH
         DC    AL1(CSdfpexp),AL1(MDLcf66d+02-MDLcf66) dfp exp
         DC    AL1(CSdfpexps),AL1(MDLcf66e+02-MDLcf66) dfp exp
         DC    AL1(CSRELOPR),AL1(mdlcf66F+1-mdlcf66)  RELATIONAL CC
         DC    AL1(CSFALSEO),AL1(mdlcf66F+2-mdlcf66)  FALSE  BRANCH
         DC    AL1(CSTRUEO),AL1(mdlcf66T+2-mdlcf66)   TRUE   BRANCH
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        COMPARE FIELDS           (TEMPORARY FIELD)                   *
***********************************************************************
MDLCF24  LAY   R14,0(,R2)         LOAD ACCUMULATOR ADDR (CHG'D TO "LY")
MDLcf24_la LAY R15,0(0,0)         get address
MDLCF24C CLC   0(0,r15),0(R14)    COMPARE EVNT FIELD AGAINST LOW  VAL
MDLCF24F jlu   *+l'*              BRANCH  TO   FALSE IF  NOT GREATER
MDLCF24T jlu   *+l'*              BRANCH  TO   TRUE (OPTIONAL)
MDLCF24L EQU   *-MDLCF24
*
MDLCF24P EQU   4+4                LITERAL POOL USAGE (EXCL FIELD LEN)
*
MDLCF24R DC    AL1(CSACCOF2),AL1(MDLCF24+02-MDLCF24)  VALUE  2  OFF
         DC    AL1(CStgtlof),AL1(MDLcf24_lA+02-MDLcf24) FIELD  2  OFF
         DC    AL1(CSTGTLN),AL1(MDLCF24C+01-MDLCF24)  FIELD  1  LENGTH
         DC    AL1(CSRELOPR),AL1(MDLCF24F+1-MDLCF24)  RELATIONAL CC
         DC    AL1(CSFALSEO),AL1(MDLCF24F+2-MDLCF24)  FALSE  BRANCH
         DC    AL1(CSTRUEO),AL1(MDLCF24T+2-MDLCF24)   TRUE   BRANCH
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        compare edit to sortp                                        *
***********************************************************************
mdlcf33  LAY   R4,0(0,0)           get address
mdlcf33s llgt  R5,0(,R2)          load logic table row address
         LA    R1,workar2
mdlcf33bb BAS   R10,*-*            CALL "GVBDL96"  (FORMAT  FIELD)
mdlcf33A jlu   *+l'*              FORMAT UNSUCCESSFUL BRANCH (FALSE)
*        do NOT use R14 here as it gets NOPed out
         ld    fp4,workar2        load first operand into fp4/6
         ld    fp6,workar2+8
mdlcf33b mvc   workar2(0),0(r4)   copy event field to workplace
         ic    r0,0(0,r4)         save first character into r0
         if tmll,r0,x'00f0',z     test to see if not ones
mdlcf33c   xc workar2(0),hexff   flip all the bits
         endif
         ni    workar2,x'0f'      clean top nibble in workarea
mdlcf33d mvo   WORKAREA,workar2(0)  CONVERT SOURCE FIELD
         ni workarea+l'workarea-1,x'f0'     clean the sign bits
         if tmll,r0,x'00f0',o     test to see if all ones
           oi workarea+l'workarea-1,x'0c'   and set sign to X'c'
         else
           oi workarea+l'workarea-1,x'0d'   and set sign to X'd'
         endif
         lmg   r0,r1,workarea
         cxstr fp1,r0
MDLcf33e lghi  r15,*-*           Create biased exponent
         iextr fp1,fp1,r15       and insert
         cxtr  fp4,fp1            COMPARE TWO  FIELDS
mdlcf33F jlu   *+l'*              BRANCH  TO   FALSE IF  NOT TRUE
mdlcf33T jlu   *+l'*              BRANCH  TO   TRUE (OPTIONAL)
mdlcf33L EQU   *-mdlcf33
*
mdlcf33P EQU   4                  LITERAL POOL USAGE (EXCL FIELD LEN)
*
                        SPACE 3
mdlcf33r DC    AL1(CStgtlof),AL1(mdlcf33+02-mdlcf33) source  OFFSET
         DC    AL1(CSltroff),AL1(mdlcf33s+02-mdlcf33)  TARGET    OFFSET
         DC    AL1(CSdl96calln),AL1(MDLcf33bb-MDLcf33) MR96 BAS
         DC    AL1(CSFALSEO),AL1(mdlcf33A+2-mdlcf33)  FALSE  BRANCH
         DC    AL1(CStgtLN),AL1(mdlcf33b+01-mdlcf33) TARGET    OFFSET
         DC    AL1(CStgtLN),AL1(mdlcf33c+01-mdlcf33) TARGET    OFFSET
         DC    AL1(CStgtLNR),AL1(mdlcf33d+01-mdlcf33) TARGET    LENGTH
         DC    AL1(CSdfpexp),AL1(MDLcf33e+02-MDLcf33) dfp exp
         DC    AL1(CSRELOPR),AL1(mdlcf33F+1-mdlcf33)  RELATIONAL CC
         DC    AL1(CSFALSEO),AL1(mdlcf33F+2-mdlcf33)  FALSE  BRANCH
         DC    AL1(CSTRUEO),AL1(mdlcf33T+2-mdlcf33)   TRUE   BRANCH
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        COMPARE FIELDS           EDITED/MASKED NUMERIC TO CONSTANT   *
***********************************************************************
MDLCF57  llgt  R5,0(,R2)          LOAD LOGIC  TABLE  ROW ADDRESS
         LA    R1,WORKAREA
mdlcf57bb BAS   R10,*-*            CALL "GVBDL96"  (FORMAT  FIELD)
MDLCF57A jlu   *+l'*              FORMAT UNSUCCESSFUL BRANCH (FALSE)
         ld    fp4,workarea       load first operand into fp4/6
         ld    fp6,workarea+8
MDLCF57B LAY   R14,0(,R2)                             COMPARE VALUES
         ld    fp1,0(,r14)        load first operand into fp4/6
         ld    fp3,8(,r14)
         cxtr  fp4,fp1            COMPARE VALUES
MDLCF57F jlu   *+l'*              BRANCH  TO   FALSE  IF  NOT TRUE
MDLCF57T jlu   *+l'*              BRANCH  TO   TRUE  (OPTIONAL)
MDLCF57L EQU   *-MDLCF57
*
MDLCF57P EQU   4                  LITERAL POOL USAGE (EXCL FIELD LEN)
*
MDLCF57R DC    AL1(CSLTROFF),AL1(MDLCF57+02-MDLCF57)  LOGIC TBL ROW ADR
         DC    AL1(CSdl96calln),AL1(MDLcf57bb-MDLcf57) MR96 BAS
         DC    AL1(CSFALSEO),AL1(MDLCF57A+2-MDLCF57)  FALSE  BRANCH
         DC    AL1(CSV1OFF),AL1(MDLCF57B+02-MDLCF57)  CONSTANT  OFFSET
         DC    AL1(CSRELOPR),AL1(MDLCF57F+1-MDLCF57)  RELATIONAL CC
         DC    AL1(CSFALSEO),AL1(MDLCF57F+2-MDLCF57)  FALSE  BRANCH
         DC    AL1(CSTRUEO),AL1(MDLCF57T+2-MDLCF57)   TRUE   BRANCH
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        COMPARE FIELDS           EDITED/MASKED NUMERIC TO CONSTANT   *
***********************************************************************
mdlcfx7  llgt  R5,0(,R2)          LOAD LOGIC  TABLE  ROW ADDRESS
         LA    R1,WORKAREA
mdlcfx7bb BAS   R10,*-*            CALL "GVBDL96"  (FORMAT  FIELD)
mdlcfx7A jlu   *+l'*              FORMAT UNSUCCESSFUL BRANCH (FALSE)
         ld    fp4,workarea       load Ednum operand into fp4/6
         ld    fp6,workarea+8
mdlcfx7B LAY   R14,0(,R2)                             COMPARE VALUES
         ld    fp1,0(,r14)        load const operand into fp1/3
         ld    fp3,8(,r14)
         cxtr  fp1,fp4            COMPARE VALUES
mdlcfx7F jlu   *+l'*              BRANCH  TO   FALSE  IF  NOT TRUE
mdlcfx7T jlu   *+l'*              BRANCH  TO   TRUE  (OPTIONAL)
mdlcfx7L EQU   *-mdlcfx7
*
mdlcfx7P EQU   4                  LITERAL POOL USAGE (EXCL FIELD LEN)
*
mdlcfx7R DC    AL1(CSLTROFF),AL1(mdlcfx7+02-mdlcfx7)  LOGIC TBL ROW ADR
         DC    AL1(CSdl96calln_r),AL1(mdlcfx7bb-mdlcfx7) MR96 BAS
         DC    AL1(CSFALSEO),AL1(mdlcfx7A+2-mdlcfx7)  FALSE  BRANCH
         DC    AL1(CSV1OFFr),AL1(mdlcfx7B+02-mdlcfx7)  CONSTANT  OFFSET
         DC    AL1(CSRELOPR),AL1(mdlcfx7F+1-mdlcfx7)  RELATIONAL CC
         DC    AL1(CSFALSEO),AL1(mdlcfx7F+2-mdlcfx7)  FALSE  BRANCH
         DC    AL1(CSTRUEO),AL1(mdlcfx7T+2-mdlcfx7)   TRUE   BRANCH
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        COMPARE FIELDS           (NORMALIZED DATE COMPARISON)
***********************************************************************
MDLCF59  LAy   R0,0(,0)           LOAD  LOOKUP DATE   ADDRESS
MDLCF59A LAY   R1,0(,R2)          LOAD ACCUMULATOR ADDR (CHG'D TO "LY")
MDLCF59B llgt  R5,0(,R2)          LOAD LOGIC  TABLE  ROW ADDRESS
         BAS   R10,DATECMP0_indirect NORMALIZE AND  COMPARE DATES
         CLC   LKUPKEY+8(8),LKUPKEY+0    COMPARE   NORMALIZED DATES
MDLCF59F jlu   *+l'*              BRANCH TO    FALSE  IF  NOT TRUE
MDLCF59T jlu   *+l'*              BRANCH TO    TRUE
MDLCF59L EQU   *-MDLCF59
*
MDLCF59P EQU   4                  LITERAL POOL USAGE (EXCL FIELD LEN)
*
MDLCF59R DC    AL1(CSTGTloF),AL1(MDLCF59+02-MDLCF59)  TARGET OFFSET
         DC    AL1(CSACCOF2),AL1(MDLCF59A+02-MDLCF59) VALUE  2  OFF
         DC    AL1(CSLTROFF),AL1(MDLCF59B+02-MDLCF59) LOGIC  TABLE ROW
         DC    AL1(CSRELOPR),AL1(MDLCF59F+1-MDLCF59)  RELATIONAL CC
         DC    AL1(CSFALSEM),AL1(MDLCF59F+02-MDLCF59) FALSE  BRANCH
         DC    AL1(CSTRUEO),AL1(MDLCF59T+02-MDLCF59)  TRUE   BRANCH
         DC   2XL1'FF'
                        EJECT
***********************************************************************
*        CLASS TEST - SPACES      (CHARACTER)                         *
***********************************************************************
MDLcf60  LAY   R15,0(0,0)         get address
MDLCF60C CLC   0(0,R15),SPACES     COMPARE
MDLCF60F jlNE  *+l'*              BRANCH  TO   FALSE IF INVALID
MDLCF60T jlu   *+l'*              BRANCH  TO   TRUE  (OPTIONAL)
MDLCF60L EQU   *-MDLCF60
*
MDLCF60P EQU   0                  LITERAL POOL USAGE (EXCL FIELD LEN)
*
MDLCF60R DC    AL1(CSSRCLN),AL1(MDLCF60c+01-MDLCF60)   FIELD  1  LEN
         DC    AL1(CSSRClof),AL1(MDLcf60+02-MDLcf60) FIELD  1  OFF
         DC    AL1(CSFALSEO),AL1(MDLCF60F+2-MDLCF60)  FALSE  BRANCH
         DC    AL1(CSTRUEO),AL1(MDLCF60T+2-MDLCF60)   TRUE   BRANCH
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        CLASS TEST - NUMERIC     (CHARACTER)                         *
***********************************************************************
MDLCF61  llgt  R14,0(0,R2)        LOAD    TRANSLATE  TABLE ADDRESS
         lgr   R0,R2              SAVE GENERATED CODE BASE REGISTER
         xgr   R2,R2              CLEAR FUNCTION CODE REGISTER
MDLcf61_la LAY R15,0(0,0)         get address
MDLCF61C TRT   0(0,R15),0(R14)    SCAN    STRING FOR INVALID BYTES
         lgr   R1,R2              SAVE  FUNCTION CODE
         lgr   R2,R0              RESTORE BASE REGISTER
MDLCF61D jlL   *+l'*              BRANCH  TO   FALSE IF INVALID
         CHI   R1,4               VALID   SIGN BYTE  IN LAST POSITION
MDLCF61F jlH   *+l'*              BRANCH  TO   FALSE IF INVALID
MDLCF61T jlu   *+l'*              BRANCH  TO   TRUE  (OPTIONAL)
MDLCF61L EQU   *-MDLCF61
*
MDLCF61P EQU   4                  LITERAL POOL USAGE (EXCL FIELD LEN)
*
MDLCF61R DC    AL1(CSTRTTBL),AL1(MDLCF61+02-MDLCF61) "TRT"  TABLE
         DC    AL1(CSSRClof),AL1(MDLcf61_lA+02-MDLcf61) FIELD  1  OFF
         DC    AL1(CSSRCLN),AL1(MDLCF61C+01-MDLCF61)  FIELD  1  LEN
         DC    AL1(CSFALSEM),AL1(MDLCF61D+2-MDLCF61)  FALSE  BRANCH
         DC    AL1(CSFALSEO),AL1(MDLCF61F+2-MDLCF61)  FALSE  BRANCH
         DC    AL1(CSTRUEO),AL1(MDLCF61T+2-MDLCF61)   TRUE   BRANCH
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        CLASS TEST - NUMERIC     (PACKED)                            *
***********************************************************************
MDLCF62  llgt  R14,0(0,R2)        LOAD    TRANSLATE  TABLE ADDRESS
         lgr   R0,R2              SAVE GENERATED CODE BASE REGISTER
         xgr   R2,R2              CLEAR FUNCTION CODE REGISTER
MDLcf62_la LAY R15,0(0,0)         get address
MDLCF62C TRT   0(0,R15),0(R14)    SCAN    STRING FOR INVALID BYTES
         lgr   R1,R2              SAVE  FUNCTION CODE
         lgr   R2,R0              RESTORE BASE REGISTER
MDLCF62D jlC   12,*+l'*           BRANCH  TO   FALSE IF INVALID
         CHI   R1,4               VALID   SIGN BYTE  IN LAST POSITION
MDLCF62F jlNE  *+l'*              BRANCH  TO   FALSE IF INVALID
MDLCF62T jlu   *+l'*              BRANCH  TO   TRUE  (OPTIONAL)
MDLCF62L EQU   *-MDLCF62
*
MDLCF62P EQU   4                  LITERAL POOL USAGE (EXCL FIELD LEN)
*
MDLCF62R DC    AL1(CSTRTTBL),AL1(MDLCF62+02-MDLCF62) "TRT"  TABLE
         DC    AL1(CSSRClof),AL1(MDLcf62_lA+02-MDLcf62) FIELD  1  OFF
         DC    AL1(CSSRCLN),AL1(MDLCF62C+01-MDLCF62)  FIELD  1  LEN
         DC    AL1(CSFALSEM),AL1(MDLCF62D+02-MDLCF62) FALSE  BRANCH
         DC    AL1(CSFALSEM),AL1(MDLCF62F+02-MDLCF62) FALSE  BRANCH
         DC    AL1(CSTRUEO),AL1(MDLCF62T+02-MDLCF62)  TRUE   BRANCH
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        CLASS TEST - NULLS                                           *
***********************************************************************
MDLcf63  LAY   R15,0(0,0)         get address
MDLCF63C OC    0(0,r15),0(r15)    COMPARE
MDLCF63F jlNE  *+l'*              BRANCH  TO   FALSE IF INVALID
MDLCF63T jlu   *+l'*              BRANCH  TO   TRUE  (OPTIONAL)
MDLCF63L EQU   *-MDLCF63
*
MDLCF63P EQU   0                  LITERAL POOL USAGE (EXCL FIELD LEN)
*
MDLCF63R DC    AL1(CSSRCLN),AL1(MDLCF63C+01-MDLCF63)   FIELD  1  LEN
         DC    AL1(CSSRClof),AL1(MDLcf63+02-MDLcf63) FIELD  1  OFF
         DC    AL1(CSFALSEO),AL1(MDLCF63F+2-MDLCF63)  FALSE  BRANCH
         DC    AL1(CSTRUEO),AL1(MDLCF63T+2-MDLCF63)   TRUE   BRANCH
         DC   2XL1'FF'
                        SPACE 3

***********************************************************************
*        COMPARE FIELDS           (TEMPORARY AN   /TEMPORARY AN   )   *
***********************************************************************
MDLCF70  LAY   R14,0(,R2)         LOAD ACCUMULATOR ADDR (CHG'D TO "LY")
MDLCF70A LAY   R15,0(,R2)         LOAD ACCUMULATOR ADDR (CHG'D TO "LY")
MDLCF70C CLC   0(256,R14),0(R15)  COMPARE TEMP FIELD AGAINST TEMP FIELD
MDLCF70F jlu   *+l'*              BRANCH  TO   FALSE IF  NOT GREATER
MDLCF70T jlu   *+l'*              BRANCH  TO   TRUE (OPTIONAL)
MDLCF70L EQU   *-MDLCF70
*
MDLCF70P EQU   4+4                LITERAL POOL USAGE (EXCL FIELD LEN)
*
MDLCF70R DC    AL1(CSACCOFF),AL1(MDLCF70+02-MDLCF70)  VALUE  1  OFF
         DC    AL1(CSACCOF2),AL1(MDLCF70A+02-MDLCF70) VALUE  2  OFF
         DC    AL1(CSRELOP2),AL1(MDLCF70F+1-MDLCF70)  RELATIONAL CC
         DC    AL1(CSFALSEO),AL1(MDLCF70F+2-MDLCF70)  FALSE  BRANCH
         DC    AL1(CSTRUEO),AL1(MDLCF70T+2-MDLCF70)   TRUE   BRANCH
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        COMPARE FIELDS           (TEMPORARY PK   /TEMPORARY PK   )   *
***********************************************************************
MDLCF71  LAY   R14,0(,R2)         LOAD ACCUMULATOR ADDR (CHG'D TO "LY")
MDLCF71A LAY   R15,0(,R2)         LOAD ACCUMULATOR ADDR (CHG'D TO "LY")
MDLCF71C CP    0(L'COLDATA,R14),0(L'COLDATA,R15)  ACCUM  VS  ACCUM
MDLCF71F jlu   *+l'*              BRANCH  TO   FALSE IF  NOT GREATER
MDLCF71T jlu   *+l'*              BRANCH  TO   TRUE (OPTIONAL)
MDLCF71L EQU   *-MDLCF71
*
MDLCF71P EQU   4+4                LITERAL POOL USAGE (EXCL FIELD LEN)
*
MDLCF71R DC    AL1(CSACCOFF),AL1(MDLCF71+02-MDLCF71)  ACCUM  1  OFF
         DC    AL1(CSACCOF2),AL1(MDLCF71A+02-MDLCF71) ACCUM  2  OFF
         DC    AL1(CSRELOP2),AL1(MDLCF71F+1-MDLCF71)  RELATIONAL CC
         DC    AL1(CSFALSEO),AL1(MDLCF71F+2-MDLCF71)  FALSE  BRANCH
         DC    AL1(CSTRUEO),AL1(MDLCF71T+2-MDLCF71)   TRUE   BRANCH
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        COMPARE FIELDS           (TEMPORARY BIN  /TEMPORARY BIN  )   *
***********************************************************************
MDLCF72  LAY   R14,0(,R2)         LOAD ACCUMULATOR ADDR (CHG'D TO "LY")
MDLCF72A LAY   R15,0(,R2)         LOAD ACCUMULATOR ADDR (CHG'D TO "LY")
         Xgr   R0,R0              LOAD BINARY  FIELD
MDLCF72B TM    0(R14),X'80'
         if (o)
           lghi  r0,-1              fill with 1's
         endif
MDLCF72C ICM   R0,B'0000',0(R14)
         cxgtr fp1,r0
mdlcf72se lghi r14,*-*
         iextr fp1,fp1,r14
         Xgr   R1,R1              LOAD BINARY FIELD
MDLCF72D TM    0(R15),X'80'
         if (o)
           lghi  r1,-1              fill with 1's
         endif
MDLCF72E ICM   R1,B'0000',0(R15)
         cxgtr fp4,r1
mdlcf72te lghi r15,*-*
         iextr fp4,fp4,r15
         cxtr  fp1,fp4            COMPARE TWO  VALUES
MDLCF72F jlu   *+l'*              BRANCH  TO   FALSE IF  NOT GREATER
MDLCF72T jlu   *+l'*              BRANCH  TO   TRUE (OPTIONAL)
MDLCF72L EQU   *-MDLCF72
*
MDLCF72P EQU   4+4                LITERAL POOL USAGE (EXCL FIELD LEN)
*
MDLCF72R DC    AL1(CSACCOFF),AL1(MDLCF72+02-MDLCF72)  ACCUM  1  OFF
         DC    AL1(CSACCOF2),AL1(MDLCF72A+02-MDLCF72) ACCUM  2  OFF
         DC    AL1(CSACCOFF),AL1(MDLCF72B+02-MDLCF72) ACCUM  1  OFF
         DC    AL1(CSBYTMSS),AL1(MDLCF72C+01-MDLCF72) BYTE   1  MASK
         DC    AL1(CSACCOF2),AL1(MDLCF72D+02-MDLCF72) ACCUM  2  OFF
         DC    AL1(CSBYTMSK),AL1(MDLCF72E+01-MDLCF72) BYTE   2  MASK
         DC    AL1(CSdfpexps),AL1(MDLcf72se+02-MDLcf72) dfpexp
         DC    AL1(CSdfpexp),AL1(MDLcf72te+02-MDLcf72)  dfpexp
         DC    AL1(CSRELOP2),AL1(MDLCF72F+1-MDLCF72)  RELATIONAL CC
         DC    AL1(CSFALSEO),AL1(MDLCF72F+2-MDLCF72)  FALSE  BRANCH
         DC    AL1(CSTRUEO),AL1(MDLCF72T+2-MDLCF72)   TRUE   BRANCH
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        COMPARE FIELDS           (TEMPORARY BIN  /TEMPORARY BIN  )   *
***********************************************************************
MDLcf72_b8 LAY R14,0(,R2)         LOAD ACCUMULATOR ADDR (CHG'D TO "LY")
MDLcf72_b8A LAY R15,0(,R2)        LOAD ACCUMULATOR ADDR (CHG'D TO "LY")
         LG    R0,0(,R14)
         cxgtr fp1,r0
mdlcf72_b8se lghi r14,*-*
         iextr fp1,fp1,r14
         LG    R1,0(,R15)
         cxgtr fp4,r1
mdlcf72_b8te lghi r15,*-*
         iextr fp4,fp4,r15
         cxtr  fp1,fp4            COMPARE TWO  VALUES
MDLcf72_b8F jlu *+l'*             BRANCH  TO   FALSE IF  NOT GREATER
MDLcf72_b8T jlu *+l'*             BRANCH  TO   TRUE (OPTIONAL)
MDLcf72_b8L EQU *-MDLcf72_b8
*
MDLcf72_b8P EQU 4+4               LITERAL POOL USAGE (EXCL FIELD LEN)
*
MDLcf72_b8R DC AL1(CSACCOFF),AL1(MDLcf72_b8+02-MDLcf72_b8) ACC1 OFF
         DC    AL1(CSACCOF2),AL1(MDLcf72_b8A+02-MDLcf72_b8) ACC2 OFF
         DC    AL1(CSdfpexps),AL1(MDLcf72_b8se+02-MDLcf72_b8) dfpexp
         DC    AL1(CSdfpexp),AL1(MDLcf72_b8te+02-MDLcf72_b8)  dfpexp
         DC    AL1(CSRELOP2),AL1(MDLcf72_b8F+1-MDLcf72_b8) RELA CC
         DC    AL1(CSFALSEO),AL1(MDLcf72_b8F+2-MDLcf72_b8) FALSE BRANCH
         DC    AL1(CSTRUEO),AL1(MDLcf72_b8T+2-MDLcf72_b8) TRUE BRANCH
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        COMPARE ACCUMULATOR - EVENT   BCD                            *
***********************************************************************
MDLCF73  LAY   R14,0(,R2)         LOAD ACCUMULATOR ADDR (CHG'D TO "LY")
MDLcf73A LAY   R15,0(,0)          LOAD SOURCE  FLD ADDRESS
MDLcf73B mvo   WORKAREA,0(0,R15)  CONVERT SOURCE FIELD
         oi workarea+l'workarea-1,x'0F'     and set sign to X'f'
         lmg   r0,r1,workarea
         cxstr fp1,r0
MDLcf73C lghi  r15,*-*           Create biased exponent
         iextr fp1,fp1,r15       and insert
mdlcf73d ld    fp0,0(0,r14)
         ld    fp2,8(0,r14)
         cxtr  fp1,fp0
MDLCF73F jlu   *+l'*              BRANCH  TO   FALSE IF  NOT GREATER
MDLCF73T jlu   *+l'*              BRANCH  TO   TRUE (OPTIONAL)
MDLCF73L EQU   *-MDLCF73
*
MDLCF73P EQU   4+4                LITERAL POOL USAGE (EXCL FIELD LEN)
*
MDLCF73R DC    AL1(CSaccof2),AL1(MDLCF73+02-MDLCF73)  accum2 off
         DC    AL1(CSTGTLOF),AL1(MDLcf73A+02-MDLcf73) TARGET    OFFSET
         DC    AL1(CSTGTLNR),AL1(MDLcf73B+01-MDLcf73) TARGET    LENGTH
         DC    AL1(CSdfpexp),AL1(MDLcf73C+02-MDLcf73) dfp exp
         DC    AL1(CSdfpopt),AL1(MDLcf73d-MDLcf73) optimise loads
         DC    AL1(CSRELOPR),AL1(MDLCF73F+1-MDLCF73)  RELATIONAL CC
         DC    AL1(CSFALSEM),AL1(MDLCF73F+02-MDLCF73) FALSE    BRANCH
         DC    AL1(CSTRUEO),AL1(MDLCF73T+02-MDLCF73)  TRUE     BRANCH
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        COMPARE FIELDS           (DFP / DFP)                         *
***********************************************************************
mdlcf74  LAY   R14,0(,R2)         LOAD ACCUMULATOR ADDR (CHG'D TO "LY")
mdlcf74A LAY   R15,0(,R2)         LOAD ACCUMULATOR ADDR (CHG'D TO "LY")
mdlcf74d ld    fp0,0(0,r14)
         ld    fp2,8(0,r14)
         ld    fp4,0(0,r15)
         ld    fp6,8(0,r15)
         cxtr  fp0,fp4
mdlcf74F jlu   *+l'*              BRANCH  TO   FALSE IF  NOT GREATER
mdlcf74T jlu   *+l'*              BRANCH  TO   TRUE (OPTIONAL)
mdlcf74L EQU   *-mdlcf74
*
mdlcf74P EQU   4+4                LITERAL POOL USAGE (EXCL FIELD LEN)
*
mdlcf74R DC    AL1(CSACCOFF),AL1(mdlcf74+02-mdlcf74)  ACCUM  1  OFF
         DC    AL1(CSACCOF2),AL1(mdlcf74A+02-mdlcf74) ACCUM  2  OFF
         DC    AL1(CSdfpopt),AL1(mdlcf74d-mdlcf74) optimise loads
         DC    AL1(CSRELOP2),AL1(mdlcf74F+1-mdlcf74)  RELATIONAL CC
         DC    AL1(CSFALSEO),AL1(mdlcf74F+2-mdlcf74)  FALSE  BRANCH
         DC    AL1(CSTRUEO),AL1(mdlcf74T+2-mdlcf74)   TRUE   BRANCH
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        DAYS/MONTHS/YEARS BETWEEN                                    *
***********************************************************************
MDLfncc  llgt  R5,0(,R2)          LOAD LOGIC  TABLE  ROW ADDRESS
MDLfnccA LAY   R4,0(,R2)          LOAD ACCUMULATOR ADDR (CHG'D TO "LY")
         bas   r10,fnccsub_indirect branch to calculation routine
MDLfnccL EQU   *-MDLfncc
*
MDLfnccP EQU   4+4+4              LITERAL POOL USAGE (EXCL FIELD LEN)
*
MDLfnccR DC    AL1(CSLTROFF),AL1(MDLfncc+02-MDLfncc) LOGIC TBL ROW ADDR
         DC    AL1(CSACCOF2),AL1(MDLfnccA+02-MDLfncc)  ACCUMULATOR ADDR
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        DAYS/MONTHS/YEARS BETWEEN                                    *
***********************************************************************

mdlfnxc  LAY   R14,0(0,0)         get address - must be 1st inst in    +
                                  model so that we get r5 on lookups
mDLFNxclt llgt  R5,0(,R2)         LOAD LOGIC  TABLE  ROW ADDRESS
mdlfnxca LAY   R4,0(,R2)          LOAD ACCUMULATOR ADDR (CHG'D TO "LY")
MDLFNxcb LAY   R15,0(,R2)         Compare constant
         bas   r10,fnxcsub_indirect branch to calculation routine
MDLFNxcL EQU   *-mdlfnxc
*
MDLFNxcP EQU   4+4                LITERAL POOL USAGE (EXCL FIELD LEN)
*
MDLFNxcR DC    AL1(CSSRCloF),AL1(MDLfnxc+02-MDLfnxc) FIELD 1  OFF  ADDR
         DC    AL1(CSLTROFF),AL1(mdlfnxclt+02-mdlfnxc) LOGIC TBL ROWad
         DC    AL1(CSACCOF2),AL1(mdlfnxcA+02-mdlfncx)  ACCUMULATOR ADDR
         DC    AL1(CSV1OFF),AL1(MDLfnxcb+02-MDLfnxc)  VALUE  1  OFF
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        DAYS/MONTHS/YEARS BETWEEN                                    *
***********************************************************************
mdlfncx  LAY   R14,0(0,0)         get address - must be 1st inst in    +
                                  model so that we get r5 on lookups
mdlfncxlt llgt  R5,0(,R2)         LOAD LOGIC  TABLE  ROW ADDRESS
mdlfncxA LAY   R4,0(,R2)          LOAD ACCUMULATOR ADDR (CHG'D TO "LY")
MDLFNcxb LAY   R15,0(,R2)         Compare constant
         bas   r10,fncxsub_indirect branch to calculation routine
mdlfncxL EQU   *-mdlfncx
*
mdlfncxP EQU   4+4                LITERAL POOL USAGE (EXCL FIELD LEN)
*
MDLFNcxR DC    AL1(CSSRCloFr),AL1(MDLfncx+02-MDLfncx) FIELD 1 OFF ADDR
         DC    AL1(CSLTROFF),AL1(mdlfncxlt+02-mdlfncx) LOGIC TBL ROWad
         DC    AL1(CSACCOF2),AL1(mdlfncxA+02-mdlfncx)  ACCUMULATOR ADDR
         DC    AL1(CSV1OFFr),AL1(MDLfnxcb+02-MDLfnxc)  VALUE  1  OFF
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        DAYS/MONTHS/YEARS BETWEEN                                    *
***********************************************************************
mdlfnxx  LAY   R14,0(0,0)         get address - must be 1st inst in    +
                                  model so that we get r5 on lookups
MDLfnxxLA LAY  R15,0(0,0)         get second operand (needle)
mdlfnxxlt llgt  R5,0(,R2)         LOAD LOGIC  TABLE  ROW ADDRESS
mdlfnxxA LAY   R4,0(,R2)          LOAD ACCUMULATOR ADDR (CHG'D TO "LY")
         bas   r10,fnxxsub_indirect branch to calculation routine
mdlfnxxL EQU   *-mdlfnxx
*
mdlfnxxP EQU   4+4                LITERAL POOL USAGE (EXCL FIELD LEN)
*
MDLFNxxR DC    AL1(CSSRCloF),AL1(MDLfnxx+02-MDLfnxx) FIELD 1  OFF  ADDR
         DC    AL1(CStgtloF),AL1(MDLfnxxLA+02-MDLfnxx) FIELD 2  OFF
         DC    AL1(CSLTROFF),AL1(mdlfnxxlt+02-mdlfnxx) LOGIC TBL ROWad
         DC    AL1(CSACCOF2),AL1(mdlfnxxA+02-mdlfnxx)  ACCUMULATOR ADDR
         DC   2XL1'FF'
                        EJECT
***********************************************************************
*        SAVE  LOOK-UP KEY BUILT IN LOOK-UP KEY AREA                  *
***********************************************************************
MDLKS01  MVC   EXTREC+0(0),LKUPKEY
         MVC   LKUPKEY,SPACES
MDLKS01L EQU   *-MDLKS01
*
MDLKS01P EQU   0
*
MDLKS01R DC    AL1(CSSRCLN),AL1(MDLKS01+01-MDLKS01)   TITLE KEY LENGTH
         DC    AL1(CSTTLOFF),AL1(MDLKS01+02-MDLKS01)  TITLE KEY OFFSET
         DC   2XL1'FF'
*
***********************************************************************
*        ASSIGN/MOVE FIELD       (LOOK-UP - MIXED/MASKED)             *
***********************************************************************
MDLDT00  LAy   R1,0(,0)           LOAD  DATA  AREA    ADDRESS
MDLDT00A llgt  R5,0(,R2)          LOAD LOGIC  TABLE  ROW ADDRESS
mdldt00b BAS   R10,*-*            CALL "GVBDL96"  (FORMAT  FIELD)
MDLDT00F jlu   *+l'*              FORMAT UNSUCCESSFUL BRANCH (FALSE)
MDLDT00T jlu   *+l'*              FORMAT   SUCCESSFUL BRANCH (OPTIONAL)
MDLDT00L EQU   *-MDLDT00
*
MDLDT00P EQU   4                  LITERAL POOL USAGE (EXCL FIELD LEN)
*
MDLDT00R DC    AL1(CSLTROFF),AL1(MDLDT00A+02-MDLDT00)  LOGIC  TABLE ROW
         DC    AL1(CSTGTloF),AL1(MDLDT00+02-MDLDT00) TARGET OFFSET
         DC    AL1(CSdl96calln),AL1(MDLdt00b-MDLdt00)  MR96 BAS
         DC    AL1(CSFALSEO),AL1(MDLDT00F+02-MDLDT00) FALSE  BRANCH
         DC    AL1(CSTRUEO),AL1(MDLDT00T+02-MDLDT00)  TRUE   BRANCH
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        ASSIGN/MOVE FIELD       (MIXED/MASKED)                       *
***********************************************************************
MDLDT01  llgt  R5,0(,R2)          LOAD LOGIC  TABLE  ROW ADDRESS
MDLDT01A LAy   R1,0(,0)           LOAD  DATA  AREA    ADDRESS
         BAS   R10,CALL96T_indirect CONVERT EDITED/MASKED  NUMERIC
MDLDT01F jlu   *+l'*              FORMAT UNSUCCESSFUL BRANCH (FALSE)
MDLDT01T jlu   *+l'*              FORMAT   SUCCESSFUL BRANCH (OPTIONAL)
MDLDT01L EQU   *-MDLDT01
*
MDLDT01P EQU   4                  LITERAL POOL USAGE (EXCL FIELD LEN)
*
MDLDT01R DC    AL1(CSLTROFF),AL1(MDLDT01+02-MDLDT01)  LOGIC  TABLE ROW
         DC    AL1(CSTGTloF),AL1(MDLDT01A+02-MDLDT01) TARGET OFFSET
         DC    AL1(CSFALSEO),AL1(MDLDT01F+02-MDLDT01) FALSE  BRANCH
         DC    AL1(CSTRUEO),AL1(MDLDT01T+02-MDLDT01)  TRUE   BRANCH
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        ASSIGN/MOVE FIELD       (CHARACTER)                          *
***********************************************************************
MDLdt02  LAY   R15,0(0,0)         get address
MDLdt02_la LAY R14,0(0,0)         get address
MDLDT02c MVC   0(0,r14),0(r15)    MOVE
MDLDT02L EQU   *-MDLDT02
*
MDLDT02P EQU   0                  LITERAL POOL USAGE (EXCL FIELD LEN)
*
MDLDT02R DC    AL1(CSTGTLN),AL1(MDLDT02c+01-MDLDT02)   TARGET    LENGTH
         DC    AL1(CSSRClof),AL1(MDLdt02+02-MDLdt02)  FIELD  1  OFF
         DC    AL1(CStgtlof),AL1(MDLdt02_lA+02-MDLdt02) FIELD  2  OFF
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        ASSIGN/MOVE FIELD       (CHARACTER WITH FILLER)              *
***********************************************************************
MDLdt03  LAY   R14,0(0,0)         get address
MDLdt03_la LAY R15,0(0,0)         get address
MDLDT03m MVC   0(0,r14),SPACES      BLANK  OUT AREA  BEFORE     MOVE
MDLDT03A MVC   0(0,r14),0(r15)      MOVE FIELD VALUE TO COLUMN  AREA
MDLDT03L EQU   *-MDLDT03
*
MDLDT03P EQU   0                  LITERAL POOL USAGE (EXCL FIELD LEN)
*
MDLDT03R DC    AL1(CSTGTLN),AL1(MDLDT03m+01-MDLDT03)   TARGET    LENGTH
         DC    AL1(CStgtlof),AL1(MDLdt03+02-MDLdt03) FIELD  2  OFF
         DC    AL1(CSSRClof),AL1(MDLdt03_lA+02-MDLdt03) FIELD  1  OFF
         DC    AL1(CSSRCLN),AL1(MDLDT03A+01-MDLDT03)  SOURCE    LENGTH
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        ASSIGN/MOVE FIELD       (PACKED TO PACKED - SIGNED           *
***********************************************************************
MDLdt04  LAY   R15,0(0,0)         get address
MDLdt04_la LAY R14,0(0,0)         get address
MDLDT04sZ ZAP   workarea,0(0,r15)  COPY  PACKED  TO PACKED FORMAT
mdldt04a jnop  mdldt04tz
         lmg   r0,r1,workarea
         cxstr fp0,r0             convert to DFP
mdldt04se lghi r15,*-*
         iextr fp4,fp0,r15        set quantum of source
mdldt04te lghi r15,*-*
         iextr fp8,fp8,r15        set quantum of target
         qaxtr fp0,fp4,fp8,0      and qantise souce to target
         csxtr r0,fp0,0
         stmg  r0,r1,workarea
MDLDT04tZ ZAP   0(0,r14),workarea  COPY  PACKED  TO PACKED FORMAT
MDLDT04L EQU   *-MDLDT04
*
MDLDT04P EQU   0                  LITERAL POOL USAGE (EXCL FIELD LEN)
*
MDLDT04R DC    AL1(CSTGTLNL),AL1(MDLDT04tz+01-MDLDT04) TARGET    LENGTH
         DC    AL1(CSSRCLNR),AL1(MDLDT04sz+01-MDLDT04) SOURCE    LENGTH
         DC    AL1(CSSRClof),AL1(MDLdt04+02-MDLdt04)   FIELD  1  OFF
         DC    AL1(CSSRPsrc),AL1(MDLDT04A+01-MDLDT04)  skip code if 0
         DC    AL1(CSdfpexps),AL1(MDLdt04se+02-MDLdt04) dfp exp
         DC    AL1(CStgtlof),AL1(MDLdt04_la+02-MDLdt04)  FIELD  2  OFF
         DC    AL1(CSdfpexp),AL1(MDLdt04te+02-MDLdt04) dfp exp
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        ASSIGN/MOVE FIELD       (PACKED TO PACKED - UNSIGNED         *
***********************************************************************
MDLdt05  LAY   R15,0(0,0)         get address
MDLdt05_la LAY R14,0(0,0)         get address
MDLDT05sZ ZAP   workarea,0(0,r15)  COPY  PACKED  TO PACKED FORMAT
         lmg   r0,r1,workarea
         cxstr fp0,r0             convert to DFP
mdldt05a jnop  mdldt05lp
mdldt05se lghi r15,*-*
         iextr fp4,fp0,r15        set quantum of source
mdldt05te lghi r15,*-*
         iextr fp8,fp8,r15        set quantum of target
         qaxtr fp0,fp4,fp8,0      and qantise souce to target
mdldt05lp lpdfr fp0,fp0            force positive
         csxtr r0,fp0,1
         stmg  r0,r1,workarea
MDLDT05tZ ZAP   0(0,r14),workarea  COPY  PACKED  TO PACKED FORMAT
MDLDT05B OI    0(r14),X'0F'       FORCE TO UNSIGNED
MDLDT05L EQU   *-MDLDT05
*
MDLDT05P EQU   0                  LITERAL POOL USAGE (EXCL FIELD LEN)
*
MDLDT05R DC    AL1(CSTGTLNL),AL1(MDLDT05tz+01-MDLDT05) TARGET    LENGTH
         DC    AL1(CSSRCLNR),AL1(MDLDT05sz+01-MDLDT05) SOURCE    LENGTH
         DC    AL1(CSSRClof),AL1(MDLdt05+02-MDLdt05)  FIELD  1  OFF
         DC    AL1(CSSRPsrc),AL1(MDLDT05A+01-MDLDT05)  skip code if 0
         DC    AL1(CSdfpexps),AL1(MDLdt05se+02-MDLdt05) dfp exp
         DC    AL1(CStgtlof),AL1(MDLdt05_la+02-MDLdt05) FIELD  2  OFF
         DC    AL1(CSLSTBYT),AL1(MDLDT05B+02-MDLDT05) LAST  TGT BYTE
         DC    AL1(CSdfpexp),AL1(MDLdt05te+02-MDLdt05) dfp exp
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        ASSIGN/MOVE FIELD       (PACKED TO NUMERIC - SIGNED)         *
***********************************************************************
MDLdt06  LAY   R15,0(0,0)         get address
MDLdt06_la LAY R14,0(0,0)         get address
MDLDT06z ZAP   WORKAREA,0(0,r15) COPY PACKED  VALUE  TO WORK   AREA
mdldt06a jnop  mdldt06b
         lmg   r0,r1,workarea
         cxstr fp0,r0             convert to DFP
mdldt06se lghi r15,*-*
         iextr fp4,fp0,r15        set quantum of source
mdldt06te lghi r15,*-*
         iextr fp8,fp8,r15        set quantum of target
         qaxtr fp0,fp4,fp8,0      and qantise souce to target
         csxtr r0,fp0,0
         stmg  r0,r1,workarea
MDLDT06B UNPK  0(0,r14),WORKAREA  CONVERT  FIELD   TO  DISPLAY FORMAT
MDLDT06L EQU   *-MDLDT06
*
MDLDT06P EQU   0                  LITERAL POOL USAGE (EXCL FIELD LEN)
*
MDLDT06R DC    AL1(CSTGTLNL),AL1(MDLDT06b+01-MDLDT06) TARGET    LENGTH
         DC    AL1(CSSRCLNR),AL1(MDLDT06z+01-MDLDT06) SOURCE    LENGTH
         DC    AL1(CSSRClof),AL1(MDLdt06+02-MDLdt06)  FIELD  1  OFF
         DC    AL1(CSSRPsrc),AL1(MDLDT06A+01-MDLDT06)  skip code if 0
         DC    AL1(CSdfpexps),AL1(MDLdt06se+02-MDLdt06) dfp exp
         DC    AL1(CStgtlof),AL1(MDLdt06_la+02-MDLdt06) FIELD  2  OFF
         DC    AL1(CSdfpexp),AL1(MDLdt06te+02-MDLdt06) dfp exp
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        ASSIGN/MOVE FIELD       (PACKED TO NUMERIC - UNSIGNED)       *
***********************************************************************
MDLdt07  LAY   R15,0(0,0)         get address
MDLdt07_la LAY R14,0(0,0)         get address
MDLDT07z ZAP   WORKAREA,0(0,r15) COPY PACKED  VALUE  TO WORK   AREA
         lmg   r0,r1,workarea
         cxstr fp0,r0             convert to DFP
mdldt07a jnop  mdldt07lp
mdldt07se lghi r15,*-*
         iextr fp4,fp0,r15        set quantum of source
mdldt07te lghi r15,*-*
         iextr fp8,fp8,r15        set quantum of target
         qaxtr fp0,fp4,fp8,0      and qantise souce to target
mdldt07lp lpdfr fp0,fp0            force positive
         csxtr r0,fp0,1
         stmg  r0,r1,workarea
MDLDT07B UNPK  0(0,r14),WORKAREA  CONVERT  FIELD   TO  DISPLAY FORMAT
MDLDT07C OI    0(r14),X'F0'
MDLDT07L EQU   *-MDLDT07
*
MDLDT07P EQU   0                  LITERAL POOL USAGE (EXCL FIELD LEN)
*
MDLDT07R DC    AL1(CSTGTLNL),AL1(MDLDT07b+01-MDLDT07) TARGET    LENGTH
         DC    AL1(CSSRCLNR),AL1(MDLDT07z+01-MDLDT07) SOURCE    LENGTH
         DC    AL1(CSSRClof),AL1(MDLdt07+02-MDLdt07)  FIELD  1  OFF
         DC    AL1(CSSRPsrc),AL1(MDLDT07A+01-MDLDT07)  skip code if 0
         DC    AL1(CSdfpexps),AL1(MDLdt07se+02-MDLdt07) dfp exp
         DC    AL1(CStgtlof),AL1(MDLdt07_la+02-MDLdt07) FIELD  2  OFF
         DC    AL1(CSLSTBYT),AL1(MDLDT07C+02-MDLDT07) LAST BYTE OFFSET
         DC    AL1(CSdfpexp),AL1(MDLdt07te+02-MDLdt07) dfp exp
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        ASSIGN/MOVE FIELD       (PACKED TO BINARY - SIGNED           *
***********************************************************************
MDLdt08  LAY   R15,0(0,0)         get address
MDLDT08z ZAP   WORKAREA,0(0,r15) COPY PACKED  VALUE  TO WORK   AREA
         lmg   r0,r1,workarea
         cxstr fp0,r0             convert to DFP
mdldt08a jnop  mdldt08g
mdldt08se lghi r15,*-*
mdldt08te lghi r14,*-*
         iextr fp4,fp0,r15        set quantum of source
         iextr fp8,fp8,r14        set quantum of target
         qaxtr fp0,fp4,fp8,0      and qantise souce to target
mdldt08g cgxtr r0,0,fp0
MDLDT08B STCMy R0,B'0000',0(0)    STORE REQUIRED   BYTES
MDLDT08L EQU   *-MDLDT08
*
MDLDT08P EQU   0                  LITERAL POOL USAGE (EXCL FIELD LEN)
*
MDLDT08R DC    AL1(CSSRCLNR),AL1(MDLDT08z+01-MDLDT08)  SOURCE    LENGTH
         DC    AL1(CSSRClof),AL1(MDLdt08+02-MDLdt08)  FIELD  1  OFF
         DC    AL1(CSSRPsrc),AL1(MDLDT08A+01-MDLDT08)  skip code if 0
         DC    AL1(CSdfpexps),AL1(MDLdt08se+02-MDLdt08) dfp exp
         DC    AL1(CSdfpexp),AL1(MDLdt08te+02-MDLdt08) dfp exp
         DC    AL1(CSBYTMSK),AL1(MDLDT08B+01-MDLDT08) STCM BYTE MASK
         DC    AL1(CSTGTloF),AL1(MDLDT08b+02-MDLDT08) TARGET    OFFSET
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        ASSIGN/MOVE FIELD       (PACKED TO BINARY8 signed)           *
***********************************************************************
MDLdt08_b8  LAY R15,0(0,0)        get address
mdldt08_b8z ZAP WORKAR2,0(0,r15)  CONVERT FIELD TO PACKED FORMAT
         lmg   r0,r1,workar2
         cxstr fp0,r0             convert to DFP
mdldt08_b8a jnop  mdldt08_b8g
mdldt08_b8se lghi r15,*-*
mdldt08_b8te lghi r14,*-*
         iextr fp4,fp0,r15        set quantum of source
         iextr fp8,fp8,r14        set quantum of target
         qaxtr fp0,fp4,fp8,0      and qantise souce to target
mdldt08_b8g cgxtr r0,0,fp0
mdldt08_b8B STG R0,0(0,0)         STORE REQUIRED BYTES
mdldt08_b8L EQU *-mdldt08_b8
*
mdldt08_b8P EQU 0                 LITERAL POOL USAGE (EXCL FIELD LEN)
*
mdldt08_b8R DC AL1(CSSRCLNR),AL1(mdldt08_b8z+01-mdldt08_b8) SOURCE LEN
         DC    AL1(CSSRClof),AL1(MDLdt08_b8+02-MDLdt08_b8)  FIELD 1 OFF
         DC    AL1(CSSRPsrc),AL1(MDLDT08_b8A+01-MDLDT08_b8) skip if 0
         DC    AL1(CSdfpexps),AL1(MDLdt08_b8se+02-MDLdt08_b8) dfp exp
         DC    AL1(CSdfpexp),AL1(MDLdt08_b8te+02-MDLdt08_b8) dfp exp
         DC    AL1(CSTGTLOF),AL1(mdldt08_b8B+02-mdldt08_b8) TARGET OFF
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        ASSIGN/MOVE FIELD       (NUMERIC 2 BINARY - UNSIGNED         *
***********************************************************************
MDLdt09  LAY   R15,0(0,0)         get address
MDLDT09z ZAP   WORKAREA,0(0,r15) COPY PACKED  VALUE  TO WORK   AREA
         lmg   r0,r1,workarea
         cxstr fp0,r0             convert to DFP
mdldt09a jnop  mdldt09g
mdldt09se lghi r15,*-*
mdldt09te lghi r14,*-*
         iextr fp4,fp0,r15        set quantum of source
         iextr fp8,fp8,r14        set quantum of target
         qaxtr fp0,fp4,fp8,0      and qantise souce to target
mdldt09g lpdfr fp0,fp0            force positive
         cgxtr r0,0,fp0
MDLDT09B STCMy R0,B'0000',0(0)    STORE REQUIRED   BYTES
MDLDT09L EQU   *-MDLDT09
*
MDLDT09P EQU   0                  LITERAL POOL USAGE (EXCL FIELD LEN)
*
MDLDT09R DC    AL1(CSSRCLNR),AL1(MDLDT09z+01-MDLDT09)  SOURCE    LENGTH
         DC    AL1(CSSRClof),AL1(MDLdt09+02-MDLdt09)  FIELD  1  OFF
         DC    AL1(CSSRPsrc),AL1(MDLDT09A+01-MDLDT09)  skip code if 0
         DC    AL1(CSdfpexps),AL1(MDLdt09se+02-MDLdt09) dfp exp
         DC    AL1(CSdfpexp),AL1(MDLdt09te+02-MDLdt09) dfp exp
         DC    AL1(CSBYTMSK),AL1(MDLDT09B+01-MDLDT09) STCM BYTE MASK
         DC    AL1(CSTGTloF),AL1(MDLDT09b+02-MDLDT09) TARGET    OFFSET
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        ASSIGN/MOVE FIELD       (NUMERIC 2 BINARY8- UNSIGNED         *
***********************************************************************
MDLdt09_b8  LAY   R15,0(0,0)         get address
MDLDt09_b8z ZAP workar2,0(0,r15)  CONVERT FIELD TO PACKED FORMAT
         lmg   r0,r1,workar2
         cxstr fp0,r0             convert to DFP
mdldt09_b8a jnop  mdldt09_b8g
mdldt09_b8se lghi r15,*-*
mdldt09_b8te lghi r14,*-*
         iextr fp4,fp0,r15        set quantum of source
         iextr fp8,fp8,r14        set quantum of target
         qaxtr fp0,fp4,fp8,0      and qantise souce to target
mdldt09_b8g lpdfr fp0,fp0            force positive
         cgxtr r0,0,fp0
MDLDt09_b8B STG R0,0(0,0)         STORE REQUIRED   BYTES
MDLDt09_b8L EQU *-MDLDt09_b8
*
MDLDt09_b8P EQU 0                 LITERAL POOL USAGE (EXCL FIELD LEN)
*
MDLDt09_b8R DC AL1(CSSRCLNR),AL1(MDLDt09_b8z+01-MDLDt09_b8) SOURCE LEN
         DC    AL1(CSSRClof),AL1(MDLdt09_b8+02-MDLdt09_b8) FIELD 1 OFF
         DC    AL1(CSSRPsrc),AL1(MDLDT09_b8A+01-MDLDT09_b8)  skip if 0
         DC    AL1(CSdfpexps),AL1(MDLdt09_b8se+02-MDLdt09_b8) dfp exp
         DC    AL1(CSdfpexp),AL1(MDLdt09_b8te+02-MDLdt09_b8) dfp exp
         DC    AL1(CSTGTloF),AL1(MDLDt09_b8b+02-MDLDt09_b8) TAR OFFSET
         DC   2XL1'FF'
                        SPACE 3
*
***********************************************************************
*        ASSIGN/MOVE FIELD       (NUMERIC TO PACKED - SIGNED          *
***********************************************************************
MDLdt10  LAY   R15,0(0,0)         get address
MDLdt10_la LAY R14,0(0,0)         get address
MDLDT10k PACK  WORKAREA,0(0,r15)    CONVERT FIELD TO PACKED FORMAT
mdldt10j jnop  mdldt10a
         lmg   r0,r1,workarea
         cxstr fp0,r0             convert to DFP
mdldt10se lghi r15,*-*
         iextr fp4,fp0,r15        set quantum of source
mdldt10te lghi r15,*-*
         iextr fp8,fp8,r15        set quantum of target
         qaxtr fp0,fp4,fp8,0      and qantise souce to target
         csxtr r0,fp0,0
         stmg  r0,r1,workarea
MDLDT10A zap   0(0,r14),workarea
MDLDT10L EQU   *-MDLDT10
*
MDLDT10P EQU   0                  LITERAL POOL USAGE (EXCL FIELD LEN)
*
MDLDT10R DC    AL1(CSSRCLNR),AL1(MDLDT10k+01-MDLDT10)  SOURCE    LENGTH
         DC    AL1(CSSRClof),AL1(MDLdt10+02-MDLdt10)  FIELD  1  OFF
         DC    AL1(CStgtlof),AL1(MDLdt10_la+02-MDLdt10) FIELD  2  OFF
         DC    AL1(CSSRPsrc),AL1(MDLDT10j+01-MDLDT10)  skip code if 0
         DC    AL1(CSdfpexps),AL1(MDLdt10se+02-MDLdt10) dfp exp
         DC    AL1(CSdfpexp),AL1(MDLdt10te+02-MDLdt10) dfp exp
         DC    AL1(CSTGTLNL),AL1(MDLDT10A+01-MDLDT10) TARGET    OFFSET
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        ASSIGN/MOVE FIELD       (NUMERIC TO PACKED - UNSIGNED        *
***********************************************************************
MDLdt11  LAY   R15,0(0,0)         get address
MDLdt11_la LAY R14,0(0,0)         get address
MDLDT11k PACK  WORKAREA,0(0,r15)    CONVERT FIELD TO PACKED FORMAT
         lmg   r0,r1,workarea
         cxstr fp0,r0             convert to DFP
mdldt11j jnop  mdldt11lp
mdldt11se lghi r15,*-*
         iextr fp0,fp0,r15        set quantum of source
mdldt11te lghi r15,*-*
         iextr fp8,fp8,r15        set quantum of target
         qaxtr fp0,fp0,fp4,0      and qantise souce to target
mdldt11lp lpdfr fp0,fp0
         csxtr r0,fp0,1
         stmg  r0,r1,workarea
MDLDT11A zap   0(0,r14),workarea
MDLDT11B OI    0(r14),X'0F'         FORCE TO UNSIGNED
MDLDT11L EQU   *-MDLDT11
*
MDLDT11P EQU   0                  LITERAL POOL USAGE (EXCL FIELD LEN)
*
*
MDLDT11R DC    AL1(CSSRCLNR),AL1(MDLDT11k+01-MDLDT11)  SOURCE    LENGTH
         DC    AL1(CSSRClof),AL1(MDLdt11+02-MDLdt11)  FIELD  1  OFF
         DC    AL1(CStgtlof),AL1(MDLdt11_la+02-MDLdt11) FIELD  2  OFF
         DC    AL1(CSSRPsrc),AL1(MDLDT11j+01-MDLDT11)  skip code if 0
         DC    AL1(CSdfpexps),AL1(MDLdt10se+02-MDLdt10) dfp exp
         DC    AL1(CSdfpexp),AL1(MDLdt10te+02-MDLdt10) dfp exp
         DC    AL1(CSTGTLNL),AL1(MDLDT11A+01-MDLDT11) TARGET    OFFSET
         DC    AL1(CSLSTBYT),AL1(MDLDT11B+02-MDLDT11) LAST BYTE OFFSET
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        ASSIGN/MOVE FIELD       (NUMERIC TO NUMERIC - SIGNED         *
***********************************************************************
MDLdt12  LAY   R15,0(0,0)         get address
MDLdt12_la LAY R14,0(0,0)         get address
MDLDT12k PACK  WORKAREA,0(0,r15) CONVERT FIELD   TO PACKED FORMAT
         lmg   r0,r1,workarea
         cxstr fp0,r0             convert to DFP
mdldt12se lghi r15,*-*
         iextr fp4,fp0,r15        set quantum of source
mdldt12te lghi r15,*-*
         iextr fp8,fp8,r15        set quantum of target
         qaxtr fp0,fp4,fp8,0      and qantise souce to target
         csxtr r0,fp0,0
         stmg  r0,r1,workarea
MDLDT12B UNPK  0(0,r14),workarea    CONVERT TO NUMERIC
MDLDT12L EQU   *-MDLDT12
*
MDLDT12P EQU   0                  LITERAL POOL USAGE (EXCL FIELD LEN)
*
MDLDT12R DC    AL1(CSSRCLNR),AL1(MDLDT12k+01-MDLDT12)  SOURCE    LENGTH
         DC    AL1(CSSRClof),AL1(MDLdt12+02-MDLdt12)  FIELD  1  OFF
         DC    AL1(CStgtlof),AL1(MDLdt12_la+02-MDLdt12) FIELD  2  OFF
         DC    AL1(CSdfpexps),AL1(MDLdt12se+02-MDLdt12) dfp exp
         DC    AL1(CSdfpexp),AL1(MDLdt12te+02-MDLdt12) dfp exp
         DC    AL1(CSTGTLNL),AL1(MDLDT12B+01-MDLDT12) TARGET    LENGTH
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        ASSIGN/MOVE FIELD       (NUMERIC TO NUMERIC - UNSIGNED       *
***********************************************************************
MDLdt13  LAY   R15,0(0,0)         get address
MDLdt13_la LAY R14,0(0,0)         get address
MDLDT13k PACK  WORKAREA,0(0,r15) CONVERT FIELD   TO PACKED FORMAT
         lmg   r0,r1,workarea
         cxstr fp0,r0             convert to DFP
mdldt13j jnop  mdldt13lp
mdldt13se lghi r15,*-*
         iextr fp4,fp0,r15        set quantum of source
mdldt13te lghi r15,*-*
         iextr fp8,fp8,r15        set quantum of target
         qaxtr fp0,fp4,fp8,0      and qantise souce to target
mdldt13lp lpdfr fp0,fp0
         csxtr r0,fp0,1
         stmg  r0,r1,workarea
MDLDT13B UNPK  0(0,r14),WORKAREA  CONVERT TO NUMERIC
MDLDT13C OI    0(r14),X'F0'
MDLDT13L EQU   *-MDLDT13
*
MDLDT13P EQU   0                  LITERAL POOL USAGE (EXCL FIELD LEN)
*
MDLDT13R DC    AL1(CSSRCLNR),AL1(MDLDT13k+01-MDLDT13)  SOURCE    LENGTH
         DC    AL1(CSSRClof),AL1(MDLdt13+02-MDLdt13)  FIELD  1  OFF
         DC    AL1(CStgtlof),AL1(MDLdt13_la+02-MDLdt13) FIELD  2  OFF
         DC    AL1(CSSRPsrc),AL1(MDLDT13j+01-MDLDT13)  skip code if 0
         DC    AL1(CSdfpexps),AL1(MDLdt13se+02-MDLdt13) dfp exp
         DC    AL1(CSdfpexp),AL1(MDLdt13te+02-MDLdt13) dfp exp
         DC    AL1(CSTGTLNL),AL1(MDLDT13B+01-MDLDT13) TARGET    LENGTH
         DC    AL1(CSLSTBYT),AL1(MDLDT13C+02-MDLDT13) LAST BYTE OFFSET
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        ASSIGN/MOVE FIELD       (NUMERIC TO BINARY - SIGNED          *
***********************************************************************
MDLdt14  LAY   R15,0(0,0)         get address
MDLDT14k PACK  workarea,0(0,r15)  CONVERT FIELD TO PACKED FORMAT
         lmg   r0,r1,workarea
         cxstr fp0,r0             convert to DFP
mdldt14j jnop  mdldt14g
mdldt14se lghi r15,*-*
mdldt14te lghi r14,*-*
         iextr fp4,fp0,r15        set quantum of source
         iextr fp8,fp8,r14        set quantum of target
         qaxtr fp0,fp4,fp8,0      and quantise souce to target
mdldt14g cgxtr r0,0,fp0
MDLDT14B STCMy R0,B'0000',0(0)    STORE REQUIRED   BYTES
MDLDT14L EQU   *-MDLDT14
*
MDLDT14P EQU   0                  LITERAL POOL USAGE (EXCL FIELD LEN)
*
MDLDT14R DC    AL1(CSSRCLNR),AL1(MDLDT14k+01-MDLDT14)  SOURCE    LENGTH
         DC    AL1(CSSRClof),AL1(MDLdt14+02-MDLdt14)  FIELD  1  OFF
         DC    AL1(CSSRPsrc),AL1(MDLDT14j+01-MDLDT14)  skip code if 0
         DC    AL1(CSdfpexps),AL1(MDLdt14se+02-MDLdt14) dfp exp
         DC    AL1(CSdfpexp),AL1(MDLdt14te+02-MDLdt14) dfp exp
         DC    AL1(CSBYTMSK),AL1(MDLDT14B+01-MDLDT14) STCM BYTE MASK
         DC    AL1(CSTGTloF),AL1(MDLDT14b+02-MDLDT14) TARGET    OFFSET
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        ASSIGN/MOVE FIELD       (NUMERIC TO BINARY8)                 *
***********************************************************************
MDLdt14_b8  LAY   R15,0(0,0)      get address
mdldt14_b8k PACK workar2,0(0,r15) CONVERT FIELD TO PACKED FORMAT
         lmg   r0,r1,workar2
         cxstr fp0,r0             convert to DFP
mdldt14_b8j jnop  mdldt14_b8g
mdldt14_b8se lghi r15,*-*
mdldt14_b8te lghi r14,*-*
         iextr fp4,fp0,r15        set quantum of source
         iextr fp8,fp8,r14        set quantum of target
         qaxtr fp0,fp4,fp8,0      and quantise souce to target
mdldt14_b8g cgxtr r0,0,fp0
mdldt14_b8B STG R0,0(0,0)         STORE REQUIRED BYTES
mdldt14_b8L EQU *-mdldt14_b8
*
mdldt14_b8P EQU 0                 LITERAL POOL USAGE (EXCL FIELD LEN)
*
mdldt14_b8R DC AL1(CSSRCLNR),AL1(mdldt14_b8k+01-mdldt14_b8) SOURCE LEN
         DC    AL1(CSSRClof),AL1(MDLdt14_b8+02-MDLdt14_b8) FIELD 1 OFF
         DC    AL1(CSSRPsrc),AL1(MDLDT14_b8j+01-MDLDT14_b8)  skip if 0
         DC    AL1(CSdfpexps),AL1(MDLdt14_b8se+02-MDLdt14_b8) dfp exp
         DC    AL1(CSdfpexp),AL1(MDLdt14_b8te+02-MDLdt14_b8) dfp exp
         DC    AL1(CSTGTLOF),AL1(mdldt14_b8B+02-mdldt14_b8) TARGET OFF
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        ASSIGN/MOVE FIELD       (NUMERIC TO BINARY - UNSIGNED        *
***********************************************************************
MDLdt15  LAY   R15,0(0,0)         get address
MDLDT15k PACK  workarea,0(0,r15)   CONVERT FIELD TO PACKED FORMAT
         lmg   r0,r1,workarea
         cxstr fp0,r0             convert to DFP
mdldt15j jnop  mdldt15lp
mdldt15se lghi r15,*-*
mdldt15te lghi r14,*-*
         iextr fp4,fp0,r15        set quantum of source
         iextr fp8,fp8,r14        set quantum of target
         qaxtr fp0,fp4,fp8,0      and quantise souce to target
mdldt15lp  lpdfr fp0,fp0            force positive
         cgxtr r0,0,fp0
MDLDT15B STCMy R0,B'0000',0(0)    STORE REQUIRED   BYTES
MDLDT15L EQU   *-MDLDT15
*
MDLDT15P EQU   0                  LITERAL POOL USAGE (EXCL FIELD LEN)
*
MDLDT15R DC    AL1(CSSRCLNR),AL1(MDLDT15k+01-MDLDT15)  SOURCE    LENGTH
         DC    AL1(CSSRClof),AL1(MDLdt15+02-MDLdt15)  FIELD  1  OFF
         DC    AL1(CSSRPsrc),AL1(MDLDT15j+01-MDLDT15)  skip code if 0
         DC    AL1(CSdfpexps),AL1(MDLdt15se+02-MDLdt15) dfp exp
         DC    AL1(CSdfpexp),AL1(MDLdt15te+02-MDLdt15) dfp exp
         DC    AL1(CSBYTMSK),AL1(MDLDT15B+01-MDLDT15) STCM BYTE MASK
         DC    AL1(CSTGTloF),AL1(MDLDT15b+02-MDLDT15) TARGET    OFFSET
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        ASSIGN/MOVE FIELD       (NUMERIC TO BINARY8- UNSIGNED        *
***********************************************************************
MDLdt15_b8 LAY R15,0(0,0)         get address
MDLDt15_b8k PACK workar2,0(0,r15) CONVERT FIELD TO PACKED FORMAT
         lmg   r0,r1,workar2
         cxstr fp0,r0             convert to DFP
mdldt15_b8j jnop  mdldt15_b8lp
mdldt15_b8se lghi r15,*-*
mdldt15_b8te lghi r14,*-*
         iextr fp4,fp0,r15        set quantum of source
         iextr fp8,fp8,r14        set quantum of target
         qaxtr fp0,fp4,fp8,0      and quantise souce to target
mdldt15_b8lp  lpdfr fp0,fp0            force positive
         cgxtr r0,0,fp0
MDLDt15_b8B STG R0,0(0,0)         STORE REQUIRED   BYTES
MDLDt15_b8L EQU *-MDLDt15_b8
*
MDLDt15_b8P EQU 0                 LITERAL POOL USAGE (EXCL FIELD LEN)
*
MDLDt15_b8R DC AL1(CSSRCLNR),AL1(MDLDt15_b8k+01-MDLDt15_b8) SOURCE LEN
         DC    AL1(CSSRClof),AL1(MDLdt15_b8+02-MDLdt15_b8) FIELD 1 OFF
         DC    AL1(CSSRPsrc),AL1(MDLDT15_b8j+01-MDLDT15_b8)  skip if 0
         DC    AL1(CSdfpexps),AL1(MDLdt15_b8se+02-MDLdt15_b8) dfp exp
         DC    AL1(CSdfpexp),AL1(MDLdt15_b8te+02-MDLdt15_b8) dfp exp
         DC    AL1(CSTGTloF),AL1(MDLDt15_b8b+02-MDLDt15_b8) TAR OFFSET
         DC   2XL1'FF'
                        SPACE 3
*
***********************************************************************
*        ASSIGN/MOVE FIELD       (BINARY TO PACKED - SIGNED/Signed)   *
***********************************************************************
MDLDT16  Xgr   R0,R0              LOAD BINARY NUMBER
MDLDT16S TMy   0(0),X'80'
         if (o)
           lghi r0,-1             fill with 1's
         endif
MDLDT16A ICMy  R0,B'0000',0(0)
MDLdt16_la LAY R14,0(0,0)         get address
         cxgtr fp0,r0             convert to DFP
mdldt16j jnop  mdldt16x
mdldt16se lghi r15,*-*
         iextr fp4,fp0,r15        set quantum of source
mdldt16te lghi r15,*-*
         iextr fp8,fp8,r15        set quantum of target
         qaxtr fp0,fp4,fp8,0      and quantise souce to target
mdldt16x csxtr r0,fp0,0
         stmg  r0,r1,workarea
MDLDT16C ZAP   0(0,r14),workarea
MDLDT16L EQU   *-MDLDT16
*
MDLDT16P EQU   0                  LITERAL POOL USAGE (EXCL FIELD LEN)
*
MDLDT16R DC    AL1(CSSRCloF),AL1(MDLDT16S+02-MDLDT16) SOURCE    OFFSET
         DC    AL1(CSBYTMSS),AL1(MDLDT16A+01-MDLDT16) ICM  BYTE MASK
         DC    AL1(CSSRCloF),AL1(MDLDT16A+02-MDLDT16) SOURCE    OFFSET
         DC    AL1(CStgtlof),AL1(MDLdt16_la+02-MDLdt16) FIELD  2  OFF
         DC    AL1(CSSRPsrc),AL1(MDLDT16j+01-MDLDT16)  skip code if 0
         DC    AL1(CSdfpexps),AL1(MDLdt16se+02-MDLdt16) dfp exp
         DC    AL1(CSdfpexp),AL1(MDLdt16te+02-MDLdt16) dfp exp
         DC    AL1(CSTGTLNL),AL1(MDLDT16C+01-MDLDT16) TARGET    LENGTH
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        ASSIGN/MOVE FIELD       (BINARY TO PACKED - SIGNED/Signed)   *
***********************************************************************
MDLdt16_b8 LG  R0,0(0,0)          LOAD BINARY NUMBER
MDLdt16_b8la LAY R14,0(0,0)         get address
         cxgtr fp0,r0             convert to DFP
mdldt16_b8j jnop  mdldt16_b8x
mdldt16_b8se lghi r15,*-*
         iextr fp4,fp0,r15        set quantum of source
mdldt16_b8te lghi r15,*-*
         iextr fp8,fp8,r15        set quantum of target
         qaxtr fp0,fp4,fp8,0      and quantise souce to target
mdldt16_b8x csxtr r0,fp0,0
         stmg  r0,r1,workarea
MDLDT16_b8C ZAP   0(0,r14),workarea
MDLdt16_b8L EQU *-MDLdt16_b8
*
MDLdt16_b8P EQU 0                 LITERAL POOL USAGE (EXCL FIELD LEN)
*
MDLdt16_b8R DC AL1(CSSRCLof),AL1(MDLdt16_b8+02-MDLdt16_b8) SOURCE OFF
         DC    AL1(CStgtlof),AL1(MDLdt16_b8la+02-MDLdt16_b8) FIELD 2OFF
         DC    AL1(CSSRPsrc),AL1(MDLDT16_b8j+01-MDLDT16_b8)  skip if 0
         DC    AL1(CSdfpexps),AL1(MDLdt16_b8se+02-MDLdt16_b8) dfp exp
         DC    AL1(CSdfpexp),AL1(MDLdt16_b8te+02-MDLdt16_b8) dfp exp
         DC    AL1(CSTGTLNL),AL1(MDLdt16_b8C+01-MDLdt16_b8) TARGET LEN
         DC   2XL1'FF'
                        SPACE 3
*
***********************************************************************
*        ASSIGN/MOVE FIELD       (BINARY TO PACKED - SIGNED/Unsigned) *
***********************************************************************
MDLDT51  Xgr   R0,R0              LOAD BINARY NUMBER
MDLDT51S TMy   0(0),X'80'
         if (o)
           lghi r0,-1             fill with 1's
         endif
MDLDT51A ICMy  R0,B'0000',0(0)
MDLdt51_la LAY R14,0(0,0)         get address
         cxgtr fp0,r0             convert to DFP
mdldt51j jnop  mdldt51lp
mdldt51se lghi r15,*-*
         iextr fp4,fp0,r15        set quantum of source
mdldt51te lghi r15,*-*
         iextr fp8,fp8,r15        set quantum of target
         qaxtr fp0,fp4,fp8,0      and quantise souce to target
mdldt51lp lpdfr fp0,fp0
         csxtr r0,fp0,1
         stmg  r0,r1,workarea
MDLDT51C ZAP   0(0,r14),workarea
MDLDT51D OI    0(r14),X'0F'
MDLDT51L EQU   *-MDLDT51
*
MDLDT51P EQU   0                  LITERAL POOL USAGE (EXCL FIELD LEN)
*
MDLDT51R DC    AL1(CSSRCloF),AL1(MDLDT51S+02-MDLDT51) SOURCE    OFFSET
         DC    AL1(CSBYTMSS),AL1(MDLDT51A+01-MDLDT51) ICM  BYTE MASK
         DC    AL1(CSSRCloF),AL1(MDLDT51A+02-MDLDT51) SOURCE    OFFSET
         DC    AL1(CStgtlof),AL1(MDLdt51_la+02-MDLdt51) FIELD  2  OFF
         DC    AL1(CSSRPsrc),AL1(MDLDT51j+01-MDLDT51)  skip code if 0
         DC    AL1(CSdfpexps),AL1(MDLdt51se+02-MDLdt51) dfp exp
         DC    AL1(CSdfpexp),AL1(MDLdt51te+02-MDLdt51) dfp exp
         DC    AL1(CSTGTLNL),AL1(MDLDT51C+01-MDLDT51) TARGET    LENGTH
         DC    AL1(CSLSTBYT),AL1(MDLDT51D+02-MDLDT51) LAST BYTE OFFSET
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        ASSIGN/MOVE FIELD       (BINARY8 2 PACKED - SIGNED/Unsigned) *
***********************************************************************
MDLdt51_b8 LG  R0,0(0,0)
MDLdt51_b8la LAY R14,0(0,0)         get address
         cxgtr fp0,r0             convert to DFP
mdldt51_b8j jnop  mdldt51_b8lp
mdldt51_b8se lghi r15,*-*
         iextr fp4,fp0,r15        set quantum of source
mdldt51_b8te lghi r15,*-*
         iextr fp8,fp8,r15        set quantum of target
         qaxtr fp0,fp4,fp8,0      and quantise souce to target
mdldt51_b8lp lpdfr fp0,fp0
         csxtr r0,fp0,1
         stmg  r0,r1,workarea
MDLDT51_b8C ZAP   0(0,r14),workarea
MDLdt51_b8D OI 0(r14),X'0F'
MDLdt51_b8L EQU *-MDLdt51_b8
*
MDLdt51_b8P EQU 0                 LITERAL POOL USAGE (EXCL FIELD LEN)
*
MDLdt51_b8R DC AL1(CSSRCLOF),AL1(MDLdt51_b8+02-MDLdt51_b8) SOURCE OFF
         DC    AL1(CStgtlof),AL1(MDLdt51_b8la+02-MDLdt51_b8) FIELD 2OFF
         DC    AL1(CSSRPsrc),AL1(MDLDT51_b8j+01-MDLDT51_b8)  skip if 0
         DC    AL1(CSdfpexps),AL1(MDLdt51_b8se+02-MDLdt51_b8) dfp exp
         DC    AL1(CSdfpexp),AL1(MDLdt51_b8te+02-MDLdt51_b8) dfp exp
         DC    AL1(CSTGTLNL),AL1(MDLdt51_b8C+01-MDLdt51_b8) TARGET len
         DC    AL1(CSLSTBYT),AL1(MDLdt51_b8D+02-MDLdt51_b8) LSTBYTE OF
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        ASSIGN/MOVE FIELD      (BINARY TO PACKED - UNSIGNED/unsigned)*
***********************************************************************
MDLDT17  Xgr   R0,R0              LOAD BINARY NUMBER
MDLDT17A ICMy  R0,B'0000',0(0)
MDLdt17_la LAY R14,0(0,0)         get address
         cxgtr fp0,r0             convert to DFP
mdldt17j jnop  mdldt17lp
mdldt17se lghi r15,*-*
         iextr fp4,fp0,r15        set quantum of source
mdldt17te lghi r15,*-*
         iextr fp8,fp8,r15        set quantum of target
         qaxtr fp0,fp4,fp8,0      and quantise souce to target
mdldt17lp lpdfr fp0,fp0
         csxtr r0,fp0,1
         stmg  r0,r1,workarea
MDLDT17C ZAP   0(0,r14),workarea
MDLDT17D OI    0(r14),X'0F'
MDLDT17L EQU   *-MDLDT17
*
MDLDT17P EQU   0                  LITERAL POOL USAGE (EXCL FIELD LEN)
*
MDLDT17R DC    AL1(CSBYTMSS),AL1(MDLDT17A+01-MDLDT17) ICM  BYTE MASK
         DC    AL1(CSSRCloF),AL1(MDLDT17A+02-MDLDT17) SOURCE    OFFSET
         DC    AL1(CStgtlof),AL1(MDLdt17_la+02-MDLdt17) FIELD  2  OFF
         DC    AL1(CSSRPsrc),AL1(MDLDT17j+01-MDLDT17)  skip code if 0
         DC    AL1(CSdfpexps),AL1(MDLdt17se+02-MDLdt17) dfp exp
         DC    AL1(CSdfpexp),AL1(MDLdt17te+02-MDLdt17) dfp exp
         DC    AL1(CSTGTLNL),AL1(MDLDT17C+01-MDLDT17) TARGET    LENGTH
         DC    AL1(CSLSTBYT),AL1(MDLDT17D+02-MDLDT17) LAST BYTE OFFSET
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        ASSIGN/MOVE FIELD      (BINARY TO PACKED - UNSIGNED/Signed)  *
***********************************************************************
MDLDT52  Xgr   R0,R0              LOAD BINARY NUMBER
MDLDT52A ICMy  R0,B'0000',0(0)
MDLdt52_la LAY R14,0(0,0)         get address
         cxgtr fp0,r0             convert to DFP
mdldt52j jnop  mdldt52x
mdldt52se lghi r15,*-*
         iextr fp4,fp0,r15        set quantum of source
mdldt52te lghi r15,*-*
         iextr fp8,fp8,r15        set quantum of target
         qaxtr fp0,fp4,fp8,0      and quantise souce to target
mdldt52x csxtr r0,fp0,0
         stmg  r0,r1,workarea
MDLDT52C ZAP   0(0,r14),workarea
MDLDT52L EQU   *-MDLDT52
*
MDLDT52P EQU   0                  LITERAL POOL USAGE (EXCL FIELD LEN)
*
MDLDT52R DC    AL1(CSBYTMSS),AL1(MDLDT52A+01-MDLDT52) ICM  BYTE MASK
         DC    AL1(CSSRCloF),AL1(MDLDT52A+02-MDLDT52) SOURCE    OFFSET
         DC    AL1(CStgtlof),AL1(MDLdt52_la+02-MDLdt52) FIELD  2  OFF
         DC    AL1(CSSRPsrc),AL1(MDLDT52j+01-MDLDT52)  skip code if 0
         DC    AL1(CSdfpexps),AL1(MDLdt52se+02-MDLdt52) dfp exp
         DC    AL1(CSdfpexp),AL1(MDLdt52te+02-MDLdt52) dfp exp
         DC    AL1(CSTGTLNL),AL1(MDLDT52C+01-MDLDT52) TARGET    LENGTH
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        ASSIGN/MOVE FIELD      (BINARY TO PACKED - UNSIGNED/Signed)  *
***********************************************************************
MDLDT52_b8 lg  R0,0(0,0)          LOAD BINARY NUMBER
MDLdt52_b8_la LAY R14,0(0,0)      get address
         cxgtr fp0,r0             convert to DFP
mdldt52_b8j jnop  mdldt52_b8x
mdldt52_b8se lghi r15,*-*
         iextr fp4,fp0,r15        set quantum of source
mdldt52_b8te lghi r15,*-*
         iextr fp8,fp8,r15        set quantum of target
         qaxtr fp0,fp4,fp8,0      and quantise souce to target
mdldt52_b8x csxtr r0,fp0,0
         stmg  r0,r1,workarea
MDLDT52_b8C ZAP   0(0,r14),workarea
MDLDT52_b8L EQU *-MDLDT52_b8
*
MDLDT52_b8P EQU 0                 LITERAL POOL USAGE (EXCL FIELD LEN)
*
MDLDT52_b8R ds 0h
         DC    AL1(CSSRCloF),AL1(MDLDT52_b8+02-MDLDT52_b8) SOURCE OFF
         DC    AL1(CStgtlof),AL1(MDLdt52_b8_la+02-MDLdt52_b8) FLD2 OFF
         DC    AL1(CSSRPsrc),AL1(MDLDT52_b8j+01-MDLDT52_b8) skip if 0
         DC    AL1(CSdfpexps),AL1(MDLdt52_b8se+02-MDLdt52_b8) dfp exp
         DC    AL1(CSdfpexp),AL1(MDLdt52_b8te+02-MDLdt52_b8) dfp exp
         DC    AL1(CSTGTLNL),AL1(MDLDT52_b8C+01-MDLDT52_b8) TARGET LEN
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        ASSIGN/MOVE FIELD       (BINARY TO NUMERIC - SIGNED/Signed)  *
***********************************************************************
MDLDT18  XgR    R0,R0              LOAD BINARY NUMBER
MDLDT18S TMy   0(0),X'80'
         if (o)
           lghi r0,-1             fill with 1's
         endif
MDLDT18A ICMy  R0,B'0000',0(0)
MDLdt18_la LAY R14,0(0,0)         get address
         cxgtr fp0,r0             convert to DFP
mdldt18j jnop  mdldt18x
mdldt18se lghi r15,*-*
         iextr fp4,fp0,r15        set quantum of source
mdldt18te lghi r15,*-*
         iextr fp8,fp8,r15        set quantum of target
         qaxtr fp0,fp4,fp8,0      and quantise souce to target
mdldt18x csxtr r0,fp0,0
         stmg  r0,r1,workarea
MDLDT18C UNPK  0(0,r14),workarea
MDLDT18L EQU   *-MDLDT18
*
MDLDT18P EQU   0                  LITERAL POOL USAGE (EXCL FIELD LEN)
*
MDLDT18R DC    AL1(CSSRCloF),AL1(MDLDT18S+02-MDLDT18) SOURCE    OFFSET
         DC    AL1(CSBYTMSS),AL1(MDLDT18A+01-MDLDT18) ICM  BYTE MASK
         DC    AL1(CSSRCloF),AL1(MDLDT18A+02-MDLDT18) SOURCE    OFFSET
         DC    AL1(CStgtlof),AL1(MDLdt18_la+02-MDLdt18) FIELD  2  OFF
         DC    AL1(CSSRPsrc),AL1(MDLDT18j+01-MDLDT18)  skip code if 0
         DC    AL1(CSdfpexps),AL1(MDLdt18se+02-MDLdt18) dfp exp
         DC    AL1(CSdfpexp),AL1(MDLdt18te+02-MDLdt18) dfp exp
         DC    AL1(CSTGTLNL),AL1(MDLDT18C+01-MDLDT18) TARGET    LENGTH
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        ASSIGN/MOVE FIELD       (BINARY TO NUMERIC - SIGNED/Signed)  *
***********************************************************************
MDLdt18_b8  LG  R0,0(0,0)
MDLdt18_b8la LAY R14,0(0,0)         get address
         cxgtr fp0,r0             convert to DFP
mdldt18_b8j jnop  mdldt18_b8x
mdldt18_b8se lghi r15,*-*
         iextr fp4,fp0,r15        set quantum of source
mdldt18_b8te lghi r15,*-*
         iextr fp8,fp8,r15        set quantum of target
         qaxtr fp0,fp4,fp8,0      and quantise souce to target
mdldt18_b8x csxtr r0,fp0,0
         stmg  r0,r1,workarea
MDLdt18_b8C UNPK 0(0,r14),workarea
MDLdt18_b8L EQU *-MDLdt18_b8
*
MDLdt18_b8P EQU 0                 LITERAL POOL USAGE (EXCL FIELD LEN)
*
MDLdt18_b8R ds 0h
         DC    AL1(CSSRCLoF),AL1(MDLdt18_b8+02-MDLdt18_b8) SOURCE OFF
         DC    AL1(CStgtlof),AL1(MDLdt18_b8la+02-MDLdt18_b8) fld 2 off
         DC    AL1(CSSRPsrc),AL1(MDLdt18_b8j+01-MDLdt18_b8) skip if 0
         DC    AL1(CSdfpexps),AL1(MDLdt18_b8se+02-MDLdt18_b8) dfp exp
         DC    AL1(CSdfpexp),AL1(MDLdt18_b8te+02-MDLdt18_b8) dfp exp
         DC    AL1(CSTGTLNL),AL1(MDLdt18_b8C+01-MDLdt18_b8) TARGET LEN
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        ASSIGN/MOVE FIELD       (BINARY TO NUMERIC - SIGNED/Unsigned)*
***********************************************************************
MDLDT53  XgR   R0,R0              LOAD BINARY NUMBER
MDLDT53S TMy   0(0),X'80'
         if (o)
           lghi r0,-1             fill with 1's
         endif
MDLDT53A ICMy  R0,B'0000',0(0)
MDLdt53_la LAY R14,0(0,0)         get address
         cxgtr fp0,r0             convert to DFP
mdldt53j jnop  mdldt53lp
mdldt53se lghi r15,*-*
         iextr fp4,fp0,r15        set quantum of source
mdldt53te lghi r15,*-*
         iextr fp8,fp8,r15        set quantum of target
         qaxtr fp0,fp4,fp8,0      and quantise souce to target
mdldt53lp lpdfr fp0,fp0
         csxtr r0,fp0,1
         stmg  r0,r1,workarea
MDLdt53C UNPK 0(0,r14),workarea
MDLDT53L EQU   *-MDLDT53
*
MDLDT53P EQU   0                  LITERAL POOL USAGE (EXCL FIELD LEN)
*
MDLDT53R DC    AL1(CSSRCloF),AL1(MDLDT53S+02-MDLDT53) SOURCE    OFFSET
         DC    AL1(CSBYTMSS),AL1(MDLDT53A+01-MDLDT53) ICM  BYTE MASK
         DC    AL1(CSSRCloF),AL1(MDLDT53A+02-MDLDT53) SOURCE    OFFSET
         DC    AL1(CStgtlof),AL1(MDLdt53_la+02-MDLdt53) FIELD  2  OFF
         DC    AL1(CSSRPsrc),AL1(MDLDT53j+01-MDLDT53)  skip code if 0
         DC    AL1(CSdfpexps),AL1(MDLdt53se+02-MDLdt53) dfp exp
         DC    AL1(CSdfpexp),AL1(MDLdt53te+02-MDLdt53) dfp exp
         DC    AL1(CSTGTLNL),AL1(MDLDT53C+01-MDLDT53) TARGET    LENGTH
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        ASSIGN/MOVE FIELD       (BINARY8TO NUMERIC - SIGNED/Unsigned)*
***********************************************************************
MDLdt53_b8  LG  R0,0(0,0)         LOAD BINARY NUMBER
MDLdt53_b8la LAY R14,0(0,0)         get address
         cxgtr fp0,r0             convert to DFP
mdldt53_b8j jnop  mdldt53_b8lp
mdldt53_b8se lghi r15,*-*
         iextr fp4,fp0,r15        set quantum of source
mdldt53_b8te lghi r15,*-*
         iextr fp8,fp8,r15        set quantum of target
         qaxtr fp0,fp4,fp8,0      and quantise souce to target
mdldt53_b8lp lpdfr fp0,fp0
         csxtr r0,fp0,1
         stmg  r0,r1,workarea
MDLdt53_b8C UNPK 0(0,r14),workarea
MDLdt53_b8L EQU *-MDLdt53_b8
*
MDLdt53_b8P EQU 0                 LITERAL POOL USAGE (EXCL FIELD LEN)
*
MDLdt53_b8R ds 0h
         DC    AL1(CSSRCloF),AL1(MDLdt53_b8+02-MDLdt53_b8) SOURCE OFF
         DC    AL1(CStgtlof),AL1(MDLdt53_b8la+02-MDLdt53_b8) fld 2 off
         DC    AL1(CSSRPsrc),AL1(MDLDT53_b8j+01-MDLDT53_b8)  skip if 0
         DC    AL1(CSdfpexps),AL1(MDLdt53_b8se+02-MDLdt53_b8) dfp exp
         DC    AL1(CSdfpexp),AL1(MDLdt53_b8te+02-MDLdt53_b8) dfp exp
         DC    AL1(CSTGTLNL),AL1(MDLdt53_b8C+01-MDLdt53_b8) TARGET LEN
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        ASSIGN/MOVE FIELD     (BINARY TO NUMERIC - UNSIGNED/Unsigned)*
***********************************************************************
MDLDT19  Xgr   R0,R0              LOAD BINARY NUMBER
MDLDT19A ICMy  R0,B'0000',0(0)
MDLdt19_la LAY R14,0(0,0)         get address
         cxgtr fp0,r0             convert to DFP
mdldt19j jnop  mdldt19lp
mdldt19se lghi r15,*-*
         iextr fp4,fp0,r15        set quantum of source
mdldt19te lghi r15,*-*
         iextr fp8,fp8,r15        set quantum of target
         qaxtr fp0,fp4,fp8,0      and quantise souce to target
mdldt19lp lpdfr fp0,fp0
         csxtr r0,fp0,1
         stmg  r0,r1,workarea
MDLdt19C UNPK 0(0,r14),workarea
MDLDT19L EQU   *-MDLDT19
*
MDLDT19P EQU   0                  LITERAL POOL USAGE (EXCL FIELD LEN)
*
MDLDT19R DC    AL1(CSBYTMSS),AL1(MDLDT19A+01-MDLDT19) ICM  BYTE MASK
         DC    AL1(CSSRCloF),AL1(MDLDT19A+02-MDLDT19) SOURCE    OFFSET
         DC    AL1(CStgtlof),AL1(MDLdt19_la+02-MDLdt19) FIELD  2  OFF
         DC    AL1(CSSRPsrc),AL1(MDLDT19j+01-MDLDT19)  skip code if 0
         DC    AL1(CSdfpexps),AL1(MDLdt19se+02-MDLdt19) dfp exp
         DC    AL1(CSdfpexp),AL1(MDLdt19te+02-MDLdt19) dfp exp
         DC    AL1(CSTGTLNL),AL1(MDLDT19C+01-MDLDT19) TARGET    LENGTH
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        ASSIGN/MOVE FIELD    (BINARY8 TO NUMERIC - UNSIGNED/unsigned)
***********************************************************************
MDLdt19_b8 LG  R0,0(0,0)          LOAD BINARY NUMBER
MDLdt19_b8la LAY R14,0(0,0)         get address
         cxgtr fp0,r0             convert to DFP
mdldt19_b8j jnop  mdldt19_b8x
mdldt19_b8se lghi r15,*-*
         iextr fp4,fp0,r15        set quantum of source
mdldt19_b8te lghi r15,*-*
         iextr fp8,fp8,r15        set quantum of target
         qaxtr fp0,fp4,fp8,0      and quantise souce to target
mdldt19_b8x csxtr r0,fp0,1
         stmg  r0,r1,workarea
MDLdt19_b8C UNPK 0(0,r14),workarea
MDLdt19_b8L EQU *-MDLdt19_b8
*
MDLdt19_b8P EQU 0                 LITERAL POOL USAGE (EXCL FIELD LEN)
*
MDLdt19_b8R Ds 0h
         DC    AL1(CSSRCLoF),AL1(MDLdt19_b8+02-MDLdt19_b8) SOURCE OFF
         DC    AL1(CStgtlof),AL1(MDLdt19_b8la+02-MDLdt19_b8) fld 2 off
         DC    AL1(CSSRPsrc),AL1(MDLDT19_b8j+01-MDLDT19_b8)  skip if 0
         DC    AL1(CSdfpexps),AL1(MDLdt19_b8se+02-MDLdt19_b8) dfp exp
         DC    AL1(CSdfpexp),AL1(MDLdt19_b8te+02-MDLdt19_b8) dfp exp
         DC    AL1(CSTGTLNL),AL1(MDLdt19_b8C+01-MDLdt19_b8) TARGET LEN
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        ASSIGN/MOVE FIELD     (BINARY TO NUMERIC - UNSIGNED/Signed)  *
***********************************************************************
MDLDT54  Xgr   R0,R0              LOAD BINARY NUMBER
MDLDT54A ICMy  R0,B'0000',0(0)
MDLdt54_la LAY R14,0(0,0)         get address
         cxgtr fp0,r0             convert to DFP
mdldt54j jnop  mdldt54x
mdldt54se lghi r15,*-*
         iextr fp4,fp0,r15        set quantum of source
mdldt54te lghi r15,*-*
         iextr fp8,fp8,r15        set quantum of target
         qaxtr fp0,fp4,fp8,0      and quantise souce to target
mdldt54x csxtr r0,fp0,0
         stmg  r0,r1,workarea
MDLdt54C UNPK 0(0,r14),workarea
MDLDT54L EQU   *-MDLDT54
*
MDLDT54P EQU   0                  LITERAL POOL USAGE (EXCL FIELD LEN)
*
MDLDT54R DC    AL1(CSBYTMSS),AL1(MDLDT54A+01-MDLDT54) ICM  BYTE MASK
         DC    AL1(CSSRCloF),AL1(MDLDT54A+02-MDLDT54) SOURCE    OFFSET
         DC    AL1(CStgtlof),AL1(MDLdt54_la+02-MDLdt54) FIELD  2  OFF
         DC    AL1(CSSRPsrc),AL1(MDLDT54j+01-MDLDT54)  skip code if 0
         DC    AL1(CSdfpexps),AL1(MDLdt54se+02-MDLdt54) dfp exp
         DC    AL1(CSdfpexp),AL1(MDLdt54te+02-MDLdt54) dfp exp
         DC    AL1(CSTGTLNL),AL1(MDLDT54C+01-MDLDT54) TARGET    LENGTH
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        ASSIGN/MOVE FIELD     (BINARY TO NUMERIC - UNSIGNED/Signed)  *
***********************************************************************
MDLdt54_b8 LG  R0,0(0,0)          LOAD BINARY NUMBER
MDLdt54_b8la LAY R14,0(0,0)         get address
         cxgtr fp0,r0             convert to DFP
mdldt54_b8j jnop  mdldt54_b8x
mdldt54_b8se lghi r15,*-*
         iextr fp4,fp0,r15        set quantum of source
mdldt54_b8te lghi r15,*-*
         iextr fp8,fp8,r15        set quantum of target
         qaxtr fp0,fp4,fp8,0      and quantise souce to target
mdldt54_b8x csxtr r0,fp0,0
         stmg  r0,r1,workarea
MDLdt54_b8C UNPK 0(0,r14),workarea
MDLdt54_b8L EQU *-MDLdt54_b8
*
MDLdt54_b8P EQU 0                 LITERAL POOL USAGE (EXCL FIELD LEN)
*
MDLdt54_b8R Ds 0h
         DC    AL1(CSSRCLoF),AL1(MDLdt54_b8+02-MDLdt54_b8) SOURCE OFF
         DC    AL1(CStgtlof),AL1(MDLdt54_b8la+02-MDLdt54_b8) fld 2 off
         DC    AL1(CSSRPsrc),AL1(MDLDT54_b8j+01-MDLDT54_b8)  skip if 0
         DC    AL1(CSdfpexps),AL1(MDLdt54_b8se+02-MDLdt54_b8) dfp exp
         DC    AL1(CSdfpexp),AL1(MDLdt54_b8te+02-MDLdt54_b8) dfp exp
         DC    AL1(CSTGTLNL),AL1(MDLdt54_b8C+01-MDLdt54_b8) TARGET LEN
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        ASSIGN/MOVE FIELD       (BINARY TO BINARY - BOTH UNSIGNED)   *
***********************************************************************
MDLDT20  XR    R0,R0              LOAD BINARY NUMBER
MDLDT20A ICMy  R0,B'0000',0(0)
MDLDT20B STCMy R0,B'0000',0(0)
MDLDT20L EQU   *-MDLDT20
*
MDLDT20P EQU   0                  LITERAL POOL USAGE (EXCL FIELD LEN)
*
MDLDT20R DC    AL1(CSBYTMSS),AL1(MDLDT20A+01-MDLDT20) ICM  BYTE MASK
         DC    AL1(CSSRCloF),AL1(MDLDT20A+02-MDLDT20) SOURCE    OFFSET
         DC    AL1(CSBYTMSK),AL1(MDLDT20B+01-MDLDT20) STCM BYTE MASK
         DC    AL1(CSjusoff),AL1(MDLDT20B+02-MDLDT20) TARGET    OFFSET +
                                        right justified
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        ASSIGN/MOVE FIELD       (BINARY TO BINARY - BOTH SIGNED)     *
***********************************************************************
*
*  This model is only used for lengths 1 to 4 - code in the LTBLBSN
*  routine in MR96 will prevent this being used for longer lengths
*
MDLDT21  xgr   R0,R0              LOAD BINARY NUMBER
MDLDT21S TMy   0(0),X'80'
         JNO   mdldt21a
         Lghi  R0,-1              Fills the register with 1's
MDLDT21A ICMy  R0,B'0000',0(0)
         cxgtr fp0,r0             convert to DFP
mdldt21j jnop  mdldt21x
mdldt21se lghi r15,*-*
mdldt21te lghi r14,*-*
         iextr fp4,fp0,r15        set quantum of source
         iextr fp8,fp8,r14        set quantum of target
         qaxtr fp0,fp4,fp8,0      and quantise souce to target
mdldt21x cgxtr r0,0,fp0
MDLDT21C STCMy R0,B'0000',0(0)
MDLDT21L EQU   *-MDLDT21
*
MDLDT21P EQU   0                  LITERAL POOL USAGE (EXCL FIELD LEN)
*
MDLDT21R DC    AL1(CSSRCloF),AL1(MDLDT21S+02-MDLDT21) SOURCE    OFFSET
         DC    AL1(CSBYTMSS),AL1(MDLDT21A+01-MDLDT21) ICM  BYTE MASK
         DC    AL1(CSSRCloF),AL1(MDLDT21A+02-MDLDT21) SOURCE    OFFSET
         DC    AL1(CSSRPsrc),AL1(MDLDT21j+01-MDLDT21) skip code if 0
         DC    AL1(CSdfpexps),AL1(MDLdt21se+02-MDLdt21) dfp exp
         DC    AL1(CSdfpexp),AL1(MDLdt21te+02-MDLdt21) dfp exp
         DC    AL1(CSBYTMSK),AL1(MDLDT21C+01-MDLDT21) STCM BYTE MASK
         DC    AL1(CSTGTloF),AL1(MDLDT21C+02-MDLDT21) TARGET    OFFSET
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        ASSIGN/MOVE FIELD       (BIN 1,2,4  BINARY8 BOTH SIGNED)     *
***********************************************************************
*
*  This model is used to conver from bin 1,2, or 4 to bin 8
*
MDLDT21_b8 xgr  R0,R0              LOAD BINARY NUMBER
MDLDT21_b8t TMy 0(0),X'80'
          JNO  mdldt21_b8a
          Lghi R0,-1              Fills the register with 1's
MDLDT21_b8a ICMy R0,B'0000',0(0)
         cxgtr fp0,r0             convert to DFP
mdldt21_b8j jnop  mdldt21_b8x
mdldt21_b8se lghi r15,*-*
mdldt21_b8te lghi r14,*-*
         iextr fp4,fp0,r15        set quantum of source
         iextr fp8,fp8,r14        set quantum of target
         qaxtr fp0,fp4,fp8,0      and quantise souce to target
mdldt21_b8x cgxtr r0,0,fp0
MDLdt21_b8C STG R0,0(0,0)
MDLdt21_b8L EQU *-MDLdt21_b8
*
MDLdt21_b8P EQU 0                 LITERAL POOL USAGE (EXCL FIELD LEN)
*
MDLdt21_b8R Ds 0h
         DC    AL1(CSSRCloF),AL1(MDLDT21_b8t+02-MDLDT21_b8) SOURCE OFF
         DC    AL1(CSBYTMSS),AL1(MDLDT21_b8A+01-MDLDT21_b8) ICM MASK
         DC    AL1(CSSRCloF),AL1(MDLDT21_b8A+02-MDLDT21_b8) SOURCE OFF
         DC    AL1(CSSRPsrc),AL1(MDLdt21_b8j+01-MDLdt21_b8) skip if 0
         DC    AL1(CSdfpexps),AL1(MDLdt21_b8se+02-MDLdt21_b8) dfp exp
         DC    AL1(CSdfpexp),AL1(MDLdt21_b8te+02-MDLdt21_b8) dfp exp
         DC    AL1(CSTGTLoF),AL1(MDLdt21_b8C+02-MDLdt21_b8) TARGETOFF
         DC   2XL1'FF'
***********************************************************************
*        ASSIGN/MOVE FIELD       (BIN8  BINARY1 2 4  BOTH SIGNED)     *
***********************************************************************
*
*  This model is used to conver from bin 8 to bin 1,2, or 4
*
MDLdt21_8b LG  R0,0(0,0)          LOAD BINARY NUMBER
         cxgtr fp0,r0             convert to DFP
mdldt21_8bj jnop  mdldt21_8bx
mdldt21_8bse lghi r15,*-*
mdldt21_8bte lghi r14,*-*
         iextr fp4,fp0,r15        set quantum of source
         iextr fp8,fp8,r14        set quantum of target
         qaxtr fp0,fp4,fp8,0      and quantise souce to target
mdldt21_8bx cgxtr r0,0,fp0
MDLdt21_8bC STcmy R0,b'0000',0(0)
MDLdt21_8bL EQU *-MDLdt21_8b
*
MDLdt21_8bP EQU 0                 LITERAL POOL USAGE (EXCL FIELD LEN)
*
MDLdt21_8bR Ds 0h
         DC    AL1(CSSRCloF),AL1(MDLDT21_8b+02-MDLDT21_8b) SOURCE OFF
         DC    AL1(CSSRPsrc),AL1(MDLdt21_8bj+01-MDLdt21_8b) skip if 0
         DC    AL1(CSdfpexps),AL1(MDLdt21_8bse+02-MDLdt21_8b) dfp exp
         DC    AL1(CSdfpexp),AL1(MDLdt21_8bte+02-MDLdt21_8b) dfp exp
         DC    AL1(CSBYTMSK),AL1(MDLDT21_8bC+01-MDLDT21_8b) ICM MASK
         DC    AL1(CSTGTLoF),AL1(MDLdt21_8bC+02-MDLdt21_8b) TARGETOFF
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        ASSIGN/MOVE FIELD       (BINARY8 to BINARY8 BOTH SIGNED)     *
***********************************************************************
*
*  This model is only used for length  8
*
MDLdt21_88 LG  R0,0(0,0)          LOAD BINARY NUMBER
         cxgtr fp0,r0             convert to DFP
mdldt21_88j jnop  mdldt21_88x
mdldt21_88se lghi r15,*-*
mdldt21_88te lghi r14,*-*
         iextr fp4,fp0,r15        set quantum of source
         iextr fp8,fp8,r14        set quantum of target
         qaxtr fp0,fp4,fp8,0      and quantise souce to target
mdldt21_88x cgxtr r0,0,fp0
MDLdt21_88C STG R0,0(0,0)
MDLdt21_88L EQU *-MDLdt21_88
*
MDLdt21_88P EQU 0                 LITERAL POOL USAGE (EXCL FIELD LEN)
*
MDLdt21_88R Ds 0h
         DC    AL1(CSSRCLoF),AL1(MDLdt21_88+02-MDLdt21_88) SOURCE OFF
         DC    AL1(CSSRPsrc),AL1(MDLdt21_88j+01-MDLdt21_88) skip if 0
         DC    AL1(CSdfpexps),AL1(MDLdt21_88se+02-MDLdt21_88) dfp exp
         DC    AL1(CSdfpexp),AL1(MDLdt21_88te+02-MDLdt21_88) dfp exp
         DC    AL1(CSTGTLoF),AL1(MDLdt21_88C+02-MDLdt21_88) TARGETOFF
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        ASSIGN/MOVE FIELD       (BINARY TO BINARY - SIGNED/UNSIGNED) *
***********************************************************************
*        this model is used to convert from anything to unsigned
*        - essentially no sign propogation.
*        And this has the potential to cause hidden errors
MDLDT22  Xgr   R0,R0              LOAD BINARY NUMBER
MDLDT22A ICMy  R0,B'0000',0(0)
         cxgtr fp0,r0             convert to DFP
mdldt22j jnop  mdldt22lp
mdldt22se lghi r15,*-*
mdldt22te lghi r14,*-*
         iextr fp4,fp0,r15        set quantum of source
         iextr fp8,fp8,r14        set quantum of target
         qaxtr fp0,fp4,fp8,0      and quantise souce to target
mdldt22lp lpdfr fp0,fp0            force positive
         cgxtr r0,0,fp0
MDLDT22C STCMy R0,B'0000',0(0)
MDLDT22L EQU   *-MDLDT22
*
MDLDT22P EQU   0                  LITERAL POOL USAGE (EXCL FIELD LEN)
*
MDLDT22R ds    0h
         DC    AL1(CSBYTMSS),AL1(MDLDT22A+01-MDLDT22) ICM  BYTE MASK
         DC    AL1(CSSRCloF),AL1(MDLDT22A+02-MDLDT22) SOURCE    OFFSET
         DC    AL1(CSSRPsrc),AL1(MDLDT22j+01-MDLDT22) SHIFT DEC PLACES
         DC    AL1(CSdfpexps),AL1(MDLdt22se+02-MDLdt22) dfp exp
         DC    AL1(CSdfpexp),AL1(MDLdt22te+02-MDLdt22) dfp exp
         DC    AL1(CSBYTMSK),AL1(MDLDT22C+01-MDLDT22) STCM BYTE MASK
         DC    AL1(csjusoff),AL1(MDLDT22C+02-MDLDT22) TARGET    OFFSET
         DC   2XL1'FF'
                        SPACE 3
*
*  This model is used to conver from bin 1,2, or 4 to bin 8
*
MDLDT22_b8 xgr  R0,R0              LOAD BINARY NUMBER
MDLDT22_b8a ICMy R0,B'0000',0(0)
         cxgtr fp0,r0             convert to DFP
mdldt22_b8j jnop  mdldt22_b8lp
mdldt22_b8se lghi r15,*-*
mdldt22_b8te lghi r14,*-*
         iextr fp4,fp0,r15        set quantum of source
         iextr fp8,fp8,r14        set quantum of target
         qaxtr fp0,fp4,fp8,0      and quantise souce to target
mdldt22_b8lp lpdfr fp0,fp0            force positive
         cgxtr r0,0,fp0
MDLdt22_b8C STG R0,0(0,0)
MDLdt22_b8L EQU *-MDLdt22_b8
*
MDLdt22_b8P EQU 0                 LITERAL POOL USAGE (EXCL FIELD LEN)
*
MDLdt22_b8R Ds 0h
         DC    AL1(CSBYTMSS),AL1(MDLDT22_b8A+01-MDLDT22_b8) ICM MASK
         DC    AL1(CSSRCloF),AL1(MDLDT22_b8A+02-MDLDT22_b8) SOURCE OFF
         DC    AL1(CSSRPsrc),AL1(MDLdt22_b8j+01-MDLdt22_b8) skip if 0
         DC    AL1(CSdfpexps),AL1(MDLdt22_b8se+02-MDLdt22_b8) dfp exp
         DC    AL1(CSdfpexp),AL1(MDLdt22_b8te+02-MDLdt22_b8) dfp exp
         DC    AL1(CSTGTLoF),AL1(MDLdt22_b8C+02-MDLdt22_b8) TARGETOFF
         DC   2XL1'FF'
*
*  This model is used to conver from bin 8 to  bin 1 2 or 4
*
MDLdt22_8b LG  R0,0(0,0)          LOAD BINARY NUMBER
         cxgtr fp0,r0             convert to DFP
mdldt22_8bj jnop  mdldt22_8blp
mdldt22_8bse lghi r15,*-*
mdldt22_8bte lghi r14,*-*
         iextr fp4,fp0,r15        set quantum of source
         iextr fp8,fp8,r14        set quantum of target
         qaxtr fp0,fp4,fp8,0      and quantise souce to target
mdldt22_8blp lpdfr fp0,fp0            force positive
         cgxtr r0,0,fp0
MDLdt22_8bC STcmy R0,b'0000',0(0)
MDLdt22_8bL EQU *-MDLdt22_8b
*
MDLdt22_8bP EQU 0                 LITERAL POOL USAGE (EXCL FIELD LEN)
*
MDLdt22_8bR Ds 0h
         DC    AL1(CSSRCloF),AL1(MDLDT22_8b+02-MDLDT22_8b) SOURCE OFF
         DC    AL1(CSSRPsrc),AL1(MDLdt22_8bj+01-MDLdt22_8b) skip if 0
         DC    AL1(CSdfpexps),AL1(MDLdt22_8bse+02-MDLdt22_8b) dfp exp
         DC    AL1(CSdfpexp),AL1(MDLdt22_8bte+02-MDLdt22_8b) dfp exp
         DC    AL1(CSBYTMSK),AL1(MDLDT22_8bC+01-MDLDT22_8b) ICM MASK
         DC    AL1(CSTGTLoF),AL1(MDLdt22_8bC+02-MDLdt22_8b) TARGETOFF
         DC   2XL1'FF'
                        SPACE 3
*
*  This model is only used for length  8
*
*        this model is used to convert from signed to unsigned
MDLdt22_88 LG  R0,0(0,0)          LOAD BINARY NUMBER
         cxgtr fp0,r0             convert to DFP
mdldt22_88j jnop  mdldt22_88lp
mdldt22_88se lghi r15,*-*
mdldt22_88te lghi r14,*-*
         iextr fp4,fp0,r15        set quantum of source
         iextr fp8,fp8,r14        set quantum of target
         qaxtr fp0,fp4,fp8,0      and quantise souce to target
mdldt22_88lp lpdfr fp0,fp0            force positive
         cgxtr r0,0,fp0
MDLdt22_88C STG R0,0(0,0)
MDLdt22_88L EQU *-MDLdt22_88
*
MDLdt22_88P EQU 0                 LITERAL POOL USAGE (EXCL FIELD LEN)
*
MDLdt22_88R Ds 0h
         DC    AL1(CSSRCLoF),AL1(MDLdt22_88+02-MDLdt22_88) SOURCE OFF
         DC    AL1(CSSRPsrc),AL1(MDLdt22_88j+01-MDLdt22_88) skip if 0
         DC    AL1(CSdfpexps),AL1(MDLdt22_88se+02-MDLdt22_88) dfp exp
         DC    AL1(CSdfpexp),AL1(MDLdt22_88te+02-MDLdt22_88) dfp exp
         DC    AL1(CSTGTLoF),AL1(MDLdt22_88C+02-MDLdt22_88) TARGETOFF
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        ASSIGN/MOVE FIELD       (BINARY TO BINARY - UNSIGNED/SIGNED) *
***********************************************************************
*        this model is used to convert from unsigned to signed
MDLDT23  XgR    R0,R0              LOAD BINARY NUMBER
MDLDT23A ICMY  R0,B'0000',0(0)
         cxgtr fp0,r0             convert to DFP
mdldt23j jnop  mdldt23x
mdldt23se lghi r15,*-*
mdldt23te lghi r14,*-*
         iextr fp4,fp0,r15        set quantum of source
         iextr fp8,fp8,r14        set quantum of target
         qaxtr fp0,fp4,fp8,0      and quantise souce to target
mdldt23x cgxtr r0,0,fp0
MDLDT23C STCMy R0,B'0000',0(0)
MDLDT23L EQU   *-MDLDT23
*
MDLDT23P EQU   0                  LITERAL POOL USAGE (EXCL FIELD LEN)
*
MDLDT23R DC    AL1(CSBYTMSS),AL1(MDLDT23A+01-MDLDT23) ICM  BYTE MASK
         DC    AL1(CSSRCloF),AL1(MDLDT23A+02-MDLDT23) SOURCE    OFFSET
         DC    AL1(CSSRPsrc),AL1(MDLDT23j+01-MDLDT23) skip if 0
         DC    AL1(CSdfpexps),AL1(MDLdt23se+02-MDLdt23) dfp exp
         DC    AL1(CSdfpexp),AL1(MDLdt23te+02-MDLdt23) dfp exp
         DC    AL1(CSBYTMSK),AL1(MDLDT23C+01-MDLDT23) STCM BYTE MASK
         DC    AL1(csjusoff),AL1(MDLDT23C+02-MDLDT23) TARGET    OFFSET
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        ASSIGN/MOVE FIELD       (PACKED TO NUMERIC - COMPATIBLE      *
***********************************************************************
MDLdt24  LAY   R15,0(0,0)         get address
MDLdt24_la LAY R14,0(0,0)         get address
MDLDT24U UNPK  0(0,r14),0(0,r15)  CONVERT  FIELD   TO  NUMERIC FORMAT
MDLDT24L EQU   *-MDLDT24
*
MDLDT24P EQU   0                  LITERAL POOL USAGE (EXCL FIELD LEN)
*
MDLDT24R DC    AL1(CSTGTLNL),AL1(MDLDT24u+01-MDLDT24)  TARGET    LENGTH
         DC    AL1(CSSRCLNR),AL1(MDLDT24u+01-MDLDT24)  TARGET    LENGTH
         DC    AL1(CSSRClof),AL1(MDLdt24+02-MDLdt24)   FIELD  1  OFF
         DC    AL1(CStgtlof),AL1(MDLdt24_lA+02-MDLdt24) FIELD  2  OFF
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        ASSIGN/MOVE FIELD       (NUMERIC TO PACKED - COMPATIBLE      *
***********************************************************************
MDLdt25  LAY   R15,0(0,0)         get address
MDLdt25_la LAY R14,0(0,0)         get address
MDLDT25k PACK  0(0,r14),0(0,r15)  CONVERT  FIELD   TO  NUMERIC FORMAT
MDLDT25L EQU   *-MDLDT25
*
MDLDT25P EQU   0                  LITERAL POOL USAGE (EXCL FIELD LEN)
*
MDLDT25R DC    AL1(CSTGTLNL),AL1(MDLDT25k+01-MDLDT25)  TARGET    LENGTH
         DC    AL1(CSSRCLNR),AL1(MDLDT25k+01-MDLDT25)  TARGET    LENGTH
         DC    AL1(CSSRClof),AL1(MDLdt25+02-MDLdt25)   FIELD  1  OFF
         DC    AL1(CStgtlof),AL1(MDLdt25_lA+02-MDLdt25) FIELD  2  OFF
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        ASSIGN/MOVE ACCUM       (PACKED TO ALPHA/EDITED/MASKED)      *
***********************************************************************
MDLDT27  LAY   R14,0(,R2)         LOAD ACCUMULATOR ADDR (CHG'D TO "LY")
mdldt27a ld    fp0,0(0,r14)       Load value from storage
         ld    fp2,8(0,r14)
mdldt27d lghi  r15,*-*            Create biased exponent
         iextr fp1,fp0,r15          and insert
         csxtr r0,fp1,0
         stmg  r0,r1,workarea
MDLdt27_la LAY R15,0(0,0)         get address
MDLDT27Z ZAP   0(0,r15),workarea  COPY  PACKED  TO PACKED FORMAT
MDLDT27L EQU   *-MDLDT27
*
MDLDT27P EQU   4                  LITERAL POOL USAGE (EXCL FIELD LEN)
*
MDLDT27R DC    AL1(CSACCOF2),AL1(MDLDT27+02-MDLDT27)  ACCUM ADR OFFSET
         DC    AL1(CStgtlof),AL1(MDLdt27_lA+02-MDLdt27) FIELD  2  OFF
         DC    AL1(CSdfpopt),AL1(mdldt27a-mdldt27) optimise loads
         DC    AL1(CSdfpexp),AL1(MDLdt27d+02-MDLdt27) SHIFT DEC PLACES
         DC    AL1(CSTGTLNL),AL1(MDLDT27Z+01-MDLDT27) TARGET    LENGTH
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        ASSIGN/MOVE ACCUM       (Float to packed              )      *
***********************************************************************
MDLdt27f LAY   R14,0(,R2)         LOAD ACCUMULATOR ADDR (CHG'D TO "LY")
mdldt27fa ld   fp0,0(0,r14)       Load value from storage
         ld    fp2,8(0,r14)
mdldt27fd lghi r15,*-*            Create biased exponent
         iextr fp8,fp8,r15          and insert into the dfp zero
         qaxtr fp1,fp0,fp8,0         quantise the data
         csxtr r0,fp1,0
         stmg  r0,r1,workarea
MDLdt27f_la LAY R15,0(0,0)        get address
MDLdt27fZ ZAP  0(0,r15),workarea  COPY  PACKED  TO PACKED FORMAT
MDLdt27fL EQU  *-MDLdt27f
*
MDLdt27fP EQU  4                  LITERAL POOL USAGE (EXCL FIELD LEN)
*
MDLdt27fR DC   AL1(CSACCOF2),AL1(MDLdt27f+02-MDLdt27f) ACCUM ADR OFFSET
         DC    AL1(CStgtlof),AL1(MDLdt27f_lA+02-MDLdt27f) FIELD 2 OFF
         DC    AL1(CSdfpopt),AL1(mdldt27fa-mdldt27f) optimise loads
         DC    AL1(CSdfpexp),AL1(MDLdt27fd+02-MDLdt27f) SHIFT DECPLACES
         DC    AL1(CSTGTLNL),AL1(MDLdt27fZ+01-MDLdt27f) TARGET  LENGTH
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        ASSIGN/MOVE ACCUM       (PACKED TO PACKED - UNSIGNED         *
***********************************************************************
MDLDT28  LAY   R14,0(,R2)         LOAD ACCUMULATOR ADDR (CHG'D TO "LY")
mdldt28a ld    fp0,0(0,r14)       Load value from storage
         ld    fp2,8(0,r14)
         lpdfr fp0,fp0            force it positive
mdldt28d lghi  r15,*-*            Create biased exponent
         iextr fp1,fp0,r15          and insert
         csxtr r0,fp1,1           The M value of 1 sets the sign to F
         stmg  r0,r1,workarea
MDLdt28_la LAY R15,0(0,0)         get address
MDLDT28Z ZAP   0(0,r15),workarea  COPY  PACKED  TO PACKED FORMAT
MDLDT28B OI    0(r15),X'0F'       FORCE TO UNSIGNED
MDLDT28L EQU   *-MDLDT28
*
MDLDT28P EQU   4                  LITERAL POOL USAGE (EXCL FIELD LEN)
*
MDLDT28R DC    AL1(CSACCOF2),AL1(MDLDT28+02-MDLDT28)  ACCUM ADR OFFSET
         DC    AL1(CStgtlof),AL1(MDLdt28_lA+02-MDLdt28) FIELD  2  OFF
         DC    AL1(CSdfpopt),AL1(mdldt28a-mdldt28) optimise loads
         DC    AL1(CSdfpexp),AL1(MDLdt28d+02-MDLdt28) SHIFT DEC PLACES
         DC    AL1(CSTGTLNL),AL1(MDLDT28Z+01-MDLDT28) TARGET    LENGTH
         DC    AL1(CSLSTBYT),AL1(MDLDT28B+02-MDLDT28) LAST  TGT BYTE
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        ASSIGN/MOVE ACCUM       (PACKED TO NUMERIC - SIGNED)         *
***********************************************************************
MDLDT29  LAY   R14,0(,R2)         LOAD ACCUMULATOR ADDR (CHG'D TO "LY")
mdldt29a ld    fp0,0(0,r14)       Load value from storage
         ld    fp2,8(0,r14)
mdldt29d lghi  r15,*-*            Create biased exponent
         iextr fp1,fp0,r15          and insert
         csxtr r0,fp1,0
         stmg  r0,r1,workarea
MDLdt29_la LAY R15,0(0,0)         get address
MDLDT29B UNPK  0(0,r15),workarea  CONVERT  FIELD   TO  DISPLAY FORMAT
MDLDT29L EQU   *-MDLDT29
*
MDLDT29P EQU   4                  LITERAL POOL USAGE (EXCL FIELD LEN)
*
MDLDT29R DC    AL1(CSACCOF2),AL1(MDLDT29+02-MDLDT29)  ACCUM ADR OFFSET
         DC    AL1(CStgtlof),AL1(MDLdt29_lA+02-MDLdt29) FIELD  2  OFF
         DC    AL1(CSdfpopt),AL1(mdldt29a-mdldt29) optimise loads
         DC    AL1(CSdfpexp),AL1(MDLdt29d+02-MDLdt29) SHIFT DEC PLACES
         DC    AL1(CSTGTLNL),AL1(MDLDT29B+01-MDLDT29) TARGET    LENGTH
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        ASSIGN/MOVE ACCUM       (PACKED TO NUMERIC - UNSIGNED)       *
***********************************************************************
MDLDT30  LAY   R14,0(,R2)         LOAD ACCUMULATOR ADDR (CHG'D TO "LY")
mdldt30a ld    fp0,0(0,r14)       Load value from storage
         ld    fp2,8(0,r14)
         lpdfr fp0,fp0            force it positive
mdldt30d lghi  r15,*-*            Create biased exponent
         iextr fp1,fp0,r15          and insert
         csxtr r0,fp1,1
         stmg  r0,r1,workarea
MDLdt30_la LAY R15,0(0,0)         get address
MDLDT30B UNPK  0(0,r15),workarea  CONVERT FIELD TO DISPLAY FORMAT
MDLDT30C OI    0(r15),X'F0'
MDLDT30L EQU   *-MDLDT30
*
MDLDT30P EQU   4                  LITERAL POOL USAGE (EXCL FIELD LEN)
*
MDLDT30R DC    AL1(CSACCOF2),AL1(MDLDT30+02-MDLDT30)  ACCUM ADR OFFSET
         DC    AL1(CStgtlof),AL1(MDLdt30_lA+02-MDLdt30) FIELD  2  OFF
         DC    AL1(CSdfpopt),AL1(mdldt30a-mdldt30) optimise loads
         DC    AL1(CSdfpexp),AL1(MDLdt30d+02-MDLdt30) SHIFT DEC PLACES
         DC    AL1(CSTGTLNL),AL1(MDLDT30B+01-MDLDT30) TARGET    LENGTH
         DC    AL1(CSLSTBYT),AL1(MDLDT30C+02-MDLDT30) LAST BYTE OFFSET
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        ASSIGN/MOVE ACCUM       (PACKED TO BINARY - SIGNED           *
***********************************************************************
MDLDT31  LAY   R14,0(,R2)         LOAD ACCUMULATOR ADDR (CHG'D TO "LY")
mdldt31a ld    fp0,0(0,r14)       Load value from storage
         ld    fp2,8(0,r14)
mdldt31d lghi  r15,*-*            Create biased exponent
         iextr fp1,fp0,r15          and insert
         cgxtr r0,0,fp1           Convert to fixed
MDLDT31B STCMy R0,B'0000',0(0)    STORE REQUIRED   BYTES
MDLDT31L EQU   *-MDLDT31
*
MDLDT31P EQU   4                  LITERAL POOL USAGE (EXCL FIELD LEN)
*
MDLDT31R DC    AL1(CSACCOF2),AL1(MDLDT31+02-MDLDT31)  ACCUM ADR OFFSET
         DC    AL1(CSdfpopt),AL1(mdldt31a-mdldt31) optimise loads
         DC    AL1(CSdfpexp),AL1(MDLdt31d+02-MDLdt31) SHIFT DEC PLACES
         DC    AL1(CSBYTMSK),AL1(MDLDT31B+01-MDLDT31) STCM BYTE MASK
         DC    AL1(CSTGTloF),AL1(MDLDT31b+02-MDLDT31) TARGET    OFFSET
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        ASSIGN/MOVE ACCUM       (PACKED TO BINARY8- SIGNED           *
***********************************************************************
MDLdt31_b8 LAY R14,0(,R2)         LOAD ACCUMULATOR ADDR (CHG'D TO "LY")
mdldt31_b8a ld fp0,0(0,r14)       Load value from storage
         ld    fp2,8(0,r14)
mdldt31_b8d lghi r15,*-*          Create biased exponent
         iextr fp1,fp0,r15          and insert
         cgxtr r0,0,fp1           Convert to fixed
MDLdt31_b8C STG  R0,0(0,0)          STORE REQUIRED   BYTES
MDLdt31_b8L EQU *-MDLdt31_b8
*
MDLdt31_b8P EQU 4                 LITERAL POOL USAGE (EXCL FIELD LEN)
*
MDLdt31_b8R DC AL1(CSACCOF2),AL1(MDLdt31_b8+02-MDLdt31_b8) ACCM ADR OFF
         DC    AL1(CSdfpopt),AL1(mdldt31_b8a-mdldt31_b8) optimise loads
         DC    AL1(CSdfpexp),AL1(MDLdt31_b8d+02-MDLdt31_b8) SHIFT DEC
         DC    AL1(CSTGTLOF),AL1(MDLdt31_b8C+02-MDLdt31_b8) TARGETOFF
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        ASSIGN/MOVE ACCUM       (PACKED TO BINARY - UNSIGNED         *
***********************************************************************
MDLDT32  LAY   R14,0(,R2)         LOAD ACCUMULATOR ADDR (CHG'D TO "LY")
mdldt32a ld    fp0,0(0,r14)       Load value from storage
         ld    fp2,8(0,r14)
mdldt32d lghi  r15,*-*            Create biased exponent
         iextr fp1,fp0,r15          and insert
         cgxtr r0,0,fp1           Convert to fixed
         lpgr  r0,r0              make it positive
MDLDT32B STCMy R0,B'0000',0(0)    STORE REQUIRED   BYTES
MDLDT32L EQU   *-MDLDT32
*
MDLDT32P EQU   4                  LITERAL POOL USAGE (EXCL FIELD LEN)
*
MDLDT32R DC    AL1(CSACCOF2),AL1(MDLDT32+02-MDLDT32)  ACCUM ADR OFFSET
         DC    AL1(CSdfpopt),AL1(mdldt32a-mdldt32) optimise loads
         DC    AL1(CSdfpexp),AL1(MDLdt32d+02-MDLdt32) SHIFT DEC PLACES
         DC    AL1(CSBYTMSK),AL1(MDLDT32B+01-MDLDT32) STCM BYTE MASK
         DC    AL1(CSTGTloF),AL1(MDLDT32b+02-MDLDT32) TARGET    OFFSET
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        ASSIGN/MOVE ACCUM       (BINARY TO BINARY - UNSIGNED         *
***********************************************************************
MDLDT33  LAY   R14,0(,R2)         LOAD ACCUMULATOR ADDR (CHG'D TO "LY")
         Xgr   R0,R0
MDLDT33Z ICM   R0,B'0000',0(R14)  CONVERT FIELD TO PACKED FORMAT
         cxgtr fp0,r0             convert to DFP
mdldt33j jnop  mdldt33lp
mdldt33se lghi r15,*-*
mdldt33te lghi r14,*-*
         iextr fp4,fp0,r15        set quantum of source
         iextr fp8,fp8,r14        set quantum of target
         qaxtr fp0,fp4,fp8,0      and quantise souce to target
mdldt33lp lpdfr fp0,fp0
         cgxtr r0,0,fp0
MDLDT33B STCMy R0,B'0000',0(0)    STORE REQUIRED   BYTES
MDLDT33L EQU   *-MDLDT33
*
MDLDT33P EQU   4                  LITERAL POOL USAGE (EXCL FIELD LEN)
*
MDLDT33R DC    AL1(CSACCOF2),AL1(MDLDT33+02-MDLDT33)  ACCUM ADR OFFSET
         DC    AL1(CSBYTMSS),AL1(MDLDT33Z+01-MDLDT33) ICM  BYTE MASK
         DC    AL1(CSSRPsrc),AL1(MDLDT33j+01-MDLDT33) skip if 0
         DC    AL1(CSdfpexps),AL1(MDLdt33se+02-MDLdt33) dfp exp
         DC    AL1(CSdfpexp),AL1(MDLdt33te+02-MDLdt33) dfp exp
         DC    AL1(CSBYTMSK),AL1(MDLDT33B+01-MDLDT33) STCM BYTE MASK
         DC    AL1(CSTGTloF),AL1(MDLDT33b+02-MDLDT33) TARGET    OFFSET
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        ASSIGN/MOVE ACCUM       (BINARY TO BINARY - UNSIGNED         *
***********************************************************************
MDLdt33_b8 LAY R14,0(,R2)         LOAD ACCUMULATOR ADDR (CHG'D TO "LY")
           lg   R0,0(,r14)        CONVERT FIELD TO PACKED FORMAT
         cxgtr fp0,r0             convert to DFP
mdldt33_b8j jnop  mdldt33_b8lp
mdldt33_b8se lghi r15,*-*
mdldt33_b8te lghi r14,*-*
         iextr fp4,fp0,r15        set quantum of source
         iextr fp8,fp8,r14        set quantum of target
         qaxtr fp0,fp4,fp8,0      and quantise souce to target
mdldt33_b8lp lpdfr fp0,fp0
         cgxtr r0,0,fp0
MDLdt33_b8B STG R0,0(,0)          STORE REQUIRED   BYTES
MDLdt33_b8L EQU *-MDLdt33_b8
*
MDLdt33_b8P EQU 4                 LITERAL POOL USAGE (EXCL FIELD LEN)
*
MDLdt33_b8R DC AL1(CSACCOF2),AL1(MDLdt33_b8+02-MDLdt33_b8) ACCUM offs
   DC    AL1(CSSRPsrc),AL1(MDLdt33_b8j+01-MDLdt33_b8) skip if 0
         DC    AL1(CSdfpexps),AL1(MDLdt33_b8se+02-MDLdt33_b8) dfp exp
         DC    AL1(CSdfpexp),AL1(MDLdt33_b8te+02-MDLdt33_b8) dfp exp
   DC    AL1(CSBYTMSK),AL1(MDLdt33_b8B+01-MDLdt33_b8) STCM BYTE MASK
   DC    AL1(CSTGTloF),AL1(MDLdt33_b8b+02-MDLdt33_b8) TARGET OFFSET
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        ASSIGN/MOVE FIELD       (VALUE_1 CONSTANT)                   *
***********************************************************************
MDLDT34  LAY   R14,0(,R2)         CONSTANT   ADDRESS
MDLdt34_la LAY R15,0(0,0)         get address
MDLDT34A MVC   0(0,r15),0(R14)    MOVE
MDLDT34L EQU   *-MDLDT34
*
MDLDT34P EQU   0                  LITERAL POOL USAGE (EXCL FIELD LEN)
*
MDLDT34R DC    AL1(CSV1OFF),AL1(MDLDT34+02-MDLDT34)   CONSTANT  OFFSET
         DC    AL1(CSSRClof),AL1(MDLdt34_lA+02-MDLdt34) FIELD  1  OFF
         DC    AL1(CSSRCLN),AL1(MDLDT34A+01-MDLDT34)  TARGET    LENGTH
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        ASSIGN/MOVE FIELD       (MIXED/MASKED)                       *
***********************************************************************
MDLDT39  llgt  R5,0(,R2)          LOAD LOGIC  TABLE  ROW ADDRESS
MDLDT39A LAY   R14,0(,R2)         LOAD ACCUMULATOR ADDR (CHG'D TO "LY")
MDLDT39B LAy   R1,0(,0)           LOAD  DATA  AREA    ADDRESS
         BAS   R10,CALL96_indirect CALL "GVBDL96"    (FORMAT  FIELD)
MDLDT39F jlu   *+l'*              FORMAT UNSUCCESSFUL BRANCH (FALSE)
MDLDT39T jlu   *+l'*              FORMAT   SUCCESSFUL BRANCH (OPTIONAL)
MDLDT39L EQU   *-MDLDT39
*
MDLDT39P EQU   4                  LITERAL POOL USAGE (EXCL FIELD LEN)
*
MDLDT39R DC    AL1(CSLTROFF),AL1(MDLDT39+02-MDLDT39)  LOGIC  TABLE ROW
         DC    AL1(CSACCOF2),AL1(MDLDT39A+02-MDLDT39) ACCUMULATOR ADDR
         DC    AL1(CSTGTloF),AL1(MDLDT39B+02-MDLDT39) TARGET OFFSET
         DC    AL1(CSFALSEO),AL1(MDLDT39F+02-MDLDT39) FALSE  BRANCH
         DC    AL1(CSTRUEO),AL1(MDLDT39T+02-MDLDT39)  TRUE   BRANCH
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        ASSIGN/MOVE FIELD       (NUMERIC TO BINARY - UNSIGNED        *
***********************************************************************
MDLDT50  LAY   R14,0(,R2)         LOAD ACCUMULATOR ADDR (CHG'D TO "LY")
mdldt50a ld    fp0,0(0,r14)       Load value from storage
         ld    fp2,8(0,r14)
         cgxtr r0,0,fp0           Convert to fixed
MDLDT50C STY   R0,0(,0)           STORE BINARY  DATE
MDLDT50L EQU   *-MDLDT50
*
MDLDT50P EQU   0                  LITERAL POOL USAGE (EXCL FIELD LEN)
*
MDLDT50R DC    AL1(CSACCOF2),AL1(MDLDT50+02-MDLDT50)  ACCUM ADR OFFSET
         DC    AL1(CSdfpopt),AL1(mdldt50a-mdldt50) optimise loads
         DC    AL1(CSTGTloF),AL1(MDLDT50C+02-MDLDT50) TARGET    OFFSET
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        ASSIGN/MOVE FIELD       (MIXED/MASKED)                       *
***********************************************************************
MDLSK01  llgt  R5,0(,R2)          LOAD LOGIC  TABLE  ROW ADDRESS
MDLSK01A LAy   R1,0(,0)           LOAD  DATA  AREA    ADDRESS
         BAS   R10,CALL96L_indirect  CONVERT EDITED/MASKED NUMERIC
MDLSK01F jlu   *+l'*              FORMAT UNSUCCESSFUL BRANCH (FALSE)
MDLSK01T jlu   *+l'*              FORMAT   SUCCESSFUL BRANCH (OPTIONAL)
MDLSK01L EQU   *-MDLSK01
*
MDLSK01P EQU   4                  LITERAL POOL USAGE (EXCL FIELD LEN)
*
MDLSK01R DC    AL1(CSLTROFF),AL1(MDLSK01+02-MDLSK01)  LOGIC  TABLE ROW
         DC    AL1(CSTGTloF),AL1(MDLSK01A+02-MDLSK01) TARGET OFFSET
         DC    AL1(CSFALSEO),AL1(MDLSK01F+02-MDLSK01) FALSE  BRANCH
         DC    AL1(CSTRUEO),AL1(MDLSK01T+02-MDLSK01)  TRUE   BRANCH
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        ASSIGN/MOVE FIELD       (CHARACTER)                          *
***********************************************************************
MDLsk02  LAY   R15,0(0,0)         get address
MDLsk02_la LAY R14,0(0,0)         get address
MDLSK02m MVC   0(0,r14),0(r15)    MOVE
MDLSK02X XC    0(0,r14),HEXFF     COMPLEMENT  IF DESCENDING  (OPTIONAL)
MDLSK02L EQU   *-MDLSK02
*
MDLSK02P EQU   0                  LITERAL POOL USAGE (EXCL FIELD LEN)
*
MDLSK02R DC    AL1(CSTGTLN),AL1(MDLSK02m+01-MDLSK02)   TARGET    LENGTH
         DC    AL1(CStgtlof),AL1(MDLsk02_lA+02-MDLsk02) FIELD  2  OFF
         DC    AL1(CSSRClof),AL1(MDLsk02+02-MDLsk02)   FIELD  1  OFF
         DC    AL1(CSSDNLN),AL1(MDLSK02X+01-MDLSK02)  SORT DESCEND LEN
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        ASSIGN/MOVE FIELD       (CHARACTER WITH FILLER)              *
***********************************************************************
MDLsk03  LAY   R15,0(0,0)         get address
MDLsk03_la LAY R14,0(0,0)         get address
MDLSK03m MVC   0(0,r14),SPACES    BLANK  OUT AREA  BEFORE     MOVE
MDLSK03A MVC   0(0,r14),0(r15)    MOVE FIELD VALUE TO COLUMN  AREA
MDLSK03X XC    0(0,r14),HEXFF     COMPLEMENT  IF DESCENDING  (OPTIONAL)
MDLSK03L EQU   *-MDLSK03
*
MDLSK03P EQU   0                  LITERAL POOL USAGE (EXCL FIELD LEN)
*
MDLSK03R DC    AL1(CSTGTLN),AL1(MDLSK03m+01-MDLSK03)   TARGET    LENGTH
         DC    AL1(CStgtlof),AL1(MDLsk03_lA+02-MDLsk03) FIELD  2  OFF
         DC    AL1(CSSRClof),AL1(MDLsk03+02-MDLsk03)   FIELD  1  OFF
         DC    AL1(CSSRCLN),AL1(MDLSK03A+01-MDLSK03)  SOURCE    LENGTH
         DC    AL1(CSSDNLN),AL1(MDLSK03X+01-MDLSK03)  SORT DESCEND LEN
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        ASSIGN/MOVE FIELD       (PACKED TO PACKED - SIGNED           *
***********************************************************************
MDLsk04  LAY   R15,0(0,0)         get address
MDLsk04_la LAY R14,0(0,0)         get address
MDLsk04Z ZAP   workarea,0(0,r15)  COPY  PACKED  TO PACKED FORMAT
mdlsk04j jnop  mdlsk04a
         lmg   r0,r1,workarea
         cxstr fp0,r0             convert to DFP
mdlsk04se lghi r15,*-*
         iextr fp4,fp0,r15        set quantum of source
mdlsk04te lghi r15,*-*
         iextr fp8,fp8,r15        set quantum of target
         qaxtr fp0,fp4,fp8,0      and qantise souce to target
         csxtr r0,fp0,0
         stmg  r0,r1,workarea
MDLsk04a ZAP   0(0,r14),workarea  COPY  PACKED  TO PACKED FORMAT
MDLSK04X XC    0(0,r14),HEXFF     COMPLEMENT  IF DESCENDING  (OPTIONAL)
MDLSK04L EQU   *-MDLSK04
*
MDLSK04P EQU   0                  LITERAL POOL USAGE (EXCL FIELD LEN)
*
MDLSK04R DC    AL1(CSSRCLNR),AL1(MDLSK04z+01-MDLSK04)  SOURCE    LENGTH
         DC    AL1(CSSRClof),AL1(MDLsk04+02-MDLsk04)   FIELD  1  OFF
         DC    AL1(CStgtlof),AL1(MDLsk04_lA+02-MDLsk04) FIELD  2  OFF
         DC    AL1(CSTGTLNL),AL1(MDLSK04A+01-MDLSK04) TARGET    LENGTH
         DC    AL1(CSSRPsrc),AL1(MDLSK04j+01-MDLSK04) skip if zero
         DC    AL1(CSdfpexps),AL1(MDLsk04se+02-MDLsk04) dfp exp
         DC    AL1(CSdfpexp),AL1(MDLsk04te+02-MDLsk04) dfp exp
         DC    AL1(CSSDNLN),AL1(MDLSK04X+01-MDLSK04)  SORT DESCEND LEN
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        ASSIGN/MOVE FIELD       (PACKED TO PACKED - UNSIGNED         *
***********************************************************************
MDLsk05  LAY   R15,0(0,0)         get address
MDLsk05_la LAY R14,0(0,0)         get address
MDLsk05Z ZAP   workarea,0(0,r15)  COPY  PACKED  TO PACKED FORMAT
         lmg   r0,r1,workarea
         cxstr fp0,r0             convert to DFP
mdlsk05j jnop  mdlsk05lp
mdlsk05se lghi r15,*-*
         iextr fp4,fp0,r15        set quantum of source
mdlsk05te lghi r15,*-*
         iextr fp8,fp8,r15        set quantum of target
         qaxtr fp0,fp4,fp8,0      and qantise souce to target
mdlsk05lp lpdfr fp0,fp0            force positive
         csxtr r0,fp0,1
         stmg  r0,r1,workarea
MDLsk05a ZAP   0(0,r14),workarea  COPY  PACKED  TO PACKED FORMAT
MDLSK05B OI    0(r14),X'0F'       FORCE TO UNSIGNED
MDLSK05X XC    0(0,r14),HEXFF     COMPLEMENT  IF DESCENDING  (OPTIONAL)
MDLSK05L EQU   *-MDLSK05
*
MDLSK05P EQU   0                  LITERAL POOL USAGE (EXCL FIELD LEN)
*
MDLSK05R DC    AL1(CSSRCLNR),AL1(MDLSK05z+01-MDLSK05)  SOURCE    LENGTH
         DC    AL1(CSSRClof),AL1(MDLsk05+02-MDLsk05)   FIELD  1  OFF
         DC    AL1(CStgtlof),AL1(MDLsk05_lA+02-MDLsk05) FIELD  2  OFF
         DC    AL1(CSTGTLNL),AL1(MDLSK05A+01-MDLSK05) TARGET    LENGTH
         DC    AL1(CSLSTBYT),AL1(MDLSK05B+02-MDLSK05) LAST  TGT BYTE
         DC    AL1(CSSRPsrc),AL1(MDLSK05j+01-MDLSK05) skip if 0
         DC    AL1(CSdfpexps),AL1(MDLsk05se+02-MDLsk05) dfp exp
         DC    AL1(CSdfpexp),AL1(MDLsk05te+02-MDLsk05) dfp exp
         DC    AL1(CSSDNLN),AL1(MDLSK05X+01-MDLSK05)  SORT DESCEND LEN
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        ASSIGN/MOVE FIELD       (PACKED TO NUMERIC - SIGNED)         *
***********************************************************************
MDLsk06  LAY   R15,0(0,0)           get address
MDLsk06_la LAY R14,0(0,0)         get address
MDLsk06Z ZAP   workarea,0(0,r15)  COPY  PACKED  TO PACKED FORMAT
mdlsk06j jnop  mdlsk06b
         lmg   r0,r1,workarea
         cxstr fp0,r0             convert to DFP
mdlsk06se lghi r15,*-*
         iextr fp4,fp0,r15        set quantum of source
mdlsk06te lghi r15,*-*
         iextr fp8,fp8,r15        set quantum of target
         qaxtr fp0,fp4,fp8,0      and qantise souce to target
         csxtr r0,fp0,0
         stmg  r0,r1,workarea
MDLSK06B UNPK  0(0,r14),WORKAREA  CONVERT  FIELD   TO  DISPLAY FORMAT
MDLSK06X XC    0(0,r14),HEXFF     COMPLEMENT  IF DESCENDING  (OPTIONAL)
MDLSK06L EQU   *-MDLSK06
*
MDLSK06P EQU   0                  LITERAL POOL USAGE (EXCL FIELD LEN)
*
MDLSK06R DC    AL1(CSSRCLNR),AL1(MDLSK06z+01-MDLSK06)  SOURCE    LENGTH
         DC    AL1(CSSRClof),AL1(MDLsk06+02-MDLsk06)   FIELD  1  OFF
         DC    AL1(CStgtlof),AL1(MDLsk06_lA+02-MDLsk06) FIELD  2  OFF
         DC    AL1(CSSRPsrc),AL1(MDLSK06j+01-MDLSK06) skip if 0
         DC    AL1(CSdfpexps),AL1(MDLsk06se+02-MDLsk06) dfp exp
         DC    AL1(CSdfpexp),AL1(MDLsk06te+02-MDLsk06) dfp exp
         DC    AL1(CSTGTLNL),AL1(MDLSK06B+01-MDLSK06) TARGET    LENGTH
         DC    AL1(CSSDNLN),AL1(MDLSK06X+01-MDLSK06)  SORT DESCEND LEN
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        ASSIGN/MOVE FIELD       (PACKED TO NUMERIC - UNSIGNED)       *
***********************************************************************
MDLsk07  LAY   R15,0(0,0)           get address
MDLsk07_la LAY R14,0(0,0)         get address
MDLsk07Z ZAP   workarea,0(0,r15)  COPY  PACKED  TO PACKED FORMAT
         lmg   r0,r1,workarea
         cxstr fp0,r0             convert to DFP
mdlsk07j jnop  mdlsk07lp
mdlsk07se lghi r15,*-*
         iextr fp4,fp0,r15        set quantum of source
mdlsk07te lghi r15,*-*
         iextr fp8,fp8,r15        set quantum of target
         qaxtr fp0,fp4,fp8,0      and qantise souce to target
mdlsk07lp lpdfr fp0,fp0
         csxtr r0,fp0,1
         stmg  r0,r1,workarea
MDLSK07B UNPK  0(0,r14),WORKAREA  CONVERT  FIELD   TO  DISPLAY FORMAT
MDLSK07C OI    0(r14),X'F0'
MDLSK07X XC    0(0,r14),HEXFF     COMPLEMENT  IF DESCENDING  (OPTIONAL)
MDLSK07L EQU   *-MDLSK07
*
MDLSK07P EQU   0                  LITERAL POOL USAGE (EXCL FIELD LEN)
*
MDLSK07R DC    AL1(CSSRCLNR),AL1(MDLSK07z+01-MDLSK07)  SOURCE    LENGTH
         DC    AL1(CSSRClof),AL1(MDLsk07+02-MDLsk07)   FIELD  1  OFF
         DC    AL1(CStgtlof),AL1(MDLsk07_lA+02-MDLsk07) FIELD  2  OFF
         DC    AL1(CSSRPsrc),AL1(MDLSK07j+01-MDLSK07) Skip if zero
         DC    AL1(CSdfpexps),AL1(MDLsk07se+02-MDLsk07) dfp exp
         DC    AL1(CSdfpexp),AL1(MDLsk07te+02-MDLsk07) dfp exp
         DC    AL1(CSTGTLNL),AL1(MDLSK07B+01-MDLSK07) TARGET    LENGTH
         DC    AL1(CSLSTBYT),AL1(MDLSK07C+02-MDLSK07) LAST BYTE OFFSET
         DC    AL1(CSSDNLN),AL1(MDLSK07X+01-MDLSK07)  SORT DESCEND LEN
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        ASSIGN/MOVE FIELD       (PACKED TO BINARY - SIGNED           *
***********************************************************************
MDLsk08  LAY   R15,0(0,0)         get address
MDLsk08_la LAY R14,0(0,0)         get address
MDLsk08z ZAP   WORKAREA,0(0,r15) COPY PACKED  VALUE  TO WORK   AREA
         lmg   r0,r1,workarea
         cxstr fp0,r0             convert to DFP
mdlsk08j jnop  mdlsk08y
mdlsk08se lghi r15,*-*
         iextr fp4,fp0,r15        set quantum of source
mdlsk08te lghi r15,*-*
         iextr fp8,fp8,r15        set quantum of target
         qaxtr fp0,fp4,fp8,0      and qantise souce to target
mdlsk08y cgxtr r0,0,fp0
MDLSK08B STCM  R0,B'0000',DBLWORK STORE REQUIRED   BYTES
MDLSK08C MVC   0(0,r14),DBLWORK
MDLSK08X XC    0(0,r14),HEXFF     COMPLEMENT  IF DESCENDING  (OPTIONAL)
MDLSK08L EQU   *-MDLSK08
*
MDLSK08P EQU   0                  LITERAL POOL USAGE (EXCL FIELD LEN)
*
MDLSK08R DC    AL1(CSSRClof),AL1(MDLsk08+02-MDLsk08)   FIELD  1  OFF
         DC    AL1(CStgtlof),AL1(MDLsk08_lA+02-MDLsk08) FIELD  2  OFF
         DC    AL1(CSSRPsrc),AL1(MDLSK08j+01-MDLSK08) skip if zero
         DC    AL1(CSdfpexps),AL1(MDLsk08se+02-MDLsk08) dfp exp
         DC    AL1(CSdfpexp),AL1(MDLsk08te+02-MDLsk08) dfp exp
         DC    AL1(CSBYTMSK),AL1(MDLSK08B+01-MDLSK08) STCM BYTE MASK
         DC    AL1(CSTGTLN),AL1(MDLSK08C+01-MDLSK08)  TARGET    LENGTH
         DC    AL1(CSSDNLN),AL1(MDLSK08X+01-MDLSK08)  SORT DESCEND LEN
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        ASSIGN/MOVE FIELD       (PACKED TO BINARY8- SIGNED           *
***********************************************************************
MDLsk08_b8  LAY R15,0(0,0)         get address
MDLsk08_b8la LAY R14,0(0,0)         get address
MDLSK08_b8z ZAP workarea,0(0,r15)   CONVERT FIELD TO PACKED FORMAT
         lmg   r0,r1,workarea
         cxstr fp0,r0             convert to DFP
mdlsk08_b8j jnop  mdlsk08_b8y
mdlsk08_b8se lghi r15,*-*
         iextr fp4,fp0,r15        set quantum of source
mdlsk08_b8te lghi r15,*-*
         iextr fp8,fp8,r15        set quantum of target
         qaxtr fp0,fp4,fp8,0      and qantise souce to target
mdlsk08_b8y cgxtr r0,0,fp0
         STg   R0,DBLWORK         STORE REQUIRED   BYTES
MDLSK08_b8C MVC 0(0,r14),DBLWORK
MDLSK08_b8X XC 0(0,r14),HEXFF     COMPLEMENT  IF DESCENDING  (OPTIONAL)
MDLSK08_b8L EQU *-MDLSK08_b8
*
MDLSK08_b8P EQU 0                 LITERAL POOL USAGE (EXCL FIELD LEN)
*
MDLSK08_b8R DC AL1(CSSRCLNR),AL1(MDLSK08_b8z+01-MDLSK08_b8) SRCE LEN
            dc AL1(CSSRClof),AL1(MDLsk08_b8+02-MDLsk08_b8) FIELD 1 OFF
         DC    AL1(CStgtlof),AL1(MDLsk08_b8lA+02-MDLsk08_b8) FLD 2 off
         DC    AL1(CSSRPsrc),AL1(MDLSK08_b8j+01-MDLSK08_b8) skip if 0
         DC    AL1(CSdfpexps),AL1(MDLsk08_b8se+02-MDLsk08_b8) dfp exp
         DC    AL1(CSdfpexp),AL1(MDLsk08_b8te+02-MDLsk08_b8) dfp exp
         DC    AL1(CSTGTLN),AL1(MDLSK08_b8C+01-MDLSK08_b8) TARGETLEN
         DC    AL1(CSSDNLN),AL1(MDLSK08_b8X+01-MDLSK08_b8) SORTd LEN
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        ASSIGN/MOVE FIELD       (PACKED TO BINARY - UNSIGNED         *
***********************************************************************
MDLsk09  LAY   R15,0(0,0)         get address
MDLsk09_la LAY R14,0(0,0)         get address
MDLSK09z ZAP   workarea,0(0,r15)  CONVERT FIELD TO PACKED FORMAT
         lmg   r0,r1,workarea
         cxstr fp0,r0             convert to DFP
mdlsk09j jnop  mdlsk09lp
mdlsk09se lghi r15,*-*
         iextr fp4,fp0,r15        set quantum of source
mdlsk09te lghi r15,*-*
         iextr fp8,fp8,r15        set quantum of target
         qaxtr fp0,fp4,fp8,0      and qantise souce to target
mdlsk09lp lpdfr fp0,fp0
         cgxtr r0,0,fp0
MDLSK09B STCM  R0,B'0000',DBLWORK STORE REQUIRED   BYTES
MDLSK09C MVC   0(0,r14),DBLWORK
MDLSK09X XC    0(0,r14),HEXFF     COMPLEMENT  IF DESCENDING  (OPTIONAL)
MDLSK09L EQU   *-MDLSK09
*
MDLSK09P EQU   0                  LITERAL POOL USAGE (EXCL FIELD LEN)
*
MDLSK09R DC    AL1(CSSRCLNR),AL1(MDLSK09z+01-MDLSK09)  SOURCE    LENGTH
         DC    AL1(CSSRClof),AL1(MDLsk09+02-MDLsk09)   FIELD  1  OFF
         DC    AL1(CStgtlof),AL1(MDLsk09_lA+02-MDLsk09) FIELD  2  OFF
         DC    AL1(CSSRPsrc),AL1(MDLSK09j+01-MDLSK09) skip if zero
         DC    AL1(CSdfpexps),AL1(MDLsk09se+02-MDLsk09) dfp exp
         DC    AL1(CSdfpexp),AL1(MDLsk09te+02-MDLsk09) dfp exp
         DC    AL1(CSBYTMSK),AL1(MDLSK09B+01-MDLSK09) STCM BYTE MASK
         DC    AL1(CSTGTLN),AL1(MDLSK09C+01-MDLSK09)  TARGET    LENGTH
         DC    AL1(CSSDNLN),AL1(MDLSK09X+01-MDLSK09)  SORT DESCEND LEN
         DC   2XL1'FF'

MDLsk09_b8 LAY R15,0(0,0)         get address
MDLsk09_b8_la LAY R14,0(0,0)      get address
MDLsk09_b8z ZAP workarea,0(0,r15)  CONVERT FIELD TO PACKED FORMAT
         lmg   r0,r1,workarea
         cxstr fp0,r0             convert to DFP
mdlsk09_b8j jnop  mdlsk09_b8lp
mdlsk09_b8se lghi r15,*-*
         iextr fp4,fp0,r15        set quantum of source
mdlsk09_b8te lghi r15,*-*
         iextr fp8,fp8,r15        set quantum of target
         qaxtr fp0,fp4,fp8,0      and qantise souce to target
mdlsk09_b8lp lpdfr fp0,fp0
         cgxtr r0,0,fp0
MDLsk09_b8C stg r0,0(0,0)         store result
MDLsk09_b8X XC 0(0,r14),HEXFF     COMPLEMENT  IF DESCENDING  (OPTIONAL)
MDLsk09_b8L EQU *-MDLsk09_b8
*
MDLsk09_b8P EQU 0                 LITERAL POOL USAGE (EXCL FIELD LEN)
*
MDLsk09_b8R DC AL1(CSSRCLNR),AL1(MDLsk09_b8z+01-MDLsk09_b8) SOURCE LEN
         DC    AL1(CSSRClof),AL1(MDLsk09_b8+02-MDLsk09_b8) FIELD 1 OFF
         DC    AL1(CStgtlof),AL1(MDLsk09_b8_lA+02-MDLsk09_b8) FIELD 2
         DC    AL1(CSSRPsrc),AL1(MDLsk09_b8j+01-MDLsk09_b8) SHIFT
         DC    AL1(CSdfpexps),AL1(MDLsk09_b8se+02-MDLsk09_b8) dfp exp
         DC    AL1(CSdfpexp),AL1(MDLsk09_b8te+02-MDLsk09_b8) dfp exp
         DC    AL1(CSTGTlof),AL1(MDLsk09_b8C+02-MDLsk09_b8) TARGET off
         DC    AL1(CSSDNLN),AL1(MDLsk09_b8X+01-MDLsk09_b8) SORT DES LEN
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        ASSIGN/MOVE FIELD       (NUMERIC TO PACKED - SIGNED          *
***********************************************************************
MDLsk10  LAY   R15,0(0,0)         get address
MDLsk10_la LAY R14,0(0,0)         get address
MDLsk10k PACK  WORKAREA,0(0,r15)    CONVERT FIELD TO PACKED FORMAT
mdlsk10j jnop  mdlsk10a
         lmg   r0,r1,workarea
         cxstr fp0,r0             convert to DFP
mdlsk10se lghi r15,*-*
         iextr fp4,fp0,r15        set quantum of source
mdlsk10te lghi r15,*-*
         iextr fp8,fp8,r15        set quantum of target
         qaxtr fp0,fp4,fp8,0      and qantise souce to target
         csxtr r0,fp0,0
         stmg  r0,r1,workarea
MDLsk10A zap   0(0,r14),workarea
MDLSK10X XC    0(0,r14),HEXFF     COMPLEMENT  IF DESCENDING  (OPTIONAL)
MDLSK10L EQU   *-MDLSK10
*
MDLSK10P EQU   0                  LITERAL POOL USAGE (EXCL FIELD LEN)
*
MDLSK10R DC    AL1(CSSRCLNR),AL1(MDLSK10k+01-MDLSK10)  SOURCE    LENGTH
         DC    AL1(CSSRClof),AL1(MDLsk10+02-MDLsk10)   FIELD  1  OFF
         DC    AL1(CStgtlof),AL1(MDLsk10_lA+02-MDLsk10) FIELD  2  OFF
         DC    AL1(CSSRPsrc),AL1(MDLSK10j+01-MDLSK10) skip if zero
         DC    AL1(CSdfpexps),AL1(MDLsk10se+02-MDLsk10) dfp exp
         DC    AL1(CSdfpexp),AL1(MDLsk10te+02-MDLsk10) dfp exp
         DC    AL1(CSTGTLNL),AL1(MDLSK10A+01-MDLSK10) TARGET    OFFSET
         DC    AL1(CSSDNLN),AL1(MDLSK10X+01-MDLSK10)  SORT DESCEND LEN
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        ASSIGN/MOVE FIELD       (NUMERIC TO PACKED - UNSIGNED        *
***********************************************************************
MDLsk11  LAY   R15,0(0,0)         get address
MDLsk11_la LAY R14,0(0,0)         get address
MDLsk11k PACK  WORKAREA,0(0,r15)    CONVERT FIELD TO PACKED FORMAT
         lmg   r0,r1,workarea
         cxstr fp0,r0             convert to DFP
mdlsk11j jnop  mdlsk11lp
mdlsk11se lghi r15,*-*
         iextr fp4,fp0,r15        set quantum of source
mdlsk11te lghi r15,*-*
         iextr fp8,fp8,r15        set quantum of target
         qaxtr fp0,fp4,fp8,0      and qantise souce to target
mdlsk11lp lpdfr fp0,fp0
         csxtr r0,fp0,1
         stmg  r0,r1,workarea
MDLsk11A zap   0(0,r14),workarea
MDLSK11B OI    0(r14),X'0F'       FORCE TO UNSIGNED
MDLSK11X XC    0(0,r14),HEXFF     COMPLEMENT  IF DESCENDING  (OPTIONAL)
MDLSK11L EQU   *-MDLSK11
*
MDLSK11P EQU   0                  LITERAL POOL USAGE (EXCL FIELD LEN)
*
MDLSK11R DC    AL1(CSSRCLNR),AL1(MDLSK11k+01-MDLSK11)  SOURCE    LENGTH
         DC    AL1(CSSRClof),AL1(MDLsk11+02-MDLsk11)   FIELD  1  OFF
         DC    AL1(CStgtlof),AL1(MDLsk11_lA+02-MDLsk11) FIELD  2  OFF
         DC    AL1(CSSRPsrc),AL1(MDLSK11j+01-MDLSK11) skip if zero
         DC    AL1(CSdfpexps),AL1(MDLsk11se+02-MDLsk11) dfp exp
         DC    AL1(CSdfpexp),AL1(MDLsk11te+02-MDLsk11) dfp exp
         DC    AL1(CSTGTLNL),AL1(MDLSK11A+01-MDLSK11) TARGET    OFFSET
         DC    AL1(CSLSTBYT),AL1(MDLSK11B+02-MDLSK11) LAST BYTE OFFSET
         DC    AL1(CSSDNLN),AL1(MDLSK11X+01-MDLSK11)  SORT DESCEND LEN
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        ASSIGN/MOVE FIELD       (NUMERIC TO NUMERIC - SIGNED         *
***********************************************************************
MDLsk12  LAY   R15,0(0,0)         get address
MDLsk12_la LAY R14,0(0,0)         get address
MDLSK12k PACK  WORKAREA,0(0,r15)  CONVERT FIELD   TO PACKED FORMAT
mdlsk12j jnop  mdlsk12b
         lmg   r0,r1,workarea
         cxstr fp0,r0             convert to DFP
mdlsk12se lghi r15,*-*
         iextr fp4,fp0,r15        set quantum of source
mdlsk12te lghi r15,*-*
         iextr fp8,fp8,r15        set quantum of target
         qaxtr fp0,fp4,fp8,0      and qantise souce to target
         csxtr r0,fp0,0
         stmg  r0,r1,workarea
MDLSK12B UNPK  0(0,r14),WORKAREA     CONVERT TO NUMERIC
MDLSK12X XC    0(0,r14),HEXFF     COMPLEMENT  IF DESCENDING  (OPTIONAL)
MDLSK12L EQU   *-MDLSK12
*
MDLSK12P EQU   0                  LITERAL POOL USAGE (EXCL FIELD LEN)
*
MDLSK12R DC    AL1(CSSRCLNR),AL1(MDLSK12k+01-MDLSK12)  SOURCE    LENGTH
         DC    AL1(CSSRClof),AL1(MDLsk12+02-MDLsk12)  FIELD  1  OFF
         DC    AL1(CStgtlof),AL1(MDLsk12_lA+02-MDLsk12) FIELD  2  OFF
         DC    AL1(CSSRPsrc),AL1(MDLSK12j+01-MDLSK12) SHIFT DEC PLACES
         DC    AL1(CSdfpexps),AL1(MDLsk12se+02-MDLsk12) dfp exp
         DC    AL1(CSdfpexp),AL1(MDLsk12te+02-MDLsk12) dfp exp
         DC    AL1(CSTGTLNL),AL1(MDLSK12B+01-MDLSK12) TARGET    LENGTH
         DC    AL1(CSSDNLN),AL1(MDLSK12X+01-MDLSK12)  SORT DESCEND LEN
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        ASSIGN/MOVE FIELD       (NUMERIC TO NUMERIC - UNSIGNED       *
***********************************************************************
MDLsk13  LAY   R15,0(0,0)         get address
MDLsk13_la LAY R14,0(0,0)         get address
MDLSK13k PACK  WORKAREA,0(0,r15) CONVERT FIELD   TO PACKED FORMAT
         lmg   r0,r1,workarea
         cxstr fp0,r0             convert to DFP
mdlsk13j jnop  mdlsk13lp
mdlsk13se lghi r15,*-*
         iextr fp4,fp0,r15        set quantum of source
mdlsk13te lghi r15,*-*
         iextr fp8,fp8,r15        set quantum of target
         qaxtr fp0,fp4,fp8,0      and qantise souce to target
mdlsk13lp lpdfr fp0,fp0
         csxtr r0,fp0,1
         stmg  r0,r1,workarea
MDLSK13B UNPK  0(0,r14),WORKAREA  CONVERT TO NUMERIC
MDLSK13C OI    0(r14),X'F0'
MDLSK13X XC    0(0,r14),HEXFF     COMPLEMENT  IF DESCENDING  (OPTIONAL)
MDLSK13L EQU   *-MDLSK13
*
MDLSK13P EQU   0                  LITERAL POOL USAGE (EXCL FIELD LEN)
*
MDLSK13R DC    AL1(CSSRCLNR),AL1(MDLSK13k+01-MDLSK13)  SOURCE    LENGTH
         DC    AL1(CSSRClof),AL1(MDLsk13+02-MDLsk13)  FIELD  1  OFF
         DC    AL1(CStgtlof),AL1(MDLsk13_lA+02-MDLsk13) FIELD  2  OFF
         DC    AL1(CSSRPsrc),AL1(MDLSK13j+01-MDLSK13) skip if zero
         DC    AL1(CSdfpexps),AL1(MDLsk13se+02-MDLsk13) dfp exp
         DC    AL1(CSdfpexp),AL1(MDLsk13te+02-MDLsk13) dfp exp
         DC    AL1(CSTGTLNL),AL1(MDLSK13B+01-MDLSK13) TARGET    LENGTH
         DC    AL1(CSLSTBYT),AL1(MDLSK13C+02-MDLSK13) LAST BYTE OFFSET
         DC    AL1(CSSDNLN),AL1(MDLSK13X+01-MDLSK13)  SORT DESCEND LEN
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        ASSIGN/MOVE FIELD       (NUMERIC TO BINARY - SIGNED          *
***********************************************************************
MDLsk14  LAY   R15,0(0,0)         get address
MDLsk14_la LAY R14,0(0,0)         get address
MDLsk14k PACK  workarea,0(0,r15)  CONVERT FIELD TO PACKED FORMAT
         lmg   r0,r1,workarea
         cxstr fp0,r0             convert to DFP
mdlsk14j jnop  mdlsk14y
mdlsk14se lghi r15,*-*
         iextr fp4,fp0,r15        set quantum of source
mdlsk14te lghi r15,*-*
         iextr fp8,fp8,r15        set quantum of target
         qaxtr fp0,fp4,fp8,0      and quantise souce to target
mdlsk14y cgxtr r0,0,fp0
MDLSK14B STCM  R0,B'0000',DBLWORK STORE REQUIRED   BYTES
MDLSK14C MVC   0(0,r14),DBLWORK
MDLSK14X XC    0(0,r14),HEXFF     COMPLEMENT  IF DESCENDING  (OPTIONAL)
MDLSK14L EQU   *-MDLSK14
*
MDLSK14P EQU   0                  LITERAL POOL USAGE (EXCL FIELD LEN)
*
MDLSK14R DC    AL1(CSSRCLNR),AL1(MDLSK14k+01-MDLSK14)  SOURCE    LENGTH
         DC    AL1(CSSRClof),AL1(MDLsk14+02-MDLsk14)  FIELD  1  OFF
         DC    AL1(CStgtlof),AL1(MDLsk14_lA+02-MDLsk14) FIELD  2  OFF
         DC    AL1(CSSRPsrc),AL1(MDLSK14j+01-MDLSK14) SHIFT DEC PLACES
         DC    AL1(CSdfpexps),AL1(MDLsk14se+02-MDLsk14) dfp exp
         DC    AL1(CSdfpexp),AL1(MDLsk14te+02-MDLsk14) dfp exp
         DC    AL1(CSBYTMSK),AL1(MDLSK14B+01-MDLSK14) STCM BYTE MASK
         DC    AL1(CSTGTLN),AL1(MDLSK14C+01-MDLSK14)  TARGET    LENGTH
         DC    AL1(CSSDNLN),AL1(MDLSK14X+01-MDLSK14)  SORT DESCEND LEN
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        ASSIGN/MOVE FIELD       (NUMERIC TO BINARY8- SIGNED          *
***********************************************************************
MDLsk14_b8  LAY R15,0(0,0)         get address
MDLsk14_b8la LAY R14,0(0,0)         get address
MDLSK14_b8k PACK workar2,0(0,r15)  CONVERT FIELD TO PACKED FORMAT
         lmg   r0,r1,workar2
         cxstr fp0,r0             convert to DFP
mdlsk14_b8j jnop  mdlsk14_b8y
mdlsk14_b8se lghi r15,*-*
         iextr fp4,fp0,r15        set quantum of source
mdlsk14_b8te lghi r15,*-*
         iextr fp8,fp8,r15        set quantum of target
         qaxtr fp0,fp4,fp8,0      and quantise souce to target
mdlsk14_b8y cgxtr r0,0,fp0
         STg   R0,DBLWORK         STORE REQUIRED   BYTES
MDLSK14_b8C MVC 0(0,r14),DBLWORK
MDLSK14_b8X XC 0(0,r14),HEXFF     COMPLEMENT  IF DESCENDING  (OPTIONAL)
MDLSK14_b8L EQU *-MDLSK14_b8
*
MDLSK14_b8P EQU 0                 LITERAL POOL USAGE (EXCL FIELD LEN)
*
MDLSK14_b8R DC AL1(CSSRCLNR),AL1(MDLSK14_b8k+01-MDLSK14_b8) SRCE LEN
         DC    AL1(CSSRClof),AL1(MDLsk14_b8+02-MDLsk14_b8) FIELD 1  OFF
         DC    AL1(CStgtlof),AL1(MDLsk14_b8lA+02-MDLsk14_b8) FLD 2 off
         DC    AL1(CSSRPsrc),AL1(MDLSK14_b8j+01-MDLSK14_b8) SHIFT DEC
         DC    AL1(CSdfpexps),AL1(MDLsk14_b8se+02-MDLsk14_b8) dfp exp
         DC    AL1(CSdfpexp),AL1(MDLsk14_b8te+02-MDLsk14_b8) dfp exp
         DC    AL1(CSTGTLN),AL1(MDLSK14_b8C+01-MDLSK14_b8) TARGETlen
         DC    AL1(CSSDNLN),AL1(MDLSK14_b8X+01-MDLSK14_b8) SORTd LEN
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        ASSIGN/MOVE FIELD       (NUMERIC TO BINARY - UNSIGNED        *
***********************************************************************
MDLsk15  LAY   R15,0(0,0)         get address
MDLsk15_la LAY R14,0(0,0)         get address
MDLSK15k PACK  workarea,0(0,r15)   CONVERT FIELD TO PACKED FORMAT
         lmg   r0,r1,workarea
         cxstr fp0,r0             convert to DFP
mdlsk15j jnop  mdlsk15lp
mdlsk15se lghi r15,*-*
         iextr fp4,fp0,r15        set quantum of source
mdlsk15te lghi r15,*-*
         iextr fp8,fp8,r15        set quantum of target
         qaxtr fp0,fp4,fp8,0      and quantise souce to target
mdlsk15lp lpdfr fp0,fp0            force positive
         cgxtr r0,0,fp0
MDLSK15B STCM  R0,B'0000',DBLWORK STORE REQUIRED   BYTES
MDLSK15C MVC   0(0,r14),DBLWORK
MDLSK15X XC    0(0,r14),HEXFF     COMPLEMENT  IF DESCENDING  (OPTIONAL)
MDLSK15L EQU   *-MDLSK15
*
MDLSK15P EQU   0                  LITERAL POOL USAGE (EXCL FIELD LEN)
*
MDLSK15R DC    AL1(CSSRCLNR),AL1(MDLSK15k+01-MDLSK15)  SOURCE    LENGTH
         DC    AL1(CSSRClof),AL1(MDLsk15+02-MDLsk15)  FIELD  1  OFF
         DC    AL1(CStgtlof),AL1(MDLsk15_lA+02-MDLsk15) FIELD  2  OFF
         DC    AL1(CSSRPsrc),AL1(MDLSK15j+01-MDLSK15) skip if zero
         DC    AL1(CSdfpexps),AL1(MDLsk15se+02-MDLsk15) dfp exp
         DC    AL1(CSdfpexp),AL1(MDLsk15te+02-MDLsk15) dfp exp
         DC    AL1(CSBYTMSK),AL1(MDLSK15B+01-MDLSK15) STCM BYTE MASK
         DC    AL1(CSTGTLN),AL1(MDLSK15C+01-MDLSK15)  TARGET    LENGTH
         DC    AL1(CSSDNLN),AL1(MDLSK15X+01-MDLSK15)  SORT DESCEND LEN
         DC    AL1(CSBYTMSK),AL1(MDLDT15B+01-MDLDT15) STCM BYTE MASK
         DC    AL1(CSTGTloF),AL1(MDLDT15b+02-MDLDT15) TARGET    OFFSET
         DC   2XL1'FF'
                        SPACE 3
MDLsk15_b8 LAY R15,0(0,0)         get address
MDLsk15_b8_la LAY R14,0(0,0)      get address
MDLsk15_b8k PACK workar2,0(0,r15) CONVERT FIELD TO PACKED FORMAT
         lmg   r0,r1,workar2
         cxstr fp0,r0             convert to DFP
mdlsk15_b8j jnop  mdlsk15_b8lp
mdlsk15_b8se lghi r15,*-*
         iextr fp4,fp0,r15        set quantum of source
mdlsk15_b8te lghi r15,*-*
         iextr fp8,fp8,r15        set quantum of target
         qaxtr fp0,fp4,fp8,0      and quantise souce to target
mdlsk15_b8lp lpdfr fp0,fp0            force positive
         cgxtr r0,0,fp0
MDLsk15_b8C STG r0,0(0,0)         save result
MDLsk15_b8X XC 0(0,r14),HEXFF     COMPLEMENT  IF DESCENDING  (OPTIONAL)
MDLsk15_b8L EQU *-MDLsk15_b8
*
MDLsk15_b8P EQU 0                 LITERAL POOL USAGE (EXCL FIELD LEN)
*
MDLsk15_b8R DC AL1(CSSRCLNR),AL1(MDLsk15_b8k+01-MDLsk15_b8) SOURCE LEN
         DC    AL1(CSSRClof),AL1(MDLsk15_b8+02-MDLsk15_b8) F1 OFF
         DC    AL1(CStgtlof),AL1(MDLsk15_b8_lA+02-MDLsk15_b8) F2 OFF
         DC    AL1(CSSRPsrc),AL1(MDLsk15_b8j+01-MDLsk15_b8) skip if 0
         DC    AL1(CSdfpexps),AL1(MDLsk15_b8se+02-MDLsk15_b8) dfp exp
         DC    AL1(CSdfpexp),AL1(MDLsk15_b8te+02-MDLsk15_b8) dfp exp
         DC    AL1(CSTGTLof),AL1(MDLsk15_b8C+02-MDLsk15_b8) TAR len
         DC    AL1(CSSDNLN),AL1(MDLsk15_b8X+01-MDLsk15_b8) SORT DES LEN
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        ASSIGN/MOVE FIELD       (BINARY TO PACKED - SIGNED           *
***********************************************************************
MDLSK16  Xgr   R0,R0              LOAD BINARY NUMBER
MDLsk16_la LAY R14,0(0,0)         get address
MDLSK16S TMy   0(0),X'80'
         if (o)
           lghi r0,-1             fill with 1's
         endif
MDLSK16A ICMy  R0,B'0000',0(0)
         cxgtr fp0,r0             convert to DFP
mdlsk16j jnop  mdlsk16y
mdlsk16se lghi r15,*-*
         iextr fp4,fp0,r15        set quantum of source
mdlsk16te lghi r15,*-*
         iextr fp8,fp8,r15        set quantum of target
         qaxtr fp0,fp4,fp8,0      and quantise souce to target
mdlsk16y csxtr r0,fp0,0
         stmg  r0,r1,workarea
MDLsk16C ZAP   0(0,r14),workarea
MDLSK16X XC    0(0,r14),HEXFF     COMPLEMENT  IF DESCENDING  (OPTIONAL)
MDLSK16L EQU   *-MDLSK16
*
MDLSK16P EQU   0                  LITERAL POOL USAGE (EXCL FIELD LEN)
*
MDLSK16R DC    AL1(CSSRCloF),AL1(MDLSK16S+02-MDLSK16) SOURCE    OFFSET
         DC    AL1(CSBYTMSS),AL1(MDLSK16A+01-MDLSK16) ICM  BYTE MASK
         DC    AL1(CSSRCloF),AL1(MDLSK16A+02-MDLSK16) SOURCE    OFFSET
         DC    AL1(CStgtlof),AL1(MDLsk16_lA+02-MDLsk16) FIELD  2  OFF
         DC    AL1(CSSRPsrc),AL1(MDLSK16j+01-MDLSK16) skip if zero
         DC    AL1(CSdfpexps),AL1(MDLsk16se+02-MDLsk16) dfp exp
         DC    AL1(CSdfpexp),AL1(MDLsk16te+02-MDLsk16) dfp exp
         DC    AL1(CSTGTLNL),AL1(MDLSK16C+01-MDLSK16) TARGET    LENGTH
         DC    AL1(CSSDNLN),AL1(MDLSK16X+01-MDLSK16)  SORT DESCEND LEN
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        ASSIGN/MOVE FIELD       (BINARY8 2 PACKED - SIGNED           *
***********************************************************************
MDLSK16_b8 LG  R0,0(0,0)          LOAD BINARY NUMBER
MDLsk16_b8la LAY R14,0(0,0)         get address
         cxgtr fp0,r0             convert to DFP
mdlsk16_b8j jnop  mdlsk16_b8y
mdlsk16_b8se lghi r15,*-*
         iextr fp4,fp0,r15        set quantum of source
mdlsk16_b8te lghi r15,*-*
         iextr fp8,fp8,r15        set quantum of target
         qaxtr fp0,fp4,fp8,0      and quantise souce to target
mdlsk16_b8y csxtr r0,fp0,0
         stmg  r0,r1,workarea
MDLsk16_b8C ZAP   0(0,r14),workarea
MDLSK16_b8X XC 0(0,r14),HEXFF     COMPLEMENT  IF DESCENDING  (OPTIONAL)
MDLSK16_b8L EQU *-MDLSK16_b8
*
MDLSK16_b8P EQU 0                 LITERAL POOL USAGE (EXCL FIELD LEN)
*
MDLSK16_b8R ds 0h
         DC    AL1(CSSRCLoF),AL1(MDLSK16_b8+02-MDLSK16_b8) SRCE OFF
         DC    AL1(CStgtlof),AL1(MDLsk16_b8lA+02-MDLsk16_b8) FLD 2 off
         DC    AL1(CSSRPsrc),AL1(MDLSK16_b8j+01-MDLSK16_b8) skip if 0
         DC    AL1(CSdfpexps),AL1(MDLsk16_b8se+02-MDLsk16_b8) dfp exp
         DC    AL1(CSdfpexp),AL1(MDLsk16_b8te+02-MDLsk16_b8) dfp exp
         DC    AL1(CSTGTLNL),AL1(MDLSK16_b8C+01-MDLSK16_b8) TARGETLEN
         DC    AL1(CSSDNLN),AL1(MDLSK16_b8X+01-MDLSK16_b8) SORTd LEN
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        ASSIGN/MOVE FIELD       (BINARY TO PACKED - SIGNED/Unsigned) *
***********************************************************************
mdlsk51  Xgr   R0,R0              LOAD BINARY NUMBER
mdlsk51S TMy   0(0),X'80'
         if (o)
           lghi r0,-1             fill with 1's
         endif
mdlsk51A ICMy  R0,B'0000',0(0)
mdlsk51_la LAY R14,0(0,0)         get address
         cxgtr fp0,r0             convert to DFP
mdlsk51j jnop  mdlsk51lp
mdlsk51se lghi r15,*-*
         iextr fp4,fp0,r15        set quantum of source
mdlsk51te lghi r15,*-*
         iextr fp8,fp8,r15        set quantum of target
         qaxtr fp0,fp4,fp8,0      and quantise souce to target
mdlsk51lp lpdfr fp0,fp0
         csxtr r0,fp0,1
         stmg  r0,r1,workarea
MDLsk51C ZAP   0(0,r14),workarea
mdlsk51D OI    0(r14),X'0F'
MDLSK51X XC    0(0,r14),HEXFF     COMPLEMENT  IF DESCENDING  (OPTIONAL)
mdlsk51L EQU   *-mdlsk51
*
mdlsk51P EQU   0                  LITERAL POOL USAGE (EXCL FIELD LEN)
*
mdlsk51R DC    AL1(CSSRCloF),AL1(mdlsk51S+02-mdlsk51) SOURCE    OFFSET
         DC    AL1(CSBYTMSS),AL1(mdlsk51A+01-mdlsk51) ICM  BYTE MASK
         DC    AL1(CSSRCloF),AL1(mdlsk51A+02-mdlsk51) SOURCE    OFFSET
         DC    AL1(CStgtlof),AL1(mdlsk51_la+02-mdlsk51) FIELD  2  OFF
         DC    AL1(CSSRPsrc),AL1(mdlsk51j+01-mdlsk51) SHIFT DEC PLACES
         DC    AL1(CSdfpexps),AL1(MDLsk51se+02-MDLsk51) dfp exp
         DC    AL1(CSdfpexp),AL1(MDLsk51te+02-MDLsk51) dfp exp
         DC    AL1(CSTGTLNL),AL1(mdlsk51C+01-mdlsk51) TARGET    LENGTH
         DC    AL1(CSLSTBYT),AL1(mdlsk51D+02-mdlsk51) LAST BYTE OFFSET
         DC    AL1(CSSDNLN),AL1(MDLSK51X+01-MDLSK51) SORTd LEN
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        ASSIGN/MOVE FIELD       (BINARY8 2 PACKED - SIGNED/Unsigned) *
***********************************************************************
mdlsk51_b8 LG  R0,0(0,0)
mdlsk51_b8la LAY R14,0(0,0)         get address
         cxgtr fp0,r0             convert to DFP
mdlsk51_b8j jnop  mdlsk51_b8lp
mdlsk51_b8se lghi r15,*-*
         iextr fp4,fp0,r15        set quantum of source
mdlsk51_b8te lghi r15,*-*
         iextr fp8,fp8,r15        set quantum of target
         qaxtr fp0,fp4,fp8,0      and quantise souce to target
mdlsk51_b8lp lpdfr fp0,fp0
         csxtr r0,fp0,1
         stmg  r0,r1,workarea
MDLsk51_b8C ZAP   0(0,r14),workarea
mdlsk51_b8D OI 0(r14),X'0F'
MDLSK51_b8X XC 0(0,r14),HEXFF     COMPLEMENT  IF DESCENDING  (OPTIONAL)
mdlsk51_b8L EQU *-mdlsk51_b8
*
mdlsk51_b8P EQU 0                 LITERAL POOL USAGE (EXCL FIELD LEN)
*
mdlsk51_b8R DC AL1(CSSRCLOF),AL1(mdlsk51_b8+02-mdlsk51_b8) SOURCE OFF
         DC    AL1(CStgtlof),AL1(mdlsk51_b8la+02-mdlsk51_b8) FIELD 2OFF
         DC    AL1(CSSRPsrc),AL1(mdlsk51_b8j+01-mdlsk51_b8) SHIFT DEC
         DC    AL1(CSdfpexps),AL1(MDLsk51_b8se+02-MDLsk51_b8) dfp exp
         DC    AL1(CSdfpexp),AL1(MDLsk51_b8te+02-MDLsk51_b8) dfp exp
         DC    AL1(CSTGTLNL),AL1(mdlsk51_b8C+01-mdlsk51_b8) TARGET len
         DC    AL1(CSLSTBYT),AL1(mdlsk51_b8D+02-mdlsk51_b8) LSTBYTE OF
         DC    AL1(CSSDNLN),AL1(MDLSK51_b8X+01-MDLSK51_b8) SORTd LEN
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        ASSIGN/MOVE FIELD       (BINARY TO PACKED - UNSIGNED)        *
***********************************************************************
MDLSK17  Xgr   R0,R0              LOAD BINARY NUMBER
MDLsk17_la LAY R14,0(0,0)         get address
MDLSK17A ICMy  R0,B'0000',0(0)
         cxgtr fp0,r0             convert to DFP
mdlsk17j jnop  mdlsk17lp
mdlsk17se lghi r15,*-*
         iextr fp4,fp0,r15        set quantum of source
mdlsk17te lghi r15,*-*
         iextr fp8,fp8,r15        set quantum of target
         qaxtr fp0,fp4,fp8,0      and quantise souce to target
mdlsk17lp lpdfr fp0,fp0
         csxtr r0,fp0,1
         stmg  r0,r1,workarea
MDLsk17C ZAP   0(0,r14),workarea
MDLSK17D OI    0(r14),X'0F'
MDLSK17X XC    0(0,r14),HEXFF     COMPLEMENT  IF DESCENDING  (OPTIONAL)
MDLSK17L EQU   *-MDLSK17
*
MDLSK17P EQU   0                  LITERAL POOL USAGE (EXCL FIELD LEN)
*
MDLSK17R DC    AL1(CSBYTMSS),AL1(MDLSK17A+01-MDLSK17) ICM  BYTE MASK
         DC    AL1(CSSRCloF),AL1(MDLSK17A+02-MDLSK17) SOURCE    OFFSET
         DC    AL1(CStgtlof),AL1(MDLsk17_lA+02-MDLsk17) FIELD  2  OFF
         DC    AL1(CSSRPsrc),AL1(MDLSK17j+01-MDLSK17) skip if 0
         DC    AL1(CSdfpexps),AL1(MDLsk17se+02-MDLsk17) dfp exp
         DC    AL1(CSdfpexp),AL1(MDLsk17te+02-MDLsk17) dfp exp
         DC    AL1(CSTGTLNL),AL1(MDLSK17C+01-MDLSK17) TARGET    LENGTH
         DC    AL1(CSLSTBYT),AL1(MDLSK17D+02-MDLSK17) LAST BYTE OFFSET
         DC    AL1(CSSDNLN),AL1(MDLSK17X+01-MDLSK17)  SORT DESCEND LEN
         DC   2XL1'FF'
***********************************************************************
*        ASSIGN/MOVE FIELD      (BINARY TO PACKED - UNSIGNED/Signed)  *
***********************************************************************
mdlsk52  Xgr   R0,R0              LOAD BINARY NUMBER
mdlsk52A ICMy  R0,B'0000',0(0)
mdlsk52_la LAY R14,0(0,0)         get address
         cxgtr fp0,r0             convert to DFP
mdlsk52j jnop  mdlsk52y
mdlsk52se lghi r15,*-*
         iextr fp4,fp0,r15        set quantum of source
mdlsk52te lghi r15,*-*
         iextr fp8,fp8,r15        set quantum of target
         qaxtr fp0,fp4,fp8,0      and quantise souce to target
mdlsk52y csxtr r0,fp0,0
         stmg  r0,r1,workarea
MDLsk52C ZAP   0(0,r14),workarea
MDLSK52X XC    0(0,r14),HEXFF     COMPLEMENT  IF DESCENDING  (OPTIONAL)
mdlsk52L EQU   *-mdlsk52
*
mdlsk52P EQU   0                  LITERAL POOL USAGE (EXCL FIELD LEN)
*
mdlsk52R DC    AL1(CSBYTMSS),AL1(mdlsk52A+01-mdlsk52) ICM  BYTE MASK
         DC    AL1(CSSRCloF),AL1(mdlsk52A+02-mdlsk52) SOURCE    OFFSET
         DC    AL1(CStgtlof),AL1(mdlsk52_la+02-mdlsk52) FIELD  2  OFF
         DC    AL1(CSSRPsrc),AL1(mdlsk52j+01-mdlsk52) skip if zero
         DC    AL1(CSdfpexps),AL1(MDLsk52se+02-MDLsk52) dfp exp
         DC    AL1(CSdfpexp),AL1(MDLsk52te+02-MDLsk52) dfp exp
         DC    AL1(CSTGTLNL),AL1(mdlsk52C+01-mdlsk52) TARGET    LENGTH
         DC    AL1(CSSDNLN),AL1(MDLSK52X+01-MDLSK52) SORTd LEN
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        ASSIGN/MOVE FIELD      (BINARY TO PACKED - UNSIGNED/Signed)  *
***********************************************************************
mdlsk52_b8 lg  R0,0(0,0)          LOAD BINARY NUMBER
mdlsk52_b8_la LAY R14,0(0,0)      get address
         cxgtr fp0,r0             convert to DFP
mdlsk52_b8j jnop  mdlsk52_b8y
mdlsk52_b8se lghi r15,*-*
         iextr fp4,fp0,r15        set quantum of source
mdlsk52_b8te lghi r15,*-*
         iextr fp8,fp8,r15        set quantum of target
         qaxtr fp0,fp4,fp8,0      and quantise souce to target
mdlsk52_b8y csxtr r0,fp0,0
         stmg  r0,r1,workarea
MDLsk52_b8C ZAP   0(0,r14),workarea
MDLSK52_b8X XC 0(0,r14),HEXFF     COMPLEMENT  IF DESCENDING  (OPTIONAL)
mdlsk52_b8L EQU *-mdlsk52_b8
*
mdlsk52_b8P EQU 0                 LITERAL POOL USAGE (EXCL FIELD LEN)
*
mdlsk52_b8R ds 0h
         DC    AL1(CSSRCloF),AL1(mdlsk52_b8+02-mdlsk52_b8) SOURCE OFF
         DC    AL1(CStgtlof),AL1(mdlsk52_b8_la+02-mdlsk52_b8) FLD2 OFF
         DC    AL1(CSSRPsrc),AL1(mdlsk52_b8j+01-mdlsk52_b8) skip if 0
         DC    AL1(CSdfpexps),AL1(MDLsk52_b8se+02-MDLsk52_b8) dfp exp
         DC    AL1(CSdfpexp),AL1(MDLsk52_b8te+02-MDLsk52_b8) dfp exp
         DC    AL1(CSTGTLNL),AL1(mdlsk52_b8C+01-mdlsk52_b8) TARGET LEN
         DC    AL1(CSSDNLN),AL1(MDLSK52_b8X+01-MDLSK52_b8) SORTd LEN
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        ASSIGN/MOVE FIELD       (BINARY TO NUMERIC - SIGNED)         *
***********************************************************************
MDLSK18  Xgr   R0,R0              LOAD BINARY NUMBER
MDLsk18_la LAY R14,0(0,0)         get address
MDLSK18S TMy   0(0),X'80'
         if (o)
           lghi r0,-1             fill with 1's
         endif
MDLSK18A ICMy  R0,B'0000',0(0)
         cxgtr fp0,r0             convert to DFP
mdlsk18j jnop  mdlsk18y
mdlsk18se lghi r15,*-*
         iextr fp4,fp0,r15        set quantum of source
mdlsk18te lghi r15,*-*
         iextr fp8,fp8,r15        set quantum of target
         qaxtr fp0,fp4,fp8,0      and quantise souce to target
mdlsk18y csxtr r0,fp0,0
         stmg  r0,r1,workarea
MDLsk18C UNPK  0(0,r14),workarea
MDLSK18X XC    0(0,r14),HEXFF     COMPLEMENT  IF DESCENDING  (OPTIONAL)
MDLSK18L EQU   *-MDLSK18
*
MDLSK18P EQU   0                  LITERAL POOL USAGE (EXCL FIELD LEN)
*
MDLSK18R DC    AL1(CSSRCloF),AL1(MDLSK18S+02-MDLSK18) SOURCE    OFFSET
         DC    AL1(CSBYTMSS),AL1(MDLSK18A+01-MDLSK18) ICM  BYTE MASK
         DC    AL1(CSSRCloF),AL1(MDLSK18A+02-MDLSK18) SOURCE    OFFSET
         DC    AL1(CStgtlof),AL1(MDLsk18_lA+02-MDLsk18) FIELD  2  OFF
         DC    AL1(CSSRPsrc),AL1(MDLSK18j+01-MDLSK18) skip if zero
         DC    AL1(CSdfpexps),AL1(MDLsk18se+02-MDLsk18) dfp exp
         DC    AL1(CSdfpexp),AL1(MDLsk18te+02-MDLsk18) dfp exp
         DC    AL1(CSTGTLNL),AL1(MDLSK18C+01-MDLSK18) TARGET    LENGTH
         DC    AL1(CSSDNLN),AL1(MDLSK18X+01-MDLSK18)  SORT DESCEND LEN
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        ASSIGN/MOVE FIELD       (BINARY8 2 NUMERIC - SIGNED)         *
***********************************************************************
MDLSK18_b8 lg  R0,0(0,0)          LOAD BINARY NUMBER
MDLsk18_b8la LAY R14,0(0,0)         get address
         cxgtr fp0,r0             convert to DFP
mdlsk18_b8j jnop  mdlsk18_b8y
mdlsk18_b8se lghi r15,*-*
         iextr fp4,fp0,r15        set quantum of source
mdlsk18_b8te lghi r15,*-*
         iextr fp8,fp8,r15        set quantum of target
         qaxtr fp0,fp4,fp8,0      and quantise souce to target
mdlsk18_b8y csxtr r0,fp0,0
         stmg  r0,r1,workarea
MDLsk18_b8C UNPK 0(0,r14),workarea
MDLSK18_b8X XC 0(0,r14),HEXFF     COMPLEMENT  IF DESCENDING  (OPTIONAL)
MDLSK18_b8L EQU *-MDLSK18_b8
*
MDLSK18_b8P EQU 0                 LITERAL POOL USAGE (EXCL FIELD LEN)
*
MDLSK18_b8R Ds 0h
         DC    AL1(CSSRCloF),AL1(MDLSK18_b8+02-MDLSK18_b8) SRCE OFF
         DC    AL1(CStgtlof),AL1(MDLsk18_b8lA+02-MDLsk18_b8) FLD 2 off
         DC    AL1(CSSRPsrc),AL1(MDLSK18_b8j+01-MDLSK18_b8) SHIFT DEC
         DC    AL1(CSdfpexps),AL1(MDLsk18_b8se+02-MDLsk18_b8) dfp exp
         DC    AL1(CSdfpexp),AL1(MDLsk18_b8te+02-MDLsk18_b8) dfp exp
         DC    AL1(CSTGTLNL),AL1(MDLSK18_b8C+01-MDLSK18_b8) TARGETLEN
         DC    AL1(CSSDNLN),AL1(MDLSK18_b8X+01-MDLSK18_b8) SORTd LEN
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        ASSIGN/MOVE FIELD       (BINARY TO NUMERIC - SIGNED/Unsigned)*
***********************************************************************
mdlsk53  Xgr   R0,R0              LOAD BINARY NUMBER
mdlsk53S TMy   0(0),X'80'
         if (o)
           lghi r0,-1             fill with 1's
         endif
mdlsk53A ICMy  R0,B'0000',0(0)
mdlsk53_la LAY R14,0(0,0)         get address
         cxgtr fp0,r0             convert to DFP
mdlsk53j jnop  mdlsk53lp
mdlsk53se lghi r15,*-*
         iextr fp4,fp0,r15        set quantum of source
mdlsk53te lghi r15,*-*
         iextr fp8,fp8,r15        set quantum of target
         qaxtr fp0,fp4,fp8,0      and quantise souce to target
mdlsk53lp lpdfr fp0,fp0
         csxtr r0,fp0,1
         stmg  r0,r1,workarea
         OI    workarea+L'workarea-1,X'0F'
MDLsk53C UNPK 0(0,r14),workarea
MDLSK53X XC    0(0,r14),HEXFF     COMPLEMENT  IF DESCENDING  (OPTIONAL)
mdlsk53L EQU   *-mdlsk53
*
mdlsk53P EQU   0                  LITERAL POOL USAGE (EXCL FIELD LEN)
*
mdlsk53R DC    AL1(CSSRCloF),AL1(mdlsk53S+02-mdlsk53) SOURCE    OFFSET
         DC    AL1(CSBYTMSS),AL1(mdlsk53A+01-mdlsk53) ICM  BYTE MASK
         DC    AL1(CSSRCloF),AL1(mdlsk53A+02-mdlsk53) SOURCE    OFFSET
         DC    AL1(CStgtlof),AL1(mdlsk53_la+02-mdlsk53) FIELD  2  OFF
         DC    AL1(CSSRPsrc),AL1(mdlsk53j+01-mdlsk53) skip if zero
         DC    AL1(CSdfpexps),AL1(MDLsk53se+02-MDLsk53) dfp exp
         DC    AL1(CSdfpexp),AL1(MDLsk53te+02-MDLsk53) dfp exp
         DC    AL1(CSTGTLNL),AL1(mdlsk53C+01-mdlsk53) TARGET    LENGTH
         DC    AL1(CSSDNLN),AL1(MDLSK53X+01-MDLSK53)  SORT DESCEND LEN
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        ASSIGN/MOVE FIELD       (BINARY8TO NUMERIC - SIGNED/Unsigned)*
***********************************************************************
mdlsk53_b8  LG  R0,0(0,0)         LOAD BINARY NUMBER
mdlsk53_b8la LAY R14,0(0,0)         get address
         cxgtr fp0,r0             convert to DFP
mdlsk53_b8j jnop  mdlsk53_b8lp
mdlsk53_b8se lghi r15,*-*
         iextr fp4,fp0,r15        set quantum of source
mdlsk53_b8te lghi r15,*-*
         iextr fp8,fp8,r15        set quantum of target
         qaxtr fp0,fp4,fp8,0      and quantise souce to target
mdlsk53_b8lp lpdfr fp0,fp0
         csxtr r0,fp0,1
         stmg  r0,r1,workarea
         OI    workarea+L'workarea-1,X'0F'
MDLsk53_b8C UNPK 0(0,r14),workarea
MDLSK53_b8X XC 0(0,r14),HEXFF     COMPLEMENT  IF DESCENDING  (OPTIONAL)
mdlsk53_b8L EQU *-mdlsk53_b8
*
mdlsk53_b8P EQU 0                 LITERAL POOL USAGE (EXCL FIELD LEN)
*
mdlsk53_b8R ds 0h
         DC    AL1(CSSRCloF),AL1(mdlsk53_b8+02-mdlsk53_b8) SOURCE OFF
         DC    AL1(CStgtlof),AL1(mdlsk53_b8la+02-mdlsk53_b8) fld 2 off
         DC    AL1(CSSRPsrc),AL1(mdlsk53_b8j+01-mdlsk53_b8) SHIFT DEC
         DC    AL1(CSdfpexps),AL1(MDLsk53_b8se+02-MDLsk53_b8) dfp exp
         DC    AL1(CSdfpexp),AL1(MDLsk53_b8te+02-MDLsk53_b8) dfp exp
         DC    AL1(CSTGTLNL),AL1(mdlsk53_b8C+01-mdlsk53_b8) TARGET LEN
         DC    AL1(CSSDNLN),AL1(MDLSK53_b8X+01-MDLSK53_b8) SORTd LEN
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        ASSIGN/MOVE FIELD       (BINARY TO NUMERIC - UNSIGNED)       *
***********************************************************************
MDLSK19  Xgr   R0,R0              LOAD BINARY NUMBER
MDLsk19_la LAY R14,0(0,0)         get address
MDLSK19A ICMy  R0,B'0000',0(0)
         cxgtr fp0,r0             convert to DFP
mdlsk19j jnop  mdlsk19lp
mdlsk19se lghi r15,*-*
         iextr fp4,fp0,r15        set quantum of source
mdlsk19te lghi r15,*-*
         iextr fp8,fp8,r15        set quantum of target
         qaxtr fp0,fp4,fp8,0      and quantise souce to target
mdlsk19lp lpdfr fp0,fp0
         csxtr r0,fp0,1
         stmg  r0,r1,workarea
         OI    workarea+L'workarea-1,X'0F'
MDLsk19C UNPK 0(0,r14),workarea
MDLSK19X XC    0(0,r14),HEXFF     COMPLEMENT  IF DESCENDING  (OPTIONAL)
MDLSK19L EQU   *-MDLSK19
*
MDLSK19P EQU   0                  LITERAL POOL USAGE (EXCL FIELD LEN)
*
MDLSK19R DC    AL1(CSBYTMSS),AL1(MDLSK19A+01-MDLSK19) ICM  BYTE MASK
         DC    AL1(CSSRCloF),AL1(MDLSK19A+02-MDLSK19) SOURCE    OFFSET
         DC    AL1(CStgtlof),AL1(MDLsk19_lA+02-MDLsk19) FIELD  2  OFF
         DC    AL1(CSSRPsrc),AL1(MDLSK19j+01-MDLSK19) skip if zero
         DC    AL1(CSdfpexps),AL1(MDLsk19se+02-MDLsk19) dfp exp
         DC    AL1(CSdfpexp),AL1(MDLsk19te+02-MDLsk19) dfp exp
         DC    AL1(CSTGTLNL),AL1(MDLSK19C+01-MDLSK19) TARGET    LENGTH
         DC    AL1(CSSDNLN),AL1(MDLSK19X+01-MDLSK19)  SORT DESCEND LEN
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        ASSIGN/MOVE FIELD     (BINARY TO NUMERIC - UNSIGNED/Signed)  *
***********************************************************************
mdlsk54  Xgr   R0,R0              LOAD BINARY NUMBER
mdlsk54A ICMy  R0,B'0000',0(0)
mdlsk54_la LAY R14,0(0,0)         get address
         cxgtr fp0,r0             convert to DFP
mdlsk54j jnop  mdlsk54y
mdlsk54se lghi r15,*-*
         iextr fp4,fp0,r15        set quantum of source
mdlsk54te lghi r15,*-*
         iextr fp8,fp8,r15        set quantum of target
         qaxtr fp0,fp4,fp8,0      and quantise souce to target
mdlsk54y csxtr r0,fp0,0
         stmg  r0,r1,workarea
MDLsk54C UNPK 0(0,r14),workarea
MDLSK54X XC    0(0,r14),HEXFF     COMPLEMENT  IF DESCENDING  (OPTIONAL)
mdlsk54L EQU   *-mdlsk54
*
mdlsk54P EQU   0                  LITERAL POOL USAGE (EXCL FIELD LEN)
*
mdlsk54R DC    AL1(CSBYTMSS),AL1(mdlsk54A+01-mdlsk54) ICM  BYTE MASK
         DC    AL1(CSSRCloF),AL1(mdlsk54A+02-mdlsk54) SOURCE    OFFSET
         DC    AL1(CStgtlof),AL1(mdlsk54_la+02-mdlsk54) FIELD  2  OFF
         DC    AL1(CSSRPsrc),AL1(mdlsk54j+01-mdlsk54) skip if zero
         DC    AL1(CSdfpexps),AL1(MDLsk54se+02-MDLsk54) dfp exp
         DC    AL1(CSdfpexp),AL1(MDLsk54te+02-MDLsk54) dfp exp
         DC    AL1(CSTGTLNL),AL1(mdlsk54C+01-mdlsk54) TARGET    LENGTH
         DC    AL1(CSSDNLN),AL1(MDLSK54X+01-MDLSK54)  SORT DESCEND LEN
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        ASSIGN/MOVE FIELD     (BINARY TO NUMERIC - UNSIGNED/Signed)  *
***********************************************************************
mdlsk54_b8 LG  R0,0(0,0)          LOAD BINARY NUMBER
mdlsk54_b8la LAY R14,0(0,0)         get address
         cxgtr fp0,r0             convert to DFP
mdlsk54_b8j jnop  mdlsk54_b8y
mdlsk54_b8se lghi r15,*-*
         iextr fp4,fp0,r15        set quantum of source
mdlsk54_b8te lghi r15,*-*
         iextr fp8,fp8,r15        set quantum of target
         qaxtr fp0,fp4,fp8,0      and quantise souce to target
mdlsk54_b8y csxtr r0,fp0,0
         stmg  r0,r1,workarea
MDLsk54_b8C UNPK 0(0,r14),workarea
MDLSK54_b8X XC 0(0,r14),HEXFF     COMPLEMENT  IF DESCENDING  (OPTIONAL)
mdlsk54_b8L EQU *-mdlsk54_b8
*
mdlsk54_b8P EQU 0                 LITERAL POOL USAGE (EXCL FIELD LEN)
*
mdlsk54_b8R Ds 0h
         DC    AL1(CSSRCLoF),AL1(mdlsk54_b8+02-mdlsk54_b8) SOURCE OFF
         DC    AL1(CStgtlof),AL1(mdlsk54_b8la+02-mdlsk54_b8) fld 2 off
         DC    AL1(CSSRPsrc),AL1(mdlsk54_b8j+01-mdlsk54_b8) skip if 0
         DC    AL1(CSdfpexps),AL1(MDLsk54_b8se+02-MDLsk54_b8) dfp exp
         DC    AL1(CSdfpexp),AL1(MDLsk54_b8te+02-MDLsk54_b8) dfp exp
         DC    AL1(CSTGTLNL),AL1(mdlsk54_b8C+01-mdlsk54_b8) TARGET LEN
         DC    AL1(CSSDNLN),AL1(MDLSK54_b8X+01-MDLSK54_b8) SORTd LEN
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        ASSIGN/MOVE FIELD       (BINARY TO BINARY - BOTH UNSIGNED)   *
***********************************************************************
MDLSK20  XR    R0,R0              LOAD BINARY NUMBER
MDLsk20_la LAY R14,0(0,0)         get address
MDLSK20A ICMy  R0,B'0000',0(0)
MDLSK20B STCMy R0,B'0000',0(0)
MDLSK20X XC    0(0,r14),HEXFF     COMPLEMENT  IF DESCENDING  (OPTIONAL)
MDLSK20L EQU   *-MDLSK20
*
MDLSK20P EQU   0                  LITERAL POOL USAGE (EXCL FIELD LEN)
*
MDLSK20R DC    AL1(CSBYTMSS),AL1(MDLSK20A+01-MDLSK20) ICM  BYTE MASK
         DC    AL1(CSSRCloF),AL1(MDLSK20A+02-MDLSK20) SOURCE    OFFSET
         DC    AL1(CStgtlof),AL1(MDLsk20_lA+02-MDLsk20) FIELD  2  OFF
         DC    AL1(CSBYTMSK),AL1(MDLSK20B+01-MDLSK20) STCM BYTE MASK
         DC    AL1(CSTGTloF),AL1(MDLSK20B+02-MDLSK20) TARGET    OFFSET
         DC    AL1(CSSDNLN),AL1(MDLSK20X+01-MDLSK20)  SORT DESCEND LEN
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        ASSIGN/MOVE FIELD       (BINARY TO BINARY - SIGNED)          *
***********************************************************************
MDLSK21  Xgr   R0,R0              LOAD BINARY NUMBER
MDLsk21_la LAY R14,0(0,0)         get address
MDLSK21S TMy   0(0),X'80'
         if (o)
           lghi r0,-1             fill with 1's
         endif
MDLSK21A ICMy  R0,B'0000',0(0)
         cxgtr fp0,r0             convert to DFP
mdlsk21j jnop  mdlsk21y
mdlsk21se lghi r15,*-*
         iextr fp4,fp0,r15        set quantum of source
mdlsk21te lghi r15,*-*
         iextr fp8,fp8,r15        set quantum of target
         qaxtr fp0,fp4,fp8,0      and quantise souce to target
mdlsk21y cgxtr r0,0,fp0
MDLSK21C STCMy R0,B'0000',0(0)
MDLSK21X XC    0(0,r14),HEXFF     COMPLEMENT  IF DESCENDING  (OPTIONAL)
MDLSK21L EQU   *-MDLSK21
*
MDLSK21P EQU   0                  LITERAL POOL USAGE (EXCL FIELD LEN)
*
MDLSK21R DC    AL1(CSSRCloF),AL1(MDLSK21S+02-MDLSK21) SOURCE    OFFSET
         DC    AL1(CStgtlof),AL1(MDLsk21_lA+02-MDLsk21) FIELD  2  OFF
         DC    AL1(CSBYTMSS),AL1(MDLSK21A+01-MDLSK21) ICM  BYTE MASK
         DC    AL1(CSSRCloF),AL1(MDLSK21A+02-MDLSK21) SOURCE    OFFSET
         DC    AL1(CSSRPsrc),AL1(MDLSK21j+01-MDLSK21) skip if zero
         DC    AL1(CSdfpexps),AL1(MDLsk21se+02-MDLsk21) dfp exp
         DC    AL1(CSdfpexp),AL1(MDLsk21te+02-MDLsk21) dfp exp
         DC    AL1(CSBYTMSK),AL1(MDLSK21C+01-MDLSK21) STCM BYTE MASK
         DC    AL1(CSTGTloF),AL1(MDLSK21C+02-MDLSK21) TARGET    OFFSET
         DC    AL1(CSSDNLN),AL1(MDLSK21X+01-MDLSK21)  SORT DESCEND LEN
         DC   2XL1'FF'
*
*  This model is used to conver from bin 1,2, or 4 to bin 8
*
MDLsk21_b8 xgr  R0,R0              LOAD BINARY NUMBER
MDLsk21_b8la LAY R14,0(0,0)         get address
MDLsk21_b8t TMy 0(0),X'80'
          JNO  mdlsk21_b8a
          Lghi R0,-1              Fills the register with 1's
MDLsk21_b8a ICMy R0,B'0000',0(0)
         cxgtr fp0,r0             convert to DFP
mdlsk21_b8j jnop  mdlsk21_b8y
mdlsk21_b8se lghi r15,*-*
         iextr fp4,fp0,r15        set quantum of source
mdlsk21_b8te lghi r15,*-*
         iextr fp8,fp8,r15        set quantum of target
         qaxtr fp0,fp4,fp8,0      and quantise souce to target
mdlsk21_b8y cgxtr r0,0,fp0
MDLsk21_b8C STG R0,0(0,0)
MDLSK21_b8x xc 0(0,r14),HEXFF     COMPLEMENT  IF DESCENDING  (OPTIONAL)
MDLsk21_b8L EQU *-MDLsk21_b8
*
MDLsk21_b8P EQU 0                 LITERAL POOL USAGE (EXCL FIELD LEN)
*
MDLsk21_b8R Ds 0h
         DC    AL1(CSSRCloF),AL1(MDLsk21_b8t+02-MDLsk21_b8) SOURCE OFF
         DC    AL1(CStgtlof),AL1(MDLsk21_b8lA+02-MDLsk21_b8)
         DC    AL1(CSBYTMSS),AL1(MDLsk21_b8A+01-MDLsk21_b8) ICM MASK
         DC    AL1(CSSRCloF),AL1(MDLsk21_b8A+02-MDLsk21_b8) SOURCE OFF
         DC    AL1(CSSRPsrc),AL1(MDLsk21_b8j+01-MDLsk21_b8) skip if 0
         DC    AL1(CSdfpexps),AL1(MDLsk21_b8se+02-MDLsk21_b8) dfp exp
         DC    AL1(CSdfpexp),AL1(MDLsk21_b8te+02-MDLsk21_b8) dfp exp
         DC    AL1(CSTGTLoF),AL1(MDLsk21_b8C+02-MDLsk21_b8) TARGETOFF
         DC    AL1(CSSDNLN),AL1(MDLSK21_b8X+01-MDLSK21_b8x) SORT DES LN
         DC   2XL1'FF'
***********************************************************************
*
*  This model is used to conver from bin 1,2, or 4 to bin 8
*
MDLsk21_8b LG  R0,0(0,0)          LOAD BINARY NUMBER
MDLsk21_8bla LAY R14,0(0,0)         get address
         cxgtr fp0,r0             convert to DFP
mdlsk21_8bj jnop  mdlsk21_8by
mdlsk21_8bse lghi r15,*-*
         iextr fp4,fp0,r15        set quantum of source
mdlsk21_8bte lghi r15,*-*
         iextr fp8,fp8,r15        set quantum of target
         qaxtr fp0,fp4,fp8,0      and quantise souce to target
mdlsk21_8by cgxtr r0,0,fp0
MDLsk21_8bC STcmy R0,b'0000',0(0)
MDLSK21_8bX XC 0(0,r14),HEXFF     COMPLEMENT  IF DESCENDING  (OPTIONAL)
MDLsk21_8bL EQU *-MDLsk21_8b
*
MDLsk21_8bP EQU 0                 LITERAL POOL USAGE (EXCL FIELD LEN)
*
MDLsk21_8bR Ds 0h
         DC    AL1(CSSRCloF),AL1(MDLsk21_8b+02-MDLsk21_8b) SOURCE OFF
         DC    AL1(CStgtlof),AL1(MDLsk21_8blA+02-MDLsk21_8b) FLD 2 off
         DC    AL1(CSSRPsrc),AL1(MDLsk21_8bj+01-MDLsk21_8b) skip if 0
         DC    AL1(CSdfpexps),AL1(MDLsk21_8bse+02-MDLsk21_8b) dfp exp
         DC    AL1(CSdfpexp),AL1(MDLsk21_8bte+02-MDLsk21_8b) dfp exp
         DC    AL1(CSBYTMSK),AL1(MDLsk21_8bC+01-MDLsk21_8b) ICM MASK
         DC    AL1(CSTGTLoF),AL1(MDLsk21_8bC+02-MDLsk21_8b) TARGETOFF
         DC    AL1(CSSDNLN),AL1(MDLSK21_8bX+01-MDLSK21_8b) SORTd LEN
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        ASSIGN/MOVE FIELD       (BIN8   TO BIN8   - SIGNED)          *
***********************************************************************
MDLSK21_88 lg  R0,0(0,0)          LOAD BINARY NUMBER
MDLsk21_88la LAY R14,0(0,0)         get address
         cxgtr fp0,r0             convert to DFP
mdlsk21_88j jnop  mdlsk21_88y
mdlsk21_88se lghi r15,*-*
         iextr fp4,fp0,r15        set quantum of source
mdlsk21_88te lghi r15,*-*
         iextr fp8,fp8,r15        set quantum of target
         qaxtr fp0,fp4,fp8,0      and quantise souce to target
mdlsk21_88y cgxtr r0,0,fp0
Mdlsk21_88c STG R0,0(0,0)
MDLSK21_88X XC 0(0,r14),HEXFF     COMPLEMENT  IF DESCENDING  (OPTIONAL)
MDLSK21_88L EQU *-MDLSK21_88
*
MDLSK21_88P EQU 0                 LITERAL POOL USAGE (EXCL FIELD LEN)
*
MDLSK21_88R DC AL1(CSSRCLoF),AL1(MDLSK21_88+02-MDLSK21_88) SRCE OFF
         DC    AL1(CStgtlof),AL1(MDLsk21_88lA+02-MDLsk21_88) FLD 2 off
         DC    AL1(CSSRPsrc),AL1(MDLSK21_88j+01-MDLSK21_88) skip if 0
         DC    AL1(CSdfpexps),AL1(MDLsk21_88se+02-MDLsk21_88) dfp exp
         DC    AL1(CSdfpexp),AL1(MDLsk21_88te+02-MDLsk21_88) dfp exp
         DC    AL1(CSTGTloF),AL1(MDLSK21_88C+02-MDLSK21_88) TARGETOFF
         DC    AL1(CSSDNLN),AL1(MDLSK21_88X+01-MDLSK21_88) SORTd LEN
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        ASSIGN/MOVE FIELD       (BINARY TO BINARY - SIGNED->UNSIGNED)*
***********************************************************************
MDLSK22  Xgr   R0,R0              LOAD BINARY NUMBER
MDLsk22_la LAY R14,0(0,0)         get address
MDLSK22A ICMY  R0,B'0000',0(0)
         cxgtr fp0,r0             convert to DFP
mdlsk22j jnop  mdlsk22lp
mdlsk22se lghi r15,*-*
         iextr fp4,fp0,r15        set quantum of source
mdlsk22te lghi r15,*-*
         iextr fp8,fp8,r15        set quantum of target
         qaxtr fp0,fp4,fp8,0      and quantise souce to target
mdlsk22lp lpdfr fp0,fp0            force positive
         cgxtr r0,0,fp0
MDLSK22C STCMy R0,B'0000',0(0)
MDLSK22X XC    0(0,r14),HEXFF     COMPLEMENT  IF DESCENDING  (OPTIONAL)
MDLSK22L EQU   *-MDLSK22
*
MDLSK22P EQU   0                  LITERAL POOL USAGE (EXCL FIELD LEN)
*
MDLSK22R ds    0h
         DC    AL1(CStgtlof),AL1(MDLsk22_lA+02-MDLsk22) FIELD  2  OFF
         DC    AL1(CSBYTMSS),AL1(MDLSK22A+01-MDLSK22) ICM  BYTE MASK
         DC    AL1(CSSRCloF),AL1(MDLSK22A+02-MDLSK22) SOURCE    OFFSET
         DC    AL1(CSSRPsrc),AL1(MDLSK22j+01-MDLSK22) skip if zero
         DC    AL1(CSdfpexps),AL1(MDLsk22se+02-MDLsk22) dfp exp
         DC    AL1(CSdfpexp),AL1(MDLsk22te+02-MDLsk22) dfp exp
         DC    AL1(CSBYTMSK),AL1(MDLSK22C+01-MDLSK22) STCM BYTE MASK
         DC    AL1(CSTGTloF),AL1(MDLSK22C+02-MDLSK22) TARGET    OFFSET
         DC    AL1(CSSDNLN),AL1(MDLSK22X+01-MDLSK22)  SORT DESCEND LEN
         DC   2XL1'FF'
                        SPACE 3
*
*  This model is used to conver from bin 1,2, or 4 to bin 8
*
MDLsk22_b8 xgr  R0,R0              LOAD BINARY NUMBER
MDLsk22_b8la LAY R14,0(0,0)         get address
MDLsk22_b8a ICMy R0,B'0000',0(0)
         cxgtr fp0,r0             convert to DFP
mdlsk22_b8j jnop  mdlsk22_b8lp
mdlsk22_b8se lghi r15,*-*
         iextr fp4,fp0,r15        set quantum of source
mdlsk22_b8te lghi r15,*-*
         iextr fp8,fp8,r15        set quantum of target
         qaxtr fp0,fp4,fp8,0      and quantise souce to target
mdlsk22_b8lp lpdfr fp0,fp0            force positive
         cgxtr r0,0,fp0
MDLsk22_b8C STG R0,0(0,0)
MDLsk22_b8x xc 0(0,r14),HEXFF     COMPLEMENT  IF DESCENDING  (OPTIONAL)
MDLsk22_b8L EQU *-MDLsk22_b8
*
MDLsk22_b8P EQU 0                 LITERAL POOL USAGE (EXCL FIELD LEN)
*
MDLsk22_b8R Ds 0h
         DC    AL1(CStgtlof),AL1(MDLsk22_b8lA+02-MDLsk22_b8)
         DC    AL1(CSBYTMSS),AL1(MDLsk22_b8A+01-MDLsk22_b8) ICM MASK
         DC    AL1(CSSRCloF),AL1(MDLsk22_b8A+02-MDLsk22_b8) SOURCE OFF
         DC    AL1(CSSRPsrc),AL1(MDLsk22_b8j+01-MDLsk22_b8) skip if 0
         DC    AL1(CSdfpexps),AL1(MDLsk22_b8se+02-MDLsk22_b8) dfp exp
         DC    AL1(CSdfpexp),AL1(MDLsk22_b8te+02-MDLsk22_b8) dfp exp
         DC    AL1(CSTGTLoF),AL1(MDLsk22_b8C+02-MDLsk22_b8) TARGETOFF
         DC    AL1(CSSDNLN),AL1(MDLsk22_b8X+01-MDLsk22_b8x) SORT DES LN
         DC   2XL1'FF'
***********************************************************************
*
*  This model is used to conver from bin 1,2, or 4 to bin 8
*
MDLsk22_8b LG  R0,0(0,0)          LOAD BINARY NUMBER
MDLsk22_8bla LAY R14,0(0,0)         get address
         cxgtr fp0,r0             convert to DFP
mdlsk22_8bj jnop  mdlsk22_8blp
mdlsk22_8bse lghi r15,*-*
         iextr fp4,fp0,r15        set quantum of source
mdlsk22_8bte lghi r15,*-*
         iextr fp8,fp8,r15        set quantum of target
         qaxtr fp0,fp4,fp8,0      and quantise souce to target
mdlsk22_8blp lpdfr fp0,fp0            force positive
         cgxtr r0,0,fp0
MDLsk22_8bC STcmy R0,b'0000',0(0)
MDLsk22_8bX XC 0(0,r14),HEXFF     COMPLEMENT  IF DESCENDING  (OPTIONAL)
MDLsk22_8bL EQU *-MDLsk22_8b
*
MDLsk22_8bP EQU 0                 LITERAL POOL USAGE (EXCL FIELD LEN)
*
MDLsk22_8bR Ds 0h
         DC    AL1(CSSRCloF),AL1(MDLsk22_8b+02-MDLsk22_8b) SOURCE OFF
         DC    AL1(CStgtlof),AL1(MDLsk22_8blA+02-MDLsk22_8b) FLD 2 off
         DC    AL1(CSSRPsrc),AL1(MDLsk22_8bj+01-MDLsk22_8b) SHIFT DEC
         DC    AL1(CSdfpexps),AL1(MDLsk22_8bse+02-MDLsk22_8b) dfp exp
         DC    AL1(CSdfpexp),AL1(MDLsk22_8bte+02-MDLsk22_8b) dfp exp
         DC    AL1(CSBYTMSK),AL1(MDLsk22_8bC+01-MDLsk22_8b) ICM MASK
         DC    AL1(CSTGTLoF),AL1(MDLsk22_8bC+02-MDLsk22_8b) TARGETOFF
         DC    AL1(CSSDNLN),AL1(MDLsk22_8bX+01-MDLsk22_8b) SORTd LEN
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        ASSIGN/MOVE FIELD       (BINARY8 2 BINARY - SIGNED->UNSIGNED)*
***********************************************************************
MDLSK22_88 lg  R0,0(0,0)          LOAD BINARY NUMBER
MDLsk22_88la LAY R14,0(0,0)         get address
         cxgtr fp0,r0             convert to DFP
mdlsk22_88j jnop  mdlsk22_88lp
mdlsk22_88se lghi r15,*-*
         iextr fp4,fp0,r15        set quantum of source
mdlsk22_88te lghi r15,*-*
         iextr fp8,fp8,r15        set quantum of target
         qaxtr fp0,fp4,fp8,0      and quantise souce to target
mdlsk22_88lp lpdfr fp0,fp0            force positive
         cgxtr r0,0,fp0
MDLSK22_88C STG R0,0(0,0)
MDLSK22_88X XC 0(0,r14),HEXFF     COMPLEMENT  IF DESCENDING  (OPTIONAL)
MDLSK22_88L EQU *-MDLSK22_88
*
MDLSK22_88P EQU 0                 LITERAL POOL USAGE (EXCL FIELD LEN)
*
MDLSK22_88R DC AL1(CSSRCloF),AL1(MDLSK22_88+02-MDLSK22_88) SRCE OFF
         DC    AL1(CStgtlof),AL1(MDLsk22_88lA+02-MDLsk22_88) FLD 2 off
         DC    AL1(CSSRPsrc),AL1(MDLSK22_88j+01-MDLSK22_88) skip if 0
         DC    AL1(CSdfpexps),AL1(MDLsk22_88se+02-MDLsk22_88) dfp exp
         DC    AL1(CSdfpexp),AL1(MDLsk22_88te+02-MDLsk22_88) dfp exp
         DC    AL1(CSTGTloF),AL1(MDLSK22_88C+02-MDLSK22_88) TARGETOFF
         DC    AL1(CSSDNLN),AL1(MDLSK22_88X+01-MDLSK22_88) SORTd len
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        ASSIGN/MOVE FIELD       (BINARY TO BINARY - UNSIGNED->SIGNED)*
***********************************************************************
MDLSK23  Xgr   R0,R0              LOAD BINARY NUMBER
MDLsk23_la LAY R14,0(0,0)         get address
MDLSK23A ICMY  R0,B'0000',0(0)
mdlsk23j jnop  mdlsk23c
         cxgtr fp0,r0             convert to DFP
mdlsk23se lghi r15,*-*
         iextr fp4,fp0,r15        set quantum of source
mdlsk23te lghi r15,*-*
         iextr fp8,fp8,r15        set quantum of target
         qaxtr fp0,fp4,fp8,0      and quantise souce to target
         cgxtr r0,0,fp0
MDLSK23C STCMy R0,B'0000',0(0)
MDLSK23X XC    0(0,r14),HEXFF     COMPLEMENT  IF DESCENDING  (OPTIONAL)
MDLSK23L EQU   *-MDLSK23
*
MDLSK23P EQU   0                  LITERAL POOL USAGE (EXCL FIELD LEN)
*
MDLSK23R DC    AL1(CSBYTMSS),AL1(MDLSK23A+01-MDLSK23) ICM  BYTE MASK
         DC    AL1(CSSRCloF),AL1(MDLSK23A+02-MDLSK23) SOURCE    OFFSET
         DC    AL1(CStgtlof),AL1(MDLsk23_lA+02-MDLsk23) FIELD  2  OFF
         DC    AL1(CSSRPsrc),AL1(MDLSK23j+01-MDLSK23) skip if zero
         DC    AL1(CSdfpexps),AL1(MDLsk23se+02-MDLsk23) dfp exp
         DC    AL1(CSdfpexp),AL1(MDLsk23te+02-MDLsk23) dfp exp
         DC    AL1(CSBYTMSK),AL1(MDLSK23C+01-MDLSK23) STCM BYTE MASK
         DC    AL1(CSTGTloF),AL1(MDLSK23C+02-MDLSK23) TARGET    OFFSET
         DC    AL1(CSSDNLN),AL1(MDLSK23X+01-MDLSK23)  SORT DESCEND LEN
         DC   2XL1'FF'
                        SPACE 3
*
*  This model is used to conver from bin 1,2, or 4 to bin 8
*
MDLsk23_b8 xgr  R0,R0              LOAD BINARY NUMBER
MDLsk23_b8la LAY R14,0(0,0)         get address
MDLsk23_b8a ICMy R0,B'0000',0(0)
mdlsk23_b8j jnop  mdlsk23_b8c
         cxgtr fp0,r0             convert to DFP
mdlsk23_b8se lghi r15,*-*
         iextr fp4,fp0,r15        set quantum of source
mdlsk23_b8te lghi r15,*-*
         iextr fp8,fp8,r15        set quantum of target
         qaxtr fp0,fp4,fp8,0      and quantise souce to target
         cgxtr r0,0,fp0
MDLsk23_b8C STG R0,0(0,0)
MDLsk23_b8x xc 0(0,r14),HEXFF     COMPLEMENT  IF DESCENDING  (OPTIONAL)
MDLsk23_b8L EQU *-MDLsk23_b8
*
MDLsk23_b8P EQU 0                 LITERAL POOL USAGE (EXCL FIELD LEN)
*
MDLsk23_b8R Ds 0h
         DC    AL1(CStgtlof),AL1(MDLsk23_b8lA+02-MDLsk23_b8)
         DC    AL1(CSBYTMSS),AL1(MDLsk23_b8A+01-MDLsk23_b8) ICM MASK
         DC    AL1(CSSRCloF),AL1(MDLsk23_b8A+02-MDLsk23_b8) SOURCE OFF
         DC    AL1(CSSRPsrc),AL1(MDLsk23_b8j+01-MDLsk23_b8) skip if 0
         DC    AL1(CSdfpexps),AL1(MDLsk23se+02-MDLsk23) dfp exp
         DC    AL1(CSdfpexp),AL1(MDLsk23te+02-MDLsk23) dfp exp
         DC    AL1(CSTGTLoF),AL1(MDLsk23_b8C+02-MDLsk23_b8) TARGETOFF
         DC    AL1(CSSDNLN),AL1(MDLsk23_b8X+01-MDLsk23_b8x) SORT DES LN
         DC   2XL1'FF'
***********************************************************************
*                                (BIN8  BINARY1 2 4  BOTH SIGNED)     *
***********************************************************************
*
*  This model is used to conver from bin 1,2, or 4 to bin 8
*
MDLsk23_8b LG  R0,0(0,0)          LOAD BINARY NUMBER
MDLsk23_8bla LAY R14,0(0,0)         get address
mdlsk23_8bj jnop  mdlsk23_8bc
         cxgtr fp0,r0             convert to DFP
mdlsk23_8bse lghi r15,*-*
         iextr fp4,fp0,r15        set quantum of source
mdlsk23_8bte lghi r15,*-*
         iextr fp8,fp8,r15        set quantum of target
         qaxtr fp0,fp4,fp8,0      and quantise souce to target
         cgxtr r0,0,fp0
MDLsk23_8bC STcmy R0,b'0000',0(0)
MDLsk23_8bX XC 0(0,r14),HEXFF     COMPLEMENT  IF DESCENDING  (OPTIONAL)
MDLsk23_8bL EQU *-MDLsk23_8b
*
MDLsk23_8bP EQU 0                 LITERAL POOL USAGE (EXCL FIELD LEN)
*
MDLsk23_8bR Ds 0h
         DC    AL1(CSSRCloF),AL1(MDLsk23_8b+02-MDLsk23_8b) SOURCE OFF
         DC    AL1(CStgtlof),AL1(MDLsk23_8blA+02-MDLsk23_8b) FLD 2 off
         DC    AL1(CSSRPsrc),AL1(MDLsk23_8bj+01-MDLsk23_8b) skip if 0
         DC    AL1(CSdfpexps),AL1(MDLsk23_8bse+02-MDLsk23_8b) dfp exp
         DC    AL1(CSdfpexp),AL1(MDLsk23_8bte+02-MDLsk23_8b) dfp exp
         DC    AL1(CSBYTMSK),AL1(MDLsk23_8bC+01-MDLsk23_8b) ICM MASK
         DC    AL1(CSTGTLoF),AL1(MDLsk23_8bC+02-MDLsk23_8b) TARGETOFF
         DC    AL1(CSSDNLN),AL1(MDLsk23_8bX+01-MDLsk23_8b) SORTd LEN
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        ASSIGN/MOVE FIELD       (BINARY TO BINARY - UNSIGNED->SIGNED)*
***********************************************************************
MDLSK23_88 LG  R0,0(0,0)          LOAD BINARY NUMBER
MDLsk23_88la LAY R14,0(0,0)         get address
mdlsk23_88j jnop  mdlsk23_88c
         cxgtr fp0,r0             convert to DFP
mdlsk23_88se lghi r15,*-*
         iextr fp4,fp0,r15        set quantum of source
mdlsk23_88te lghi r15,*-*
         iextr fp8,fp8,r15        set quantum of target
         qaxtr fp0,fp4,fp8,0      and quantise souce to target
         cgxtr r0,0,fp0
MDLSK23_88C STG R0,0(0,0)
MDLSK23_88X XC 0(0,r14),HEXFF     COMPLEMENT  IF DESCENDING  (OPTIONAL)
MDLSK23_88L EQU *-MDLSK23_88
*
MDLSK23_88P EQU 0                 LITERAL POOL USAGE (EXCL FIELD LEN)
*
MDLSK23_88R ds 0h
         DC    AL1(CSSRCLoF),AL1(MDLSK23_88+02-MDLSK23_88) SRCE OFF
         DC    AL1(CStgtlof),AL1(MDLsk23_88lA+02-MDLsk23_88) FLD 2 off
         DC    AL1(CSSRPsrc),AL1(MDLSK23_88j+01-MDLSK23_88) skip if 0
         DC    AL1(CSdfpexps),AL1(MDLsk23_88se+02-MDLsk23_88) dfp exp
         DC    AL1(CSdfpexp),AL1(MDLsk23_88te+02-MDLsk23_88) dfp exp
         DC    AL1(CSTGTloF),AL1(MDLSK23_88C+02-MDLSK23_88) TARGETOFF
         DC    AL1(CSSDNLN),AL1(MDLSK23_88X+01-MDLSK23_88) SORTd LEN
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        ASSIGN/MOVE FIELD       (PACKED TO NUMERIC - COMPATIBLE      *
***********************************************************************
MDLsk24  LAY   R15,0(0,0)         get address
MDLsk24_la LAY R14,0(0,0)         get address
MDLSK24u UNPK  0(0,r14),0(0,r15)  CONVERT  FIELD   TO  NUMERIC FORMAT
MDLSK24X XC    0(0,r14),HEXFF     COMPLEMENT  IF DESCENDING  (OPTIONAL)
MDLSK24L EQU   *-MDLSK24
*
MDLSK24P EQU   0                  LITERAL POOL USAGE (EXCL FIELD LEN)
*
MDLSK24R DC    AL1(CSTGTLNL),AL1(MDLSK24u+01-MDLSK24)  TARGET    LENGTH
         DC    AL1(CSSRCLNR),AL1(MDLSK24u+01-MDLSK24)  TARGET    LENGTH
         DC    AL1(CSSRClof),AL1(MDLsk24+02-MDLsk24)  FIELD  1  OFF
         DC    AL1(CStgtlof),AL1(MDLsk24_lA+02-MDLsk24) FIELD  2  OFF
         DC    AL1(CSSDNLN),AL1(MDLSK24X+01-MDLSK24)  SORT DESCEND LEN
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        ASSIGN/MOVE FIELD       (NUMERIC TO PACKED - COMPATIBLE      *
***********************************************************************
MDLsk25  LAY   R15,0(0,0)         get address
MDLsk25_la LAY R14,0(0,0)         get address
MDLSK25k PACK  0(0,r14),0(0,r15)  CONVERT  FIELD   TO  NUMERIC FORMAT
MDLSK25X XC    0(0,r14),HEXFF     COMPLEMENT  IF DESCENDING  (OPTIONAL)
MDLSK25L EQU   *-MDLSK25
*
MDLSK25P EQU   0                  LITERAL POOL USAGE (EXCL FIELD LEN)
*
MDLSK25R DC    AL1(CSTGTLNL),AL1(MDLSK25k+01-MDLSK25)  TARGET    LENGTH
         DC    AL1(CSSRCLNR),AL1(MDLSK25k+01-MDLSK25)  TARGET    LENGTH
         DC    AL1(CSSRClof),AL1(MDLsk25+02-MDLsk25)  FIELD  1  OFF
         DC    AL1(CStgtlof),AL1(MDLsk25_lA+02-MDLsk25) FIELD  2  OFF
         DC    AL1(CSSDNLN),AL1(MDLSK25X+01-MDLSK25)  SORT DESCEND LEN
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        ASSIGN/MOVE FIELD       (VALUE_1 CONSTANT)                   *
***********************************************************************
MDLSK34  LAY   R14,0(,R2)         CONSTANT  ADDR
MDLsk34_la LAY R15,0(0,0)         get address
MDLSK34A MVC   0(0,r15),0(R14)      MOVE
MDLSK34X XC    0(0,r15),HEXFF     COMPLEMENT  IF DESCENDING  (OPTIONAL)
MDLSK34L EQU   *-MDLSK34
*
MDLSK34P EQU   0                  LITERAL POOL USAGE (EXCL FIELD LEN)
*
MDLSK34R DC    AL1(CSV1OFF),AL1(MDLSK34+02-MDLSK34)   CONSTANT  OFFSET
         DC    AL1(CSSRClof),AL1(MDLsk34_lA+02-MDLsk34) FIELD  1  OFF
         DC    AL1(CSSRCLN),AL1(MDLSK34A+01-MDLSK34)  TARGET    LENGTH
         DC    AL1(CSSDNSLN),AL1(MDLSK34X+01-MDLSK34) SORT DESCEND LEN
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        ASSIGN/MOVE FIELD       (CHARACTER)   (LONG FIELD POSITION)  *
***********************************************************************
MDLSK35  LAY   R14,0(,R6)         LOAD SOURCE ADDRESS
MDLsk35_la LAY R15,0(0,0)         get address
MDLSK35B MVC   0(0,r15),0(R14)    MOVE
MDLSK35X XC    0(0,r15),HEXFF     COMPLEMENT  IF DESCENDING  (OPTIONAL)
MDLSK35L EQU   *-MDLSK35
*
MDLSK35P EQU   0                  LITERAL POOL USAGE (EXCL FIELD LEN)
*
MDLSK35R DC    AL1(CSSRCLOF),AL1(MDLSK35+02-MDLSK35)  LONG SRC  OFFSET
         DC    AL1(CStgtlof),AL1(MDLsk35_lA+02-MDLsk35) FIELD  2  OFF
         DC    AL1(CSTGTLN),AL1(MDLSK35B+01-MDLSK35)  TARGET    LENGTH
         DC    AL1(CSSDNLN),AL1(MDLSK35X+01-MDLSK35)  SORT DESCEND LEN
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        ASSIGN/MOVE FIELD       (CHARACTER WITH FILLER)              *
***********************************************************************
MDLsk36  LAY   R15,0(0,0)         get address
MDLSK36m MVC   0(0,r15),SPACES    BLANK  OUT AREA  BEFORE     MOVE
MDLSK36A LAY   R14,0(,R6)         LOAD SOURCE ADDRESS
MDLSK36B MVC   0(0,r15),0(R14)    MOVE FIELD VALUE TO COLUMN  AREA
MDLSK36X XC    0(0,r15),HEXFF     COMPLEMENT  IF DESCENDING  (OPTIONAL)
MDLSK36L EQU   *-MDLSK36
*
MDLSK36P EQU   0                  LITERAL POOL USAGE (EXCL FIELD LEN)
*
MDLSK36R DC    AL1(CSTGTLN),AL1(MDLSK36m+01-MDLSK36)  TARGET    LENGTH
         DC    AL1(CStgtlof),AL1(MDLsk35_lA+02-MDLsk35) FIELD  2  OFF
         DC    AL1(CSSRCLOF),AL1(MDLSK36A+02-MDLSK36) LONG SRC  OFFSET
         DC    AL1(CSSRCLN),AL1(MDLSK36B+01-MDLSK36)  SOURCE    LENGTH
         DC    AL1(CSSDNLN),AL1(MDLSK36X+01-MDLSK36)  SORT DESCEND LEN
         DC   2XL1'FF'
                        EJECT
***********************************************************************
*        ASSIGN/MOVE FIELD        ACCUMULATOR                         *
***********************************************************************
MDLSK37  llgt  R5,0(,R2)          LOAD LOGIC  TABLE  ROW ADDRESS
MDLSK37A LAy   R1,0(,0)           LOAD  DATA  AREA    ADDRESS
         BAS   R10,CALL96A_Indirect Call "GVBDL96"    (FORMAT  FIELD)
MDLSK37F jlu   *+l'*              FORMAT UNSUCCESSFUL BRANCH (FALSE)
MDLSK37T jlu   *+l'*              FORMAT   SUCCESSFUL BRANCH (OPTIONAL)
MDLSK37L EQU   *-MDLSK37
*
MDLSK37P EQU   4                  LITERAL POOL USAGE (EXCL FIELD LEN)
*
MDLSK37R DC    AL1(CSLTROFF),AL1(MDLSK37+02-MDLSK37)  LOGIC  TABLE ROW
         DC    AL1(CSTGTloF),AL1(MDLSK37A+02-MDLSK37) TARGET OFFSET
         DC    AL1(CSFALSEO),AL1(MDLSK37F+02-MDLSK37) FALSE  BRANCH
         DC    AL1(CSTRUEO),AL1(MDLSK37T+02-MDLSK37)  TRUE   BRANCH
         DC   2XL1'FF'
                        EJECT
***********************************************************************
*        ASSIGN/MOVE FIELD       (BINARY TO BINARY8 - SIGNED)         *
***********************************************************************
MDLSK39  Xgr   R0,R0              LOAD BINARY NUMBER
MDLsk39_la LAY R14,0(0,0)         get address
MDLSK39S TMy   0(0),X'80'
         if (o)
           lghi r0,-1             fill with 1's
         endif
MDLSK39A ICMy  R0,B'0000',0(0)
mdlsk39j jnop  mdlsk39c
         cxgtr fp0,r0             convert to DFP
mdlsk39se lghi r15,*-*
         iextr fp4,fp0,r15        set quantum of source
mdlsk39te lghi r15,*-*
         iextr fp8,fp8,r15        set quantum of target
         qaxtr fp0,fp4,fp8,0      and quantise souce to target
         cgxtr r0,0,fp0
MDLSK39C STCMy R0,B'0000',0(0)
MDLSK39X XC    0(0,r14),HEXFF     COMPLEMENT  IF DESCENDING  (OPTIONAL)
MDLSK39L EQU   *-MDLSK39
*
MDLSK39P EQU   0                  LITERAL POOL USAGE (EXCL FIELD LEN)
*
MDLSK39R DC    AL1(CSSRCloF),AL1(MDLSK39S+02-MDLSK39) SOURCE    OFFSET
         DC    AL1(CStgtlof),AL1(MDLsk39_lA+02-MDLsk39) FIELD  2  OFF
         DC    AL1(CSBYTMSS),AL1(MDLSK39A+01-MDLSK39) ICM  BYTE MASK
         DC    AL1(CSSRCloF),AL1(MDLSK39A+02-MDLSK39) SOURCE    OFFSET
         DC    AL1(CSSRPsrc),AL1(MDLSK39j+01-MDLSK39) skip if zero
         DC    AL1(CSdfpexps),AL1(MDLsk39se+02-MDLsk39) dfp exp
         DC    AL1(CSdfpexp),AL1(MDLsk39te+02-MDLsk39) dfp exp
         DC    AL1(CSBYTMSK),AL1(MDLSK39C+01-MDLSK39) STCM BYTE MASK
         DC    AL1(CSTGTloF),AL1(MDLSK39C+02-MDLSK39) TARGET    OFFSET
         DC    AL1(CSSDNLN),AL1(MDLSK39X+01-MDLSK39)  SORT DESCEND LEN
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        ASSIGN/MOVE FIELD      (BINARY TO BINARY8 - SIGNED->UNSIGNED)*
***********************************************************************
MDLSK40  Xgr   R0,R0              LOAD BINARY NUMBER
MDLsk40_la LAY R14,0(0,0)         get address
MDLSK40S TMy   0(0),X'80'
         if (o)
           lghi r0,-1             fill with 1's
         endif
MDLSK40A ICMy  R0,B'0000',0(0)
         cxgtr fp0,r0             convert to DFP
mdlsk40j jnop  mdlsk40lp
mdlsk40se lghi r15,*-*
         iextr fp4,fp0,r15        set quantum of source
mdlsk40te lghi r15,*-*
         iextr fp8,fp8,r15        set quantum of target
         qaxtr fp0,fp4,fp8,0      and quantise souce to target
mdlsk40lp lpdfr fp0,fp0
         cgxtr r0,0,fp0
MDLSK40C STCMy R0,B'0000',0(0)
MDLSK40X XC    0(0,r14),HEXFF     COMPLEMENT  IF DESCENDING  (OPTIONAL)
MDLSK40L EQU   *-MDLSK40
*
MDLSK40P EQU   0                  LITERAL POOL USAGE (EXCL FIELD LEN)
*
MDLSK40R DC    AL1(CSSRCloF),AL1(MDLSK40S+02-MDLSK40) SOURCE    OFFSET
         DC    AL1(CStgtlof),AL1(MDLsk40_lA+02-MDLsk40) FIELD  2  OFF
         DC    AL1(CSBYTMSS),AL1(MDLSK40A+01-MDLSK40) ICM  BYTE MASK
         DC    AL1(CSSRCloF),AL1(MDLSK40A+02-MDLSK40) SOURCE    OFFSET
         DC    AL1(CSSRPsrc),AL1(MDLSK40j+01-MDLSK40) skip if zero
         DC    AL1(CSdfpexps),AL1(MDLsk40se+02-MDLsk40) dfp exp
         DC    AL1(CSdfpexp),AL1(MDLsk40te+02-MDLsk40) dfp exp
         DC    AL1(CSBYTMSK),AL1(MDLSK40C+01-MDLSK40) STCM BYTE MASK
         DC    AL1(CSTGTloF),AL1(MDLSK40C+02-MDLSK40) TARGET    OFFSET
         DC    AL1(CSSDNLN),AL1(MDLSK40X+01-MDLSK40)  SORT DESCEND LEN
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        ASSIGN/MOVE FIELD      (BINARY TO BINARY8 - UNSIGNED->SIGNED)*
***********************************************************************
MDLSK41  XR    R0,R0              LOAD BINARY NUMBER
MDLsk41_la LAY R14,0(0,0)         get address
MDLSK41A ICMY  R0,B'0000',0(0)
         cxgtr fp0,r0             convert to DFP
mdlsk41j jnop  mdlsk41lp
mdlsk41se lghi r15,*-*
         iextr fp4,fp0,r15        set quantum of source
mdlsk41te lghi r15,*-*
         iextr fp8,fp8,r15        set quantum of target
         qaxtr fp0,fp4,fp8,0      and quantise souce to target
mdlsk41lp lpdfr fp0,fp0
         cgxtr r0,0,fp0
MDLSK41C STCMy R0,B'0000',0(0)
MDLSK41X XC    0(0,r14),HEXFF     COMPLEMENT  IF DESCENDING  (OPTIONAL)
MDLSK41L EQU   *-MDLSK41
*
MDLSK41P EQU   0                  LITERAL POOL USAGE (EXCL FIELD LEN)
*
MDLSK41R DC    AL1(CSBYTMSS),AL1(MDLSK41A+01-MDLSK41) ICM  BYTE MASK
         DC    AL1(CSSRCloF),AL1(MDLSK41A+02-MDLSK41) SOURCE    OFFSET
         DC    AL1(CSSRPsrc),AL1(MDLSK41j+01-MDLSK41) skip if zero
         DC    AL1(CStgtlof),AL1(MDLsk41_lA+02-MDLsk41) FIELD  2  OFF
         DC    AL1(CSdfpexps),AL1(MDLsk41se+02-MDLsk41) dfp exp
         DC    AL1(CSdfpexp),AL1(MDLsk41te+02-MDLsk41) dfp exp
         DC    AL1(CSBYTMSK),AL1(MDLSK41C+01-MDLSK41) STCM BYTE MASK
         DC    AL1(CSTGTloF),AL1(MDLSK41C+02-MDLSK41) TARGET    OFFSET
         DC    AL1(CSSDNLN),AL1(MDLSK41X+01-MDLSK41)  SORT DESCEND LEN
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        LOOK-UP KEY LOGICAL RECORD ID                                *
***********************************************************************
MDLLK01  LAY   R14,0(,R2)         LRID ADDRESS
         MVC   LKUPKEY(4),0(R14)  MOVE
MDLLK01L EQU   *-MDLLK01
*
MDLLK01P EQU   4                  LITERAL POOL USAGE
*
MDLLK01R DC    AL1(CSLRID),AL1(MDLLK01+02-MDLLK01)    LOGICAL REC ID
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        LOOK-UP KEY LOGICAL RECORD ID WITH OPTIMIZATION              *
***********************************************************************
MDLLK02  llgt  R5,0(,R2)          LOAD LOOKUP BUFFER ADDRESS
         clc   lblstcnt-lkupbufr(l'lblstcnt,r5),GPRECCNT
         JNE   MDLLK02C
         CLC   LBLSTFND-LKUPBUFR(L'LBLSTFND,R5),HEXFF
MDLLK02F jlE   *+l'*              BRANCH TO FALSE IF HIGH  VALUES
MDLLK02T jlu   *+l'*              BRANCH TO TRUE  IF ON
mdllk02c mvc   lblstcnt-lkupbufr(l'lblstcnt,r5),GPRECCNT
*
         MVC   LKUPKEY(4),LBLRID-LKUPBUFR(R5)
MDLLK02L EQU   *-MDLLK02
*
MDLLK02P EQU   4+4                LITERAL POOL USAGE
*
MDLLK02R DC    AL1(CSLBAOFF),AL1(MDLLK02+2-MDLLK02)   LOOKUP  BUFFER
         DC    AL1(CSFALSEO),AL1(MDLLK02F+2-MDLLK02)  FALSE   BRANCH
         DC    AL1(CSTRUEO),AL1(MDLLK02T+2-MDLLK02)   TRUE    BRANCH
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        LOOK-UP KEY LOGICAL RECORD ID WITH OPTIMIZATION for token    *
***********************************************************************
MDLlk03  llgt  R5,0(,R2)          LOAD LOOKUP BUFFER ADDRESS
         llgt  r14,nvlogtbl-nvconst(,r11)   LOAD  NV LOGIC ADDR    @05I
         llgt  r14,ltviewre-logictbl(,r14)  Get RE for this view   @05I
         lgf   r14,ltfilcnt-logictbl(,r14)  Get lit pool offset    @05I
         agr   r14,r2                       Get address            @05I
         clc   lblstcnt-lkupbufr(l'lblstcnt,r5),0(r14)             @05c
         JNE   MDLlk03C
         CLC   LBLSTFND-LKUPBUFR(L'LBLSTFND,R5),HEXFF
MDLlk03F jlE   *+l'*              BRANCH TO FALSE IF HIGH  VALUES
MDLlk03T jlu   *+l'*              BRANCH TO TRUE  IF ON
mdllk03c mvc   lblstcnt-lkupbufr(l'lblstcnt,r5),0(r14)  set rec no.@05C
         MVC   LBLSTFND-LKUPBUFR(L'LBLSTFND,R5),HEXFF
*
         MVC   LKUPKEY(4),LBLRID-LKUPBUFR(R5)
MDLlk03L EQU   *-MDLlk03
*
MDLlk03P EQU   4+4                LITERAL POOL USAGE
*
MDLlk03R DC    AL1(CSLBAOFF),AL1(MDLlk03+2-MDLlk03)   LOOKUP  BUFFER
         DC    AL1(CSFALSEO),AL1(MDLlk03F+2-MDLlk03)  FALSE   BRANCH
         DC    AL1(CSTRUEO),AL1(MDLlk03T+2-MDLlk03)   TRUE    BRANCH
         DC   2XL1'FF'
                        EJECT
***********************************************************************
*        CALCULATED COLUMN AREA  -  GENERIC                           *
***********************************************************************
         USING COLEXTR,R8
*
MDLCT00  llgt  R5,0(,R2)          LOAD LOGIC  TABLE  ROW ADDRESS
         LA    R1,2(,R8)          LOAD  DATA  AREA    ADDRESS
mdlct00b BAS   R10,*-*            CALL "GVBDL96"  (FORMAT  FIELD)
MDLCT00F jlu   *+l'*              FORMAT UNSUCCESSFUL BRANCH (FALSE)
MDLCT00C LAY   R14,0(,R2)         FORMAT   SUCCESSFUL SAVE    COLUMN NO
         MVC   COLNO,0(R14)
         aghi  R8,COLDATAL
MDLCT00L EQU   *-MDLCT00
*
MDLCT00P EQU   4+2                LITERAL POOL USAGE (EXCL FIELD LEN)
*
MDLCT00R DC    AL1(CSLTROFF),AL1(MDLCT00+02-MDLCT00)  LOGIC TABLE ROW
         DC    AL1(CSdl96calln),AL1(MDLct00b-MDLct00)  MR96 BAS
         DC    AL1(CSFALSEO),AL1(MDLCT00F+02-MDLCT00) FALSE    BRANCH
         DC    AL1(CSCOLNO),AL1(MDLCT00C+02-MDLCT00)  COLUMN   NO.
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        CALCULATED COLUMN AREA  -  PACKED  SOURCE                    *
***********************************************************************
MDLct02  LAY   R15,0(0,0)         get address
MDLCT02m ZAP   COLDATA,0(0,r15)
MDLCT02A SRP   COLDATA,0,5
MDLCT02B LAY   R14,0(,R2)         COPY  COLUMN  NO.
         MVC   COLNO,0(R14)
         aghi  R8,COLDATAL
MDLCT02L EQU   *-MDLCT02
*
MDLCT02P EQU   2                  LITERAL POOL USAGE (EXCL FIELD LEN)
*
MDLCT02R DC    AL1(CSSRCLNR),AL1(MDLCT02m+01-MDLCT02)  SOURCE    LENGTH
         DC    AL1(CSSRClof),AL1(MDLct02+02-MDLct02) FIELD  1  OFF
         DC    AL1(CSSRPCT),AL1(MDLCT02A+04-MDLCT02)  SHIFT DEC PLACES
         DC    AL1(CSCOLNO),AL1(MDLCT02B+02-MDLCT02)  COLUMN    NUMBER
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        CALCULATED COLUMN AREA  -  NUMERIC SOURCE                    *
***********************************************************************
MDLct03  LAY   R15,0(0,0)         get address
MDLCT03k PACK  COLDATA,0(0,r15)
MDLCT03A SRP   COLDATA,0,5
MDLCT03B LAY   R14,0(,R2)         COPY  COLUMN  NO.
         MVC   COLNO,0(R14)
         aghi  R8,COLDATAL
MDLCT03L EQU   *-MDLCT03
*
MDLCT03P EQU   2                  LITERAL POOL USAGE (EXCL FIELD LEN)
*
MDLCT03R DC    AL1(CSSRCLNR),AL1(MDLCT03k+01-MDLCT03)  SOURCE    LENGTH
         DC    AL1(CSSRCloF),AL1(MDLCT03+02-MDLCT03)  SOURCE    OFFSET
         DC    AL1(CSSRPCT),AL1(MDLCT03A+04-MDLCT03)  SHIFT DEC PLACES
         DC    AL1(CSCOLNO),AL1(MDLCT03B+02-MDLCT03)  COLUMN    NUMBER
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        CALCULATED COLUMN AREA  -  BINARY  SOURCE - UNSIGNED         *
***********************************************************************
MDLCT04  Xgr   R0,R0
MDLCT04A ICMy  R0,B'0000',0(0)
         CVDG  R0,workarea
         ZAP   COLDATA,workarea
MDLCT04B SRP   COLDATA,0,5
MDLCT04C LAY   R14,0(,R2)         COPY  COLUMN  NO.
         MVC   COLNO,0(R14)
         aghi  R8,COLDATAL
MDLCT04L EQU   *-MDLCT04
*
MDLCT04P EQU   2                  LITERAL POOL USAGE (EXCL FIELD LEN)
*
MDLCT04R DC    AL1(CSBYTMSS),AL1(MDLCT04A+01-MDLCT04) ICM  BYTE MASK
         DC    AL1(CSSRCloF),AL1(MDLCT04A+02-MDLCT04) SOURCE    OFFSET
         DC    AL1(CSSRPCT),AL1(MDLCT04B+04-MDLCT04)  SHIFT DEC PLACES
         DC    AL1(CSCOLNO),AL1(MDLCT04C+02-MDLCT04)  COLUMN    NUMBER
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        CALCULATED COLUMN AREA  -  BINARY  SOURCE - SIGNED           *
***********************************************************************
MDLCT05  XR    R0,R0
MDLCT05S TMy   0(0),X'80'
         if (o)
           lhi r0,-1             fill with 1's
         endif
MDLCT05A ICMy  R0,B'0000',0(0)
         CVD   R0,DBLWORK
         ZAP   COLDATA,DBLWORK
MDLCT05B SRP   COLDATA,0,5
MDLCT05C LAY   R14,0(,R2)         COPY  COLUMN  NO.
         MVC   COLNO,0(R14)
         aghi  R8,COLDATAL
MDLCT05L EQU   *-MDLCT05
*
MDLCT05P EQU   2                  LITERAL POOL USAGE (EXCL FIELD LEN)
*
MDLCT05R DC    AL1(CSSRCloF),AL1(MDLCT05S+02-MDLCT05) SOURCE    OFFSET
         DC    AL1(CSBYTMSS),AL1(MDLCT05A+01-MDLCT05) ICM  BYTE MASK
         DC    AL1(CSSRCloF),AL1(MDLCT05A+02-MDLCT05) SOURCE    OFFSET
         DC    AL1(CSSRPCT),AL1(MDLCT05B+04-MDLCT05)  SHIFT DEC PLACES
         DC    AL1(CSCOLNO),AL1(MDLCT05C+02-MDLCT05)  COLUMN    NUMBER
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        CALCULATED COLUMN AREA  -  BINARY8 SOURCE - SIGNED           *
***********************************************************************
MDLCT05_b8 LG  R0,0(0,0)
         CVDG  R0,workar2
         ZAP   COLDATA,workar2
MDLCT05_b8B SRP COLDATA,0,5
MDLCT05_b8C LAY R14,0(,R2)        COPY  COLUMN  NO.
         MVC   COLNO,0(R14)
         aghi  R8,COLDATAL
MDLCT05_b8L EQU *-MDLCT05_b8
*
MDLCT05_b8P EQU 2                 LITERAL POOL USAGE (EXCL FIELD LEN)
*
MDLCT05_b8R DC AL1(CSSRCloF),AL1(MDLCT05_b8+02-MDLCT05_b8) SRCE OFF
         DC    AL1(CSSRPCT),AL1(MDLCT05_b8B+04-MDLCT05_b8) SHIFT DEC
         DC    AL1(CSCOLNO),AL1(MDLCT05_b8C+02-MDLCT05_b8) COL NUM
         DC   2XL1'FF'
                        SPACE 3
***********************************************************************
*        CALCULATED COLUMN  -  CONSTANT                               *
***********************************************************************
MDLCT06  LAY   R14,0(,R2)         CONSTANT   ADDRESS
MDLCT06A LAY   R15,0(,R2)         COLUMN     NUMBER
         MVC   COLDATA,0(R14)
         MVC   COLNO,0(R15)
         aghi  R8,COLDATAL
MDLCT06L EQU   *-MDLCT06
*
MDLCT06P EQU   2                  LITERAL POOL USAGE (EXCL FIELD LEN)
*
MDLCT06R DC    AL1(CSV1OFF),AL1(MDLCT06+02-MDLCT06)   CONSTANT  OFFSET
         DC    AL1(CSCOLNO),AL1(MDLCT06A+02-MDLCT06)  COLUMN    NUMBER
         DC   2XL1'FF'
                        SPACE 3
*******************************************************************@02I
*        CALCULATED COLUMN AREA  -  ACCUMULATOR CTA Type 12        @02I
*******************************************************************@02I
MDLCT10  LAY   R14,0(,0)          ACCUMULATOR   ADDRESS (chg'd to ly)
mdlct10d ld    fp0,0(0,r14)       Load value from storage
         ld    fp2,8(0,r14)
*              fp9/11 preloaded with correct quantum
         qaxtr fp4,fp0,fp9,0      and quantise the input
         csxtr r0,fp4,0
         st    r0,2(0,r8)         save first 4 bytes of result
         stg   r1,2+4(0,r8)            and the right hand 8
MDLCT10B LAY   R14,0(,R2)         COPY  COLUMN  NO.
         MVC   COLNO,0(R14)
         aghi  R8,COLDATAL                                         @02I
MDLCT10L EQU   *-MDLCT10                                           @02I
*                                                                  @02I
MDLCT10P EQU   4+2                LIT POOL USAGE (EXCL FIELD LEN)  @02I
*                                                                  @02I
MDLCT10R DC    AL1(CSACCOF2),AL1(MDLCT10+02-MDLCT10)  ACCUM ADDRESS@02I
         DC    AL1(CSdfpopt),AL1(mdlct10d-mdlct10) optimise loads
         DC    AL1(CSCTACUM_12),AL1(MDLCT10B+02-MDLCT10) COL NUMBER
         DC   2XL1'FF'                                             @02I
*
         DROP  R8
*
                        EJECT
*
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*                                                                     *
*        D A T A   C O N T R O L   B L O C K S                        *
*                                                                     *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*
logfile  DCB   DSORG=PS,DDNAME=EXTRLOG,MACRF=(PM),DCBE=Logfdcbe,       X
               RECFM=VB,LRECL=164
Logfdcbe DCBE  RMODE31=BUFF
Logfilel EQU   *-Logfile
SORTFILE DCB   DSORG=PS,DDNAME=SORT,MACRF=(PM),DCBE=SORTDCBE,          X
               RECFM=FB,LRECL=80
SORTDCBE DCBE  RMODE31=BUFF
sortfilel EQU  *-sortfile
*
EXTRFILE DCB   DSORG=PS,DDNAME=EXTR,MACRF=(W),DCBE=EXTRDCBE,           X
               RECFM=VB,LRECL=8192
EXTRDCBE DCBE  RMODE31=BUFF
EXTRDCBL EQU   *-EXTRFILE
*
                        SPACE 5
         IHASDWA
         IHASaver
*
*
         CVT DSECT=YES
         ihaecvt
*
         IKJTCB DSECT=YES
*
         IHASRB
*
         IHAPSA
*
         IWMYCON
*
         IEAASM
*
GVBMR95 CSECT
static    loctr
          ltorg
                        EJECT
         ds    0h
WEXITMSG DC    C'DISABLED BY WRITE EXIT'
LIMITMSG DC    C'REACHED EXTRACT LIMIT COUNT'
*
         ds  0h          align so that LARL works correctly
tot15    dc  c'Total number of SRB/TCB switches:   '
tot15_a  dc  cl15' '
                        EJECT
TE       DC    CL2'TE'              terminate user exits function call
WR_EX    DC    CL4'WREX'
*
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*        L O G I C   T A B L E   T R A C E   M E S S A G E S          *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         DS    0H
TRACEMSG DS   0CL161
TRACECC  DC    CL01' '
TRACEDDN DC    CL08' '
         DC    CL01' '
TRACECNT DC    CL10' '
         DC    CL01' '
TRACEVW# DC    CL07' '
         DC    CL01' '
TRACEROW DC    CL07' '
         DC    CL01' '
TRACEFUN DC    CL04' '
         DC    CL01' '
TRACECOL DC    CL03' '
         DC    CL01' '
TRACEFIL DC    CL08' '
         DC    CL01' '
TRACEREC DC    CL08' '
         DC    CL01' '
TRACEFLD DC    CL08' '
         DC    CL01' '
TRACEPOS DC    CL04' '
         DC    CL01' '
TRACELEN DC    CL04' '
         DC    CL01' '
TRACEFMT DC    CL02' '
         DC    CL01' '
TRACECON DC    CL02' '
         DC    CL01' '
TRACEDEC DC    CL01' '
         DC    CL01' '
TRACETPS DC    CL04' '
         DC    CL01' '
TRACETLN DC    CL04' '
         DC    CL01' '
TRACETFM DC    CL02' '
         DC    CL01' '
TRACETCN DC    CL02' '
         DC    CL01' '
TRACETDC DC    CL01' '
         DC    CL01' '
TRACEDAT DC    CL25' '
         DC    CL02' '
TRACEV2  DC    CL25' '
*
TRHD1MSG DS   0CL161
TRHD1CC  DC    CL01' '
TRHD1DDN DC    CL08' SOURCE '
         DC    CL01' '
TRHD1CNT DC    CL10'  SOURCE  '
         DC    CL01' '
TRHD1VW# DC    CL07'  VIEW '
         DC    CL01' '
TRHD1ROW DC    CL07' LOGIC '
         DC    CL01' '
TRHD1FUN DC    CL04' '
         DC    CL01' '
TRHD1COL DC    CL03'SEQ'
         DC    CL01' '
TRHD1FIL DC    CL08'   FILE '
         DC    CL01' '
TRHD1REC DC    CL08' RECORD '
         DC    CL01' '
TRHD1FLD DC    CL08'  FIELD '
         DC    CL01' '
TRHD1POS DC    CL17'*****SOURCE******'
         DC    CL01' '
TRHD1TLN DC    CL17'*****TARGET******'
         DC    CL01' '
TRHD1DAT DC    CL25' '
         DC    CL02' '
TRHD1V2  DC    CL25' '
*
TRHD2MSG DS   0CL161
TRHD2CC  DC    CL01' '
TRHD2DDN DC    CL08' DDNAME '
         DC    CL01' '
TRHD2CNT DC    CL10'  RECORD  '
         DC    CL01' '
TRHD2VW# DC    CL07' NUMBER'
         DC    CL01' '
TRHD2ROW DC    CL07'  ROW  '
         DC    CL01' '
TRHD2FUN DC    CL04' '
         DC    CL01' '
TRHD2COL DC    CL03'NUM'
         DC    CL01' '
TRHD2FIL DC    CL08'    ID  '
         DC    CL01' '
TRHD2REC DC    CL08'   ID   '
         DC    CL01' '
TRHD2FLD DC    CL08'    ID  '
         DC    CL01' '
TRHD2POS DC    CL04' POS'
         DC    CL01' '
TRHD2LEN DC    CL04' LEN'
         DC    CL01' '
TRHD2FMT DC    CL02'FM'
         DC    CL01' '
TRHD2CON DC    CL02'CN'
         DC    CL01' '
TRHD2DEC DC    CL01'D'
         DC    CL01' '
TRHD2TPS DC    CL04' POS'
         DC    CL01' '
TRHD2TLN DC    CL04' LEN'
         DC    CL01' '
TRHD2TFM DC    CL02'FM'
         DC    CL01' '
TRHD2TCN DC    CL02'CN'
         DC    CL01' '
TRHD2TDC DC    CL01'D'
         DC    CL01' '
TRHD2DAT DC    CL25'*****VALUE-1*************'
         DC    CL02' '
TRHD2V2  DC    CL25'*****VALUE-2*************'
                        EJECT
***********************************************************************
*  TRANSLATE TABLE FOR PRINTABLE EBCDIC CHARACTERS                    *
***********************************************************************
*                    0 1 2 3 4 5 6 7 8 9 A B C D E F
*
***********************************************************************
*  TRANSLATE TABLE FOR PRINTABLE EBCDIC CHARACTERS                    *
***********************************************************************
*                    0 1 2 3 4 5 6 7 8 9 A B C D E F
*
CHARTBL  DC    CL16'................'  00-0F
         DC    CL16'................'  10-1F
         DC    CL16'................'  20-2F
         DC    CL16'................'  30-3F
         DC    CL16'..........m.<(+y'  40-4F
         DC    CL16'&&.........!$*);*' 50-5F
         DC    CL16'-/.........,%_>?'  60-6F
         DC    CL16'..........:#@''="' 70-7F
         DC    CL16'.ABCDEFGHI......'  80-8F
         DC    CL16'.JKLMNOPQR......'  90-9F
         DC    CL16'..STUVWXYZ......'  A0-AF
         DC    CL16'................'  B0-BF
         DC    CL16'.ABCDEFGHI......'  C0-CF
         DC    CL16'.JKLMNOPQR......'  D0-DF
         DC    CL16'..STUVWXYZ......'  E0-EF
         DC    CL16'0123456789......'  F0-FF
                        EJECT
*
         copy  gvbrpthd
*
         ds    0h   Align the following on a halfword boundary
         ds    0h
tracp2b  dc    0cl(tracp2be-tracp2bs)
tracp2bs dc    al2(tracp2be-tracp2bs),al2(0)
         dc    c'Machine  code generation Pass-2 started'
tracp2be equ   *
*
tracp2d  dc    0cl(tracp2de-tracp2ds)
tracp2ds dc    al2(tracp2de-tracp2ds),al2(0)
         dc    c'Machine  code generation Pass-2 finished'
tracp2de equ   *
*
tracthb  dc    0cl(tracthbe-tracthbs)
tracthbs dc    al2(tracthbe-tracthbs),al2(0)
         dc    c'Parallel threads   starting'
tracthbe equ   *
*
tracthd  dc    0cl(tracthde-tracthds)
tracthds dc    al2(tracthde-tracthds),al2(0)
         dc    c'Parallel threads   finished'
tracthde equ   *
*
trac64b  dc    0cl(trac64be-trac64bs)
trac64bs dc    al2(trac64be-trac64bs),al2(0)
         DC    c'  64 BIT GETMAIN,  SUMMARY MEGS: NNNNNNNNN'
trac64be equ   *
*
tracclb  dc    0cl(tracclbe-tracclbs)
tracclbs dc    al2(tracclbe-tracclbs),al2(0)
         dc    c'Thread close phase starting'
tracclbe equ   *
*
traccld  dc    0cl(tracclde-tracclds)
tracclds dc    al2(tracclde-tracclds),al2(0)
         dc    c'Thread close phase finished'
tracclde equ   *
*
tracsch  dc    0cl(tracsche-tracschs)
tracschs dc    al2(tracsche-tracschs),al2(0)
         dc    c'Scheduling thread "srb"'
tracsche equ   *
*
tracxfr  dc    0cl(tracxfre-tracxfrs)
tracxfrs dc    al2(tracxfre-tracxfrs),al2(0)
         dc    c'Resuming "srb"'
tracxfre equ   *
*
tracrsm  dc    0cl(tracrsme-tracrsms)
tracrsms dc    al2(tracrsme-tracrsms),al2(0)
         dc    c'Resuming "tcb"'
tracrsme equ   *
*
mems_desc01  dc  cl33'Generated machine code'
mems_desc02  dc  cl33'Logic table'
mems_desc03  dc  cl33'VDP data'
mems_desc04  dc  cl33'Literal pools'
mems_desc05  dc  cl33'Run-control file I/O buffers'
mems_desc06  dc  cl33'Ref-phase work file I/O buffers'
mems_desc07  dc  cl33'I/O buffers'
mems_desc09  dc  cl33'Reference tables'
mems_desc10  dc  cl33'Extract-phase record aggr buffers'
*
exec_desc01  dc  cl29'Views processed:'
exec_desc02  dc  cl29'Parallel threads executed:'
exec_desc03  dc  cl29'Lookup steps performed:'
exec_desc04  dc  cl29'Total source files read:'
exec_desc05  dc  cl29'Total source records read:'
exec_desc06  dc  cl29'Total source bytes read:'
exec_desc04A dc  cl29'External files read:'
exec_desc05A dc  cl29'External records read:'
exec_desc06A dc  cl29'External bytes read:'
exec_desc04B dc  cl29'Pipe/Token files read:'
exec_desc05B dc  cl29'Pipe/Token records read:'
exec_desc06B dc  cl29'Pipe/Token bytes read:'
exec_desc04C dc  cl29'Read Exit files read:'
exec_desc05C dc  cl29'Read Exit records read:'
exec_desc06C dc  cl29'Read Exit bytes read:'
exec_desc07  dc  cl29'Total output files written:'
exec_desc08  dc  cl29'Total output records written:'
exec_desc09  dc  cl29'Total output bytes written:'
exec_desc07A dc  cl29'External files written:'
exec_desc08A dc  cl29'External records written:'
exec_desc09A dc  cl29'External bytes written:'
exec_desc07B dc  cl29'Pipe/Token files written:'
exec_desc08B dc  cl29'Pipe/Token records written:'
exec_desc09B dc  cl29'Pipe/Token bytes written:'
exec_desc10  dc  cl29'CPU time (seconds):'
exec_desc11  dc  cl29'CPU time (HHHH:MM:SS):'
exec_desc12  dc  cl29'Elapsed time (seconds):'
exec_desc13  dc  cl29'Elapsed time (HHHH:MM:SS.hh):'
*20813 descriptions for Reference phase
exec_desc14  dc  cl29'Reference files read:'
exec_desc15  dc  cl29'Reference records read:'
exec_desc16  dc  cl29'Reference bytes read:'
*
MDLWTO   WTO   TEXT=(R2),MF=L     MODEL WTO TO DISPLAY CONSOLE MESSAGES
*
filetype  ds   0c
ftype1    dc   cl09'Work File'
ftype2    dc   cl09'Disk File'
ftype3    dc   cl09'Tape'
ftype4    dc   cl09'Pipe'
ftype5    dc   cl09'Token'
ftype6    dc   cl09'Database'
ftype7    dc   cl09'Read Exit'
ftype8    dc   cl09'Pipe Exit' Pipe
*
*  Generate the VCONS for the lookup search routines
*   with different key lengths
*
         MACRO
         SRCHR_VCONS &ROUTINE=GVBSRCH
         LCLA &KLEN_N
&KLEN_N  SETA  1
.SRCHGN  ANOP
         &ROUTINE KEYLEN=&KLEN_N,VCON=Y
&KLEN_N  SETA  &KLEN_N+1
         AIF   ('&KLEN_N' LE '256').SRCHGN
         MEND
*
         entry SRCHADDT
SRCHADDT ds 0f
         SRCHR_VCONS ROUTINE=GVBSRCH
*
         ds    0h
         PRINT NOGEN,OFF
tiot    dsect
        ieftiot1
         DCBD  DSORG=PS
         ihadcbe
         PRINT on
         END
